{"text":"program to convert centimeters to pixels | function to convert centimeters to pixels ; ","context":"","code":"def Conversion(centi):\n    pixels = (96 * centi) \/ 2.54\n    print(round(pixels, 2))\n","test":"\ncenti = 15\nConversion(centi)\n","output":"566.93\n","fn_call":"Conversion"}
{"text":"kth array element after m replacements of array elements by xor of adjacent pairs | method that returns the corresponding output by taking the given inputs . ; if this condition is satisfied , value of m is invalid ; check if index k is valid ; loop to perform m operations ; creating a temporary list ; traversing the array ; calculate xor values of adjacent elements ; adding this value to the temporary list ; update the original array ; getting value at index k ; number of elements ; ","context":"","code":"def xor_operations(N, arr, M, K):\n    if M < 0 or M >= N:\n        return -1\n    if K < 0 or K >= N - M:\n        return -1\n    for _ in range(M):\n        temp = []\n        for i in range(len(arr) - 1):\n            value = arr[i] ^ arr[i + 1]\n            temp .append(value)\n        arr = temp[:]\n    ans = arr[K]\n    return ans\n","test":"\nN = 5\narr = [1, 4, 5, 6, 7]\nM = 1\nK = 2\nprint(xor_operations(N, arr, M, K))\n","output":"3\n","fn_call":"xor_operations"}
{"text":"check if n can be divided into k consecutive elements with a sum equal to n | function to find the k consecutive elements with a sum equal to n ; iterate over [ 2 , inf ] ; store the sum ; if the sum exceeds n then break the loop ; common difference should be divisible by number of terms ; print value of i & return ; print \" - 1\" if not possible to break n ; ","context":"","code":"def canBreakN(n):\n    for i in range(2, n):\n        m = i * (i + 1) \/\/ 2\n        if (m > n):\n            break\n        k = n - m\n        if (k % i):\n            continue\n        print(i)\n        return\n    print(\"-1\")\n","test":"\nN = 12\ncanBreakN(N)\n","output":"3\n","fn_call":"canBreakN"}
{"text":"coprime divisors of a number | python3 program to find two coprime divisors of a ","context":"\nimport math\n\n","code":"def findCoprimePair(N):\n    for x in range(2, int(math .sqrt(N)) + 1):\n        if (N % x == 0):\n            while (N % x == 0):\n                N \/\/= x\n            if (N > 1):\n                print(x, N)\n                return\n    print(\"-1\")\n","test":"\nN = 45\nfindCoprimePair(N)\nN = 25\nfindCoprimePair(N)\n","output":"3 5\n-1\n","fn_call":"findCoprimePair"}
{"text":"hexanacci numbers | function to print the nth hexanacci number ; ","context":"","code":"def printhexaRec(n):\n    if (n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5):\n        return 0\n    elif (n == 6):\n        return 1\n    else:\n        return (\n            printhexaRec(\n                n -\n                1) +\n            printhexaRec(\n                n -\n                2) +\n            printhexaRec(\n                n -\n                3) +\n            printhexaRec(\n                n -\n                4) +\n            printhexaRec(\n                n -\n                5) +\n            printhexaRec(\n                n -\n                6))\n\n\ndef printhexa(n):\n    print(printhexaRec(n))\n","test":"\nn = 11\nprinthexa(n)\n","output":"16\n","fn_call":"printhexa"}
{"text":"hexanacci numbers | function to print the nth term of the hexanacci number ; initialize first five numbers to base cases ; declare a current variable ; loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively ; ","context":"","code":"def printhexa(n):\n    if (n < 0):\n        return\n    first = 0\n    second = 0\n    third = 0\n    fourth = 0\n    fifth = 0\n    sixth = 1\n    curr = 0\n    if (n < 6):\n        print(first)\n    elif (n == 6):\n        print(sixth)\n    else:\n        for i in range(6, n):\n            curr = first + second + third + fourth + fifth + sixth\n            first = second\n            second = third\n            third = fourth\n            fourth = fifth\n            fifth = sixth\n            sixth = curr\n    print(curr)\n","test":"\nn = 11\nprinthexa(n)\n","output":"16\n","fn_call":"printhexa"}
{"text":"find the smallest number whose sum of digits is n | function to find the smallest number whose sum of digits is also n ; ","context":"","code":"def smallestNumber(N):\n    print((N % 9 + 1) * pow(10, (N \/\/ 9)) - 1)\n","test":"\nN = 10\nsmallestNumber(N)\n","output":"19\n","fn_call":"smallestNumber"}
{"text":"distinct powers of a number n such that the sum is equal to k | initializing the powerarray with all 0 's ; function to find the powers of n that add up to k ; initializing the counter ; executing the while loop until k is greater than 0 ; if k % n == 1 , then the power array is incremented by 1 ; checking if any power is occurred more than once ; for any other value , the sum of powers cannot be added up to k ; printing the powers of n that sum up to k ; ","context":"\nb = [0 for i in range(50)]\n\n","code":"def PowerArray(n, k):\n    count = 0\n    while (k):\n        if (k % n == 0):\n            k \/\/= n\n            count += 1\n        elif (k % n == 1):\n            k -= 1\n            b[count] += 1\n            if (b[count] > 1):\n                print(-1)\n                return 0\n        else:\n            print(-1)\n            return 0\n    for i in range(50):\n        if (b[i]):\n            print(i, end=\",\")\n","test":"\nif __name__ == '__main__':\n    N = 3\n    K = 40\n    PowerArray(N, K)\n","output":"0,1,2,3,","fn_call":"PowerArray"}
{"text":"program to find value of 1 ^ k + 2 ^ k + 3 ^ k + ... + n ^ k | python 3 program to find the value 1 ^ k + 2 ^ k + 3 ^ k + . . + n ^ k ; function to find value of 1 ^ k + 2 ^ k + 3 ^ k + . . + n ^ k ; initialise sum to 0 ; find the value of pow ( i , 4 ) and then add it to the sum ; return the sum ; ","context":"\nfrom math import pow\n\n","code":"def findSum(N, k):\n    sum = 0\n    for i in range(1, N + 1, 1):\n        sum += pow(i, k)\n    return sum\n","test":"\nif __name__ == '__main__':\n    N = 8\n    k = 4\n    print(int(findSum(N, k)))\n","output":"8772\n","fn_call":"findSum"}
{"text":"count of indices in an array that satisfy the given condition | function to return the count of indices that satisfy the given condition ; to store the result ; to store the current maximum initialized to 0 since there are only positive elements in the array ; i is a valid index ; update the maximum so far ; increment the counter ; ","context":"","code":"def countIndices(arr, n):\n    cnt = 0\n    max = 0\n    for i in range(n):\n        if (max < arr[i]):\n            max = arr[i]\n            cnt += 1\n    return cnt\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    n = len(arr)\n    print(countIndices(arr, n))\n","output":"4\n","fn_call":"countIndices"}
{"text":"maximum frequency of a remainder modulo 2 i | binary representation of the digits ; function to return the maximum frequency of s modulo with a power of 2 ; store the binary representation ; convert the octal to binary ; remove the lsb ; if there is 1 in the binary representation ; find the number of zeroes in between two 1 's in the binary representation ; ","context":"\nbin = [\"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\"]\n\n","code":"def maxFreq(s):\n    binary = \"\"\n    for i in range(len(s)):\n        binary += bin[ord(s[i]) - ord('0')]\n    binary = binary[0:len(binary) - 1]\n    count = 1\n    prev = -1\n    j = 0\n    for i in range(len(binary) - 1, -1, -1):\n        if (binary[i] == '1'):\n            count = max(count, j - prev)\n            prev = j\n        j += 1\n    return count\n","test":"\nif __name__ == \"__main__\":\n    octal = \"13\"\n    print(maxFreq(octal))\n","output":"2\n","fn_call":"maxFreq"}
{"text":"find the number of cells in the table contains x | function to find number of cells in the table contains x ; ","context":"","code":"def Cells(n, x):\n    if (n <= 0 or x <= 0 or x > n * n):\n        return 0\n    i = 1\n    count = 0\n    while (i * i < x):\n        if (x % i == 0 and x <= n * i):\n            count += 2\n        i += 1\n    if (i * i == x):\n        return count + 1\n    else:\n        return count\n","test":"\nn = 6\nx = 12\nprint(Cells(n, x))\n","output":"4\n","fn_call":"Cells"}
{"text":"find the maximum possible value of the minimum value of modified array | function to find the maximum possible value of the minimum value of the modified array ; to store minimum value of array ; to store sum of elements of array ; solution is not possible ; zero is the possible value ; minimum possible value ; maximum possible value ; to store a required answer ; binary search ; if mid is possible then try to increase required answer ; if mid is not possible then decrease required answer ; return required answer ; ","context":"","code":"def maxOfMin(a, n, S):\n    mi = 10 ** 9\n    s1 = 0\n    for i in range(n):\n        s1 += a[i]\n        mi = min(a[i], mi)\n    if (s1 < S):\n        return -1\n    if (s1 == S):\n        return 0\n    low = 0\n    high = mi\n    ans = 0\n    while (low <= high):\n        mid = (low + high) \/\/ 2\n        if (s1 - (mid * n) >= S):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans\n","test":"\na = [10, 10, 10, 10, 10]\nS = 10\nn = len(a)\nprint(maxOfMin(a, n, S))\n","output":"8\n","fn_call":"maxOfMin"}
{"text":"program to print ' n ' alphabet using the number pattern from 1 to n | function to print the desired alphabet n pattern ; declaring the values of right , left and diagonal values ; main loop for the rows ; for the left values ; spaces for the diagonals ; condition for the diagonals ; spaces for the right values ; for the right values ; ","context":"","code":"def Alphabet_N_Pattern(N):\n    Right = 1\n    Left = 1\n    Diagonal = 2\n    for index in range(N):\n        print(Left, end=\"\")\n        Left += 1\n        for side_index in range(0, 2 * (index), 1):\n            print(\" \", end=\"\")\n        if (index != 0 and index != N - 1):\n            print(Diagonal, end=\"\")\n            Diagonal += 1\n        else:\n            print(\" \", end=\"\")\n        for side_index in range(0, 2 * (N - index - 1), 1):\n            print(\" \", end=\"\")\n        print(Right, end=\"\")\n        Right += 1\n        print(\"\",  end=\"\")\n","test":"\nif __name__ == '__main__':\n    Size = 6\n    Alphabet_N_Pattern(Size)\n","output":"1           12  2        23    3      34      4    45        5  56           6","fn_call":"Alphabet_N_Pattern"}
{"text":"check if the sum of digits of a number n divides it | function to check if sum of digits of a number divides it ; calculate sum of all of digits of n ; ","context":"","code":"def isSumDivides(N):\n    temp = N\n    sum = 0\n    while (temp):\n        sum += temp % 10\n        temp = int(temp \/ 10)\n    if (N % sum == 0):\n        return 1\n    else:\n        return 0\n","test":"\nif __name__ == '__main__':\n    N = 12\n    if (isSumDivides(N)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"isSumDivides"}
{"text":"Sum of numbers from 1 to N which are divisible by 3 or 4 | Function to calculate the sum of numbers divisible by 3 or 4 ;","context":"","code":"def sum(N):\n    global S1, S2, S3\n    S1 = (((N \/\/ 3)) * (2 * 3 + (N \/\/ 3 - 1) * 3) \/\/ 2)\n    S2 = (((N \/\/ 4)) * (2 * 4 + (N \/\/ 4 - 1) * 4) \/\/ 2)\n    S3 = (((N \/\/ 12)) * (2 * 12 + (N \/\/ 12 - 1) * 12) \/\/ 2)\n    return int(S1 + S2 - S3)\n","test":"\nif __name__ == '__main__':\n    N = 12\n    print(sum(N))\n","output":"42\n","fn_call":"sum"}
{"text":"next greater number than n with exactly one bit different in binary representation of n | function to find next greater number than n with exactly one bit different in binary representation of n ; it is guaranteed that there is a bit zero in the number ; if the shifted bit is zero then break ; increase the bit shift ; increase the power of 2 ; set the lowest bit of the number ; ","context":"","code":"def nextGreater(N):\n    power_of_2 = 1\n    shift_count = 0\n    while (True):\n        if (((N >> shift_count) & 1) % 2 == 0):\n            break\n        shift_count += 1\n        power_of_2 = power_of_2 * 2\n    return (N + power_of_2)\n","test":"\nN = 11\nprint(\"The next number is =\", nextGreater(N))\n","output":"The next number is = 15\n","fn_call":"nextGreater"}
{"text":"count number of ways to cover a distance | set 2 | function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps ; base conditions ; to store the last three stages ; find the numbers of steps required to reach the distance i ; return the required answer ; ","context":"","code":"def countWays(n):\n    if (n == 0):\n        return 1\n    if (n <= 2):\n        return n\n    f0 = 1\n    f1 = 1\n    f2 = 2\n    ans = 0\n    for i in range(3, n + 1):\n        ans = f0 + f1 + f2\n        f0 = f1\n        f1 = f2\n        f2 = ans\n    return ans\n","test":"\nn = 4\nprint(countWays(n))\n","output":"7\n","fn_call":"countWays"}
{"text":"maximize sum by choosing elements from different section of a matrix | python3 program for the above approach ; function to find the maximum value ; dp table ; fill the dp in bottom up manner ; maximum of the three sections ; maximum of the first section ; maximum of the second section ; maximum of the third section ; if we choose element from section 1 , we cannot have selection from same section in adjacent rows ; print the maximum sum ; ","context":"\nimport numpy as np\nn = 6\nm = 6\n\n","code":"def maxSum(arr):\n    dp = np .zeros((n + 1, 3))\n    for i in range(n):\n        m1 = 0\n        m2 = 0\n        m3 = 0\n        for j in range(m):\n            if ((j \/\/ (m \/\/ 3)) == 0):\n                m1 = max(m1, arr[i][j])\n            elif ((j \/\/ (m \/\/ 3)) == 1):\n                m2 = max(m2, arr[i][j])\n            elif ((j \/\/ (m \/\/ 3)) == 2):\n                m3 = max(m3, arr[i][j])\n        dp[i + 1][0] = max(dp[i][1], dp[i][2]) + m1\n        dp[i + 1][1] = max(dp[i][0], dp[i][2]) + m2\n        dp[i + 1][2] = max(dp[i][1], dp[i][0]) + m3\n    print(max(max(dp[n][0], dp[n][1]), dp[n][2]))\n","test":"\nif __name__ == \"__main__\":\n    arr = [[1, 3, 5, 2, 4, 6], [6, 4, 5, 1, 3, 2], [1, 3, 5, 2, 4, 6],\n           [6, 4, 5, 1, 3, 2], [6, 4, 5, 1, 3, 2], [1, 3, 5, 2, 4, 6]]\n    maxSum(arr)\n","output":"35.0\n","fn_call":"maxSum"}
{"text":"total number of odd length palindrome sub | function to find the total palindromic odd length sub - sequences ; dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1 ; we will start with the largest distance between i and j ; for each len , we fix our i ; for this i we will find our j ; base cases ; if the characters are equal then look for out of bound index ; we have only 1 way that is to just pick these characters ; if the characters are not equal ; subtract it as we have counted it twice ; we have just 1 palindrome sequence of length 1 ; else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1 ; ","context":"","code":"def solve(s):\n    n = len(s)\n    dp = [[0 for i in range(n)]for i in range(n)]\n    for Len in range(n - 1, -1, -1):\n        for i in range(n):\n            if i + Len >= n:\n                break\n            j = i + Len\n            if (i == 0 and j == n - 1):\n                if (s[i] == s[j]):\n                    dp[i][j] = 2\n                elif (s[i] != s[j]):\n                    dp[i][j] = 1\n            else:\n                if (s[i] == s[j]):\n                    if (i - 1 >= 0):\n                        dp[i][j] += dp[i - 1][j]\n                    if (j + 1 <= n - 1):\n                        dp[i][j] += dp[i][j + 1]\n                    if (i - 1 < 0 or j + 1 >= n):\n                        dp[i][j] += 1\n                elif (s[i] != s[j]):\n                    if (i - 1 >= 0):\n                        dp[i][j] += dp[i - 1][j]\n                    if (j + 1 <= n - 1):\n                        dp[i][j] += dp[i][j + 1]\n                    if (i - 1 >= 0 and j + 1 <= n - 1):\n                        dp[i][j] -= dp[i - 1][j + 1]\n    ways = []\n    for i in range(n):\n        if (i == 0 or i == n - 1):\n            ways .append(1)\n        else:\n            total = dp[i - 1][i + 1]\n            ways .append(total)\n    for i in ways:\n        print(i, end=\" \")\n","test":"\ns = \"xyxyx\"\nsolve(s)\n","output":"1 3 4 3 1 ","fn_call":"solve"}
{"text":"find the number of chicks in a zoo at nth day | function to return the number of chicks on the nth day ; size of dp [ ] has to be at least 6 ( 1 - based indexing ) ; every day current population will be three times of the previous day ; manually calculated value ; from 8 th day onwards ; chick population decreases by 2 \/ 3 everyday . for 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days ; ","context":"","code":"def getChicks(n):\n    size = max(n, 7)\n    dp = [0] * size\n    dp[0] = 0\n    dp[1] = 1\n    for i in range(2, 7):\n        dp[i] = dp[i - 1] * 3\n    dp[6] = 726\n    for i in range(8, n + 1):\n        dp[i] = (dp[i - 1] - (2 * dp[i - 6] \/\/ 3)) * 3\n    return dp[n]\n","test":"\nn = 3\nprint(getChicks(n))\n","output":"9\n","fn_call":"getChicks"}
{"text":"find the number of chicks in a zoo at nth day | function to return the number of chicks on the nth day ; ","context":"","code":"def getChicks(n):\n    chicks = pow(3, n - 1)\n    return chicks\n","test":"\nif __name__ == \"__main__\":\n    n = 3\n    print(getChicks(n))\n","output":"9\n","fn_call":"getChicks"}
{"text":"find minimum steps required to reach the end of a matrix | set 2 | python3 implementation of the approach ; 2d array to store states of dp ; array to determine whether a state has been solved before ; function to return the minimum steps required ; base cases ; if a state has been solved before it won 't be evaluated again ; recurrence relation ; ","context":"\nimport numpy as np\nn = 3\ndp = np .zeros((n, n))\nv = np .zeros((n, n))\n\n","code":"def minSteps(i, j, arr):\n    if (i == n - 1 and j == n - 1):\n        return 0\n    if (i > n - 1 or j > n - 1):\n        return 9999999\n    if (v[i][j]):\n        return dp[i][j]\n    v[i][j] = 1\n    dp[i][j] = 9999999\n    for k in range(max(0, arr[i][j] + j - n + 1),\n                   min(n - i - 1, arr[i][j]) + 1):\n        dp[i][j] = min(dp[i][j], minSteps(i + k, j + arr[i][j] - k, arr))\n    dp[i][j] += 1\n    return dp[i][j]\n","test":"\nif __name__ == \"__main__\":\n    arr = [[4, 1, 2], [1, 1, 1], [2, 1, 1]]\n    ans = minSteps(0, 0, arr)\n    if (ans >= 9999999):\n        print(-1)\n    else:\n        print(ans)\n","output":"1.0\n","fn_call":"minSteps"}
{"text":"find minimum steps required to reach the end of a matrix | set | python3 program to implement above approach ; 2d array to store states of dp ; array to determine whether a state has been solved before ; function to find the minimum number of steps to reach the end of matrix ; base cases ; if a state has been solved before it won 't be evaluated again. ; recurrence relation ; ","context":"\nimport numpy as np\nn = 3\ndp = np .zeros((n, n))\nv = np .zeros((n, n))\n\n","code":"def minSteps(i, j, arr):\n    if (i == n - 1 and j == n - 1):\n        return 0\n    if (i > n - 1 or j > n - 1):\n        return 9999999\n    if (v[i][j]):\n        return dp[i][j]\n    v[i][j] = 1\n    dp[i][j] = 1 + min(minSteps(i + arr[i][j], j, arr),\n                       minSteps(i, j + arr[i][j], arr))\n    return dp[i][j]\n","test":"\narr = [[2, 1, 2], [1, 1, 1], [1, 1, 1]]\nans = minSteps(0, 0, arr)\nif (ans >= 9999999):\n    print(-1)\nelse:\n    print(ans)\n","output":"2.0\n","fn_call":"minSteps"}
{"text":"treasure and cities | a memoization based program to find maximum treasure that can be collected . ; k is current index and col is previous color . ; base case ; we have two options either visit current city or skip that ; check if color of this city is equal to prev visited city ; return max of both options ; ","context":"\nMAX = 1001\ndp = [[-1 for i in range(MAX)]for i in range(MAX)]\n\n","code":"def MaxProfit(treasure, color, n, k, col, A, B):\n    if (k == n):\n        dp[k][col] = 0\n        return dp[k][col]\n    if (dp[k][col] != -1):\n        return dp[k][col]\n    summ = 0\n    if (col == color[k]):\n        summ += max(A *\n                    treasure[k] +\n                    MaxProfit(treasure, color, n, k +\n                              1, color[k], A, B), MaxProfit(treasure, color, n, k +\n                                                            1, col, A, B))\n    else:\n        summ += max(B *\n                    treasure[k] +\n                    MaxProfit(treasure, color, n, k +\n                              1, color[k], A, B), MaxProfit(treasure, color, n, k +\n                                                            1, col, A, B))\n    dp[k][col] = summ\n    return dp[k][col]\n","test":"\nA = -5\nB = 7\ntreasure = [4, 8, 2, 9]\ncolor = [2, 2, 6, 2]\nn = len(color)\nprint(MaxProfit(treasure, color, n, 0, 0, A, B))\n","output":"133\n","fn_call":"MaxProfit"}
{"text":"tetranacci numbers | function to print the n - th tetranacci number ; base cases ; ","context":"","code":"def printTetra(n):\n    dp = [0] * (n + 5)\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 1\n    dp[3] = 2\n    for i in range(4, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4])\n    print(dp[n])\n","test":"\nn = 10\nprintTetra(n)\n","output":"208\n","fn_call":"printTetra"}
{"text":"maximum sum in circular array such that no two elements are adjacent | function to calculate the sum from 0 th position to ( n - 2 ) th position ; copy the element of original array to dp [ ] ; find the maximum element in the array ; start from 2 nd to n - 1 th pos ; traverse for all pairs bottom - up approach ; dp - condition ; find maximum sum ; return the maximum ; function to find the maximum sum from 1 st position to n - 1 - th position ; traverse from third to n - th pos ; bootom - up approach ; dp condition ; find max sum ; return max ; ","context":"","code":"def maxSum1(arr, n):\n    dp = [0] * n\n    maxi = 0\n    for i in range(n - 1):\n        dp[i] = arr[i]\n        if (maxi < arr[i]):\n            maxi = arr[i]\n    for i in range(2, n - 1):\n        for j in range(i - 1):\n            if (dp[i] < dp[j] + arr[i]):\n                dp[i] = dp[j] + arr[i]\n                if (maxi < dp[i]):\n                    maxi = dp[i]\n    return maxi\n\n\ndef maxSum2(arr, n):\n    dp = [0] * n\n    maxi = 0\n    for i in range(1, n):\n        dp[i] = arr[i]\n        if (maxi < arr[i]):\n            maxi = arr[i]\n    for i in range(3, n):\n        for j in range(1, i - 1):\n            if (dp[i] < arr[i] + dp[j]):\n                dp[i] = arr[i] + dp[j]\n                if (maxi < dp[i]):\n                    maxi = dp[i]\n    return maxi\n\n\ndef findMaxSum(arr, n):\n    return max(maxSum1(arr, n), maxSum2(arr, n))\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 1]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n","output":"4\n","fn_call":"findMaxSum"}
{"text":"permutation coefficient | returns value of permutation coefficient p ( n , k ) ; calculate value of permutation coefficient in bottom up manner ; base cases ; calculate value using previously stored values ; this step is important as p ( i , j ) = 0 for j > i ; ","context":"","code":"def permutationCoeff(n, k):\n    P = [[0 for i in range(k + 1)]for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n            if (j == 0):\n                P[i][j] = 1\n            else:\n                P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1])\n            if (j < k):\n                P[i][j + 1] = 0\n    return P[n][k]\n","test":"\nn = 10\nk = 2\nprint(\"Value fo P(\", n, \", \", k, \") is \", permutationCoeff(n, k), sep=\"\")\n","output":"Value fo P(10, 2) is 90\n","fn_call":"permutationCoeff"}
{"text":"permutation coefficient | returns value of permutation coefficient p ( n , k ) ; base case ; calculate value factorials up to n ; p ( n , k ) = n ! \/ ( n - k ) ! ; ","context":"","code":"def permutationCoeff(n, k):\n    fact = [0 for i in range(n + 1)]\n    fact[0] = 1\n    for i in range(1, n + 1):\n        fact[i] = i * fact[i - 1]\n    return int(fact[n] \/ fact[n - k])\n","test":"\nn = 10\nk = 2\nprint(\"Value of P(\", n, \", \", k, \") is \", permutationCoeff(n, k), sep=\"\")\n","output":"Value of P(10, 2) is 90\n","fn_call":"permutationCoeff"}
{"text":"dynamic programming | returns true if there is a subset of set [ ] with sun equal to given sum ; base cases ; if last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; ","context":"","code":"def isSubsetSum(set, n, sum):\n    if (sum == 0):\n        return True\n    if (n == 0):\n        return False\n    if (set[n - 1] > sum):\n        return isSubsetSum(set, n - 1, sum)\n    return isSubsetSum(set, n - 1, sum) or isSubsetSum(set,\n                                                       n - 1, sum - set[n - 1])\n","test":"\nset = [3, 34, 4, 12, 5, 2]\nsum = 9\nn = len(set)\nif (isSubsetSum(set, n, sum)):\n    print(\"Found a subset with given sum\")\nelse:\n    print(\"No subset with given sum\")\n","output":"Found a subset with given sum\n","fn_call":"isSubsetSum"}
{"text":"count of cyclic permutations having xor with other binary string as 0 | implementation of z - algorithm for linear time pattern searching ; function to get the count of the cyclic permutations of b that given 0 when xored with a ; concatenate b with b ; new b now contains all the cyclic permutations of old b as it 's sub-strings ; concatenate pattern with text ; fill z array used in z algorithm ; pattern occurs at index i since z value of i equals pattern length ; ","context":"","code":"def compute_z(s, z):\n    l = 0\n    r = 0\n    n = len(s)\n    for i in range(1, n, 1):\n        if (i > r):\n            l = i\n            r = i\n            while (r < n and s[r - l] == s[r]):\n                r += 1\n            z[i] = r - l\n            r -= 1\n        else:\n            k = i - l\n            if (z[k] < r - i + 1):\n                z[i] = z[k]\n            else:\n                l = i\n                while (r < n and s[r - l] == s[r]):\n                    r += 1\n                z[i] = r - l\n                r -= 1\n\n\ndef countPermutation(a, b):\n    b = b + b\n    b = b[0:len(b) - 1]\n    ans = 0\n    s = a + \"$\" + b\n    n = len(s)\n    z = [0 for i in range(n)]\n    compute_z(s, z)\n    for i in range(1, n, 1):\n        if (z[i] == len(a)):\n            ans += 1\n    return ans\n","test":"\nif __name__ == '__main__':\n    a = \"101\"\n    b = \"101\"\n    print(countPermutation(a, b))\n","output":"1\n","fn_call":"countPermutation"}
{"text":"lexicographically smallest k | function to find lexicographically smallest subsequence of size k ; length of string ; stores the minimum subsequence ; traverse the string s ; if the stack is empty ; iterate till the current character is less than the the character at the top of stack ; if stack size is < k ; push the current character into it ; stores the resultant string ; iterate until stack is empty ; reverse the string ; print the string ; ","context":"","code":"def smallestSubsequence(S, K):\n    N = len(S)\n    answer = []\n    for i in range(N):\n        if (len(answer) == 0):\n            answer .append(S[i])\n        else:\n            while (len(answer) > 0 and (\n                    S[i] < answer[len(answer) - 1]) and (len(answer) - 1 + N - i >= K)):\n                answer = answer[:-1]\n            if (len(answer) == 0 or len(answer) < K):\n                answer .append(S[i])\n    ret = []\n    while (len(answer) > 0):\n        ret .append(answer[len(answer) - 1])\n        answer = answer[:-1]\n    ret = ret[::-1]\n    ret = ''.join(ret)\n    print(ret)\n","test":"\nif __name__ == '__main__':\n    S = \"aabdaabc\"\n    K = 3\n    smallestSubsequence(S, K)\n","output":"aaa\n","fn_call":"smallestSubsequence"}
{"text":"check if string is right to left diagonal or not | python3 program to check if the given is right to left diagonal or not ; function to check if the given is right to left diagonal or not ; iterate over string ; if character is not same as the first character then return false ; ","context":"\nfrom math import sqrt, floor, ceil\n\n","code":"def is_rtol(s):\n    tmp = floor(sqrt(len(s))) - 1\n    first = s[tmp]\n    for pos in range(tmp, len(s) - 1, tmp):\n        if (s[pos] != first):\n            return False\n    return True\n","test":"\nif __name__ == '__main__':\n    str = \"abcxabxcaxbcxabc\"\n    if (is_rtol(str)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\n","fn_call":"is_rtol"}
{"text":"split a given string into substrings of length k with equal sum of ascii values | function for checking string ; check if the string can be split into substrings of k length only ; compute the sum of first substring of length k ; compute the sum of remaining substrings ; check if sum is equal to that of the first substring ; since all sums are not equal , return false ; all sums are equal , return true ; all substrings cannot be of size k ; ","context":"","code":"def check(str, K):\n    if (len(str) % K == 0):\n        sum = 0\n        for i in range(K):\n            sum += ord(str[i])\n        for j in range(K, len(str), K):\n            s_comp = 0\n            for p in range(j, j + K):\n                s_comp += ord(str[p])\n            if (s_comp != sum):\n                return False\n        return True\n    return False\n","test":"\nK = 3\nstr = \"abdcbbdba\"\nif (check(str, K)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n","output":"YES\n","fn_call":"check"}
{"text":"maximize count of 0 s in left and 1 s in right substring by splitting given binary string | function to maximize the sum of the count of zeros and ones in the left and right substring ; count the total numbers of ones in str ; to store the count of zeros and ones while traversing string ; iterate the given and update the maximum sum ; update the maximum sum ; ","context":"","code":"def maxSum(str):\n    maximumSum = 0\n    totalOnes = 0\n    for i in str:\n        if i == '1':\n            totalOnes += 1\n    zero = 0\n    ones = 0\n    i = 0\n    while i < len(str):\n        if (str[i] == '0'):\n            zero += 1\n        else:\n            ones += 1\n        maximumSum = max(maximumSum, zero + (totalOnes - ones))\n        i += 1\n    return maximumSum\n","test":"\nif __name__ == '__main__':\n    str = \"011101\"\n    print(maxSum(str))\n","output":"5\n","fn_call":"maxSum"}
{"text":"longest substring such that no three consecutive characters are same | function to return the length of the longest substring such that no three consecutive characters are same ; if the length of the given string is less than 3 ; initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2 ; traverse the string from the third character to the last ; if no three consecutive characters are same then increment temporary count ; else update the final ans and reset the temporary count ; ","context":"","code":"def maxLenSubStr(s):\n    if (len(s) < 3):\n        return len(s)\n    temp = 2\n    ans = 2\n    for i in range(2, len(s)):\n        if (s[i] != s[i - 1] or s[i] != s[i - 2]):\n            temp += 1\n        else:\n            ans = max(temp, ans)\n            temp = 2\n    ans = max(temp, ans)\n    return ans\n","test":"\ns = \"baaabbabbb\"\nprint(maxLenSubStr(s))\n","output":"7\n","fn_call":"maxLenSubStr"}
{"text":"number of ways to remove a sub | function to return the number of ways of removing a sub - string from s such that all the remaining characters are same ; to store the count of prefix and suffix ; loop to count prefix ; loop to count suffix ; first and last characters of the string are same ; otherwise ; ","context":"","code":"def no_of_ways(s):\n    n = len(s)\n    count_left = 0\n    count_right = 0\n    for i in range(0, n, 1):\n        if (s[i] == s[0]):\n            count_left += 1\n        else:\n            break\n    i = n - 1\n    while (i >= 0):\n        if (s[i] == s[n - 1]):\n            count_right += 1\n        else:\n            break\n        i -= 1\n    if (s[0] == s[n - 1]):\n        return ((count_left + 1) * (count_right + 1))\n    else:\n        return (count_left + count_right + 1)\n","test":"\nif __name__ == '__main__':\n    s = \"geeksforgeeks\"\n    print(no_of_ways(s))\n","output":"3\n","fn_call":"no_of_ways"}
{"text":"find the direction from given string | function to find the final direction ; if count is positive that implies resultant is clockwise direction ; if count is negative that implies resultant is anti - clockwise direction ; ","context":"","code":"def findDirection(s):\n    count = 0\n    d = \"\"\n    for i in range(len(s)):\n        if (s[i] == 'L'):\n            count -= 1\n        else:\n            if (s[i] == 'R'):\n                count += 1\n    if (count > 0):\n        if (count % 4 == 0):\n            d = \"N\"\n        elif (count % 4 == 10):\n            d = \"E\"\n        elif (count % 4 == 2):\n            d = \"S\"\n        elif (count % 4 == 3):\n            d = \"W\"\n    if (count < 0):\n        count *= -1\n        if (count % 4 == 0):\n            d = \"N\"\n        elif (count % 4 == 1):\n            d = \"W\"\n        elif (count % 4 == 2):\n            d = \"S\"\n        elif (count % 4 == 3):\n            d = \"E\"\n    return d\n","test":"\nif __name__ == '__main__':\n    s = \"LLRLRRL\"\n    print(findDirection(s))\n    s = \"LL\"\n    print(findDirection(s))\n","output":"W\nS\n","fn_call":"findDirection"}
{"text":"check if lowercase and uppercase characters are in same order | function to check if both the case follow the same order ; traverse the string ; store both lowercase and uppercase in two different strings ; transfor lowerstr to uppercase ; ","context":"","code":"def isCheck(str):\n    length = len(str)\n    lowerStr, upperStr = \"\", \"\"\n    for i in range(length):\n        if (ord(str[i]) >= 65 and ord(str[i]) <= 91):\n            upperStr = upperStr + str[i]\n        else:\n            lowerStr = lowerStr + str[i]\n    transformStr = lowerStr .upper()\n    return transformStr == upperStr\n","test":"\nif __name__ == \"__main__\":\n    str = \"geeGkEEsKS\"\n    if isCheck(str):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\n","fn_call":"isCheck"}
{"text":"print all paths of the binary tree with maximum element in each path greater than or equal to k | a binary tree node ; a recursive function to print the paths whose maximum element is greater than or equal to k . ; if the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path ; if the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0 ; append the node to the path vector ; recur left and right subtrees ; backtracking to return the vector and print the path if the flag is 1 ; function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to k ; initialize flag ; ans is used to check empty condition ; call function that print path ; if the path doesn 't exist ; ","context":"\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n","code":"def findPathUtil(root: Node, k: int, path: list, flag: int):\n    global ans\n    if root is None:\n        return\n    if root .data >= k:\n        flag = 1\n    if root .left is None and root .right is None:\n        if flag:\n            ans = 1\n            print(\"(\", end=\"\")\n            for i in range(len(path)):\n                print(path[i], end=\", \")\n            print(root .data, end=\"), \")\n        return\n    path .append(root .data)\n    findPathUtil(root .left, k, path, flag)\n    findPathUtil(root .right, k, path, flag)\n    path .pop()\n\n\ndef findPath(root: Node, k: int):\n    global ans\n    flag = 0\n    ans = 0\n    v = []\n    findPathUtil(root, k, v, flag)\n    if ans == 0:\n        print(-1)\n","test":"\nif __name__ == \"__main__\":\n    ans = 0\n    k = 25\n    root = Node(10)\n    root .left = Node(5)\n    root .right = Node(8)\n    root .left .left = Node(29)\n    root .left .right = Node(2)\n    root .right .right = Node(98)\n    root .right .left = Node(1)\n    root .right .right .right = Node(50)\n    root .left .left .left = Node(20)\n    findPath(root, k)\n","output":"(10, 5, 29, 20), (10, 8, 98, 50), ","fn_call":"findPath"}
{"text":"tridecagonal number | function to find n - th tridecagonal number ; formula to calculate nth tridecagonal number ; ","context":"","code":"def Tridecagonal_num(n):\n    return (11 * n * n - 9 * n) \/ 2\n","test":"\nn = 3\nprint(int(Tridecagonal_num(n)))\nn = 10\nprint(int(Tridecagonal_num(n)))\n","output":"36\n505\n","fn_call":"Tridecagonal_num"}
{"text":"Number of N digit integers with weight W | Function to find total possible numbers with n digits and weight w ; When Weight of an integer is Positive ; Subtract the weight from 9 ; When weight of an integer is negative ; add the weight to 10 to make it positive ; number of digits in an integer and w as weight ; print the total possible numbers with n digits and weight w","context":"","code":"def findNumbers(n, w):\n    x = 0\n    sum = 0\n    if (w >= 0 and w <= 8):\n        x = 9 - w\n    elif (w >= -9 and w <= -1):\n        x = 10 + w\n    sum = pow(10, n - 2)\n    sum = (x * sum)\n    return sum\n","test":"\nn = 3\nw = 4\nprint(findNumbers(n, w))\n","output":"50\n","fn_call":"findNumbers"}
{"text":"maximum height of triangular arrangement of array values | python program to find the maximum height of pyramidal arrangement of array values ; just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) \/ 2 elements in the array ; updating the result value each time ; otherwise we have exceeded n value ; ","context":"","code":"def MaximumHeight(a, n):\n    result = 1\n    for i in range(1, n):\n        y = (i * (i + 1)) \/ 2\n        if (y < n):\n            result = i\n        else:\n            break\n    return result\n","test":"\narr = [40, 100, 20, 30]\nn = len(arr)\nprint(MaximumHeight(arr, n))\n","output":"2\n","fn_call":"MaximumHeight"}
{"text":"k | python3 code to find k - th element in the odd - even sequence . ; insert all the odd numbers from 1 to n . ; insert all the even numbers from 1 to n . ; ","context":"","code":"def findK(n, k):\n    a = list()\n    i = 1\n    while i < n:\n        a .append(i)\n        i = i + 2\n    i = 2\n    while i < n:\n        a .append(i)\n        i = i + 2\n    return (a[k - 1])\n","test":"\nn = 10\nk = 3\nprint(findK(n, k))\n","output":"5\n","fn_call":"findK"}
{"text":"one line function for factorial of a number | python3 program to find factorial of given number ; single line to find factorial ; ","context":"","code":"def factorial(n):\n    return 1 if (n == 1 or n == 0)else n * factorial(n - 1)\n","test":"\nnum = 5\nprint(\"Factorial of\", num, \"is\", factorial(num))\n","output":"Factorial of 5 is 120\n","fn_call":"factorial"}
{"text":"pell number | calculate nth pell number ; ","context":"","code":"def pell(n):\n    if (n <= 2):\n        return n\n    a = 1\n    b = 2\n    for i in range(3, n + 1):\n        c = 2 * b + a\n        a = b\n        b = c\n    return b\n","test":"\nn = 4\nprint(pell(n))\n","output":"12\n","fn_call":"pell"}
{"text":"an efficient way to check whether n | returns true if n - th fibonacci number is multiple of 10. ; ","context":"","code":"def isMultipleOf10(n):\n    return (n % 15 == 0)\n","test":"\nn = 30\nif (isMultipleOf10(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n","output":"Yes\n","fn_call":"isMultipleOf10"}
{"text":"find politeness of a number | a function to count all odd prime factors of a given number n ; eliminate all even prime factor of number of n ; n must be odd at this point , so iterate for only odd numbers till sqrt ( n ) ; if i divides n , then start counting of odd divisors ; if n odd prime still remains then count it ; ","context":"","code":"def countOddPrimeFactors(n):\n    result = 1\n    while (n % 2 == 0):\n        n \/= 2\n    i = 3\n    while i * i <= n:\n        divCount = 0\n        while (n % i == 0):\n            n \/= i\n            divCount = divCount + 1\n        result = result * divCount + 1\n        i = i + 2\n    if (n > 2):\n        result = result * 2\n    return result\n\n\ndef politness(n):\n    return countOddPrimeFactors(n) - 1\n","test":"\nn = 90\nprint(\"Politness of \", n, \" = \", politness(n))\nn = 15\nprint(\"Politness of \", n, \" = \", politness(n))\n","output":"Politness of  90  =  5\nPolitness of  15  =  3\n","fn_call":"politness"}
{"text":"program for factorial of a number | function to find factorial of given number ; ","context":"","code":"def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n","test":"\nnum = 5\nprint(\"Factorial of\", num, \"is\", factorial(num))\n","output":"Factorial of 5 is 120\n","fn_call":"factorial"}
{"text":"turn off the rightmost set bit | set 2 | unsets the rightmost set bit of n and returns the result ; ","context":"","code":"def FlipBits(n):\n    n -= (n & (-n))\n    return n\n","test":"\nif __name__ == '__main__':\n    N = 12\n    print(\"The number after unsetting the\", end=\"\")\n    print(\" rightmost set bit: \", FlipBits(N))\n","output":"The number after unsetting the rightmost set bit:  8\n","fn_call":"FlipBits"}
{"text":"maximum value of xor among all triplets of an array | function to count maximum xor value for a triplet ; set is used to avoid repetitions ; store all possible unique xor value of pairs ; store maximum value ; ","context":"","code":"def Maximum_xor_Triplet(n, a):\n    s = set()\n    for i in range(0, n):\n        for j in range(i, n):\n            s .add(a[i] ^ a[j])\n    ans = 0\n    for i in s:\n        for j in range(0, n):\n            ans = max(ans, i ^ a[j])\n    print(ans)\n","test":"\nif __name__ == \"__main__\":\n    a = [1, 3, 8, 15]\n    n = len(a)\n    Maximum_xor_Triplet(n, a)\n","output":"15\n","fn_call":"Maximum_xor_Triplet"}
{"text":"find missing elements of a range | python library for binary search ; print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low . ; start from the found index and linearly search every range element x after this index in arr [ ] ; if x doesn 't math with current element  print it ; if x matches , move to next element in arr [ ] ; move to next element in range [ low , high ] ; print range elements thar are greater than the last element of sorted array . ; ","context":"\nfrom bisect import bisect_left\n\n","code":"def printMissing(arr, n, low, high):\n    arr .sort()\n    ptr = bisect_left(arr, low)\n    index = ptr\n    i = index\n    x = low\n    while (i < n and x <= high):\n        if (arr[i] != x):\n            print(x, end=\" \")\n        else:\n            i = i + 1\n        x = x + 1\n    while (x <= high):\n        print(x, end=\" \")\n        x = x + 1\n","test":"\narr = [1, 3, 5, 4]\nn = len(arr)\nlow = 1\nhigh = 10\nprintMissing(arr, n, low, high)\n","output":"2 6 7 8 9 10 ","fn_call":"printMissing"}
{"text":"find missing elements of a range | print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; create boolean list of size high - low + 1 , each index i representing wether ( i + low ) th element found or not . ; if ith element of arr is in range low to high then mark corresponding index as true in array ; traverse through the range and print all elements whose value is false ; ","context":"","code":"def printMissing(arr, n, low, high):\n    points_of_range = [False] * (high - low + 1)\n    for i in range(n):\n        if (low <= arr[i] and arr[i] <= high):\n            points_of_range[arr[i] - low] = True\n    for x in range(high - low + 1):\n        if (points_of_range[x] == False):\n            print(low + x, end=\" \")\n","test":"\narr = [1, 3, 5, 4]\nn = len(arr)\nlow, high = 1, 10\nprintMissing(arr, n, low, high)\n","output":"2 6 7 8 9 10 ","fn_call":"printMissing"}
{"text":"find missing elements of a range | print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ] ; insert all elements of arr [ ] in set ; traverse through the range and print all missing elements ; ","context":"","code":"def printMissing(arr, n, low, high):\n    s = set(arr)\n    for x in range(low, high + 1):\n        if x not in s:\n            print(x, end=' ')\n","test":"\narr = [1, 3, 5, 4]\nn = len(arr)\nlow, high = 1, 10\nprintMissing(arr, n, low, high)\n","output":"2 6 7 8 9 10 ","fn_call":"printMissing"}
{"text":"k | returns k - th missing element . it returns - 1 if no k is more than number of missing elements . ; insert all elements of given sequence b [ ] . ; traverse through increasing sequence and keep track of count of missing numbers . ; ","context":"","code":"def find(a, b, k, n1, n2):\n    s = set()\n    for i in range(n2):\n        s .add(b[i])\n    missing = 0\n    for i in range(n1):\n        if a[i]not in s:\n            missing += 1\n        if missing == k:\n            return a[i]\n    return -1\n","test":"\na = [0, 2, 4, 6, 8, 10, 12, 14, 15]\nb = [4, 10, 6, 8, 12]\nn1 = len(a)\nn2 = len(b)\nk = 3\nprint(find(a, b, k, n1, n2))\n","output":"14\n","fn_call":"find"}
{"text":"minimize steps to form string s from any random string of length k using a fixed length subsequences | ''function to find the minimum number of string required to generate the original string ; '' stores the frequency of each  character of string s ; '' stores the frequency of each  character of string s ; '' count unique characters in s ; '' if unique characters is greater  then n, then return -1 ; '' otherwise ; '' perform binary search ; '' find the value of mid ; '' iterate over the range  [0, 26] ; '' if the amount[i] is  greater than 0 ; '' update the ranges ; '' find the resultant string ; generate the subsequence ; ' ' \u2581 if \u2581 the \u2581 length \u2581 of \u2581 resultant \u2581 \u2581 string \u2581 is \u2581 less \u2581 than \u2581 n \u2581 than \u2581 \u2581 add \u2581 a \u2581 character \u2581 ' a '  ; '' print the string ; ''","context":"","code":"def findString(S, N):\n    amounts = [0] * 26\n    for i in range(len(S)):\n        amounts[ord(S[i]) - 97] += 1\n    count = 0\n    for i in range(26):\n        if amounts[i] > 0:\n            count += 1\n    if count > N:\n        print(\"-1\")\n    else:\n        ans = \"\"\n        high = 100001\n        low = 0\n        while (high - low) > 1:\n            total = 0\n            mid = (high + low) \/\/ 2\n            for i in range(26):\n                if amounts[i] > 0:\n                    total += (amounts[i] - 1) \/\/ mid + 1\n            if total <= N:\n                high = mid\n            else:\n                low = mid\n        print(high, end=\" \")\n        total = 0\n        for i in range(26):\n            if amounts[i] > 0:\n                total += (amounts[i] - 1) \/\/ high + 1\n                for j in range((amounts[i] - 1) \/\/ high + 1):\n                    ans += chr(i + 97)\n        for i in range(total, N):\n            ans += 'a'\n        ans = ans[::-1]\n        print(ans)\n","test":"\nS = \"toffee\"\nK = 4\nfindString(S, K)\n","output":"2 tofe\n","fn_call":"findString"}
{"text":"find the first repeating element in an array of integers | this function prints the first repeating element in arr [ ] ; initialize index of first repeating element ; creates an empty hashset ; traverse the input array from right to left ; if element is already in hash set , update min ; else add element to hash set ; print the result ; ","context":"","code":"def printFirstRepeating(arr, n):\n    Min = -1\n    myset = dict()\n    for i in range(n - 1, -1, -1):\n        if arr[i] in myset .keys():\n            Min = i\n        else:\n            myset[arr[i]] = 1\n    if (Min != -1):\n        print(\"The first repeating element is\", arr[Min])\n    else:\n        print(\"There are no repeating elements\")\n","test":"\narr = [10, 5, 3, 4, 3, 5, 6]\nn = len(arr)\nprintFirstRepeating(arr, n)\n","output":"The first repeating element is 5\n","fn_call":"printFirstRepeating"}
{"text":"find the first repeating element in an array of integers | this function prints the first repeating element in arr [ ] ; this will set k = 1 , if any repeating element found ; max = maximum from ( all elements & n ) ; array a is for storing 1 st time occurence of element initialized by 0 ; store 1 in array b if element is duplicate initialized by 0 ; duplicate element found ; storing 1 st occurence of arr [ i ] ; trace array a & find repeating element with min index ; ","context":"","code":"def printFirstRepeating(arr, n):\n    k = 0\n    max = n\n    for i in range(n):\n        if (max < arr[i]):\n            max = arr[i]\n    a = [0 for i in range(max + 1)]\n    b = [0 for i in range(max + 1)]\n    for i in range(n):\n        if (a[arr[i]]):\n            b[arr[i]] = 1\n            k = 1\n            continue\n        else:\n            a[arr[i]] = i\n    if (k == 0):\n        print(\"No repeating element found\")\n    else:\n        min = max + 1\n        for i in range(max + 1):\n            if (a[i] and (min > (a[i])) and b[i]):\n                min = a[i]\n        print(arr[min])\n","test":"\narr = [10, 5, 3, 4, 3, 5, 6]\nn = len(arr)\nprintFirstRepeating(arr, n)\n","output":"5\n","fn_call":"printFirstRepeating"}
{"text":"k | returns k - th distinct element in arr . ; check if current element is present somewhere else . ; if element is unique ; ","context":"","code":"def printKDistinct(arr, n, k):\n    dist_count = 0\n    for i in range(n):\n        j = 0\n        while j < n:\n            if (i != j and arr[j] == arr[i]):\n                break\n            j += 1\n        if (j == n):\n            dist_count += 1\n        if (dist_count == k):\n            return arr[i]\n    return -1\n","test":"\nar = [1, 2, 1, 3, 4, 2]\nn = len(ar)\nk = 2\nprint(printKDistinct(ar, n, k))\n","output":"4\n","fn_call":"printKDistinct"}
{"text":"count subarrays having an equal count of 0 s and 1 s segregated | ''function to count subarrays having equal count of 0s and 1s with all 0s and all 1s grouped together ; '' stores the count ; '' initialize cur with first element ; '' if the next element is same  as the current element ; '' increment count ; '' update curr ; '' iterate over the array count ; '' consider the minimum ;  ; ''","context":"","code":"def countSubarrays(A):\n    res = 0\n    curr, cnt = A[0], [1]\n    for c in A[1:]:\n        if c == curr:\n            cnt[-1] += 1\n        else:\n            curr = c\n        cnt .append(1)\n    for i in range(1, len(cnt)):\n        res += min(cnt[i - 1], cnt[i])\n    print(res - 1)\n","test":"\nA = [1, 1, 0, 0, 1, 0]\ncountSubarrays(A)\n","output":"4\n","fn_call":"countSubarrays"}
{"text":"maximize minimum distance between repetitions from any permutation of the given array | python3 program to implement the above approach ; size of the array ; stores the frequency of array elements ; find the highest frequency in the array ; increase count of max frequent element ; if no repetition is present ; find the maximum distance ; return the max distance ; ","context":"\nimport sys\n\n","code":"def findMaxLen(a):\n    n = len(a)\n    freq = [0] * (n + 1)\n    for i in range(n):\n        freq[a[i]] += 1\n    maxFreqElement = -sys .maxsize - 1\n    maxFreqCount = 1\n    for i in range(1, n + 1):\n        if (freq[i] > maxFreqElement):\n            maxFreqElement = freq[i]\n            maxFreqCount = 1\n        elif (freq[i] == maxFreqElement):\n            maxFreqCount += 1\n    if (maxFreqElement == 1):\n        ans = 0\n    else:\n        ans = ((n - maxFreqCount) \/\/ (maxFreqElement - 1))\n    return ans\n","test":"\na = [1, 2, 1, 2]\nprint(findMaxLen(a))\n","output":"2\n","fn_call":"findMaxLen"}
{"text":"find number of pairs in an array such that their xor is 0 | function to calculate the count ; sorting the list using built in function ; traversing through the elements ; counting frequncy of each elements ; adding the contribution of the frequency to the answer ; ","context":"","code":"def calculate(a):\n    a .sort()\n    count = 1\n    answer = 0\n    for i in range(1, len(a)):\n        if a[i] == a[i - 1]:\n            count += 1\n        else:\n            answer = answer + count * (count - 1) \/\/ 2\n            count = 1\n    answer = answer + count * (count - 1) \/\/ 2\n    return answer\n","test":"\nif __name__ == '__main__':\n    a = [1, 2, 1, 2, 4]\n    print(calculate(a))\n","output":"2\n","fn_call":"calculate"}
{"text":"find number of pairs in an array such that their xor is 0 | function to calculate the answer ; finding the maximum of the array ; creating frequency array with initial value 0 ; traversing through the array ; counting frequency ; traversing through the frequency array ; calculating answer ; ","context":"","code":"def calculate(a):\n    maximum = max(a)\n    frequency = [0 for x in range(maximum + 1)]\n    for i in a:\n        frequency[i] += 1\n    answer = 0\n    for i in frequency:\n        answer = answer + i * (i - 1) \/\/ 2\n    return answer\n","test":"\na = [1, 2, 1, 2, 4]\nprint(calculate(a))\n","output":"2\n","fn_call":"calculate"}
{"text":"largest subarray with equal number of 0 s and 1 s | this function prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . also returns the size of such subarray . ; pick a starting point as i ; consider all subarrays starting from i ; if this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; ","context":"","code":"def findSubArray(arr, n):\n    sum = 0\n    maxsize = -1\n    for i in range(0, n - 1):\n        sum = -1 if (arr[i] == 0)else 1\n        for j in range(i + 1, n):\n            sum = sum + (-1)if (arr[j] == 0)else sum + 1\n            if (sum == 0 and maxsize < j - i + 1):\n                maxsize = j - i + 1\n                startindex = i\n    if (maxsize == -1):\n        print(\"No such subarray\")\n    else:\n        print(startindex, \"to\", startindex + maxsize - 1)\n    return maxsize\n","test":"\narr = [1, 0, 0, 1, 0, 1, 1]\nsize = len(arr)\nfindSubArray(arr, size)\n","output":"0 to 5\n","fn_call":"findSubArray"}
{"text":"maximum element in a sorted and rotated array | function to return the maximum element ; if there is only one element left ; find mid ; check if mid reaches 0 , it is greater than next element or not ; check if mid itself is maximum element ; decide whether we need to go to the left half or the right half ; ","context":"","code":"def findMax(arr, low, high):\n    if (high == low):\n        return arr[low]\n    mid = low + (high - low) \/\/ 2\n    if (mid == 0 and arr[mid] > arr[mid + 1]):\n        return arr[mid]\n    if (mid < high and arr[mid + 1] < arr[mid]\n            and mid > 0 and arr[mid] > arr[mid - 1]):\n        return arr[mid]\n    if (arr[low] > arr[mid]):\n        return findMax(arr, low, mid - 1)\n    else:\n        return findMax(arr, mid + 1, high)\n","test":"\narr = [6, 5, 4, 3, 2, 1]\nn = len(arr)\nprint(findMax(arr, 0, n - 1))\n","output":"6\n","fn_call":"findMax"}
{"text":"Ternary Search | Function to perform Ternary Search ; Find mid1 and mid2 ; Check if key is at any mid ; Since key is not present at mid , Check in which region it is present Then repeat the search operation in that region ; key lies between l and mid1 ; key lies between mid2 and r ; key lies between mid1 and mid2 ; key not found ; Get the list Sort the list if not sorted ; Starting index ; Length of list ; Key to be searched in the list ; Search the key using ternary search ; Print the result ; Key to be searched in the list ; Search the key using ternary search ; Print the result","context":"","code":"def ternarySearch(l, r, key, ar):\n    while r >= l:\n        mid1 = l + (r - l) \/\/ 3\n        mid2 = r - (r - l) \/\/ 3\n        if key == ar[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n        if key < ar[mid1]:\n            r = mid1 - 1\n        elif key > ar[mid2]:\n            l = mid2 + 1\n        else:\n            l = mid1 + 1\n            r = mid2 - 1\n    return -1\n","test":"\nar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nl = 0\nr = 9\nkey = 5\np = ternarySearch(l, r, key, ar)\nprint(\"Index of\", key, \"is\", p)\nkey = 50\np = ternarySearch(l, r, key, ar)\nprint(\"Index of\", key, \"is\", p)\n","output":"Index of 5 is 4\nIndex of 50 is -1\n","fn_call":"ternarySearch"}
{"text":"majority element | set | function to print the majoritynumber ; ","context":"","code":"def majorityNumber(nums):\n    num_count = {}\n    for num in nums:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    for num in num_count:\n        if num_count[num] > len(nums) \/ 2:\n            return num\n    return -1\n","test":"\na = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityNumber(a))\n","output":"2\n","fn_call":"majorityNumber"}
{"text":"search an element in a sorted and rotated array | returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1 ; if arr [ l ... mid ] is sorted ; as this subarray is sorted , we can quickly check if key lies in half or other half ; if key not lies in first half subarray , divide other half into two subarrays , such that we can quickly check if key lies in other half ; if arr [ l . . mid ] is not sorted , then arr [ mid ... r ] must be sorted ; ","context":"","code":"def search(arr, l, h, key):\n    if l > h:\n        return -1\n    mid = (l + h) \/\/ 2\n    if arr[mid] == key:\n        return mid\n    if arr[l] <= arr[mid]:\n        if key >= arr[l] and key <= arr[mid]:\n            return search(arr, l, mid - 1, key)\n        return search(arr, mid + 1, h, key)\n    if key >= arr[mid] and key <= arr[h]:\n        return search(a, mid + 1, h, key)\n    return search(arr, l, mid - 1, key)\n","test":"\narr = [4, 5, 6, 7, 8, 9, 1, 2, 3]\nkey = 6\ni = search(arr, 0, len(arr) - 1, key)\nif i != -1:\n    print(\"Index: % d\" % i)\nelse:\n    print(\"Key not found\")\n","output":"Index:  2\n","fn_call":"search"}
{"text":"find the minimum element in a sorted and rotated array | python program to find minimum element in a sorted and rotated array ; this condition is needed to handle the case when array is not rotated at all ; if there is only one element left ; find mid ; check if element ( mid + 1 ) is minimum element . consider the cases like [ 3 , 4 , 5 , 1 , 2 ] ; check if mid itself is minimum element ; decide whether we need to go to left half or right half ; ","context":"","code":"def findMin(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = int((low + high) \/ 2)\n    if mid < high and arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    if arr[high] > arr[mid]:\n        return findMin(arr, low, mid - 1)\n    return findMin(arr, mid + 1, high)\n","test":"\narr1 = [5, 6, 1, 2, 3, 4]\nn1 = len(arr1)\nprint(\"The minimum element is \" + str(findMin(arr1, 0, n1 - 1)))\narr2 = [1, 2, 3, 4]\nn2 = len(arr2)\nprint(\"The minimum element is \" + str(findMin(arr2, 0, n2 - 1)))\narr3 = [1]\nn3 = len(arr3)\nprint(\"The minimum element is \" + str(findMin(arr3, 0, n3 - 1)))\narr4 = [1, 2]\nn4 = len(arr4)\nprint(\"The minimum element is \" + str(findMin(arr4, 0, n4 - 1)))\narr5 = [2, 1]\nn5 = len(arr5)\nprint(\"The minimum element is \" + str(findMin(arr5, 0, n5 - 1)))\narr6 = [5, 6, 7, 1, 2, 3, 4]\nn6 = len(arr6)\nprint(\"The minimum element is \" + str(findMin(arr6, 0, n6 - 1)))\narr7 = [1, 2, 3, 4, 5, 6, 7]\nn7 = len(arr7)\nprint(\"The minimum element is \" + str(findMin(arr7, 0, n7 - 1)))\narr8 = [2, 3, 4, 5, 6, 7, 8, 1]\nn8 = len(arr8)\nprint(\"The minimum element is \" + str(findMin(arr8, 0, n8 - 1)))\narr9 = [3, 4, 5, 1, 2]\nn9 = len(arr9)\nprint(\"The minimum element is \" + str(findMin(arr9, 0, n9 - 1)))\n","output":"The minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\nThe minimum element is 1\n","fn_call":"findMin"}
{"text":"find the minimum element in a sorted and rotated array | function to find minimum element ; ","context":"","code":"def findMin(arr, low, high):\n    while (low < high):\n        mid = low + (high - low) \/\/ 2\n        if (arr[mid] == arr[high]):\n            high -= 1\n        elif (arr[mid] > arr[high]):\n            low = mid + 1\n        else:\n            high = mid\n    return arr[high]\n","test":"\nif __name__ == '__main__':\n    arr1 = [5, 6, 1, 2, 3, 4]\n    n1 = len(arr1)\n    print(\"The minimum element is \", findMin(arr1, 0, n1 - 1))\n    arr2 = [1, 2, 3, 4]\n    n2 = len(arr2)\n    print(\"The minimum element is \", findMin(arr2, 0, n2 - 1))\n    arr3 = [1]\n    n3 = len(arr3)\n    print(\"The minimum element is \", findMin(arr3, 0, n3 - 1))\n    arr4 = [1, 2]\n    n4 = len(arr4)\n    print(\"The minimum element is \", findMin(arr4, 0, n4 - 1))\n    arr5 = [2, 1]\n    n5 = len(arr5)\n    print(\"The minimum element is \", findMin(arr5, 0, n5 - 1))\n    arr6 = [5, 6, 7, 1, 2, 3, 4]\n    n6 = len(arr6)\n    print(\"The minimum element is \", findMin(arr6, 0, n6 - 1))\n    arr7 = [1, 2, 3, 4, 5, 6, 7]\n    n7 = len(arr7)\n    print(\"The minimum element is \", findMin(arr7, 0, n7 - 1))\n    arr8 = [2, 3, 4, 5, 6, 7, 8, 1]\n    n8 = len(arr8)\n    print(\"The minimum element is \", findMin(arr8, 0, n8 - 1))\n    arr9 = [3, 4, 5, 1, 2]\n    n9 = len(arr9)\n    print(\"The minimum element is \", findMin(arr9, 0, n9 - 1))\n","output":"The minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\nThe minimum element is  1\n","fn_call":"findMin"}
{"text":"k | python3 program to find k - th absolute difference between two elements ; returns number of pairs with absolute difference less than or equal to mid . ; upper bound returns pointer to position of next higher number than a [ i ] + mid in a [ i . . n - 1 ] . we subtract ( a + i + 1 ) from this position to count ; returns k - th absolute difference ; sort array ; minimum absolute difference ; maximum absolute difference ; do binary search for k - th absolute difference ; ","context":"\nfrom bisect import bisect as upper_bound\n\n","code":"def countPairs(a, n, mid):\n    res = 0\n    for i in range(n):\n        res += upper_bound(a, a[i] + mid)\n    return res\n\n\ndef kthDiff(a, n, k):\n    a = sorted(a)\n    low = a[1] - a[0]\n    for i in range(1, n - 1):\n        low = min(low, a[i + 1] - a[i])\n    high = a[n - 1] - a[0]\n    while (low < high):\n        mid = (low + high) >> 1\n        if (countPairs(a, n, mid) < k):\n            low = mid + 1\n        else:\n            high = mid\n    return low\n","test":"\nk = 3\na = [1, 2, 3, 4]\nn = len(a)\nprint(kthDiff(a, n, k))\n","output":"1\n","fn_call":"kthDiff"}
{"text":"find the smallest and second smallest elements in an array | python program to find smallest and second smallest elements ; function to print first smallest and second smallest elements ; there should be atleast two elements ; if current element is smaller than first then update both first and second ; if arr [ i ] is in between first and second then update second ; ","context":"\nimport sys\n\n","code":"def print2Smallest(arr):\n    arr_size = len(arr)\n    if arr_size < 2:\n        print(\"Invalid Input\")\n        return\n    first = second = sys .maxsize\n    for i in range(0, arr_size):\n        if arr[i] < first:\n            second = first\n            first = arr[i]\n        elif (arr[i] < second and arr[i] != first):\n            second = arr[i]\n    if (second == sys .maxsize):\n        print(\"No second smallest element\")\n    else:\n        print('The smallest element is', first,\n              'and' ' second smallest element is', second)\n","test":"\narr = [12, 13, 1, 10, 34, 1]\nprint2Smallest(arr)\n","output":"The smallest element is 1 and second smallest element is 10\n","fn_call":"print2Smallest"}
{"text":"count possible decoding of a given digit sequence with hidden characters | python program for the above approach ; check the first character of the string if it is ' * ' then 9 ways ; traverse the string ; if s [ i ] = = ' * ' there can be 9 possible values of * ; if previous character is 1 then words that can be formed are k ( 11 ) , l ( 12 ) , m ( 13 ) , n ( 14 ) o ( 15 ) , p ( 16 ) , q ( 17 ) , r ( 18 ) , s ( 19 ) ; if previous character is 2 then the words that can be formed are u ( 21 ) , v ( 22 ) , w ( 23 ) , x ( 24 ) y ( 25 ) , z ( 26 ) ; if the previous digit is * then all 15 2 - digit characters can be formed ; taking the value from previous step ; if previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; if previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] . ; if previous character is * then it will contain the above 2 cases ; ","context":"\nM = 1000000007\n\n","code":"def waysOfDecoding(s):\n    dp = [0] * (len(s) + 1)\n    dp[0] = 1\n    if s[0] == '*':\n        dp[1] = 9\n    elif s[0] == '0':\n        dp[1] = 0\n    else:\n        dp[1] = 1\n    for i in range(len(s)):\n        if (s[i] == '*'):\n            dp[i + 1] = 9 * dp[i]\n            if (s[i - 1] == '1'):\n                dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % M\n            elif (s[i - 1] == '2'):\n                dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % M\n            elif (s[i - 1] == '*'):\n                dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % M\n        else:\n            if s[i] != '0':\n                dp[i + 1] = dp[i]\n            else:\n                dp[i + 1] = 0\n            if (s[i - 1] == '1'):\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M\n            elif (s[i - 1] == '2' and s[i] <= '6'):\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M\n            elif (s[i - 1] == '*'):\n                if (s[i] <= '6'):\n                    dp[i + 1] = dp[i + 1] + 2 * dp[i - 1]\n                else:\n                    dp[i + 1] = dp[i + 1] + 1 * dp[i - 1]\n                dp[i + 1] = dp[i + 1] % M\n    return dp[len(s)]\n","test":"\nif __name__ == \"__main__\":\n    s = \"12\"\n    print(waysOfDecoding(s))\n","output":"2\n","fn_call":"waysOfDecoding"}
{"text":"count ways to split array into two subsets having difference between their sum equal to k | function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff ; store the sum of the set s1 ; initializing the matrix ; number of ways to get sum using 0 elements is 0 ; number of ways to get sum 0 using i elements is 1 ; traverse the 2d array ; if the value is greater than the sum store the value of previous state ; return the result ; ","context":"","code":"def countSubset(arr, n, diff):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    sum += diff\n    sum = sum \/\/ 2\n    t = [[0 for i in range(sum + 1)]for i in range(n + 1)]\n    for j in range(sum + 1):\n        t[0][j] = 0\n    for i in range(n + 1):\n        t[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if (arr[i - 1] > j):\n                t[i][j] = t[i - 1][j]\n            else:\n                t[i][j] = t[i - 1][j] + t[i - 1][j - arr[i - 1]]\n    return t[n][sum]\n","test":"\nif __name__ == '__main__':\n    diff, n = 1, 4\n    arr = [1, 1, 2, 3]\n    print(countSubset(arr, n, diff))\n","output":"3\n","fn_call":"countSubset"}
{"text":"probability that the sum of all numbers obtained on throwing a dice n times lies between two given integers | python3 program for above approach ; function to calculate probability that the sum of numbers on n throws of dice lies between a and b ; base case ; add the probability for all the numbers between a and b ; ","context":"\ndp = [[0 for i in range(605)]for j in range(105)]\n\n","code":"def find(N, a, b):\n    probability = 0.0\n    for i in range(1, 7):\n        dp[1][i] = 1.0 \/ 6\n    for i in range(2, N + 1):\n        for j in range(i, (6 * i) + 1):\n            for k in range(1, 7):\n                dp[i][j] = dp[i][j] + dp[i - 1][j - k] \/ 6\n    for Sum in range(a, b + 1):\n        probability = probability + dp[N][Sum]\n    return probability\n","test":"\nN, a, b = 4, 13, 17\nprobability = find(N, a, b)\nprint('%.6f' % probability)\n","output":"0.505401\n","fn_call":"find"}
{"text":"maximum sum from a tree with adjacent levels not allowed | python3 code for max sum with adjacent levels not allowed ; a bst node ; recursive function to find the maximum sum returned for a root node and its grandchildren ; returns maximum sum with adjacent levels not allowed . this function mainly uses getsumalternate ( ) ; we compute sum of alternate levels starting first level and from second level . and return maximum of two values . ; ","context":"\nfrom collections import deque as queue\n\n\nclass Node:\n    def __init__(self, x):\n        self .data = x\n        self .left = None\n        self .right = None\n\n","code":"def getSumAlternate(root):\n    if (root is None):\n        return 0\n    sum = root .data\n    if (root .left is not None):\n        sum += getSum(root .left .left)\n        sum += getSum(root .left .right)\n    if (root .right is not None):\n        sum += getSum(root .right .left)\n        sum += getSum(root .right .right)\n    return sum\n\n\ndef getSum(root):\n    if (root is None):\n        return 0\n    return max(\n        getSumAlternate(root),\n        (getSumAlternate(\n            root .left) +\n            getSumAlternate(\n            root .right)))\n","test":"\nif __name__ == '__main__':\n    root = Node(1)\n    root .left = Node(2)\n    root .right = Node(3)\n    root .right .left = Node(4)\n    root .right .left .right = Node(5)\n    root .right .left .right .left = Node(6)\n    print(getSum(root))\n","output":"11\n","fn_call":"getSum"}
{"text":"subset sum problem in o ( sum ) space | returns true if there exists a subset with given sum in arr [ ] ; the value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; a subset with sum 0 is always possible ; if there exists no element no sum is possible ; ","context":"","code":"def isSubsetSum(arr, n, sum):\n    subset = [[False for j in range(sum + 1)]for i in range(3)]\n    for i in range(n + 1):\n        for j in range(sum + 1):\n            if (j == 0):\n                subset[i % 2][j] = True\n            elif (i == 0):\n                subset[i % 2][j] = False\n            elif (arr[i - 1] <= j):\n                subset[i %\n                       2][j] = subset[(i + 1) %\n                                      2][j - arr[i - 1]] or subset[(i + 1) %\n                                                                   2][j]\n            else:\n                subset[i % 2][j] = subset[(i + 1) % 2][j]\n    return subset[n % 2][sum]\n","test":"\narr = [6, 2, 5]\nsum = 7\nn = len(arr)\nif (isSubsetSum(arr, n, sum)):\n    print(\"There exists a subset with given sum\")\nelse:\n    print(\"No subset exists with given sum\")\n","output":"There exists a subset with given sum\n","fn_call":"isSubsetSum"}
{"text":"maximum equlibrium sum in an array | python 3 program to find maximum equilibrium sum . ; function to find maximum equilibrium sum . ; ","context":"\nimport sys\n\n","code":"def findMaxSum(arr, n):\n    res = -sys .maxsize - 1\n    for i in range(n):\n        prefix_sum = arr[i]\n        for j in range(i):\n            prefix_sum += arr[j]\n        suffix_sum = arr[i]\n        j = n - 1\n        while (j > i):\n            suffix_sum += arr[j]\n            j -= 1\n        if (prefix_sum == suffix_sum):\n            res = max(res, prefix_sum)\n    return res\n","test":"\nif __name__ == '__main__':\n    arr = [-2, 5, 3, 1, 2, 6, -4, 2]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n","output":"7\n","fn_call":"findMaxSum"}
{"text":"maximum equlibrium sum in an array | function to find maximum equilibrium sum . ; array to store prefix sum . ; array to store suffix sum . ; variable to store maximum sum . ; calculate prefix sum . ; calculate suffix sum and compare it with prefix sum . update ans accordingly . ; ","context":"","code":"def findMaxSum(arr, n):\n    preSum = [0 for i in range(n)]\n    suffSum = [0 for i in range(n)]\n    ans = -10000000\n    preSum[0] = arr[0]\n    for i in range(1, n):\n        preSum[i] = preSum[i - 1] + arr[i]\n    suffSum[n - 1] = arr[n - 1]\n    if (preSum[n - 1] == suffSum[n - 1]):\n        ans = max(ans, preSum[n - 1])\n    for i in range(n - 2, -1, -1):\n        suffSum[i] = suffSum[i + 1] + arr[i]\n        if (suffSum[i] == preSum[i]):\n            ans = max(ans, preSum[i])\n    return ans\n","test":"\nif __name__ == '__main__':\n    arr = [-2, 5, 3, 1, 2, 6, -4, 2]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n","output":"7\n","fn_call":"findMaxSum"}
{"text":"maximum equlibrium sum in an array | python3 program to find maximum equilibrium sum . ; function to find maximum equilibrium sum . ; ","context":"\nimport sys\n\n","code":"def findMaxSum(arr, n):\n    ss = sum(arr)\n    prefix_sum = 0\n    res = -sys .maxsize\n    for i in range(n):\n        prefix_sum += arr[i]\n        if prefix_sum == ss:\n            res = max(res, prefix_sum)\n        ss -= arr[i]\n    return res\n","test":"\nif __name__ == \"__main__\":\n    arr = [-2, 5, 3, 1, 2, 6, -4, 2]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n","output":"7\n","fn_call":"findMaxSum"}
{"text":"majority element | function to find majority element in an array ; sentinels ; update maxcount if count of current element is greater ; if maxcount is greater than n \/ 2 return the corresponding element ; ","context":"","code":"def findMajority(arr, n):\n    maxCount = 0\n    index = -1\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if (arr[i] == arr[j]):\n                count += 1\n        if (count > maxCount):\n            maxCount = count\n            index = i\n    if (maxCount > n \/\/ 2):\n        print(arr[index])\n    else:\n        print(\"No Majority Element\")\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 1, 2, 1, 3, 5, 1]\n    n = len(arr)\n    findMajority(arr, n)\n","output":"1\n","fn_call":"findMajority"}
{"text":"majority element | function to find the candidate for majority ; function to check if the candidate occurs more than n \/ 2 times ; function to print majority element ; find the candidate for majority ; print the candidate if it is majority ; ","context":"","code":"def findCandidate(A):\n    maj_index = 0\n    count = 1\n    for i in range(len(A)):\n        if A[maj_index] == A[i]:\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            maj_index = i\n            count = 1\n    return A[maj_index]\n\n\ndef isMajority(A, cand):\n    count = 0\n    for i in range(len(A)):\n        if A[i] == cand:\n            count += 1\n    if count > len(A) \/ 2:\n        return True\n    else:\n        return False\n\n\ndef printMajority(A):\n    cand = findCandidate(A)\n    if isMajority(A, cand):\n        print(cand)\n    else:\n        print(\"No Majority Element\")\n","test":"\nA = [1, 3, 3, 1, 2]\nprintMajority(A)\n","output":"No Majority Element\n","fn_call":"printMajority"}
{"text":"majority element | python3 program for finding out majority element in an array ; ","context":"","code":"def findMajority(arr, size):\n    m = {}\n    for i in range(size):\n        if arr[i] in m:\n            m[arr[i]] += 1\n        else:\n            m[arr[i]] = 1\n    count = 0\n    for key in m:\n        if m[key] > size \/ 2:\n            count = 1\n            print(\"Majority found :-\", key)\n            break\n    if (count == 0):\n        print(\"No Majority element\")\n","test":"\narr = [2, 2, 2, 2, 5, 5, 2, 3, 3]\nn = len(arr)\nfindMajority(arr, n)\n","output":"Majority found :- 2\n","fn_call":"findMajority"}
{"text":"majority element | function to find majority element in an array it returns - 1 if there is no majority element ; sort the array in o ( nlogn ) ; increases the count if the same element occurs otherwise starts counting new element ; sets maximum count and stores maximum occured element so far if maximum count becomes greater than n \/ 2 it breaks out setting the flag ; returns maximum occured element if there is no such element , returns - 1 ; ","context":"","code":"def majorityElement(arr, n):\n    arr .sort()\n    count, max_ele, temp, f = 1, -1, arr[0], 0\n    for i in range(1, n):\n        if (temp == arr[i]):\n            count += 1\n        else:\n            count = 1\n            temp = arr[i]\n        if (max_ele < count):\n            max_ele = count\n            ele = arr[i]\n            if (max_ele > (n \/\/ 2)):\n                f = 1\n                break\n    if f == 1:\n        return ele\n    else:\n        return -1\n","test":"\narr = [1, 1, 2, 1, 3, 5, 1]\nn = len(arr)\nprint(majorityElement(arr, n))\n","output":"1\n","fn_call":"majorityElement"}
{"text":"dynamic programming | returns true if there is a subset of set [ ] with sum equal to given sum ; the value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; if sum is 0 , then answer is true ; if sum is not 0 and set is empty , then answer is false ; fill the subset table in bottom up manner ; uncomment this code to print table ; ","context":"","code":"def isSubsetSum(set, n, sum):\n    subset = ([[False for i in range(sum + 1)]for i in range(n + 1)])\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= set[i - 1]:\n                subset[i][j] = (subset[i - 1][j]\n                                or subset[i - 1][j - set[i - 1]])\n    return subset[n][sum]\n","test":"\nif __name__ == '__main__':\n    set = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    n = len(set)\n    if (isSubsetSum(set, n, sum)):\n        print(\"Found a subset with given sum\")\n    else:\n        print(\"No subset with given sum\")\n","output":"Found a subset with given sum\n","fn_call":"isSubsetSum"}
{"text":"dynamic programming | taking the matrix as globally ; check if possible subset with given sum is possible or not ; if the sum is zero it means we got our expected sum ; if the value is not - 1 it means it already call the function with the same value . it will save our from the repetition . ; if the value of a [ n - 1 ] is greater than the sum . we call for the next value ; here we do two calls because we don ' t \u2581 know \u2581 which \u2581 value \u2581 is \u2581 \u2581 full - fill \u2581 our \u2581 criteria \u2581 \u2581 that ' s why we doing two calls ; ","context":"\ntab = [[-1 for i in range(2000)]for j in range(2000)]\n\n","code":"def subsetSum(a, n, sum):\n    if (sum == 0):\n        return 1\n    if (n <= 0):\n        return 0\n    if (tab[n - 1][sum] != -1):\n        return tab[n - 1][sum]\n    if (a[n - 1] > sum):\n        tab[n - 1][sum] = subsetSum(a, n - 1, sum)\n        return tab[n - 1][sum]\n    else:\n        tab[n - 1][sum] = subsetSum(a, n - 1, sum)\n        return tab[n - 1][sum] or subsetSum(a, n - 1, sum - a[n - 1])\n","test":"\nn = 5\na = [1, 5, 3, 7, 4]\nsum = 12\nif (subsetSum(a, n, sum)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n","output":"YES\n","fn_call":"subsetSum"}
{"text":"sum of bit differences for numbers from 0 to n | python3 program for the above approach ; function to implement fast exponentiation ; function to return the value for powers of 2 ; function to convert n into binary ; to store binary representation ; iterate each digit of n ; return binary representation ; function to find difference in bits ; get binary representation ; total number of bit differences from 0 to n ; iterate over each binary bit ; if current bit is '1' then add the count of current bit ; ","context":"\nfrom math import log\n\n","code":"def binpow(a, b):\n    res = 1\n    while (b > 0):\n        if (b % 2 == 1):\n            res = res * a\n        a = a * a\n        b \/\/= 2\n    return res\n\n\ndef find(x):\n    if (x == 0):\n        return 0\n    p = log(x) \/ log(2)\n    return binpow(2, p + 1) - 1\n\n\ndef getBinary(n):\n    ans = \"\"\n    while (n > 0):\n        dig = n % 2\n        ans += str(dig)\n        n \/\/= 2\n    return ans\n\n\ndef totalCountDifference(n):\n    ans = getBinary(n)\n    req = 0\n    for i in range(len(ans)):\n        if (ans[i] == '1'):\n            req += find(binpow(2, i))\n    return req\n","test":"\nN = 5\nprint(totalCountDifference(N))\n","output":"8\n","fn_call":"totalCountDifference"}
{"text":"find the maximum length of the prefix | function to return the maximum length of the required prefix ; array to store the frequency of each element of the array ; iterating for all the elements ; update the frequency of the current element i . e . v ; sorted positive values from counts array ; if current prefix satisfies the given conditions ; return the maximum length ; ","context":"","code":"def Maximum_Length(a):\n    counts = [0] * 11\n    for index, v in enumerate(a):\n        counts[v] += 1\n        k = sorted([i for i in counts if i])\n        if len(k) == 1 or (k[0] == k[-2] and k[-1] - k[-2]\n                           == 1) or (k[0] == 1 and k[1] == k[-1]):\n            ans = index\n    return ans + 1\n","test":"\nif __name__ == \"__main__\":\n    a = [1, 1, 1, 2, 2, 2]\n    n = len(a)\n    print(Maximum_Length(a))\n","output":"5\n","fn_call":"Maximum_Length"}
{"text":"online queries for gcd of array after divide operations | returns the gcd after all updates in the array ; function to calculate gcd of onine queries ; stores the gcd of the initial array elements ; calculates the gcd ; performing online queries ; index is 1 based ; divide the array element ; calculates the current gcd ; print the gcd after each step ; ","context":"","code":"def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef print_gcd_online(n, m, query, arr):\n    max_gcd = 0\n    for i in range(0, n):\n        max_gcd = gcd(max_gcd, arr[i])\n    for i in range(0, m):\n        query[i][0] -= 1\n        arr[query[i][0]] \/\/= query[i][1]\n        max_gcd = gcd(arr[query[i][0]], max_gcd)\n        print(max_gcd)\n","test":"\nif __name__ == \"__main__\":\n    n, m = 3, 3\n    query = [[1, 3], [3, 12], [2, 4]]\n    arr = [36, 24, 72]\n    print_gcd_online(n, m, query, arr)\n","output":"12\n6\n6\n","fn_call":"print_gcd_online"}
{"text":"numbers in range [ l , r ] such that the count of their divisors is both even and prime | python 3 implementation of the approach ; stores whether the number is prime or not ; stores the count of prime numbers less than or equal to the index ; create the sieve ; create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . a value in prime [ i ] will finally be false if ' i ' is not a prime , else true ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; stores the prefix sum of number of primes less than or equal to 'i ; ","context":"\nMAX = 1000000\nprime = [True] * (MAX + 1)\nsum = [0] * (MAX + 1)\n\n","code":"def SieveOfEratosthenes():\n\n    prime[1] = False\n\n    p = 2\n    while p * p <= MAX:\n        if (prime[p]):\n            i = p * 2\n            while i <= MAX:\n                prime[i] = False\n                i += p\n\n        p += 1\n\n    for i in range(1, MAX + 1):\n        if (prime[i] == True):\n            sum[i] = 1\n\n        sum[i] += sum[i - 1]\n","test":"\nif __name__ == \"__main__\":\n    SieveOfEratosthenes()\n    l = 3\n    r = 9\n    c = (sum[r] - sum[l - 1])\n    print(\"Count:\", c)\n","output":"Count: 3\n","fn_call":"SieveOfEratosthenes"}
{"text":"area of a circle inscribed in a rectangle which is inscribed in a semicircle | python 3 program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle ; function to find the area of the circle ; radius cannot be negative ; area of the circle ; ","context":"\nfrom math import pow, sqrt\n\n","code":"def area(r):\n    if (r < 0):\n        return -1\n    area = 3.14 * pow(r \/ (2 * sqrt(2)), 2)\n    return area\n","test":"\nif __name__ == '__main__':\n    a = 5\n    print(\"{0:.6}\".format(area(a)))\n","output":"9.8125\n","fn_call":"area"}
{"text":"divide a number into two parts such that sum of digits is maximum | returns sum of digits of x ; returns closest number to x in terms of 9 's ; ","context":"","code":"def sumOfDigitsSingle(x):\n    ans = 0\n    while x:\n        ans += x % 10\n        x \/\/= 10\n    return ans\n\n\ndef closest(x):\n    ans = 0\n    while (ans * 10 + 9 <= x):\n        ans = ans * 10 + 9\n    return ans\n\n\ndef sumOfDigitsTwoParts(N):\n    A = closest(N)\n    return sumOfDigitsSingle(A) + sumOfDigitsSingle(N - A)\n","test":"\nif __name__ == \"__main__\":\n    N = 35\n    print(sumOfDigitsTwoParts(N))\n","output":"17\n","fn_call":"sumOfDigitsTwoParts"}
{"text":"Primality Test | Set 5 ( Using Lucas | Function to check whether ( 2 ^ p - 1 ) is prime or not . ; generate the number ; First number of the series ; Generate the rest ( p - 2 ) terms of the series ; now if the ( p - 1 ) the term is 0 return true else false . ; Check whetherr 2 ^ ( p - 1 ) is prime or not .","context":"","code":"def isPrime(p):\n    checkNumber = 2 ** p - 1\n    nextval = 4 % checkNumber\n    for i in range(1, p - 1):\n        nextval = (nextval * nextval - 2) % checkNumber\n    if (nextval == 0):\n        return True\n    else:\n        return False\n","test":"\np = 7\ncheckNumber = 2 ** p - 1\nif isPrime(p):\n    print(checkNumber, 'is Prime.')\nelse:\n    print(checkNumber, 'is not Prime')\n","output":"127 is Prime.\n","fn_call":"isPrime"}
{"text":"sophie germain prime | function to detect prime number here we have used sieve method https : www . geeksforgeeks . org \/ sieve - of - eratosthenes \/ to detect prime number ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; we have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime . ; checking every i whether it is sophie german prime or not . ; ","context":"","code":"def sieve(n, prime):\n    p = 2\n    while (p * p <= n):\n        if (prime[p]):\n            for i in range(p * 2, n, p):\n                prime[i] = False\n        p += 1\n\n\ndef printSophieGermanNumber(n):\n    prime = [True] * (2 * n + 1)\n    sieve(2 * n + 1, prime)\n    for i in range(2, n + 1):\n        if (prime[i] and prime[2 * i + 1]):\n            print(i, end=\" \")\n","test":"\nn = 25\nprintSophieGermanNumber(n)\n","output":"2 3 5 11 23 ","fn_call":"printSophieGermanNumber"}
{"text":"an efficient way to check whether n | a simple python 3 program to check if n - th fibonacci number is multiple of 10. ; returns true if n - th fibonacci number is multiple of 10. ; ","context":"","code":"def fibonacci(n):\n    a = 0\n    b = 1\n    if (n <= 1):\n        return n\n    for i in range(2, n + 1):\n        c = a + b\n        a = b\n        b = c\n    return c\n\n\ndef isMultipleOf10(n):\n    f = fibonacci(30)\n    return (f % 10 == 0)\n","test":"\nif __name__ == \"__main__\":\n    n = 30\n    if (isMultipleOf10(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\n","fn_call":"isMultipleOf10"}
{"text":"program to find whether a given number is power of 2 | function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; ","context":"","code":"def powerof2(n):\n    if n == 1:\n        return True\n    elif n % 2 != 0 or n == 0:\n        return False\n    return powerof2(n \/ 2)\n","test":"\nif __name__ == \"__main__\":\n    print(powerof2(64))\n    print(powerof2(12))\n","output":"True\nFalse\n","fn_call":"powerof2"}
{"text":"program to find whether a given number is power of 2 | function to check if x is power of 2 ; first x in the below expression is for the case when x is 0 ; ","context":"","code":"def isPowerOfTwo(x):\n    return (x and (not (x & (x - 1))))\n","test":"\nif (isPowerOfTwo(31)):\n    print('Yes')\nelse:\n    print('No')\nif (isPowerOfTwo(64)):\n    print('Yes')\nelse:\n    print('No')\n","output":"No\nYes\n","fn_call":"isPowerOfTwo"}
{"text":"program to find whether a given number is power of 2 | function to check if x is power of 2 ; ","context":"","code":"def isPowerofTwo(n):\n    if (n == 0):\n        return 0\n    if ((n & (~(n - 1))) == n):\n        return 1\n    return 0\n","test":"\nif (isPowerofTwo(30)):\n    print('Yes')\nelse:\n    print('No')\nif (isPowerofTwo(128)):\n    print('Yes')\nelse:\n    print('No')\n","output":"No\nYes\n","fn_call":"isPowerofTwo"}
{"text":"smallest power of 2 which is greater than or equal to sum of array elements | function to find the nearest power of 2 ; the number ; if already a power of 2 ; find the next power of 2 ; function to find the memory used ; sum of array ; traverse and find the sum of array ; function call to find the nearest power of 2 ; ","context":"","code":"def nextPowerOf2(n):\n    p = 1\n    if (n and not (n & (n - 1))):\n        return n\n    while (p < n):\n        p <<= 1\n    return p\n\n\ndef memoryUsed(arr, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    nearest = nextPowerOf2(sum)\n    return nearest\n","test":"\narr = [1, 2, 3, 2]\nn = len(arr)\nprint(memoryUsed(arr, n))\n","output":"8\n","fn_call":"memoryUsed"}
{"text":"toggling k | python3 code to toggle k - th bit of n ; ","context":"","code":"def toggleKthBit(n, k):\n    return (n ^ (1 << (k - 1)))\n","test":"\nn = 5\nk = 1\nprint(toggleKthBit(n, k))\n","output":"4\n","fn_call":"toggleKthBit"}
{"text":"smallest power of 2 greater than or equal to n | python program to find smallest power of 2 greater than or equal to n ; first n in the below condition is for the case where n is 0 ; ","context":"","code":"def nextPowerOf2(n):\n    count = 0\n    if (n and not (n & (n - 1))):\n        return n\n    while (n != 0):\n        n >>= 1\n        count += 1\n    return 1 << count\n","test":"\nn = 0\nprint(nextPowerOf2(n))\n","output":"1\n","fn_call":"nextPowerOf2"}
{"text":"add elements in start to sort the array | variation of stalin sort | function to sort the array ; iterator < integer > index = arr . iterator ( ) ; ; ","context":"","code":"def variationStalinsort(arr):\n    j = 0\n    while True:\n        moved = 0\n        for i in range(len(arr) - 1 - j):\n            if arr[i] > arr[i + 1]:\n                arr .insert(moved, arr .pop(i + 1))\n                moved += 1\n        j += 1\n        if moved == 0:\n            break\n    return arr\n","test":"\nif __name__ == \"__main__\":\n    arr = [2, 1, 4, 3, 6, 5, 8, 7, 10, 9]\n    print(variationStalinsort(arr))\n","output":"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n","fn_call":"variationStalinsort"}
{"text":"maximum sum of values of n items in 0 | function to find the maximum value ; base condition ; k elements already reduced to half of their weight ; dont include item ; if weight of the item is less than or equal to the remaining weight then include the item ; return the maximum of both cases ; if the weight reduction to half is possible ; skip the item ; include item with full weight if weight of the item is less than the remaining weight ; include item with half weight if half weight of the item is less than the remaining weight ; return the maximum of all 3 cases ; ","context":"","code":"def maximum(value, weight, weight1, flag, K, index, val_len):\n    if (index >= val_len):\n        return 0\n    if (flag == K):\n        skip = maximum(value, weight, weight1, flag, K, index + 1, val_len)\n        full = 0\n        if (weight[index] <= weight1):\n            full = value[index] + maximum(value,\n                                          weight,\n                                          weight1 - weight[index],\n                                          flag,\n                                          K,\n                                          index + 1,\n                                          val_len)\n        return max(full, skip)\n    else:\n        skip = maximum(value, weight, weight1, flag, K, index + 1, val_len)\n        full = 0\n        half = 0\n        if (weight[index] <= weight1):\n            full = value[index] + maximum(value,\n                                          weight,\n                                          weight1 - weight[index],\n                                          flag,\n                                          K,\n                                          index + 1,\n                                          val_len)\n        if (weight[index] \/ 2 <= weight1):\n            half = value[index] + maximum(value,\n                                          weight,\n                                          weight1 - weight[index] \/ 2,\n                                          flag,\n                                          K,\n                                          index + 1,\n                                          val_len)\n        return max(full, max(skip, half))\n","test":"\nvalue = [17, 20, 10, 15]\nweight = [4, 2, 7, 5]\nK = 1\nW = 4\nval_len = len(value)\nprint(maximum(value, weight, W, 0, K, 0, val_len))\n","output":"37\n","fn_call":"maximum"}
{"text":"number of subsets with zero sum | python3 implementation of above approach ; variable to store states of dp ; to find the number of subsets with sum equal to 0. since s can be negative , we will maxsum to it to make it positive ; base cases ; returns the value if a state is already solved ; if the state is not visited , then continue ; recurrence relation ; returning the value ; ","context":"\nimport numpy as np\nmaxSum = 100\narrSize = 51\ndp = np .zeros((arrSize, maxSum))\nvisit = np .zeros((arrSize, maxSum))\n\n","code":"def SubsetCnt(i, s, arr, n):\n    if (i == n):\n        if (s == 0):\n            return 1\n        else:\n            return 0\n    if (visit[i][s + arrSize]):\n        return dp[i][s + arrSize]\n    visit[i][s + arrSize] = 1\n    dp[i][s + arrSize] = (SubsetCnt(i + 1, s + arr[i], arr,\n                          n) + SubsetCnt(i + 1, s, arr, n))\n    return dp[i][s + arrSize]\n","test":"\nif __name__ == \"__main__\":\n    arr = [2, 2, 2, -4, -4]\n    n = len(arr)\n    print(SubsetCnt(0, 0, arr, n))\n","output":"7.0\n","fn_call":"SubsetCnt"}
{"text":"tetranacci numbers | function to print the n - th tetranacci number ; initialize first four numbers to base cases ; declare a current variable ; loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively ; ","context":"","code":"def printTetra(n):\n    if (n < 0):\n        return\n    first = 0\n    second = 1\n    third = 1\n    fourth = 2\n    curr = 0\n    if (n == 0):\n        print(first)\n    elif (n == 1 or n == 2):\n        print(second)\n    elif (n == 3):\n        print(fourth)\n    else:\n        for i in range(4, n + 1):\n            curr = first + second + third + fourth\n            first = second\n            second = third\n            third = fourth\n            fourth = curr\n    print(curr)\n","test":"\nn = 10\nprintTetra(n)\n","output":"208\n","fn_call":"printTetra"}
{"text":"count ways to reach the nth stair using step 1 , 2 or 3 | a recursive function used by countways ; ","context":"","code":"def countWays(n):\n    res = [0] * (n + 2)\n    res[0] = 1\n    res[1] = 1\n    res[2] = 2\n    for i in range(3, n + 1):\n        res[i] = res[i - 1] + res[i - 2] + res[i - 3]\n    return res[n]\n","test":"\nn = 4\nprint(countWays(n))\n","output":"7\n","fn_call":"countWays"}
{"text":"count ways to reach the nth stair using step 1 , 2 or 3 | a recursive function used by countways ; declaring three variables and holding the ways for first three stairs ; d = 0 fourth variable ; starting from 4 as already counted for 3 stairs ; ","context":"","code":"def countWays(n):\n    a = 1\n    b = 2\n    c = 4\n    if (n == 0 or n == 1 or n == 2):\n        return n\n    if (n == 3):\n        return c\n    for i in range(4, n + 1):\n        d = c + b + a\n        a = b\n        b = c\n        c = d\n    return d\n","test":"\nn = 4\nprint(countWays(n))\n","output":"7\n","fn_call":"countWays"}
{"text":"subset sum problem in o ( sum ) space |  ; initializing with 1 as sum 0 is always possible ; loop to go through every element of the elements array ; to change the value o all possible sum values to true ; if target is possible return true else false ; ","context":"","code":"def isPossible(elements, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for ele in elements:\n        for j in range(target, ele - 1, -1):\n            if dp[j - ele]:\n                dp[j] = True\n    return dp[target]\n","test":"\narr = [6, 2, 5]\ntarget = 7\nif isPossible(arr, target):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n","output":"YES\n","fn_call":"isPossible"}
{"text":"dynamic programming | high | returns maximum amount of task that can be done till day n ; if n is less than equal to 0 , then no solution exists ; determines which task to choose on day n , then returns the maximum till that day ; ","context":"","code":"def maxTasks(high, low, n):\n    if (n <= 0):\n        return 0\n    return max(high[n - 1] + maxTasks(high, low, (n - 2)),\n               low[n - 1] + maxTasks(high, low, (n - 1)))\n","test":"\nif __name__ == \"__main__\":\n    n = 5\n    high = [3, 6, 8, 7, 6]\n    low = [1, 5, 4, 5, 3]\n    print(maxTasks(high, low, n))\n","output":"20\n","fn_call":"maxTasks"}
{"text":"kth character after replacing each character of string by its frequency exactly x times | python3 program for the above approach ; function to find the kth character after x days ; variable to store the kthchar ; traverse the string ; convert char into int ; calculate characters ; if k is less than sum than ans = str [ i ] ; return answer ; ","context":"\nimport math\n\n","code":"def FindKthChar(Str, K, X):\n    ans = ' '\n    Sum = 0\n    for i in range(len(Str)):\n        digit = ord(Str[i]) - 48\n        Range = int(math .pow(digit, X))\n        Sum += Range\n        if (K <= Sum):\n            ans = Str[i]\n            break\n    return ans\n","test":"\nStr = \"123\"\nK = 9\nX = 3\nans = FindKthChar(Str, K, X)\nprint(ans)\n","output":"2\n","fn_call":"FindKthChar"}
{"text":"total character pairs from two strings , with equal number of set bits in their ascii value | function to get no of set bits in binary representation of positive integer n ; function to return the count of valid pairs ; store frequency of number of set bits for s1 ; store frequency of number of set bits for s2 ; calculate total pairs ; return the count of valid pairs ; ","context":"","code":"def countSetBits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n\n\ndef totalPairs(s1, s2):\n    count = 0\n    arr1 = [0] * 7\n    arr2 = [0] * 7\n    for i in range(len(s1)):\n        set_bits = countSetBits(ord(s1[i]))\n        arr1[set_bits] += 1\n    for i in range(len(s2)):\n        set_bits = countSetBits(ord(s2[i]))\n        arr2[set_bits] += 1\n    for i in range(1, 7):\n        count += (arr1[i] * arr2[i])\n    return count\n","test":"\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"forgeeks\"\n    print(totalPairs(s1, s2))\n","output":"17\n","fn_call":"totalPairs"}
{"text":"enneadecagonal number | function to find nth enneadecagonal number ; formula to calculate nth enneadecagonal number ; ","context":"","code":"def nthEnneadecagonal(n):\n    return (17 * n * n - 15 * n) \/\/ 2\n","test":"\nif __name__ == '__main__':\n    n = 6\n    print(n, \"th Enneadecagonal number :\", nthEnneadecagonal(n))\n","output":"6 th Enneadecagonal number : 261\n","fn_call":"nthEnneadecagonal"}
{"text":"area of a circumscribed circle of a square | python3 program to find the area of a circumscribed circle ; utility function ; ","context":"\nPI = 3.14159265\n\n","code":"def areacircumscribed(a):\n    return (a * a * (PI \/ 2))\n","test":"\na = 6\nprint(\" Area of an circumscribed circle is :\", round(areacircumscribed(a), 2))\n","output":" Area of an circumscribed circle is : 56.55\n","fn_call":"areacircumscribed"}
{"text":"find nth item distributed from infinite items of infinite types based on given conditions | function to find the type of the item given out according to the given rules ; stores the count of item given out at each step ; iterate to find the nth day present is given out ; find the number of presents given on day is day * ( day + 1 ) \/ 2 ; iterate over the type ; return the resultant type ; ","context":"","code":"def itemType(n):\n    count = 0\n    day = 1\n    while (count + day * (day + 1) \/\/ 2 < n):\n        count += day * (day + 1) \/\/ 2\n        day += 1\n    type = day\n    while (type > 0):\n        count += type\n        if (count >= n):\n            return type\n        type -= 1\n","test":"\nif __name__ == '__main__':\n    N = 10\n    print(itemType(N))\n","output":"1\n","fn_call":"itemType"}
{"text":"maximum length of consecutive 1 s or 0 s after flipping at most k characters | function to find the maximum length continuos segment of character c after flipping at most k characters ; stores the maximum length ; stores the count of char 'c ; start of window ; remove the extra ' c ' from left ; increment the value of the left ; update the resultant maximum length of character ch ; function to find the maximum length of consecutive 0 s or 1 s by flipping at most k characters of the string ; print the maximum of the maximum length of 0 s or 1 s ; ","context":"","code":"def maxLength(str, n, c, k):\n    ans = -1\n\n    cnt = 0\n    left = 0\n    for right in range(0, n):\n        if (str[right] == c):\n            cnt += 1\n        while (cnt > k):\n            if (str[left] == c):\n                cnt -= 1\n            left += 1\n        ans = max(ans, right - left + 1)\n    return ans\n\n\ndef maxConsecutiveSegment(S, K):\n    N = len(S)\n    return max(maxLength(S, N, '0', K), maxLength(S, N, '1', K))\n","test":"\nif __name__ == \"__main__\":\n    S = \"1001\"\n    K = 1\n    print(maxConsecutiveSegment(S, K))\n","output":"3\n","fn_call":"maxConsecutiveSegment"}
{"text":"minimize coins required to obtain all possible values up to n | function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , n ] ; number of 5 valueds coins required ; number of 1 valued coins required ; number of 2 valued coins required ; ","context":"","code":"def find(N):\n    F = int((N - 4) \/ 5)\n    if ((N - 5 * F) % 2) == 0:\n        O = 2\n    else:\n        O = 1\n    T = (N - 5 * F - O) \/\/ 2\n    print(\"Count of 5 valueds coins: \", F)\n    print(\"Count of 2 valueds coins: \", T)\n    print(\"Count of 1 valueds coins: \", O)\n","test":"\nif __name__ == '__main__':\n    N = 8\n    find(N)\n","output":"Count of 5 valueds coins:  0\nCount of 2 valueds coins:  3\nCount of 1 valueds coins:  2\n","fn_call":"find"}
{"text":"check if given string is a substring of string formed by repeated concatenation of z to a | function checks if a given is valid or not and prints the output ; boolean flag variable to mark if given is valid ; traverse the given string ; if adjacent character differ by 1 ; if character ' a ' is followed by 4 ; else flip the flag and break from the loop ; output according to flag variable ; ","context":"","code":"def checkInfinite(s):\n    flag = 1\n    N = len(s)\n    for i in range(N - 1):\n        if (s[i] == chr(ord(s[i + 1]) + 1)):\n            continue\n        elif (s[i] == 'a' and s[i + 1] == 'z'):\n            continue\n        else:\n            flag = 0\n            break\n    if (flag == 0):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n","test":"\nif __name__ == '__main__':\n    s = \"ecbaz\"\n    checkInfinite(s)\n","output":"NO\n","fn_call":"checkInfinite"}
{"text":"minimum change in lanes required to cross all barriers | function to find the minimum number of changes of lane required ; if there is a barrier , then add very large value ; add the minimum value to move forword with or without crossing barrier ; return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ] ; ","context":"","code":"def minChangeInLane(barrier, n):\n    dp = [1, 0, 1]\n    for j in range(n):\n        val = barrier[j]\n        if (val > 0):\n            dp[val - 1] = 1000000\n        for i in range(3):\n            if (val != i + 1):\n                dp[i] = min(dp[i], min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1)\n    return min(dp[0], min(dp[1], dp[2]))\n","test":"\nbarrier = [0, 1, 2, 3, 0]\nN = len(barrier)\nprint(minChangeInLane(barrier, N))\n","output":"2\n","fn_call":"minChangeInLane"}
{"text":"queries to count groups of n students possible having sum of ratings within given range | function to count number of ways to get given sum groups ; initialise dp array ; mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row ; fix the ith row ; fix the sum ; iterate through all values of ith row ; if sum can be obtained ; find the prefix sum of last row ; traverse each query ; no of ways to form groups ; ","context":"","code":"def numWays(ratings, queries, n, k):\n    dp = [[0 for i in range(10002)]for j in range(n)]\n    for i in range(k):\n        dp[0][ratings[0][i]] += 1\n    for i in range(1, n):\n        for sum in range(10001):\n            for j in range(k):\n                if (sum >= ratings[i][j]):\n                    dp[i][sum] += dp[i - 1][sum - ratings[i][j]]\n    for sum in range(1, 10001):\n        dp[n - 1][sum] += dp[n - 1][sum - 1]\n    for q in range(len(queries)):\n        a = queries[q][0]\n        b = queries[q][1]\n        print(dp[n - 1][b] - dp[n - 1][a - 1], end=\" \")\n","test":"\nif __name__ == '__main__':\n    N = 2\n    K = 3\n    ratings = [[1, 2, 3], [4, 5, 6]]\n    queries = [[6, 6], [1, 6]]\n    numWays(ratings, queries, N, K)\n","output":"2 3 ","fn_call":"numWays"}
{"text":"number of permutation with k inversions | set 2 | function to count permutations with k inversions ; store number of permutations with k inversions ; if n = 1 only 1 permutation with no inversion ; for k = 0 only 1 permutation with no inversion ; otherwise update each dp state as per the reccurrance relation formed ; print final count ; ","context":"","code":"def numberOfPermWithKInversion(N, K):\n    dp = [[0] * (K + 1)] * 2\n    mod = 1000000007\n    for i in range(1, N + 1):\n        for j in range(0, K + 1):\n            if (i == 1):\n                dp[i % 2][j] = 1 if (j == 0)else 0\n            elif (j == 0):\n                dp[i % 2][j] = 1\n            else:\n                var = (0 if (max(j - (i - 1), 0) == 0)\n                       else dp[1 - i % 2][max(j - (i - 1), 0) - 1])\n                dp[i %\n                   2][j] = ((dp[i %\n                                2][j - 1] %\n                             mod + (dp[1 - i %\n                                       2][j] - (var) + mod) %\n                             mod) %\n                            mod)\n    print(dp[N % 2][K])\n","test":"\nif __name__ == '__main__':\n    N = 3\n    K = 2\n    numberOfPermWithKInversion(N, K)\n","output":"2\n","fn_call":"numberOfPermWithKInversion"}
{"text":"treasure and cities | k is current index and col is previous color . ; base case ; check if color of this city is equal to prev visited city ; return max of both options ; ","context":"","code":"def MaxProfit(treasure, color, n, k, col, A, B):\n    sum = 0\n    if k == n:\n        return 0\n    if col == color[k]:\n        sum += max(A *\n                   treasure[k] +\n                   MaxProfit(treasure, color, n, k +\n                             1, color[k], A, B), MaxProfit(treasure, color, n, k +\n                                                           1, col, A, B))\n    else:\n        sum += max(B *\n                   treasure[k] +\n                   MaxProfit(treasure, color, n, k +\n                             1, color[k], A, B), MaxProfit(treasure, color, n, k +\n                                                           1, col, A, B))\n    return sum\n","test":"\nA = -5\nB = 7\ntreasure = [4, 8, 2, 9]\ncolor = [2, 2, 6, 2]\nn = len(color)\nprint(MaxProfit(treasure, color, n, 0, 0, A, B))\n","output":"133\n","fn_call":"MaxProfit"}
{"text":"tetranacci numbers | function to return the n - th tetranacci number ; base cases ; base cases ; base cases ; function to print the nth tetranacci number ; ","context":"","code":"def printTetraRec(n):\n    if (n == 0):\n        return 0\n    if (n == 1 or n == 2):\n        return 1\n    if (n == 3):\n        return 2\n    else:\n        return (\n            printTetraRec(\n                n -\n                1) +\n            printTetraRec(\n                n -\n                2) +\n            printTetraRec(\n                n -\n                3) +\n            printTetraRec(\n                n -\n                4))\n\n\ndef printTetra(n):\n    print(printTetraRec(n), end=\" \")\n","test":"\nn = 10\nprintTetra(n)\n","output":"208 ","fn_call":"printTetra"}
{"text":"sum of products of all combination taken ( 1 to n ) at a time | to store sum of every combination ; if we have reached sufficient depth ; find the product of combination ; add the product into sum ; recursion to produce different combination ; function to print sum of products of all combination taken 1 - n at a time ; creating temporary array for storing combination ; call combination with r = i for combination taken i at a time ; displaying sum ; ","context":"","code":"def Combination(a, combi, n, r, depth, index):\n    global Sum\n    if index == r:\n        product = 1\n        for i in range(r):\n            product = product * combi[i]\n        Sum += product\n        return\n    for i in range(depth, n):\n        combi[index] = a[i]\n        Combination(a, combi, n, r, i + 1, index + 1)\n\n\ndef allCombination(a, n):\n    global Sum\n    for i in range(1, n + 1):\n        combi = [0] * i\n        Combination(a, combi, n, i, 0, 0)\n        print(\"f(\", i, \") --> \", Sum)\n        Sum = 0\n","test":"\nSum = 0\nn = 5\na = [0] * n\nfor i in range(n):\n    a[i] = i + 1\nallCombination(a, n)\n","output":"f( 1 ) -->  15\nf( 2 ) -->  85\nf( 3 ) -->  225\nf( 4 ) -->  274\nf( 5 ) -->  120\n","fn_call":"allCombination"}
{"text":"dynamic programming | high |  ; returns maximum amount of task that can be done till day n ; an array task_dp that stores the maximum task done ; if n = 0 , no solution exists ; if n = 1 , high effort task on that day will be the solution ; fill the entire array determining which task to choose on day i ; ","context":"\n\n","code":"def max1(x, y):\n    return x if (x > y)else y\n\n\ndef maxTasks(high, low, n):\n    task_dp = [0] * (n + 1)\n    task_dp[0] = 0\n    task_dp[1] = high[0]\n    for i in range(2, n + 1):\n        task_dp[i] = max(high[i - 1] + task_dp[i - 2],\n                         low[i - 1] + task_dp[i - 1])\n    return task_dp[n]\n","test":"\nn = 5\nhigh = [3, 6, 8, 7, 6]\nlow = [1, 5, 4, 5, 3]\nprint(maxTasks(high, low, n))\n","output":"20\n","fn_call":"maxTasks"}
{"text":"partition problem | dp | returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; calculate sum of all elements ; initialize top row as true ; initialize leftmost column , except part [ 0 ] [ 0 ] , as 0 ; fill the partition table in bottom up manner ; uncomment this part to print table ; ","context":"","code":"def findPartition(arr, n):\n    sum = 0\n    i, j = 0, 0\n    for i in range(n):\n        sum += arr[i]\n    if sum % 2 != 0:\n        return false\n    part = [[True for i in range(n + 1)]for j in range(sum \/\/ 2 + 1)]\n    for i in range(0, n + 1):\n        part[0][i] = True\n    for i in range(1, sum \/\/ 2 + 1):\n        part[i][0] = False\n    for i in range(1, sum \/\/ 2 + 1):\n        for j in range(1, n + 1):\n            part[i][j] = part[i][j - 1]\n            if i >= arr[j - 1]:\n                part[i][j] = (part[i][j] or part[i - arr[j - 1]][j - 1])\n    return part[sum \/\/ 2][n]\n","test":"\narr = [3, 1, 1, 2, 2, 1]\nn = len(arr)\nif findPartition(arr, n):\n    print(\"Can be divided into two\", \"subsets of equal sum\")\nelse:\n    print(\"Can not be divided into \", \"two subsets of equal sum\")\n","output":"Can be divided into two subsets of equal sum\n","fn_call":"findPartition"}
{"text":"minimum number of appends of x or y characters from the end to the front required to obtain given string | function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation ; store the original string ; stores the count of operations ; traverse the string ; cut m letters from end ; add cut m letters to beginning ; update j ; check if strings are the same ; cut n letters from end ; add cut n letters to beginning ; update j ; check if strings are the same ; update the turn ; ","context":"","code":"def minimumOperations(orig_str, m, n):\n    orig = orig_str\n    turn = 1\n    j = 1\n    for i in orig_str:\n        m_cut = orig_str[-m:]\n        orig_str = orig_str .replace(' ', '')[:-m]\n        orig_str = m_cut + orig_str\n        j = j + 1\n        if orig != orig_str:\n            turn = turn + 1\n            n_cut = orig_str[-n:]\n            orig_str = orig_str .replace(' ', '')[:-n]\n            orig_str = n_cut + orig_str\n            j = j + 1\n        if orig == orig_str:\n            break\n        turn = turn + 1\n    print(turn)\n","test":"\nS = \"GeeksforGeeks\"\nX = 5\nY = 3\nminimumOperations(S, X, Y)\n","output":"3\n","fn_call":"minimumOperations"}
{"text":"minimum rotations required to get the same string | set | prints occurrences of txt [ ] in pat [ ] ; create lps [ ] that will hold the longest prefix suffix values for pattern ; preprocess the pattern ( calculate lps [ ] array ) ; index for txt [ ] , index for pat [ ] ; mismatch after j matches ; do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway ; fills lps [ ] for given pattern pat [ 0. . m - 1 ] ; length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; the loop calculates lps [ i ] for i = 1 to m - 1 ; ( pat [ i ] != pat [ _len ] ) ; this is tricky . consider the example . aaacaaaa and i = 7. the idea is similar to search step . ; returns count of rotations to get the same string back ; form a string excluding the first character and concatenating the string at the end ; convert the string to character array ; use the kmp search algorithm to find it in o ( n ) time ; ","context":"","code":"def KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    lps = [0] * M\n    computeLPSArray(pat, M, lps)\n    i = 0\n    j = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            j += 1\n            i += 1\n        if j == M:\n            return i - j\n            j = lps[j - 1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i = i + 1\n\n\ndef computeLPSArray(pat, M, lps):\n    _len = 0\n    lps[0] = 0\n    i = 1\n    while i < M:\n        if pat[i] == pat[_len]:\n            _len += 1\n            lps[i] = _len\n            i += 1\n        else:\n            if _len != 0:\n                _len = lps[_len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n\ndef countRotations(s):\n    s1 = s[1:len(s)] + s\n    pat = s[:]\n    text = s1[:]\n    return 1 + KMPSearch(pat, text)\n","test":"\ns1 = \"geeks\"\nprint(countRotations(s1))\n","output":"5\n","fn_call":"countRotations"}
{"text":"dfa for strings not ending with \" the \" | this function is for the starting state ( zeroth ) of dfa ; on receiving ' t ' or ' t ' goto first state ( 1 ) ; this function is for the first state of dfa ; on receiving ' t ' or ' t ' goto first state ( 1 ) ; on receiving ' h ' or ' h ' goto second state ( 2 ) ; else goto starting state ( 0 ) ; this function is for the second state of dfa ; on receiving ' e ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 ) ; this function is for the third state of dfa ; on receiving ' t ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 ) ; store length of stringing ; ","context":"","code":"def start(c):\n    if (c == 't' or c == 'T'):\n        dfa = 1\n\n\ndef state1(c):\n    if (c == 't' or c == 'T'):\n        dfa = 1\n    elif (c == 'h' or c == 'H'):\n        dfa = 2\n    else:\n        dfa = 0\n\n\ndef state2(c):\n    if (c == 'e' or c == 'E'):\n        dfa = 3\n    else:\n        dfa = 0\n\n\ndef state3(c):\n    if (c == 't' or c == 'T'):\n        dfa = 1\n    else:\n        dfa = 0\n\n\ndef isAccepted(string):\n    length = len(string)\n    for i in range(length):\n        if (dfa == 0):\n            start(string[i])\n        elif (dfa == 1):\n            state1(string[i])\n        elif (dfa == 2):\n            state2(string[i])\n        else:\n            state3(string[i])\n    return (dfa != 3)\n","test":"if __name__ == \"__main__\":\n    string = \"forTHEgeeks\"\n    dfa = 0\n    if isAccepted(string):\n        print(\"ACCEPTED\")\n    else:\n        print(\"NOT ACCEPTED\")\n","output":"ACCEPTED\n","fn_call":"isAccepted"}
{"text":"print characters having prime frequencies in order of occurrence | python 3 implementation of the approach ; function to create sieve to check primes ; false here indicates that it is not prime ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p , set them to non - prime ; function to print the prime frequency characters in the order of their occurrence ; function to create sieve to check primes ; to store the frequency of each of the character of the string ; update the frequency of each character ; traverse str character by character ; if frequency of current character is prime ; ","context":"\nfrom math import sqrt\nSIZE = 26\n\n","code":"def SieveOfEratosthenes(prime, p_size):\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, int(sqrt(p_size)), 1):\n        if (prime[p]):\n            for i in range(p * 2, p_size, p):\n                prime[i] = False\n\n\ndef printChar(str, n):\n    prime = [True for i in range(n + 1)]\n    SieveOfEratosthenes(prime, len(str) + 1)\n    freq = [0 for i in range(SIZE)]\n    for i in range(n):\n        freq[ord(str[i]) - ord('a')] += 1\n    for i in range(n):\n        if (prime[freq[ord(str[i]) - ord('a')]]):\n            print(str[i], end=\"\")\n","test":"\nif __name__ == '__main__':\n    str = \"geeksforgeeks\"\n    n = len(str)\n    printChar(str, n)\n","output":"gksgks","fn_call":"printChar"}
{"text":"print characters having prime frequencies in order of occurrence | python code for the above approach ; function to check primes ; counting the frequency of all character using counter function ; traversing string ; ","context":"\nfrom collections import Counter\nimport math\n\n","code":"def prime(n):\n    if n <= 1:\n        return False\n    max_div = math .floor(math .sqrt(n))\n    for i in range(2, 1 + max_div):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef checkString(s):\n    freq = Counter(s)\n    for i in range(len(s)):\n        if prime(freq[s[i]]):\n            print(s[i], end=\"\")\n","test":"\ns = \"geeksforgeeks\"\ncheckString(s)\n","output":"gksgks","fn_call":"checkString"}
{"text":"print characters having even frequencies in order of occurrence | python3 implementation of the approach ; function to print the even frequency characters in the order of their occurrence ; to store the frequency of each of the character of the stringing initialize all elements of freq [ ] to 0 ; update the frequency of each character ; traverse string character by character ; if frequency of current character is even ; ","context":"\nSIZE = 26\n\n","code":"def printChar(string, n):\n    freq = [0] * SIZE\n    for i in range(0, n):\n        freq[ord(string[i]) - ord('a')] += 1\n    for i in range(0, n):\n        if (freq[ord(string[i]) - ord('a')] % 2 == 0):\n            print(string[i], end=\"\")\n","test":"\nif __name__ == '__main__':\n    string = \"geeksforgeeks\"\n    n = len(string)\n    printChar(string, n)\n","output":"geeksgeeks","fn_call":"printChar"}
{"text":"compare two strings considering only alphanumeric characters | function to check alphanumeric equality of both strings ; variable declaration ; length of first string ; length of second string ; to check each and every character of both string ; if the current character of the first string is not an alphanumeric character , increase the pointer i ; if the current character of the second string is not an alphanumeric character , increase the pointer j ; if all alphanumeric characters of both strings are same , then return true ; if any alphanumeric characters of both strings are not same , then return false ; if current character matched , increase both pointers to check the next character ; if not same , then return false ; function to print equal or unequal if strings are same or not ; check alphanumeric equality of both strings ; if both are alphanumeric equal , print equal ; otherwise print unequal ; ","context":"","code":"def CompareAlphanumeric(str1, str2):\n    i = 0\n    j = 0\n    len1 = len(str1)\n    len2 = len(str2)\n    while (i <= len1 and j <= len2):\n        while (\n            i < len1 and (\n                ((str1[i] >= 'a' and str1[i] <= 'z') or (\n                    str1[i] >= 'A' and str1[i] <= 'Z') or (\n                str1[i] >= '0' and str1[i] <= '9')) == False)):\n            i += 1\n        while (\n            j < len2 and (\n                ((str2[j] >= 'a' and str2[j] <= 'z') or (\n                    str2[j] >= 'A' and str2[j] <= 'Z') or (\n                str2[j] >= '0' and str2[j] <= '9')) == False)):\n            j += 1\n        if (i == len1 and j == len2):\n            return True\n        elif (str1[i] != str2[j]):\n            return False\n        else:\n            i += 1\n            j += 1\n    return False\n\n\ndef CompareAlphanumericUtil(str1, str2):\n    res = CompareAlphanumeric(str1, str2)\n    if (res):\n        print(\"Equal\")\n    else:\n        print(\"Unequal\")\n","test":"\nif __name__ == '__main__':\n    str1 = \"Ram, Shyam\"\n    str2 = \" Ram - Shyam.\"\n    CompareAlphanumericUtil(str1, str2)\n    str1 = \"abc123\"\n    str2 = \"123abc\"\n    CompareAlphanumericUtil(str1, str2)\n","output":"Equal\nUnequal\n","fn_call":"CompareAlphanumericUtil"}
{"text":"queries to print the character that occurs the maximum number of times in a given range | function that answers all the queries ; length of the string ; number of queries ; prefix array ; iterate for all the characters ; increase the count of the character ; presum array for all 26 characters ; update the prefix array ; answer every query ; range ; iterate for all characters ; times the lowercase character j occurs till r - th index ; subtract the times it occurred till ( l - 1 ) th index ; max times it occurs ; print the answer ; ","context":"","code":"def solveQueries(Str, query):\n    ll = len(Str)\n    Q = len(query)\n    pre = [[0 for i in range(256)]for i in range(ll)]\n    for i in range(ll):\n        pre[i][ord(Str[i])] += 1\n        if (i):\n            for j in range(256):\n                pre[i][j] += pre[i - 1][j]\n    for i in range(Q):\n        l = query[i][0]\n        r = query[i][1]\n        maxi = 0\n        c = 'a'\n        for j in range(256):\n            times = pre[r][j]\n            if (l):\n                times -= pre[l - 1][j]\n            if (times > maxi):\n                maxi = times\n                c = chr(j)\n        print(\"Query \", i + 1, \": \", c)\n","test":"\nStr = \"striver\"\nquery = [[0, 1], [1, 6], [5, 6]]\nsolveQueries(Str, query)\n","output":"Query  1 :  s\nQuery  2 :  r\nQuery  3 :  e\n","fn_call":"solveQueries"}
{"text":"check whether given string can be generated after concatenating given strings | function that return true if pre is a prefix of str ; while there are characters to match ; if characters differ at any position ; str starts with pre ; function that return true if suff is a suffix of str ; while there are characters to match ; if characters differ at any position ; str ends with suff ; function that returns true if str = a + b or str = b + a ; str cannot be generated by concatenating a and b ; if str starts with a i . e . a is a prefix of str ; check if the rest of the characters are equal to b i . e . b is a suffix of str ; if str starts with b i . e . b is a prefix of str ; check if the rest of the characters are equal to a i . e . a is a suffix of str ; ","context":"","code":"def startsWith(str, pre):\n    strLen = len(str)\n    preLen = len(pre)\n    i = 0\n    j = 0\n    while (i < strLen and j < preLen):\n        if (str[i] != pre[j]):\n            return False\n        i += 1\n        j += 1\n    return True\n\n\ndef endsWith(str, suff):\n    i = len(str) - 1\n    j = len(suff) - 1\n    while (i >= 0 and j >= 0):\n        if (str[i] != suff[j]):\n            return False\n        i -= 1\n        j -= 1\n    return True\n\n\ndef checkString(str, a, b):\n    if (len(str) != len(a) + len(b)):\n        return False\n    if (startsWith(str, a)):\n        if (endsWith(str, b)):\n            return True\n    if (startsWith(str, b)):\n        if (endsWith(str, a)):\n            return True\n    return False\n","test":"\nstr = \"GeeksforGeeks\"\na = \"Geeksfo\"\nb = \"rGeeks\"\nif (checkString(str, a, b)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n","output":"Yes\n","fn_call":"checkString"}
{"text":"print characters having odd frequencies in order of occurrence | python3 implementation of the approach ; function to print the odd frequency characters in the order of their occurrence ; to store the frequency of each of the character of the string and initialize all elements of freq [ ] to 0 ; update the frequency of each character ; traverse str character by character ; if frequency of current character is odd ; ","context":"\nimport sys\nimport math\n\n","code":"def printChar(str_, n):\n    freq = [0] * 26\n    for i in range(n):\n        freq[ord(str_[i]) - ord('a')] += 1\n    for i in range(n):\n        if (freq[ord(str_[i]) - ord('a')]) % 2 == 1:\n            print(\"{}\".format(str_[i]), end=\"\")\n","test":"\nif __name__ == '__main__':\n    str_ = \"geeksforgeeks\"\n    n = len(str_)\n    printChar(str_, n)\n","output":"for","fn_call":"printChar"}
{"text":"minimum number of operations to move all uppercase characters before all lower case characters | function to return the minimum number of operations required ; to store the indices of the last uppercase and the first lowercase character ; find the last uppercase character ; find the first lowercase character ; if all the characters are either uppercase or lowercase ; count of uppercase characters that appear after the first lowercase character ; count of lowercase characters that appear before the last uppercase character ; return the minimum operations required ; ","context":"","code":"def minOperations(str, n):\n    lastUpper = -1\n    firstLower = -1\n    for i in range(n - 1, -1, -1):\n        if (str[i].isupper()):\n            lastUpper = i\n            break\n    for i in range(n):\n        if (str[i].islower()):\n            firstLower = i\n            break\n    if (lastUpper == -1 or firstLower == -1):\n        return 0\n    countUpper = 0\n    for i in range(firstLower, n):\n        if (str[i].isupper()):\n            countUpper += 1\n    countLower = 0\n    for i in range(lastUpper):\n        if (str[i].islower()):\n            countLower += 1\n    return min(countLower, countUpper)\n","test":"\nif __name__ == \"__main__\":\n    str = \"geEksFOrGEekS\"\n    n = len(str)\n    print(minOperations(str, n))\n","output":"6\n","fn_call":"minOperations"}
{"text":"find the sum of all betrothed numbers up to n | python3 program to find the sum of the all betrothed numbers up to n ; function to find the sum of the all betrothed numbers ; to store the betrothed numbers ; calculate sum of number_1 's divisors ; i = 2 because we don 't  want to include  1 as a divisor. ; sum all betrothed numbers up to n ; ","context":"\nimport math\n\n","code":"def Betrothed_Sum(n):\n    Set = []\n    for number_1 in range(1, n):\n        sum_divisor_1 = 1\n        i = 2\n        while i * i <= number_1:\n            if (number_1 % i == 0):\n                sum_divisor_1 = sum_divisor_1 + i\n                if (i * i != number_1):\n                    sum_divisor_1 += number_1 \/\/ i\n            i = i + 1\n        if (sum_divisor_1 > number_1):\n            number_2 = sum_divisor_1 - 1\n            sum_divisor_2 = 1\n            j = 2\n            while j * j <= number_2:\n                if (number_2 % j == 0):\n                    sum_divisor_2 += j\n                    if (j * j != number_2):\n                        sum_divisor_2 += number_2 \/\/ j\n                j = j + 1\n            if (sum_divisor_2 == number_1 +\n                    1 and number_1 <= n and number_2 <= n):\n                Set .append(number_1)\n                Set .append(number_2)\n    Summ = 0\n    for i in Set:\n        if i <= n:\n            Summ += i\n    return Summ\n","test":"\nn = 78\nprint(Betrothed_Sum(n))\n","output":"123\n","fn_call":"Betrothed_Sum"}
{"text":"probability of rain on n + 1 th day | function to find the probability ; count occurence of 1 ; find probability ; ","context":"","code":"def rainDayProbability(a, n):\n    count = a .count(1)\n    m = count \/ n\n    return m\n","test":"\nif __name__ == \"__main__\":\n    a = [1, 0, 1, 0, 1, 1, 1, 1]\n    n = len(a)\n    print(rainDayProbability(a, n))\n","output":"0.75\n","fn_call":"rainDayProbability"}
{"text":"program to find the sum of a series 1 + 1 \/ 2 ^ 2 + 1 \/ 3 ^ 3 + \u00e2 \u20ac\u00a6 . . + 1 \/ n ^ n | function to calculate the following series ; ","context":"","code":"def Series(n):\n    sums = 0.0\n    for i in range(1, n + 1):\n        ser = 1 \/ (i ** i)\n        sums += ser\n    return sums\n","test":"\nn = 3\nres = round(Series(n), 5)\nprint(res)\n","output":"1.28704\n","fn_call":"Series"}
{"text":"lexicographically largest string formed in minimum moves by replacing characters of given string | function to print the lexicographically the largest string obtained in process of obtaining a string containing first n lower case english alphabtes ; store the frequency of each character ; traverse the string s ; stores the characters which are not appearing in s ; stores the index of the largest character in the array v , that need to be replaced ; traverse the string , s ; if frequency of s [ i ] is greater than 1 or it is outside the range ; decrement its frequency by 1 ; update s [ i ] ; decrement j by 1 ; traverse the string , s ; decrement its frequency by 1 ; update s [ i ] ; increment l by 1 ; return s ; ","context":"","code":"def lexicographicallyMaximum(S, N):\n    M = {}\n    for i in range(N):\n        if S[i] in M:\n            M[S[i]] += 1\n        else:\n            M[S[i]] = 1\n    V = []\n    for i in range(ord('a'), ord('a') + min(N, 25)):\n        if i not in M:\n            V .append(chr(i))\n    j = len(V) - 1\n    for i in range(N):\n        if (ord(S[i]) >= (ord('a') + min(N, 25))\n                or (S[i] in M and M[S[i]] > 1)):\n            if (ord(V[j]) < ord(S[i])):\n                continue\n            M[S[i]] -= 1\n            S = S[0:i] + V[j] + S[(i + 1):]\n            j -= 1\n        if (j < 0):\n            break\n    l = 0\n    for i in range(N - 1, -1, -1):\n        if (l > j):\n            break\n        if (ord(S[i]) >= (ord('a') + min(N, 25)) or S[i] in M and M[S[i]] > 1):\n            M[S[i]] -= 1\n            S = S[0:i] + V[l] + S[(i + 1):]\n            l += 1\n    s = list(S)\n    s[len(s) - 1] = 'd'\n    S = \"\".join(s)\n    return S\n","test":"\nS = \"abccefghh\"\nN = len(S)\nprint(lexicographicallyMaximum(S, N))\n","output":"abicefghd\n","fn_call":"lexicographicallyMaximum"}
{"text":"check if any subarray can be made palindromic by replacing less than half of its elements | a utility function to check if a subarray can be palindromic by replacing less than half of the elements present in it ; stores frequency of array elements ; traverse the array ; update frequency of each array element ; iterator over the map ; if frequency of any element exceeds 1 ; if no repetition is found ; function to check and print if any subarray can be made palindromic by replacing less than half of its elements ; ","context":"","code":"def isConsistingSubarrayUtil(arr, n):\n    mp = {}\n    for i in range(n):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n    for it in mp:\n        if (mp[it] > 1):\n            return True\n    return False\n\n\ndef isConsistingSubarray(arr, N):\n    if (isConsistingSubarrayUtil(arr, N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 1]\n    N = len(arr)\n    isConsistingSubarray(arr, N)\n","output":"Yes\n","fn_call":"isConsistingSubarray"}
{"text":"count composite fibonacci numbers from given array | python3 program to implement the above approach ; function to find all fibonacci numbers up to max ; store all fibonacci numbers upto max ; stores previous element of fibonacci sequence ; stores previous element of fibonacci sequence ; insert prev into hashmap ; insert all the fibonacci numbers up to max ; insert curr into hashmap ; stores curr into temp ; update curr ; update prev ; function to find all composite numbers up to max ; isprime [ i ] : stores if i is a prime number or not ; calculate all prime numbers up to max using sieve of eratosthenes ; if p is a prime number ; set all multiple of p as non - prime ; function to find the numbers which is both a composite and fibonacci number ; stores the largest element of the array ; traverse the array arr [ ] ; update max ; isprim [ i ] check i is a prime number or not ; stores all the fibonacci numbers ; traverse the array arr [ ] ; current element is not a composite number ; if current element is a fibonacci and composite number ; print current element ; ","context":"\nimport math\n\n","code":"def createhashmap(Max):\n    hashmap = {\"\"}\n    curr = 1\n    prev = 0\n    hashmap .add(prev)\n    while (curr <= Max):\n        hashmap .add(curr)\n        temp = curr\n        curr = curr + prev\n        prev = temp\n    return hashmap\n\n\ndef SieveOfEratosthenes(Max):\n    isPrime = [1 for x in range(Max + 1)]\n    isPrime[0] = 0\n    isPrime[1] = 0\n    for p in range(0, int(math .sqrt(Max))):\n        if (isPrime[p]):\n            for i in range(2 * p, Max, p):\n                isPrime[i] = 0\n    return isPrime\n\n\ndef cntFibonacciPrime(arr, N):\n    Max = arr[0]\n    for i in range(0, N):\n        Max = max(Max, arr[i])\n    isPrime = SieveOfEratosthenes(Max)\n    hashmap = createhashmap(Max)\n    for i in range(0, N):\n        if arr[i] == 1:\n            continue\n        if ((arr[i] in hashmap) and (not (isPrime[arr[i]]))):\n            print(arr[i], end=\" \")\n","test":"\narr = [13, 55, 7, 3, 5, 21, 233, 144, 89]\nN = len(arr)\ncntFibonacciPrime(arr, N)\n","output":"55 21 144 ","fn_call":"cntFibonacciPrime"}
{"text":"reduce a given number to form a key by the given operations | python3 program of the above approach ; function to find the key of the ","context":"\nimport math\n\n","code":"def key(N):\n    num = \"\" + str(N)\n    ans = 0\n    j = 0\n    while j < len(num):\n        if ((ord(num[j]) - 48) % 2 == 0):\n            add = 0\n            i = j\n            while j < len(num):\n                add += ord(num[j]) - 48\n                if (add % 2 == 1):\n                    break\n                j += 1\n            if (add == 0):\n                ans *= 10\n            else:\n                digit = int(math .floor(math .log10(add) + 1))\n                ans *= (pow(10, digit))\n                ans += add\n            i = j\n        else:\n            add = 0\n            i = j\n            while j < len(num):\n                add += ord(num[j]) - 48\n                if (add % 2 == 0):\n                    break\n                j += 1\n            if (add == 0):\n                ans *= 10\n            else:\n                digit = int(math .floor(math .log10(add) + 1))\n                ans *= (pow(10, digit))\n                ans += add\n            i = j\n        j += 1\n    if (j + 1) >= len(num):\n        return ans\n    else:\n        ans += ord(num[len(num) - 1]) - 48\n        return ans\n","test":"\nN = 1667848271\nprint(key(N))\n","output":"20291\n","fn_call":"key"}
{"text":"sentinel linear search | python3 implementation of the approach function to search key in the given array ; function to search x in the given array ; last element of the array ; element to be searched is placed at the last index ; put the last element back ; ","context":"","code":"def sentinelSearch(arr, n, key):\n    last = arr[n - 1]\n    arr[n - 1] = key\n    i = 0\n    while (arr[i] != key):\n        i += 1\n    arr[n - 1] = last\n    if ((i < n - 1) or (arr[n - 1] == key)):\n        print(key, \"is present at index\", i)\n    else:\n        print(\"Element Not found\")\n","test":"\narr = [10, 20, 180, 30, 60, 50, 110, 100, 70]\nn = len(arr)\nkey = 180\nsentinelSearch(arr, n, key)\n","output":"180 is present at index 2\n","fn_call":"sentinelSearch"}
{"text":"maximum possible middle element of the array after deleting exactly k elements | function to calculate maximum possible middle value of the array after deleting exactly k elements ; initialize answer as - 1 ; calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high ; find maximum element of the array in range low and high ; since indexing is 1 based so check element at index i - 1 ; return the maximum possible middle value of the array after deleting exactly k elements from the array ; ","context":"","code":"def maximum_middle_value(n, k, arr):\n    ans = -1\n    low = (n + 1 - k) \/\/ 2\n    high = (n + 1 - k) \/\/ 2 + k\n    for i in range(low, high + 1):\n        ans = max(ans, arr[i - 1])\n    return ans\n","test":"\nif __name__ == \"__main__\":\n    n, k = 5, 2\n    arr = [9, 5, 3, 7, 10]\n    print(maximum_middle_value(n, k, arr))\n    n, k = 9, 3\n    arr1 = [2, 4, 3, 9, 5, 8, 7, 6, 10]\n    print(maximum_middle_value(n, k, arr1))\n","output":"7\n9\n","fn_call":"maximum_middle_value"}
{"text":"ternary search | python3 program to illustrate recursive approach to ternary search ; function to perform ternary search ; find the mid1 and mid2 ; check if key is present at any mid ; since key is not present at mid , check in which region it is present then repeat the search operation in that region ; the key lies in between l and mid1 ; the key lies in between mid2 and r ; the key lies in between mid1 and mid2 ; key not found ; ","context":"\nimport math as mt\n\n","code":"def ternarySearch(l, r, key, ar):\n    if (r >= l):\n        mid1 = l + (r - l) \/\/ 3\n        mid2 = r - (r - l) \/\/ 3\n        if (ar[mid1] == key):\n            return mid1\n        if (ar[mid2] == key):\n            return mid2\n        if (key < ar[mid1]):\n            return ternarySearch(l, mid1 - 1, key, ar)\n        elif (key > ar[mid2]):\n            return ternarySearch(mid2 + 1, r, key, ar)\n        else:\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar)\n    return -1\n","test":"\nl, r, p = 0, 9, 5\nar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nl = 0\nr = 9\nkey = 5\np = ternarySearch(l, r, key, ar)\nprint(\"Index of\", key, \"is\", p)\nkey = 50\np = ternarySearch(l, r, key, ar)\nprint(\"Index of\", key, \"is\", p)\n","output":"Index of 5 is 4\nIndex of 50 is -1\n","fn_call":"ternarySearch"}
{"text":"minimum number of points to be removed to get remaining points on one side of axis | function to find the minimum number of points ; number of points on the left of y - axis . ; number of points on the right of y - axis . ; number of points above x - axis . ; number of points below x - axis . ; ","context":"","code":"def findmin(p, n):\n    a, b, c, d = 0, 0, 0, 0\n    for i in range(n):\n        if (p[i][0] <= 0):\n            a += 1\n        elif (p[i][0] >= 0):\n            b += 1\n        if (p[i][1] >= 0):\n            c += 1\n        elif (p[i][1] <= 0):\n            d += 1\n    return min([a, b, c, d])\n","test":"\np = [[1, 1], [2, 2], [-1, -1], [-2, 2]]\nn = len(p)\nprint(findmin(p, n))\n","output":"1\n","fn_call":"findmin"}
{"text":"maximum number of pair reductions possible on a given triplet | function to count the maximum number of pair reductions possible on a given triplet ; convert them into an array ; stores count of operations ; sort the array ; if the first two array elements reduce to 0 ; apply the operations ; increment count ; print the maximum count ; ","context":"","code":"def maxOps(a, b, c):\n    arr = [a, b, c]\n    count = 0\n    while True:\n        arr .sort()\n        if not arr[0] and not arr[1]:\n            break\n        arr[1] -= 1\n        arr[2] -= 1\n        count += 1\n    print(count)\n","test":"\na, b, c = 4, 3, 2\nmaxOps(a, b, c)\n","output":"4\n","fn_call":"maxOps"}
{"text":"case | python3 implementation of the approach ; function to return the sorted string ; to store the frequencies of the lowercase and the uppercase characters in the given string ; if current character is lowercase then increment its frequency in the lower [ ] array ; else increment in the upper [ ] array ; pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string ; for every character in the given string ; if the current character is lowercase then replace it with the smallest lowercase character available ; decrement the frequency of the used character ; else replace it with the smallest uppercase character available ; decrement the frequency of the used character ; return the sorted string ; ","context":"\nMAX = 26\n\n","code":"def getSortedString(s, n):\n    lower = [0] * MAX\n    upper = [0] * MAX\n    for i in range(n):\n        if (s[i].islower()):\n            lower[ord(s[i]) - ord('a')] += 1\n        elif (s[i].isupper()):\n            upper[ord(s[i]) - ord('A')] += 1\n    i = 0\n    j = 0\n    while (i < MAX and lower[i] == 0):\n        i += 1\n    while (j < MAX and upper[j] == 0):\n        j += 1\n    for k in range(n):\n        if (s[k].islower()):\n            while (lower[i] == 0):\n                i += 1\n            s[k] = chr(i + ord('a'))\n            lower[i] -= 1\n        elif (s[k].isupper()):\n            while (upper[j] == 0):\n                j += 1\n            s[k] = chr(j + ord('A'))\n            upper[j] -= 1\n    return \"\".join(s)\n","test":"\nif __name__ == \"__main__\":\n    s = \"gEeksfOrgEEkS\"\n    n = len(s)\n    print(getSortedString(list(s), n))\n","output":"eEfggkEkrEOsS\n","fn_call":"getSortedString"}
{"text":"print characters and their frequencies in order of occurrence | python3 implementation to pr the character and its frequency in order of its occurrence ; function to print the character and its frequency in order of its occurrence ; size of the 'str ; initialize all elements of freq [ ] to 0 ; accumulate frequency of each character in 'str ; traverse ' str ' from left to right ; if frequency of character str [ i ] is not equal to 0 ; print the character along with its frequency ; update frequency of str [ i ] to 0 so that the same character is not printed again ; ","context":"\nimport numpy as np\n\n","code":"def prCharWithFreq(str):\n    n = len(str)\n    freq = np.zeros(26, int)\n    for i in range(0, n):\n        freq[ord(str[i]) - ord('a')] += 1\n    for i in range(0, n):\n        if (freq[ord(str[i]) - ord('a')] != 0):\n            print(str[i], freq[ord(str[i]) - ord('a')],\n                  end=\" \")\n            freq[ord(str[i]) - ord('a')] = 0\n","test":"\nif __name__ == \"__main__\":\n\n    str = \"geeksforgeeks\"\n    prCharWithFreq(str)\n","output":"g 2 e 4 k 2 s 2 f 1 o 1 r 1 ","fn_call":"prCharWithFreq"}
{"text":"segregate prime and non | function to generate prime numbers using sieve of eratosthenes ; if prime [ p ] is unchanged , then it is a prime ; update all multiples of p ; function to segregate the primes and non - primes ; generate all primes till 10 ^ 7 ; initialize left and right ; traverse the array ; increment left while array element at left is prime ; decrement right while array element at right is non - prime ; if left < right , then swap arr [ left ] and arr [ right ] ; swap arr [ left ] and arr [ right ] ; print segregated array ; ","context":"","code":"def SieveOfEratosthenes(prime, n):\n    p = 2\n    while (p * p <= n):\n        if (prime[p]):\n            i = p * p\n            while (i <= n):\n                prime[i] = False\n                i += p\n        p += 1\n\n\ndef segregatePrimeNonPrime(prime, arr, N):\n    SieveOfEratosthenes(prime, 10000000)\n    left, right = 0, N - 1\n    while (left < right):\n        while (prime[arr[left]]):\n            left += 1\n        while (not prime[arr[right]]):\n            right -= 1\n        if (left < right):\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n    for num in arr:\n        print(num, end=\" \")\n","test":"\narr = [2, 3, 4, 6, 7, 8, 9, 10]\nN = len(arr)\nprime = [True] * 10000001\nsegregatePrimeNonPrime(prime, arr, N)\n","output":"2 3 7 6 4 8 9 10 ","fn_call":"segregatePrimeNonPrime"}
{"text":"calculate depth of a full binary tree from preorder | function to return max of left subtree height or right subtree height ; calc height of left subtree ( in preorder left subtree is processed before right ) ; calc height of right subtree ; wrapper over finddepthrec ( ) ; ","context":"","code":"def findDepthRec(tree, n, index):\n    if (index[0] >= n or tree[index[0]] == 'l'):\n        return 0\n    index[0] += 1\n    left = findDepthRec(tree, n, index)\n    index[0] += 1\n    right = findDepthRec(tree, n, index)\n    return (max(left, right) + 1)\n\n\ndef findDepth(tree, n):\n    index = [0]\n    return findDepthRec(tree, n, index)\n","test":"\nif __name__ == '__main__':\n    tree = \"nlnnlll\"\n    n = len(tree)\n    print(findDepth(tree, n))\n","output":"3\n","fn_call":"findDepth"}
{"text":"check horizontal and vertical symmetry in binary matrix | python3 program to find if a matrix is symmetric . ; initializing as both horizontal and vertical symmetric . ; checking for horizontal symmetry . we compare first row with last row , second row with second last row and so on . ; checking each cell of a column . ; check if every cell is identical ; checking for vertical symmetry . we compare first column with last column , second xolumn with second last column and so on . ; checking each cell of a row . ; check if every cell is identical ; ","context":"\nMAX = 1000\n\n","code":"def checkHV(arr, N, M):\n    horizontal = True\n    vertical = True\n    i = 0\n    k = N - 1\n    while (i < N \/\/ 2):\n        for j in range(M):\n            if (arr[i][j] != arr[k][j]):\n                horizontal = False\n                break\n        i += 1\n        k -= 1\n    i = 0\n    k = M - 1\n    while (i < M \/\/ 2):\n        for j in range(N):\n            if (arr[i][j] != arr[k][j]):\n                vertical = False\n                break\n        i += 1\n        k -= 1\n    if (not horizontal and not vertical):\n        print(\"NO\")\n    elif (horizontal and not vertical):\n        print(\"HORIZONTAL\")\n    elif (vertical and not horizontal):\n        print(\"VERTICAL\")\n    else:\n        print(\"BOTH\")\n","test":"\nmat = [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\ncheckHV(mat, 3, 3)\n","output":"BOTH\n","fn_call":"checkHV"}
{"text":"replace every matrix element with maximum of gcd of row or column | python3 program to replace each each element with maximum of gcd of row or column . ; returning the greatest common divisor of two number ; finding gcd of each row and column and replacing with each element with maximum of gcd of row or column . ; calculating gcd of each row and each column in o ( mn ) and store in arrays . ; replacing matrix element ; ","context":"\nR = 3\nC = 4\n\n","code":"def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef replacematrix(mat, n, m):\n    rgcd = [0] * R\n    cgcd = [0] * C\n    for i in range(n):\n        for j in range(m):\n            rgcd[i] = gcd(rgcd[i], mat[i][j])\n            cgcd[j] = gcd(cgcd[j], mat[i][j])\n    for i in range(n):\n        for j in range(m):\n            mat[i][j] = max(rgcd[i], cgcd[j])\n","test":"\nif __name__ == \"__main__\":\n    m = [[1, 2, 3, 3], [4, 5, 6, 6], [7, 8, 9, 9]]\n    replacematrix(m, R, C)\n    for i in range(R):\n        for j in range(C):\n            print(m[i][j], end=\" \")\n        print()\n","output":"1 1 3 3 \n1 1 3 3 \n1 1 3 3 \n","fn_call":"replacematrix"}
{"text":"program for addition of two matrices | python3 program for addition of two matrices ; this function adds a [ ] [ ] and b [ ] [ ] , and stores the result in c [ ] [ ] ; ","context":"\nN = 4\n\n","code":"def add(A, B, C):\n    for i in range(N):\n        for j in range(N):\n            C[i][j] = A[i][j] + B[i][j]\n","test":"\nA = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]\nB = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]\nC = A[:][:]\nadd(A, B, C)\nprint(\"Result matrix is\")\nfor i in range(N):\n    for j in range(N):\n        print(C[i][j], \" \", end='')\n    print()\n","output":"Result matrix is\n2  2  2  2  \n4  4  4  4  \n6  6  6  6  \n8  8  8  8  \n","fn_call":"add"}
{"text":"program for subtraction of matrices | python 3 program for subtraction of matrices ; this function returns 1 if a [ ] [ ] and b [ ] [ ] are identical otherwise returns 0 ; ","context":"\nN = 4\n\n","code":"def subtract(A, B, C):\n    for i in range(N):\n        for j in range(N):\n            C[i][j] = A[i][j] - B[i][j]\n","test":"\nA = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]\nB = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]\nC = A[:][:]\nsubtract(A, B, C)\nprint(\"Result matrix is\")\nfor i in range(N):\n    for j in range(N):\n        print(C[i][j], \" \", end='')\n    print()\n","output":"Result matrix is\n0  0  0  0  \n0  0  0  0  \n0  0  0  0  \n0  0  0  0  \n","fn_call":"subtract"}
{"text":"find a fixed point ( value equal to index ) in a given array | python program to check fixed point in an array using linear search ; if no fixed point present then return - 1 ; ","context":"","code":"def linearSearch(arr, n):\n    for i in range(n):\n        if arr[i] is i:\n            return i\n    return -1\n","test":"\narr = [-10, -1, 0, 3, 10, 11, 30, 50, 100]\nn = len(arr)\nprint(\"Fixed Point is \" + str(linearSearch(arr, n)))\n","output":"Fixed Point is 3\n","fn_call":"linearSearch"}
{"text":"find a fixed point ( value equal to index ) in a given array | python program to check fixed point in an array using binary search ;  ; return - 1 if there is no fixed point ; ","context":"","code":"def binarySearch(arr, low, high):\n    if high >= low:\n        mid = (low + high) \/\/ 2\n    if mid is arr[mid]:\n        return mid\n    if mid > arr[mid]:\n        return binarySearch(arr, (mid + 1), high)\n    else:\n        return binarySearch(arr, low, (mid - 1))\n    return -1\n","test":"\narr = [-10, -1, 0, 3, 10, 11, 30, 50, 100]\nn = len(arr)\nprint(\"Fixed Point is \" + str(binarySearch(arr, 0, n - 1)))\n","output":"Fixed Point is 3\n","fn_call":"binarySearch"}
{"text":"maximum triplet sum in array | python 3 code to find maximum triplet sum ; initialize sum with int_min ; ","context":"","code":"def maxTripletSum(arr, n):\n    sm = -1000000\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (sm < (arr[i] + arr[j] + arr[k])):\n                    sm = arr[i] + arr[j] + arr[k]\n    return sm\n","test":"\narr = [1, 0, 8, 6, 4, 2]\nn = len(arr)\nprint(maxTripletSum(arr, n))\n","output":"18\n","fn_call":"maxTripletSum"}
{"text":"maximum triplet sum in array | this function assumes that there are at least three elements in arr [ ] . ; sort the given array ; after sorting the array . add last three element of the given array ; ","context":"","code":"def maxTripletSum(arr, n):\n    arr .sort()\n    return (arr[n - 1] + arr[n - 2] + arr[n - 3])\n","test":"\narr = [1, 0, 8, 6, 4, 2]\nn = len(arr)\nprint(maxTripletSum(arr, n))\n","output":"18\n","fn_call":"maxTripletSum"}
{"text":"maximum triplet sum in array | this function assumes that there are at least three elements in arr [ ] . ; initialize maximum , second maximum and third maximum element ; update maximum , second maximum and third maximum element ; update second maximum and third maximum element ; update third maximum element ; ","context":"","code":"def maxTripletSum(arr, n):\n    maxA = -100000000\n    maxB = -100000000\n    maxC = -100000000\n    for i in range(0, n):\n        if (arr[i] > maxA):\n            maxC = maxB\n            maxB = maxA\n            maxA = arr[i]\n        elif (arr[i] > maxB):\n            maxC = maxB\n            maxB = arr[i]\n        elif (arr[i] > maxC):\n            maxC = arr[i]\n    return (maxA + maxB + maxC)\n","test":"\narr = [1, 0, 8, 6, 4, 2]\nn = len(arr)\nprint(maxTripletSum(arr, n))\n","output":"18\n","fn_call":"maxTripletSum"}
{"text":"linear search | python3 code to linearly search x in arr [ ] . if x is present then return its location , otherwise return - 1 ; ","context":"","code":"def search(arr, n, x):\n    for i in range(0, n):\n        if (arr[i] == x):\n            return i\n    return -1\n","test":"\narr = [2, 3, 4, 10, 40]\nx = 10\nn = len(arr)\nresult = search(arr, n, x)\nif (result == -1):\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index\", result)\n","output":"Element is present at index 3\n","fn_call":"search"}
{"text":"linear search | python3 program for linear search ; run loop from 0 to right ; if search_element is found with left variable ; if search_element is found with right variable ; if element not found ; ","context":"","code":"def search(arr, search_Element):\n    left = 0\n    length = len(arr)\n    position = -1\n    right = length - 1\n    for left in range(0, right, 1):\n        if (arr[left] == search_Element):\n            position = left\n            print(\n                \"Element found in Array at \",\n                position + 1,\n                \" Position with \",\n                left + 1,\n                \" Attempt\")\n            break\n        if (arr[right] == search_Element):\n            position = right\n            print(\n                \"Element found in Array at \",\n                position + 1,\n                \" Position with \",\n                length - right,\n                \" Attempt\")\n            break\n        left += 1\n        right -= 1\n    if (position == -1):\n        print(\"Not found in Array with \", left, \" Attempt\")\n","test":"\narr = [1, 2, 3, 4, 5]\nsearch_element = 5\nsearch(arr, search_element)\n","output":"Element found in Array at  5  Position with  1  Attempt\n","fn_call":"search"}
{"text":"counting sort | the function that sorts the given arr [ ] ; ","context":"","code":"def count_sort(arr):\n    max_element = int(max(arr))\n    min_element = int(min(arr))\n    range_of_elements = max_element - min_element + 1\n    count_arr = [0 for _ in range(range_of_elements)]\n    output_arr = [0 for _ in range(len(arr))]\n    for i in range(0, len(arr)):\n        count_arr[arr[i] - min_element] += 1\n    for i in range(1, len(count_arr)):\n        count_arr[i] += count_arr[i - 1]\n    for i in range(len(arr) - 1, -1, -1):\n        output_arr[count_arr[arr[i] - min_element] - 1] = arr[i]\n        count_arr[arr[i] - min_element] -= 1\n    for i in range(0, len(arr)):\n        arr[i] = output_arr[i]\n    return arr\n","test":"\narr = [-5, -10, 0, -3, 8, 5, -1, 10]\nans = count_sort(arr)\nprint(\"Sorted character array is \" + str(ans))\n","output":"Sorted character array is [-10, -5, -3, -1, 0, 5, 8, 10]\n","fn_call":"count_sort"}
{"text":"binomial coefficient | dp | returns value of binomial coefficient c ( n , k ) ; base cases ; recursive call ; ","context":"","code":"def binomialCoeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k)\n","test":"\nn = 5\nk = 2\nprint(\"Value of C(%d,%d) is (%d)\" % (n, k, binomialCoeff(n, k)))\n","output":"Value of C(5,2) is (10)\n","fn_call":"binomialCoeff"}
{"text":"binomial coefficient | dp | python program for optimized dynamic programming solution to binomail coefficient . this one uses the concept of pascal triangle and less memory ; since nc0 is 1 ; compute next row of pascal triangle using the previous row ; ","context":"","code":"def binomialCoeff(n, k):\n    C = [0 for i in range(k + 1)]\n    C[0] = 1\n    for i in range(1, n + 1):\n        j = min(i, k)\n        while (j > 0):\n            C[j] = C[j] + C[j - 1]\n            j -= 1\n    return C[k]\n","test":"\nn = 5\nk = 2\nprint(\"Value of C(%d,%d) is %d\" % (n, k, binomialCoeff(n, k)))\n","output":"Value of C(5,2) is 10\n","fn_call":"binomialCoeff"}
{"text":"binomial coefficient | dp | function to find binomial coefficient ; getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 \/ ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; ","context":"","code":"def binomialCoeff(n, r):\n    if (r > n):\n        return 0\n    m = 1000000007\n    inv = [0 for i in range(r + 1)]\n    inv[0] = 1\n    if (r + 1 >= 2):\n        inv[1] = 1\n    for i in range(2, r + 1):\n        inv[i] = m - (m \/\/ i) * inv[m % i] % m\n    ans = 1\n    for i in range(2, r + 1):\n        ans = ((ans % m) * (inv[i] % m)) % m\n    for i in range(n, n - r, -1):\n        ans = ((ans % m) * (i % m)) % m\n    return ans\n","test":"\nn = 5\nr = 2\nprint(\"Value of C(\", n, \", \", r, \") is \", binomialCoeff(n, r))\n","output":"Value of C( 5 ,  2 ) is  10\n","fn_call":"binomialCoeff"}
{"text":"partition problem | dp | returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; calculate sum of all elements ; initialze the part array as 0 ; fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; check if sum - arr [ i ] could be formed from a subset using elements before index i ; ","context":"","code":"def findPartiion(arr, n):\n    Sum = 0\n    for i in range(n):\n        Sum += arr[i]\n    if (Sum % 2 != 0):\n        return 0\n    part = [0] * ((Sum \/\/ 2) + 1)\n    for i in range((Sum \/\/ 2) + 1):\n        part[i] = 0\n    for i in range(n):\n        for j in range(Sum \/\/ 2, arr[i] - 1, -1):\n            if (part[j - arr[i]] == 1 or j == arr[i]):\n                part[j] = 1\n    return part[Sum \/\/ 2]\n","test":"\narr = [1, 3, 3, 2, 3, 2]\nn = len(arr)\nif (findPartiion(arr, n) == 1):\n    print(\"Can be divided into two subsets of equal sum\")\nelse:\n    print(\"Can not be divided into two subsets of equal sum\")\n","output":"Can be divided into two subsets of equal sum\n","fn_call":"findPartiion"}
{"text":"dynamic programming | returns true if there is a subset of set [ ] with sun equal to given sum ; base cases ; if last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; ","context":"","code":"def isSubsetSum(set, n, sum):\n    if (sum == 0):\n        return True\n    if (n == 0):\n        return False\n    if (set[n - 1] > sum):\n        return isSubsetSum(set, n - 1, sum)\n    return isSubsetSum(set, n - 1, sum) or isSubsetSum(set,\n                                                       n - 1, sum - set[n - 1])\n","test":"\nset = [3, 34, 4, 12, 5, 2]\nsum = 9\nn = len(set)\nif (isSubsetSum(set, n, sum)):\n    print(\"Found a subset with given sum\")\nelse:\n    print(\"No subset with given sum\")\n","output":"Found a subset with given sum\n","fn_call":"isSubsetSum"}
{"text":"dynamic programming | returns true if there is a subset of set [ ] with sun equal to given sum ; the value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; if sum is 0 , then answer is true ; if sum is not 0 and set is empty , then answer is false ; fill the subset table in botton up manner ; print table ; ","context":"","code":"def isSubsetSum(set, n, sum):\n    subset = ([[False for i in range(sum + 1)]for i in range(n + 1)])\n    for i in range(n + 1):\n        subset[i][0] = True\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= set[i - 1]:\n                subset[i][j] = (subset[i - 1][j]\n                                or subset[i - 1][j - set[i - 1]])\n    for i in range(n + 1):\n        for j in range(sum + 1):\n            print(subset[i][j], end=\" \")\n            print()\n    return subset[n][sum]\n","test":"\nif __name__ == '__main__':\n    set = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    n = len(set)\n    if (isSubsetSum(set, n, sum)):\n        print(\"Found a subset with given sum\")\n    else:\n        print(\"No subset with given sum\")\n","output":"True \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nFalse \nFalse \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nFalse \nFalse \nTrue \nTrue \nTrue \nFalse \nTrue \nTrue \nTrue \nTrue \nFalse \nTrue \nTrue \nTrue \nTrue \nTrue \nTrue \nTrue \nTrue \nFound a subset with given sum\n","fn_call":"isSubsetSum"}
{"text":"how to print maximum number of a 's using given four keys | a recursive function that returns the optimal length string for n keystrokes ; the optimal string length is n when n is smaller than ; initialize result ; try all possible break - points for any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is s at b 'th  keystroke then the optimal string  would have length  (n-b-1)*screen[b-1]; ; ","context":"","code":"def findoptimal(N):\n    if N <= 6:\n        return N\n    maxi = 0\n    for b in range(N - 3, 0, -1):\n        curr = (N - b - 1) * findoptimal(b)\n        if curr > maxi:\n            maxi = curr\n    return maxi\n","test":"\nif __name__ == '__main__':\n    for n in range(1, 21):\n        print(\"Maximum Number of As with\", n, \"keystrokes is\", findoptimal(n))\n","output":"Maximum Number of As with 1 keystrokes is 1\nMaximum Number of As with 2 keystrokes is 2\nMaximum Number of As with 3 keystrokes is 3\nMaximum Number of As with 4 keystrokes is 4\nMaximum Number of As with 5 keystrokes is 5\nMaximum Number of As with 6 keystrokes is 6\nMaximum Number of As with 7 keystrokes is 9\nMaximum Number of As with 8 keystrokes is 12\nMaximum Number of As with 9 keystrokes is 16\nMaximum Number of As with 10 keystrokes is 20\nMaximum Number of As with 11 keystrokes is 27\nMaximum Number of As with 12 keystrokes is 36\nMaximum Number of As with 13 keystrokes is 48\nMaximum Number of As with 14 keystrokes is 64\nMaximum Number of As with 15 keystrokes is 81\nMaximum Number of As with 16 keystrokes is 108\nMaximum Number of As with 17 keystrokes is 144\nMaximum Number of As with 18 keystrokes is 192\nMaximum Number of As with 19 keystrokes is 256\nMaximum Number of As with 20 keystrokes is 324\n","fn_call":"findoptimal"}
{"text":"how to print maximum number of a 's using given four keys | this function returns the optimal length string for n keystrokes ; the optimal string length is n when n is smaller than 7 ; an array to store result of subproblems ; initializing the optimal lengths array for uptil 6 input strokes . ; solve all subproblems in bottom manner ; initialize length of optimal string for n keystrokes ; for any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; ","context":"","code":"def findoptimal(N):\n    if (N <= 6):\n        return N\n    screen = [0] * N\n    for n in range(1, 7):\n        screen[n - 1] = n\n    for n in range(7, N + 1):\n        screen[n - 1] = 0\n        for b in range(n - 3, 0, -1):\n            curr = (n - b - 1) * screen[b - 1]\n            if (curr > screen[n - 1]):\n                screen[n - 1] = curr\n    return screen[N - 1]\n","test":"\nif __name__ == \"__main__\":\n    for N in range(1, 21):\n        print(\"Maximum Number of A's with \", N,\n              \" keystrokes is \", findoptimal(N))\n","output":"Maximum Number of A's with  1  keystrokes is  1\nMaximum Number of A's with  2  keystrokes is  2\nMaximum Number of A's with  3  keystrokes is  3\nMaximum Number of A's with  4  keystrokes is  4\nMaximum Number of A's with  5  keystrokes is  5\nMaximum Number of A's with  6  keystrokes is  6\nMaximum Number of A's with  7  keystrokes is  9\nMaximum Number of A's with  8  keystrokes is  12\nMaximum Number of A's with  9  keystrokes is  16\nMaximum Number of A's with  10  keystrokes is  20\nMaximum Number of A's with  11  keystrokes is  27\nMaximum Number of A's with  12  keystrokes is  36\nMaximum Number of A's with  13  keystrokes is  48\nMaximum Number of A's with  14  keystrokes is  64\nMaximum Number of A's with  15  keystrokes is  81\nMaximum Number of A's with  16  keystrokes is  108\nMaximum Number of A's with  17  keystrokes is  144\nMaximum Number of A's with  18  keystrokes is  192\nMaximum Number of A's with  19  keystrokes is  256\nMaximum Number of A's with  20  keystrokes is  324\n","fn_call":"findoptimal"}
{"text":"how to print maximum number of a 's using given four keys | this function returns the optimal length string for n keystrokes ; the optimal string length is n when n is smaller than 7 ; an array to store result of subproblems ; initializing the optimal lengths array for uptil 6 input strokes . ; solve all subproblems in bottom manner ; for any keystroke n , we will need to choose between : - 1. pressing ctrl - v once after copying the a ' s \u2581 obtained \u2581 by \u2581 n - 3 \u2581 keystrokes . \u2581 \u2581 2 . \u2581 pressing \u2581 ctrl - v \u2581 twice \u2581 after \u2581 copying \u2581 the \u2581 a ' s obtained by n - 4 keystrokes . 3. pressing ctrl - v thrice after copying the a 's  obtained by n-5 keystrokes. ; ","context":"","code":"def findoptimal(N):\n    if (N <= 6):\n        return N\n    screen = [0] * N\n    for n in range(1, 7):\n        screen[n - 1] = n\n    for n in range(7, N + 1):\n        screen[n - 1] = max(2 * screen[n - 4],\n                            max(3 * screen[n - 5], 4 * screen[n - 6]))\n    return screen[N - 1]\n","test":"\nif __name__ == \"__main__\":\n    for N in range(1, 21):\n        print(\"Maximum Number of A's with \", N,\n              \" keystrokes is \", findoptimal(N))\n","output":"Maximum Number of A's with  1  keystrokes is  1\nMaximum Number of A's with  2  keystrokes is  2\nMaximum Number of A's with  3  keystrokes is  3\nMaximum Number of A's with  4  keystrokes is  4\nMaximum Number of A's with  5  keystrokes is  5\nMaximum Number of A's with  6  keystrokes is  6\nMaximum Number of A's with  7  keystrokes is  9\nMaximum Number of A's with  8  keystrokes is  12\nMaximum Number of A's with  9  keystrokes is  16\nMaximum Number of A's with  10  keystrokes is  20\nMaximum Number of A's with  11  keystrokes is  27\nMaximum Number of A's with  12  keystrokes is  36\nMaximum Number of A's with  13  keystrokes is  48\nMaximum Number of A's with  14  keystrokes is  64\nMaximum Number of A's with  15  keystrokes is  81\nMaximum Number of A's with  16  keystrokes is  108\nMaximum Number of A's with  17  keystrokes is  144\nMaximum Number of A's with  18  keystrokes is  192\nMaximum Number of A's with  19  keystrokes is  256\nMaximum Number of A's with  20  keystrokes is  324\n","fn_call":"findoptimal"}
{"text":"write a program to calculate pow ( x , n ) | function to calculate x raised to the power y ; ","context":"","code":"def power(x, y):\n    if (y == 0):\n        return 1\n    elif (int(y % 2) == 0):\n        return (power(x, int(y \/ 2)) * power(x, int(y \/ 2)))\n    else:\n        return (x * power(x, int(y \/ 2)) * power(x, int(y \/ 2)))\n","test":"\nx = 2\ny = 3\nprint(power(x, y))\n","output":"8\n","fn_call":"power"}
{"text":"write a program to calculate pow ( x , n ) | python3 code for extended version of power function that can work for float x and negative y ; ","context":"","code":"def power(x, y):\n    if (y == 0):\n        return 1\n    temp = power(x, int(y \/ 2))\n    if (y % 2 == 0):\n        return temp * temp\n    else:\n        if (y > 0):\n            return x * temp * temp\n        else:\n            return (temp * temp) \/ x\n","test":"\nx, y = 2, -3\nprint('%.6f' % (power(x, y)))\n","output":"0.125000\n","fn_call":"power"}
{"text":"write a program to calculate pow ( x , n ) | python3 program for the above approach ; if x ^ 0 return 1 ; if we need to find of 0 ^ y ; for all other cases ; ","context":"","code":"def power(x, y):\n    if (y == 0):\n        return 1\n    if (x == 0):\n        return 0\n    return x * power(x, y - 1)\n","test":"\nx = 2\ny = 3\nprint(power(x, y))\n","output":"8\n","fn_call":"power"}
{"text":"babylonian method for square root | returns the square root of n . note that the function ; we are using n itself as initial approximation this can definitely be improved ; e decides the accuracy level ; ","context":"","code":"def squareRoot(n):\n    x = n\n    y = 1\n    e = 0.000001\n    while (x - y > e):\n        x = (x + y) \/ 2\n        y = n \/ x\n    return x\n","test":"\nn = 50\nprint(\"Square root of\", n, \"is\", round(squareRoot(n), 6))\n","output":"Square root of 50 is 7.071068\n","fn_call":"squareRoot"}
{"text":"average of a stream of numbers | returns the new average after including x ; prints average of a stream of numbers ; ","context":"","code":"def getAvg(prev_avg, x, n):\n    return ((prev_avg * n + x) \/ (n + 1))\n\n\ndef streamAvg(arr, n):\n    avg = 0\n    for i in range(n):\n        avg = getAvg(avg, arr[i], i)\n        print(\"Average of \", i + 1, \" numbers is \", avg)\n","test":"\narr = [10, 20, 30, 40, 50, 60]\nn = len(arr)\nstreamAvg(arr, n)\n","output":"Average of  1  numbers is  10.0\nAverage of  2  numbers is  15.0\nAverage of  3  numbers is  20.0\nAverage of  4  numbers is  25.0\nAverage of  5  numbers is  30.0\nAverage of  6  numbers is  35.0\n","fn_call":"streamAvg"}
{"text":"average of a stream of numbers | returns the new average after including x ; prints average of a stream of numbers ; ","context":"","code":"def getAvg(x, n, sum):\n    sum = sum + x\n    return float(sum) \/ n\n\n\ndef streamAvg(arr, n):\n    avg = 0\n    sum = 0\n    for i in range(n):\n        avg = getAvg(arr[i], i + 1, sum)\n        sum = avg * (i + 1)\n        print(\"Average of \", end=\"\")\n        print(i + 1, end=\"\")\n        print(\" numbers is \", end=\"\")\n        print(avg)\n    return\n","test":"\narr = [10, 20, 30, 40, 50, 60]\nn = len(arr)\nstreamAvg(arr, n)\n","output":"Average of 1 numbers is 10.0\nAverage of 2 numbers is 15.0\nAverage of 3 numbers is 20.0\nAverage of 4 numbers is 25.0\nAverage of 5 numbers is 30.0\nAverage of 6 numbers is 35.0\n","fn_call":"streamAvg"}
{"text":"space and time efficient binomial coefficient | returns value of binomial coefficient c ( n , k ) ; since c ( n , k ) = c ( n , n - k ) ; calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ] ; ","context":"","code":"def binomialCoefficient(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(k):\n        res = res * (n - i)\n        res = res \/ (i + 1)\n    return res\n","test":"\nn = 8\nk = 2\nres = binomialCoefficient(n, k)\nprint(\"Value of C(% d, % d) is % d\" % (n, k, res))\n","output":"Value of C( 8,  2) is  28\n","fn_call":"binomialCoefficient"}
{"text":"efficient program to print all prime factors of a given number | python program to print prime factors ; a function to print all prime factors of a given number n ; print the number of two 's that divide n ; n must be odd at this point so a skip of 2 ( i = i + 2 ) can be used ; while i divides n , print i ad divide n ; condition if n is a prime number greater than 2 ; ","context":"\nimport math\n\n","code":"def primeFactors(n):\n    while n % 2 == 0:\n        print(2,)\n        n = n \/ 2\n    for i in range(3, int(math .sqrt(n)) + 1, 2):\n        while n % i == 0:\n            print(i,)\n            n = n \/ i\n    if n > 2:\n        print(n)\n","test":"\nn = 315\nprimeFactors(n)\n","output":"3\n3\n5\n7\n","fn_call":"primeFactors"}
{"text":"print all possible combinations of r elements in a given array of size n | the main function that prints all combinations of size r in arr [ ] of size n . this function mainly uses combinationutil ( ) ; a temporary array to store all combination one by one ; print all combination using temprary array 'data[]   ; arr [ ] -- -> input array data [ ] -- -> temporary array to store current combination start & end -- -> staring and ending indexes in arr [ ] index -- -> current index in data [ ] r -- -> size of a combination to be printed ; current combination is ready to be printed , print it ; replace index with all possible elements . the condition \" end - i + 1 \u2581 > = \u2581 \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions ; ","context":"","code":"def combinationUtil(arr, data, start, end, index, r):\n    if (index == r):\n        for j in range(r):\n            print(data[j], end=\" \")\n        print()\n        return\n    i = start\n    while (i <= end and end - i + 1 >= r - index):\n        data[index] = arr[i]\n        combinationUtil(arr, data, i + 1, end, index + 1, r)\n        i += 1\n\ndef printCombination(arr, n, r):\n    data = [0] * r\n    combinationUtil(arr, data, 0, n - 1, 0, r)\n","test":"\narr = [1, 2, 3, 4, 5]\nr = 3\nn = len(arr)\nprintCombination(arr, n, r)\n","output":"1 2 3 \n1 2 4 \n1 2 5 \n1 3 4 \n1 3 5 \n1 4 5 \n2 3 4 \n2 3 5 \n2 4 5 \n3 4 5 \n","fn_call":"printCombination"}
{"text":"print all possible combinations of r elements in a given array of size n | the main function that prints all combinations of size r in arr [ ] of size n . this function mainly uses combinationutil ( ) ; a temporary array to store all combination one by one ; print all combination using temprary array 'data[]   ; arr [ ] -- -> input array n -- -> size of input array r -- -> size of a combination to be printed index -- -> current index in data [ ] data [ ] -- -> temporary array to store current combination i -- -> index of current element in arr [ ] ; current cobination is ready , print it ; when no more elements are there to put in data [ ] ; current is included , put next at next location ; current is excluded , replace it with next ( note that i + 1 is passed , but index is not changed ) ; ","context":"","code":"def combinationUtil(arr, n, r, index, data, i):\n    if (index == r):\n        for j in range(r):\n            print(data[j], end=\" \")\n        print()\n        return\n    if (i >= n):\n        return\n    data[index] = arr[i]\n    combinationUtil(arr, n, r, index + 1, data, i + 1)\n    combinationUtil(arr, n, r, index, data, i + 1)\n\ndef printCombination(arr, n, r):\n    data = [0] * r\n    combinationUtil(arr, n, r, 0, data, 0)\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    r = 3\n    n = len(arr)\n    printCombination(arr, n, r)\n","output":"1 2 3 \n1 2 4 \n1 2 5 \n1 3 4 \n1 3 5 \n1 4 5 \n2 3 4 \n2 3 5 \n2 4 5 \n3 4 5 \n","fn_call":"printCombination"}
{"text":"count all possible groups of size 2 or 3 that have sum as multiple of 3 | returns count of all possible groups that can be formed from elements of a [ ] . ; create an array c [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; to store the result ; count elements with remainder 0 , 1 and 2 ; case 3. a : count groups of size 2 from 0 remainder elements ; case 3. b : count groups of size 2 with one element with 1 remainder and other with 2 remainder ; case 4. a : count groups of size 3 with all 0 remainder elements ; case 4. b : count groups of size 3 with all 1 remainder elements ; case 4. c : count groups of size 3 with all 2 remainder elements ; case 4. c : count groups of size 3 with different remainders ; return total count stored in res ; ","context":"","code":"def findgroups(arr, n):\n    c = [0, 0, 0]\n    res = 0\n    for i in range(0, n):\n        c[arr[i] % 3] += 1\n    res += ((c[0] * (c[0] - 1)) >> 1)\n    res += c[1] * c[2]\n    res += (c[0] * (c[0] - 1) * (c[0] - 2)) \/ 6\n    res += (c[1] * (c[1] - 1) * (c[1] - 2)) \/ 6\n    res += ((c[2] * (c[2] - 1) * (c[2] - 2)) \/ 6)\n    res += c[0] * c[1] * c[2]\n    return res\n","test":"\narr = [3, 6, 7, 2, 9]\nn = len(arr)\nprint(\"Required number of groups are\", int(findgroups(arr, n)))\n","output":"Required number of groups are 8\n","fn_call":"findgroups"}
{"text":"smallest power of 2 greater than or equal to n |  ; first n in the below condition is for the case where n is 0 ; ","context":"","code":"def nextPowerOf2(n):\n    count = 0\n    if (n and not (n & (n - 1))):\n        return n\n    while (n != 0):\n        n >>= 1\n        count += 1\n    return 1 << count\n","test":"\nn = 0\nprint(nextPowerOf2(n))\n","output":"1\n","fn_call":"nextPowerOf2"}
{"text":"smallest power of 2 greater than or equal to n |  ; ","context":"","code":"def nextPowerOf2(n):\n    p = 1\n    if (n and not (n & (n - 1))):\n        return n\n    while (p < n):\n        p <<= 1\n    return p\n","test":"\nn = 5\nprint(nextPowerOf2(n))\n","output":"8\n","fn_call":"nextPowerOf2"}
{"text":"smallest power of 2 greater than or equal to n | finds next power of two for n . if n itself is a power of two then returns n ; ","context":"","code":"def nextPowerOf2(n):\n    n -= 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n += 1\n    return n\n","test":"\nn = 5\nprint(nextPowerOf2(n))\n","output":"8\n","fn_call":"nextPowerOf2"}
{"text":"segregate 0 s and 1 s in an array | function to put all 0 s on left and all 1 s on right ; initialize left and right indexes ; increment left index while we see 0 at left ; decrement right index while we see 1 at right ; if left is smaller than right then there is a 1 at left and a 0 at right . exchange arr [ left ] and arr [ right ] ; ","context":"","code":"def segregate0and1(arr, size):\n    left, right = 0, size - 1\n    while left < right:\n        while arr[left] == 0 and left < right:\n            left += 1\n        while arr[right] == 1 and left < right:\n            right -= 1\n        if left < right:\n            arr[left] = 0\n            arr[right] = 1\n            left += 1\n            right -= 1\n    return arr\n","test":"\narr = [0, 1, 0, 1, 1, 1]\narr_size = len(arr)\nprint(\"Array after segregation\")\nprint(segregate0and1(arr, arr_size))\n","output":"Array after segregation\n[0, 0, 1, 1, 1, 1]\n","fn_call":"segregate0and1"}
{"text":"segregate 0 s and 1 s in an array | function to put all 0 s on left and all 1 s on right ; ","context":"","code":"def segregate0and1(arr, size):\n    type0 = 0\n    type1 = size - 1\n    while (type0 < type1):\n        if (arr[type0] == 1):\n            (arr[type0], arr[type1]) = (arr[type1], arr[type0])\n            type1 -= 1\n        else:\n            type0 += 1\n","test":"\narr = [0, 1, 0, 1, 1, 1]\narr_size = len(arr)\nsegregate0and1(arr, arr_size)\nprint(\"Array after segregation is\", end=\" \")\nfor i in range(0, arr_size):\n    print(arr[i], end=\" \")\n","output":"Array after segregation is 0 0 1 1 1 1 ","fn_call":"segregate0and1"}
{"text":"distinct adjacent elements in an array | python program to check if we can make neighbors distinct . ; dict used to count the frequency of each element occurring in the array ; in this loop we count the frequency of element through map m ; mx store the frequency of element which occurs most in array . ; in this loop we calculate the maximum frequency and store it in variable mx . ; by swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) \/ 2 . ; ","context":"","code":"def distantAdjacentElement(a, n):\n    m = dict()\n    for i in range(n):\n        if a[i] in m:\n            m[a[i]] += 1\n        else:\n            m[a[i]] = 1\n    mx = 0\n    for i in range(n):\n        if mx < m[a[i]]:\n            mx = m[a[i]]\n    if mx > (n + 1) \/\/ 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n","test":"\nif __name__ == \"__main__\":\n    a = [7, 7, 7, 7]\n    n = len(a)\n    distantAdjacentElement(a, n)\n","output":"NO\n","fn_call":"distantAdjacentElement"}
{"text":"given an array arr [ ] , find the maximum j | for a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; ","context":"","code":"def maxIndexDiff(arr, n):\n    maxDiff = -1\n    for i in range(0, n):\n        j = n - 1\n        while (j > i):\n            if arr[j] > arr[i] and maxDiff < (j - i):\n                maxDiff = j - i\n            j -= 1\n    return maxDiff\n","test":"\narr = [9, 2, 3, 4, 5, 6, 7, 8, 18, 0]\nn = len(arr)\nmaxDiff = maxIndexDiff(arr, n)\nprint(maxDiff)\n","output":"8\n","fn_call":"maxIndexDiff"}
{"text":"print sorted distinct elements of array | python3 program to print sorted distinct elements . ; create a set using array elements ; print contents of the set . ; ","context":"","code":"def printRepeating(arr, size):\n    s = set()\n    for i in range(size):\n        if arr[i]not in s:\n            s .add(arr[i])\n    for i in s:\n        print(i, end=\" \")\n","test":"\nif __name__ == '__main__':\n    arr = [1, 3, 2, 2, 1]\n    size = len(arr)\n    printRepeating(arr, size)\n","output":"1 2 3 ","fn_call":"printRepeating"}
{"text":"minimum swaps to make two arrays identical | function returns the minimum number of swaps required to sort the array this method is taken from below post https : www . geeksforgeeks . org \/ minimum - number - swaps - required - sort - array \/ ; create an array of pairs where first element is array element and second element is position of first element ; sort the array by array element values to get right position of every element as second element of pair . ; to keep track of visited elements . initialize all elements as not visited or false . ; initialize result ; traverse array elements ; already swapped and corrected or already present at correct pos ; find out the number of node in this cycle and add in ans ; move to next node ; update answer by adding current cycle . ; return result ; method returns minimum number of swap to mak array b same as array a ; map to store position of elements in array b we basically store element to index mapping . ; now we 're storing position  of array a elements  in array b. ; returing minimum swap for sorting in modified array b as final answer ; ","context":"","code":"def minSwapsToSort(arr, n):\n    arrPos = [[0 for x in range(2)]for y in range(n)]\n    for i in range(n):\n        arrPos[i][0] = arr[i]\n        arrPos[i][1] = i\n    arrPos .sort()\n    vis = [False] * (n)\n    ans = 0\n    for i in range(n):\n        if (vis[i] or arrPos[i][1] == i):\n            continue\n        cycle_size = 0\n        j = i\n        while (not vis[j]):\n            vis[j] = 1\n            j = arrPos[j][1]\n            cycle_size += 1\n        ans += (cycle_size - 1)\n    return ans\n\n\ndef minSwapToMakeArraySame(a, b, n):\n    mp = {}\n    for i in range(n):\n        mp[b[i]] = i\n    for i in range(n):\n        b[i] = mp[a[i]]\n    return minSwapsToSort(b, n)\n","test":"\nif __name__ == \"__main__\":\n    a = [3, 6, 4, 8]\n    b = [4, 6, 8, 3]\n    n = len(a)\n    print(minSwapToMakeArraySame(a, b, n))\n","output":"2\n","fn_call":"minSwapToMakeArraySame"}
{"text":"k | function to find k - th missing element ; interating over the array ; check if i - th and ( i + 1 ) - th element are not consecutive ; save their difference ; check for difference and ","context":"","code":"def missingK(a, k, n):\n    difference = 0\n    ans = 0\n    count = k\n    flag = 0\n    for i in range(0, n - 1):\n        difference = 0\n        if ((a[i] + 1) != a[i + 1]):\n            difference += (a[i + 1] - a[i]) - 1\n            if (difference >= count):\n                ans = a[i] + count\n                flag = 1\n                break\n            else:\n                count -= difference\n    if (flag):\n        return ans\n    else:\n        return -1\n","test":"\na = [1, 5, 11, 19]\nk = 11\nn = len(a)\nmissing = missingK(a, k, n)\nprint(missing)\n","output":"14\n","fn_call":"missingK"}
{"text":"k | function to find kth missing number ; if the total missing number count is equal to k we can iterate backwards for the first missing number and that will be the answer . ; to further optimize we check if the previous element ' s \u2581 \u2581 missing \u2581 number \u2581 count \u2581 is \u2581 equal \u2581 \u2581 to \u2581 k . \u2581 eg : \u2581 arr \u2581 = \u2581 [ 4,5,6,7,8 ] \u2581 \u2581 if \u2581 you \u2581 observe \u2581 in \u2581 the \u2581 example \u2581 array , \u2581 \u2581 the \u2581 total \u2581 count \u2581 of \u2581 missing \u2581 numbers \u2581 for \u2581 all \u2581 \u2581 the \u2581 indices \u2581 are \u2581 same , \u2581 and \u2581 we \u2581 are \u2581 \u2581 aiming \u2581 to \u2581 narrow \u2581 down \u2581 the \u2581 \u2581 search \u2581 window \u2581 and \u2581 achieve \u2581 o ( logn ) \u2581 \u2581 time \u2581 complexity \u2581 which \u2581 \u2581 otherwise \u2581 would ' ve been o ( n ) . ; else we return arr [ mid ] - 1. ; here we appropriately narrow down the search window . ; in case the upper limit is - ve it means the missing number set is 1 , 2 , . . , k and hence we directly return k . ; else we find the residual count of numbers which we 'd then add to  arr[u] and get the missing kth number. ; return arr [ u ] + k ; ","context":"","code":"def missingK(arr, k):\n    n = len(arr)\n    l = 0\n    u = n - 1\n    mid = 0\n    while (l <= u):\n        mid = (l + u)\/\/2\n        numbers_less_than_mid = arr[mid] - (mid + 1)\n        if (numbers_less_than_mid == k):\n            if (mid > 0 and (arr[mid - 1] - (mid)) == k):\n                u = mid - 1\n                continue\n            return arr[mid]-1\n        if (numbers_less_than_mid < k):\n            l = mid + 1\n        elif (k < numbers_less_than_mid):\n            u = mid - 1\n    if (u < 0):\n        return k\n    less = arr[u] - (u + 1)\n    k -= less\n    return arr[u] + k\n","test":"\nif __name__ == '__main__':\n    arr = [2, 3, 4, 7, 11]\n    k = 5\n    print(\"Missing kth number = \" + str(missingK(arr, k)))\n","output":"Missing kth number = 9\n","fn_call":"missingK"}
{"text":"rotate all matrix elements except the diagonal k times by 90 degrees in clockwise direction | function to print the matrix ; iterate over the rows ; iterate over the columns ; print the value ; function to perform the swapping of matrix elements in clockwise manner ; stores the last row ; stores the last column ; perform the swaps ; function to rotate non - diagonal elements of the matrix k times in clockwise direction ; update k to k % 4 ; iterate until k is positive ; iterate each up to n \/ 2 - th row ; iterate each column from i to n - i - 1 ; check if the element at i , j is not a diagonal element ; perform the swapping ; print the matrix ; ","context":"","code":"def printMat(mat):\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            print(mat[i][j], end=\" \")\n        print()\n\n\ndef performSwap(mat, i, j):\n    N = len(mat)\n    ei = N - 1 - i\n    ej = N - 1 - j\n    temp = mat[i][j]\n    mat[i][j] = mat[ej][i]\n    mat[ej][i] = mat[ei][ej]\n    mat[ei][ej] = mat[j][ei]\n    mat[j][ei] = temp\n\n\ndef rotate(mat, N, K):\n    K = K % 4\n    while (K > 0):\n        for i in range(int(N \/ 2)):\n            for j in range(i, N - i - 1):\n                if (i != j and (i + j) != N - 1):\n                    performSwap(mat, i, j)\n        K -= 1\n    printMat(mat)\n","test":"\nK = 5\nmat = [[1, 2, 3, 4], [6, 7, 8, 9], [11, 12, 13, 14], [16, 17, 18, 19]]\nN = len(mat)\nrotate(mat, N, K)\n","output":"1 11 6 4 \n17 7 8 2 \n18 12 13 3 \n16 14 9 19 \n","fn_call":"rotate"}
{"text":"minimum rotations required to get the same string | returns count of rotations to get the same string back . ; tmp is the concatenated string . ; substring from i index of original string size . ; if substring matches with original string then we will come out of the loop . ; ","context":"","code":"def findRotations(str):\n    tmp = str + str\n    n = len(str)\n    for i in range(1, n + 1):\n        substring = tmp[i:i + n]\n        if (str == substring):\n            return i\n    return n\n","test":"\nif __name__ == '__main__':\n    str = \"abc\"\n    print(findRotations(str))\n","output":"3\n","fn_call":"findRotations"}
{"text":"count of integral coordinates that lies inside a square | function to calculate the integral points inside a square ; ","context":"","code":"def countIntgralPoints(x1, y1, x2, y2):\n    print((y2 - y1 - 1) * (x2 - x1 - 1))\n","test":"\nif __name__ == '__main__':\n    x1 = 1\n    y1 = 1\n    x2 = 4\n    y2 = 4\n    countIntgralPoints(x1, y1, x2, y2)\n","output":"4\n","fn_call":"countIntgralPoints"}
{"text":"find next number having distinct digits from the given number n | function to find the next distinct digits number ; loop to find the distinct digits using hash array and the number of digits ; loop to find the most significant distinct digit of the next number ; condition to check if the number is possible with the same number of digits count ; condition to check if the desired most siginificant distinct digit is found ; loop to find the minimum next digit which is not present in the number ; computation of the number ; condition to check if the number is greater than the given number ; ","context":"","code":"def findNextNumber(n):\n    h = [0 for i in range(10)]\n    i = 0\n    msb = n\n    rem = 0\n    next_num = -1\n    count = 0\n    while (msb > 9):\n        rem = msb % 10\n        h[rem] = 1\n        msb \/\/= 10\n        count += 1\n    h[msb] = 1\n    count += 1\n    for i in range(msb + 1, 10, 1):\n        if (h[i] == 0):\n            next_num = i\n            break\n    if (next_num == -1):\n        for i in range(1, msb, 1):\n            if (h[i] == 0):\n                next_num = i\n                count += 1\n                break\n    if (next_num > 0):\n        for i in range(0, 10, 1):\n            if (h[i] == 0):\n                msb = i\n                break\n        for i in range(1, count, 1):\n            next_num = ((next_num * 10) + msb)\n        if (next_num > n):\n            print(next_num)\n        else:\n            print(\"Not Possible\")\n    else:\n        print(\"Not Possible\")\n","test":"\nif __name__ == '__main__':\n    n = 2019\n    findNextNumber(n)\n","output":"3333\n","fn_call":"findNextNumber"}
{"text":"find a triplet ( a , b , c ) such that 3 * a + 5 * b + 7 * c is equal to n | function to find a triplet ( a , b , c ) such that 3 * a + 5 * b + 7 * c is n ; iterate over the range [ 0 , n7 ] ; iterate over the range [ 0 , n5 ] ; find the value of a ; if a is greater than or equal to 0 and divisible by 3 ; otherwise , print - 1 ; ","context":"","code":"def CalculateValues(N):\n    for C in range(0, N \/\/ 7 + 1):\n        for B in range(0, N \/\/ 5 + 1):\n            A = N - 7 * C - 5 * B\n            if (A >= 0 and A % 3 == 0):\n                print(\"A =\", A \/ 3, \", B =\", B, \", \\\\ C =\", C, sep=\" \")\n                return\n    print(-1)\n    return\n","test":"\nif __name__ == '__main__':\n    N = 19\n    CalculateValues(19)\n","output":"A = 3.0 , B = 2 , \\ C = 0\n","fn_call":"CalculateValues"}
{"text":"minimize total time taken by two persons to visit n cities such that none of them meet | function to find the minimum time to visit all the cities such that both the person never meets ; initialize sum as 0 ; find the maximum element ; traverse the array ; increment sum by arr [ i ] ; prmaximum of 2 * t and sum ; ","context":"","code":"def minimumTime(arr, n):\n    sum = 0\n    T = max(arr)\n    for i in range(n):\n        sum += arr[i]\n    print(max(2 * T, sum))\n","test":"\nif __name__ == '__main__':\n    arr = [2, 8, 3]\n    N = len(arr)\n    minimumTime(arr, N)\n","output":"16\n","fn_call":"minimumTime"}
{"text":"lexicographically largest string possible by reversing substrings having even number of 1 s | function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s ; store size of string ; traverse the string ; count the number of 1 s ; stores the starting index ; stores the end index ; increment count , when 1 is encountered ; traverse the remaining string ; temp is for reverse the string from starting and end index ; printing the string ; ","context":"","code":"def lexicographicallyMax(s):\n    n = len(s)\n    for i in range(n):\n        count = 0\n        beg = i\n        end = i\n        if (s[i] == '1'):\n            count += 1\n        for j in range(i + 1, n):\n            if (s[j] == '1'):\n                count += 1\n            if (count % 2 == 0 and count != 0):\n                end = j\n                break\n        temp = s[beg:end + 1]\n        temp = temp[::-1]\n        s = s[0:beg] + temp + s[end + 1:]\n    print(s)\n","test":"\nS = \"0101\"\nlexicographicallyMax(S)\n","output":"1010\n","fn_call":"lexicographicallyMax"}
{"text":"count maximum possible pairs from an array having sum k | function to count the maximum number of pairs from given array with sum k ; sort array in increasing order ; stores the final result ; initialize the left and right pointers ; traverse array until start < end ; decrement right by 1 ; increment left by 1 ; increment result and left pointer by 1 and decrement right pointer by 1 ; print the result ; ","context":"","code":"def maxPairs(nums, k):\n    nums = sorted(nums)\n    result = 0\n    start, end = 0, len(nums) - 1\n    while (start < end):\n        if (nums[start] + nums[end] > k):\n            end -= 1\n        elif (nums[start] + nums[end] < k):\n            start += 1\n        else:\n            start += 1\n            end -= 1\n            result += 1\n    print(result)\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    K = 5\n    maxPairs(arr, K)\n","output":"2\n","fn_call":"maxPairs"}
{"text":"count maximum possible pairs from an array having sum k | function to find the maximum number of pairs with a sum k such that same element can 't be used twice ; initialize a hashm ; store the final result ; iterate over the array nums [ ] ; decrement its frequency in m and increment the result by 1 ; increment its frequency by 1 if it is already present in m . otherwise , set its frequency to 1 ; print the result ; ","context":"","code":"def maxPairs(nums, k):\n    m = {}\n    result = 0\n    for i in nums:\n        if ((i in m) and m[i] > 0):\n            m[i] = m[i] - 1\n            result += 1\n        else:\n            if k - i in m:\n                m[k - i] += 1\n            else:\n                m[k - i] = 1\n    print(result)\n","test":"\narr = [1, 2, 3, 4]\nK = 5\nmaxPairs(arr, K)\n","output":"2\n","fn_call":"maxPairs"}
{"text":"print indices of array elements whose removal makes the sum of odd and even | function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal ; stores size of array ; store prefix sum of odd index array elements ; store prefix sum of even index array elements ; update even [ 0 ] ; traverse the given array ; update odd [ i ] ; update even [ i ] ; if the current index is an even number ; update even [ i ] ; if the current index is an odd number ; update odd [ i ] ; check if at least one index found or not that satisfies the condition ; store odd indices sum by removing 0 - th index ; store even indices sum by removing 0 - th index ; if p and q are equal ; traverse the array arr ; if i is an even number ; update p by removing the i - th element ; update q by removing the i - th element ; update q by removing the i - th element ; update p by removing the i - th element ; if odd index values sum is equal to even index values sum ; set the find variable ; print the current index ; if no index found ; print not possible ; ","context":"","code":"def removeIndicesToMakeSumEqual(arr):\n    N = len(arr)\n    odd = [0] * N\n    even = [0] * N\n    even[0] = arr[0]\n    for i in range(1, N):\n        odd[i] = odd[i - 1]\n        even[i] = even[i - 1]\n        if (i % 2 == 0):\n            even[i] += arr[i]\n        else:\n            odd[i] += arr[i]\n    find = False\n    p = odd[N - 1]\n    q = even[N - 1] - arr[0]\n    if (p == q):\n        print(\"0 \")\n        find = True\n    for i in range(1, N):\n        if (i % 2 == 0):\n            p = even[N - 1] - even[i - 1] - arr[i] + odd[i - 1]\n            q = odd[N - 1] - odd[i - 1] + even[i - 1]\n        else:\n            q = odd[N - 1] - odd[i - 1] - arr[i] + even[i - 1]\n            p = even[N - 1] - even[i - 1] + odd[i - 1]\n        if (p == q):\n            find = True\n            print(i, end=\"\")\n    if (find == False):\n        print(-1)\n","test":"\nif __name__ == '__main__':\n    arr = [4, 1, 6, 2]\n    removeIndicesToMakeSumEqual(arr)\n","output":"1","fn_call":"removeIndicesToMakeSumEqual"}
{"text":"minimum removals required to make a given array bitonic | function to coutnt minimum array elements required to be removed to make an array bitonic ; left [ i ] : stores the length of lis up to i - th index ; right [ i ] : stores the length of decreasing subsequence over the range [ i , n ] ; calculate the length of lis up to i - th index ; traverse the array upto i - th index ; if arr [ j ] is less than arr [ i ] ; update left [ i ] ; calculate the length of decreasing subsequence over the range [ i , n ] ; traverse right [ ] array ; if arr [ i ] is greater than arr [ j ] ; update right [ i ] ; stores length of the longest bitonic array ; traverse left [ ] and right [ ] array ; update maxlen ; function to prminimum removals required to make given array bitonic ; ","context":"","code":"def min_element_removal(arr, N):\n    left = [1] * N\n    right = [1] * (N)\n    for i in range(1, N):\n        for j in range(i):\n            if (arr[j] < arr[i]):\n                left[i] = max(left[i], left[j] + 1)\n    for i in range(N - 2, -1, -1):\n        for j in range(N - 1, i, -1):\n            if (arr[i] > arr[j]):\n                right[i] = max(right[i], right[j] + 1)\n    maxLen = 0\n    for i in range(1, N - 1):\n        maxLen = max(maxLen, left[i] + right[i] - 1)\n    print((N - maxLen))\n\n\ndef makeBitonic(arr, N):\n    if (N == 1):\n        print(\"0\")\n        return\n    if (N == 2):\n        if (arr[0] != arr[1]):\n            print(\"0\")\n        else:\n            print(\"1\")\n        return\n    min_element_removal(arr, N)\n","test":"\nif __name__ == '__main__':\n    arr = [2, 1, 1, 5, 6, 2, 3, 1]\n    N = len(arr)\n    makeBitonic(arr, N)\n","output":"3\n","fn_call":"makeBitonic"}
{"text":"count subarrays having an equal count of 0 s and 1 s segregated | function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together ; stores the count of subarrays ; if current element is different from the next array element ; increment count ; count the frequency of 1 s and 0 s ; increment count ; print the final count ; ","context":"","code":"def countSubarrays(A, N):\n    ans = 0\n    for i in range(N - 1):\n        if (A[i] != A[i + 1]):\n            ans += 1\n            j = i - 1\n            k = i + 2\n            while (j >= 0 and k < N and A[j] == A[i] and A[k] == A[i + 1]):\n                ans += 1\n                j -= 1\n                k += 1\n    print(ans)\n","test":"\nif __name__ == \"__main__\":\n    A = [1, 1, 0, 0, 1, 0]\n    N = len(A)\n    countSubarrays(A, N)\n","output":"4\n","fn_call":"countSubarrays"}
{"text":"count quadruples of given type from given array | python3 program of the above approach ; lcount [ i ] [ j ] : stores the count of i on left of index j ; rcount [ i ] [ j ] : stores the count of i on right of index j ; function to count unique elements on left and right of any index ; find the maximum array element ; calculate prefix sum of counts of each value ; calculate suffix sum of counts of each value ; function to count quadruples of the required type ; ","context":"\nmaxN = 2002\nlcount = [[0 for i in range(maxN)]for j in range(maxN)]\nrcount = [[0 for i in range(maxN)]for j in range(maxN)]\n\n","code":"def fill_counts(a, n):\n    maxA = a[0]\n    for i in range(n):\n        if (a[i] > maxA):\n            maxA = a[i]\n    for i in range(n):\n        lcount[a[i]][i] = 1\n        rcount[a[i]][i] = 1\n    for i in range(maxA + 1):\n        for j in range(n):\n            lcount[i][j] = (lcount[i][j - 1] + lcount[i][j])\n        for j in range(n - 2, -1, -1):\n            rcount[i][j] = (rcount[i][j + 1] + rcount[i][j])\n\n\ndef countSubsequence(a, n):\n    fill_counts(a, n)\n    answer = 0\n    for i in range(1, n):\n        for j in range(i + 1, n - 1):\n            answer += (lcount[a[j]][i - 1] * rcount[a[i]][j + 1])\n    return answer\n","test":"\na = [1, 2, 3, 2, 1, 3, 2]\nprint(countSubsequence(a, 7))\n","output":"5\n","fn_call":"countSubsequence"}
{"text":"reduce string by removing outermost parenthesis from each primitive substring | function to remove the outermost parentheses of every primitive substring from the given string ; stores the resultant string ; stores the count of opened parentheses ; traverse the string ; if opening parenthesis is encountered and their count exceeds 0 ; include the character ; if closing parenthesis is encountered and their count is less than count of opening parentheses ; include the character ; return the resultant string ; ","context":"","code":"def removeOuterParentheses(S):\n    res = \"\"\n    count = 0\n    for c in S:\n        if (c == '(' and count > 0):\n            res += c\n        if (c == '('):\n            count += 1\n        if (c == ')' and count > 1):\n            res += c\n        if (c == ')'):\n            count -= 1\n    return res\n","test":"\nif __name__ == '__main__':\n    S = \"(()())(())()\"\n    print(removeOuterParentheses(S))\n","output":"()()()\n","fn_call":"removeOuterParentheses"}
{"text":"length of longest subarray with increasing contiguous elements | function to find the longest subarray with increasing contiguous elements ; stores the length of required longest subarray ; stores the length of length of longest such subarray from ith index ; if consecutive elements are increasing and differ by 1 ; otherwise ; update the longest subarray obtained so far ; return the length obtained ; ","context":"","code":"def maxiConsecutiveSubarray(arr, N):\n    maxi = 0\n    for i in range(N - 1):\n        cnt = 1\n        for j in range(i, N - 1):\n            if (arr[j + 1] == arr[j] + 1):\n                cnt += 1\n            else:\n                break\n        maxi = max(maxi, cnt)\n        i = j\n    return maxi\n","test":"\nif __name__ == '__main__':\n    N = 11\n    arr = [1, 3, 4, 2, 3, 4, 2, 3, 5, 6, 7]\n    print(maxiConsecutiveSubarray(arr, N))\n","output":"3\n","fn_call":"maxiConsecutiveSubarray"}
{"text":"length of longest subsequence having sum of digits of each element as a composite number | python3 implementation of the above approach ; function to generate prime numbers using sieve of eratosthenes ; set 0 and 1 as non - prime ; if p is a prime ; set all multiples of p as non - prime ; function to find the digit sum of a given number ; stores the sum of digits ; extract digits and add to the sum ; return the sum of the digits ; function to find the longest subsequence with sum of digits of each element equal to a composite number ; calculate sum of digits of current array element ; if sum of digits equal to 1 ; if sum of digits is a prime ; ","context":"\nN = 100005\n\n","code":"def SieveOfEratosthenes(prime, p_size):\n    prime[0] = False\n    prime[1] = False\n    p = 2\n    while p * p <= p_size:\n        if (prime[p]):\n            for i in range(p * 2, p_size + 1, p):\n                prime[i] = False\n        p += 1\n\n\ndef digitSum(number):\n    sum = 0\n    while (number > 0):\n        sum += (number % 10)\n        number \/\/= 10\n    return sum\n\n\ndef longestCompositeDigitSumSubsequence(arr, n):\n    count = 0\n    prime = [True] * (N + 1)\n    SieveOfEratosthenes(prime, N)\n    for i in range(n):\n        res = digitSum(arr[i])\n        if (res == 1):\n            continue\n        if (not prime[res]):\n            count += 1\n    print(count)\n","test":"\nif __name__ == \"__main__\":\n    arr = [13, 55, 7, 3, 5, 1, 10, 21, 233, 144, 89]\n    n = len(arr)\n    longestCompositeDigitSumSubsequence(arr, n)\n","output":"4\n","fn_call":"longestCompositeDigitSumSubsequence"}
{"text":"sum of specially balanced nodes from a given binary tree | structure of binary tree ; function to create a new node ; return the created node ; function to insert a node in the tree ; left insertion ; right insertion ; return the root node ; function to find sum of specially balanced nodes in the tree ; base case ; find the left subtree sum ; find the right subtree sum ; condition of specially balanced node ; condition of specially balanced node ; return the sum ; function to build the binary tree ; form root node of the tree ; insert nodes into tree ; create a new node ; insert the node ; return the root of the tree ; function to find the sum of specially balanced nodes ; build tree ; stores the sum of specially balanced node ; function call ; print required sum ; ","context":"\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n","code":"def newnode(data):\n    temp = Node(data)\n    return temp\n\n\ndef insert(s, i, N, root, temp):\n    if (i == N):\n        return temp\n    if (s[i] == 'L'):\n        root .left = insert(s, i + 1, N, root .left, temp)\n    else:\n        root .right = insert(s, i + 1, N, root .right, temp)\n    return root\n\n\ndef SBTUtil(root, sum):\n    if (root is None):\n        return [0, sum]\n    if (root .left is None and root .right is None):\n        return [root .data, sum]\n    left, sum = SBTUtil(root .left, sum)\n    right, sum = SBTUtil(root .right, sum)\n    if (root .left and root .right):\n        if ((left %\n             2 == 0 and right %\n             2 != 0) or (left %\n                         2 != 0 and right %\n                         2 == 0)):\n            sum += root .data\n    return [left + right + root .data, sum]\n\n\ndef build_tree(R, N, str, values):\n    root = newnode(R)\n    for i in range(0, N - 1):\n        s = str[i]\n        x = values[i]\n        temp = newnode(x)\n        root = insert(s, 0, len(s), root, temp)\n    return root\n\n\ndef speciallyBalancedNodes(R, N, str, values):\n    root = build_tree(R, N, str, values)\n    sum = 0\n    tmp, sum = SBTUtil(root, sum)\n    print(sum, end=' ')\n","test":"\nif __name__ == \"__main__\":\n    N = 7\n    R = 12\n    str = [\"L\", \"R\", \"RL\", \"RR\", \"RLL\", \"RLR\"]\n    values = [17, 16, 4, 9, 2, 3]\n    speciallyBalancedNodes(R, N, str, values)\n","output":"16 ","fn_call":"speciallyBalancedNodes"}
{"text":"pair having all other given pairs lying between its minimum and maximum | function to find the position of the pair that covers every pair in the array arr ; stores the index of the resultant pair ; to count the occurences ; iterate to check every pair ; set count to 0 ; condition to checked for overlapping of pairs ; if that pair can cover all other pairs then store its position ; if position not found ; otherwise ; ","context":"","code":"def position(arr, N):\n    pos = -1\n    count = 0\n    for i in range(N):\n        count = 0\n        for j in range(N):\n            if (arr[i][0] <= arr[j][0] and arr[i][1] >= arr[j][1]):\n                count += 1\n        if (count == N):\n            pos = i\n    if (pos == -1):\n        print(pos)\n    else:\n        print(pos + 1)\n","test":"\nif __name__ == '__main__':\n    arr = [[3, 3], [1, 3], [2, 2], [2, 3], [1, 2]]\n    N = len(arr)\n    position(arr, N)\n","output":"2\n","fn_call":"position"}
{"text":"pair having all other given pairs lying between its minimum and maximum | python3 program for the above approach ; function to find the position of the pair that covers every pair in the array arr [ ] [ ] ; position to store the index ; stores the minimum second value ; stores the maximum first value ; iterate over the array of pairs ; update right maximum ; update left minimum ; iterate over the array of pairs ; if any pair exists with value { left , right then store it ; print the answer ; ","context":"\nimport sys\n\n","code":"def position(arr, N):\n    pos = -1\n    right = -sys .maxsize - 1\n    left = sys .maxsize\n    for i in range(N):\n        if (arr[i][1] > right):\n            right = arr[i][1]\n        if (arr[i][0] < left):\n            left = arr[i][0]\n    for i in range(N):\n        if (arr[i][0] == left and arr[i][1] == right):\n            pos = i + 1\n    print(pos)\n","test":"\nif __name__ == '__main__':\n    arr = [[3, 3], [1, 3], [2, 2], [2, 3], [1, 2]]\n    N = len(arr)\n    position(arr, N)\n","output":"2\n","fn_call":"position"}
{"text":"minimize count of given operations required to make two given strings permutations of each other | function to minimize the count of operations to make str1 and str2 permutations of each other ; store the frequency of each character of str1 ; store the frequency of each character of str2 ; traverse the freq1 [ ] and freq2 [ ] ; if frequency of character in str1 is greater than str2 ; otherwise ; store sum of freq1 [ ] ; store sum of freq2 [ ] ; ","context":"","code":"def ctMinEdits(str1, str2):\n    N1 = len(str1)\n    N2 = len(str2)\n    freq1 = [0] * 256\n    for i in range(N1):\n        freq1[ord(str1[i])] += 1\n    freq2 = [0] * 256\n    for i in range(N2):\n        freq2[ord(str2[i])] += 1\n    for i in range(256):\n        if (freq1[i] > freq2[i]):\n            freq1[i] = freq1[i] - freq2[i]\n            freq2[i] = 0\n        else:\n            freq2[i] = freq2[i] - freq1[i]\n            freq1[i] = 0\n    sum1 = 0\n    sum2 = 0\n    for i in range(256):\n        sum1 += freq1[i]\n        sum2 += freq2[i]\n    return max(sum1, sum2)\n","test":"\nstr1 = \"geeksforgeeks\"\nstr2 = \"geeksforcoder\"\nprint(ctMinEdits(str1, str2))\n","output":"4\n","fn_call":"ctMinEdits"}
{"text":"count pairs ( i , j ) from arrays arr [ ] & brr [ ] such that arr [ i ] | function to count the pairs such that given condition is satisfied ; stores the sum of element at each corresponding index ; find the sum of each index of both array ; stores frequency of each element present in sumarr ; initialize number of pairs ; add possible vaid pairs ; return number of pairs ; given array arr [ ] and brr [ ] ; size of ","context":"","code":"def CountPairs(a, b, n):\n    C = [0] * n\n    for i in range(n):\n        C[i] = a[i] + b[i]\n    freqCount = dict()\n    for i in range(n):\n        if C[i] in freqCount .keys():\n            freqCount[C[i]] += 1\n        else:\n            freqCount[C[i]] = 1\n    NoOfPairs = 0\n    for x in freqCount:\n        y = freqCount[x]\n        NoOfPairs = (NoOfPairs + y * (y - 1) \/\/ 2)\n    print(NoOfPairs)\n","test":"\narr = [1, 4, 20, 3, 10, 5]\nbrr = [9, 6, 1, 7, 11, 6]\nN = len(arr)\nCountPairs(arr, brr, N)\n","output":"4\n","fn_call":"CountPairs"}
{"text":"change in median of given array after deleting given elements | function to find the median change after removing elements from arr2 [ ] ; to store the median ; if n is odd ; if n is even ; find the current element in arr1 ; erase the element ; decrement n ; if n is odd ; if n is even ; print the corresponding difference of median ; ","context":"","code":"def medianChange(arr1, arr2):\n    N = len(arr1)\n    median = []\n    if (N & 1):\n        median .append(arr1[N \/\/ 2] * 1)\n    else:\n        median .append((arr1[N \/\/ 2] + arr1[(N - 1) \/\/ 2]) \/\/ 2)\n    for x in arr2:\n        it = arr1 .index(x)\n        arr1 .pop(it)\n        N -= 1\n        if (N & 1):\n            median .append(arr1[N \/\/ 2] * 1)\n        else:\n            median .append((arr1[N \/\/ 2] + arr1[(N - 1) \/\/ 2]) \/\/ 2)\n    for i in range(len(median) - 1):\n        print(median[i + 1] - median[i], end=' ')\n","test":"\nif __name__ == \"__main__\":\n    arr1 = [2, 4, 6, 8, 10]\n    arr2 = [4, 6]\n    medianChange(arr1, arr2)\n","output":"1 1 ","fn_call":"medianChange"}
{"text":"count positions such that all elements before it are greater | function to count positions such that all elements before it are greater ; count is initially 1 for the first element ; initial minimum ; traverse the array ; if current element is new minimum ; update minimum ; increment count ; ","context":"","code":"def getPositionCount(a, n):\n    count = 1\n    min = a[0]\n    for i in range(1, n):\n        if (a[i] <= min):\n            min = a[i]\n            count += 1\n    return count\n","test":"\nif __name__ == \"__main__\":\n    a = [5, 4, 6, 1, 3, 1]\n    n = len(a)\n    print(getPositionCount(a, n))\n","output":"4\n","fn_call":"getPositionCount"}
{"text":"maximum length l such that the sum of all subarrays of length l is less than k | function to return the maximum sum in a subarray of size k ; k must be greater ; compute sum of first window of size k ; compute sums of remaining windows by removing first element of previous window and adding last element of current window . ; function to return the length of subarray sum of all the subarray of this length is less than or equal to k ; binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing ; check if the subarray sum is greater than k or not ; update the maximum length ; ","context":"","code":"def maxSum(arr, n, k):\n    if (n < k):\n        return -1\n    res = 0\n    for i in range(k):\n        res += arr[i]\n    curr_sum = res\n    for i in range(k, n):\n        curr_sum += arr[i] - arr[i - k]\n        res = max(res, curr_sum)\n    return res\n\n\ndef solve(arr, n, k):\n    max_len = 0\n    l = 0\n    r = n\n    while (l <= r):\n        m = (l + r) \/\/ 2\n        if (maxSum(arr, n, m) > k):\n            r = m - 1\n        else:\n            l = m + 1\n            max_len = m\n    return max_len\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    n = len(arr)\n    k = 10\n    print(solve(arr, n, k))\n","output":"2\n","fn_call":"solve"}
{"text":"count of triplets in an array that satisfy the given conditions | python3 implementation of the approach ; all possible solutions of the equation 1 \/ a + 1 \/ b + 1 \/ c = 1 ; function to find the triplets ; storing indices of the elements ; check if y can act as the middle element of triplet with the given solution of 1 \/ a + 1 \/ b + 1 \/ c = 1 ; binary search to find the number of possible values of the first element ; binary search to find the number of possible values of the third element ; contribution to the answer would be the multiplication of the possible values for the first and the third element ; ","context":"\nMAX = 100001\nROW = 10\nCOL = 3\nindices = [0] * MAX\ntest = [\n    [\n        2, 3, 6], [\n            2, 4, 4], [\n                2, 6, 3], [\n                    3, 2, 6], [\n                        3, 3, 3], [\n                            3, 6, 2], [\n                                4, 2, 4], [\n                                    4, 4, 2], [\n                                        6, 2, 3], [\n                                            6, 3, 2]]\n\n","code":"def find_triplet(array, n):\n    answer = 0\n    for i in range(MAX):\n        indices[i] = []\n    for i in range(n):\n        indices[array[i]].append(i)\n    for i in range(n):\n        y = array[i]\n        for j in range(ROW):\n            s = test[j][1] * y\n            if s % test[j][0] != 0:\n                continue\n            if s % test[j][2] != 0:\n                continue\n            x = s \/\/ test[j][0]\n            z = s \/\/ test[j][2]\n            if x > MAX or z > MAX:\n                continue\n            l = 0\n            r = len(indices[x]) - 1\n            first = -1\n            while l <= r:\n                m = (l + r) \/\/ 2\n                if indices[x][m] < i:\n                    first = m\n                    l = m + 1\n                else:\n                    r = m - 1\n            l = 0\n            r = len(indices[z]) - 1\n            third = -1\n            while l <= r:\n                m = (l + r) \/\/ 2\n                if indices[z][m] > i:\n                    third = m\n                    r = m - 1\n                else:\n                    l = m + 1\n            if first != -1 and third != -1:\n                answer += (first + 1) * (len(indices[z]) - third)\n    return answer\n","test":"\nif __name__ == \"__main__\":\n    array = [2, 4, 5, 6, 7]\n    n = len(array)\n    print(find_triplet(array, n))\n","output":"1\n","fn_call":"find_triplet"}
{"text":"distinct adjacent elements in a binary array | python3 implementation of the above approach ; if array has only one element , return 1 ; for first element compare with only next element ; for remaining elements compare with both prev and next elements ; for last element compare with only prev element ; ","context":"","code":"def distinct(arr):\n    count = 0\n    if len(arr) == 1:\n        return 1\n    for i in range(0, len(arr) - 1):\n        if (i == 0):\n            if (arr[i] != arr[i + 1]):\n                count += 1\n        elif (i > 0 & i < len(arr) - 1):\n            if (arr[i] != arr[i + 1] or arr[i] != arr[i - 1]):\n                count += 1\n    if (arr[len(arr) - 1] != arr[len(arr) - 2]):\n        count += 1\n    return count\n","test":"\narr = [0, 0, 0, 0, 0, 1, 0]\nprint(distinct(arr))\n","output":"3\n","fn_call":"distinct"}
{"text":"check if an array of pairs can be sorted by swapping pairs with different first elements | function to check if an array is sorted or not ; traverse the array arr [ ] ; return true ; function to check if it is possible to sort the array w . r . t . first element ; stores the id of the first element ; traverse the array arr [ ] ; if arr [ i ] [ 1 ] is not equal to that of the group ; if array is sorted ; ","context":"","code":"def isSorted(arr, N):\n    for i in range(1, N):\n        if (arr[i][0] > arr[i - 1][0]):\n            return False\n    return True\n\n\ndef isPossibleToSort(arr, N):\n    group = arr[0][1]\n    for i in range(1, N):\n        if (arr[i][1] != group):\n            return \"Yes\"\n    if (isSorted(arr, N)):\n        return \"Yes\"\n    else:\n        return \"No\"\n","test":"\nif __name__ == '__main__':\n    arr = [[340000, 2], [45000, 1], [30000, 2], [50000, 4]]\n    N = len(arr)\n    print(isPossibleToSort(arr, N))\n","output":"Yes\n","fn_call":"isPossibleToSort"}
{"text":"check if n rectangles of equal area can be formed from ( 4 * n ) integers | function to check whether we can make n rectangles of equal area ; sort the array ; find the area of any one rectangle ; check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same ; update the answer to false if any condition fails ; if possible ; ","context":"","code":"def checkRectangles(arr, n):\n    ans = True\n    arr .sort()\n    area = arr[0] * arr[4 * n - 1]\n    for i in range(0, 2 * n, 2):\n        if (arr[i] != arr[i + 1] or arr[4 * n - i - 1] !=\n                arr[4 * n - i - 2] or arr[i] * arr[4 * n - i - 1] != area):\n            ans = False\n            break\n    if (ans):\n        return True\n    return False\n","test":"\narr = [1, 8, 2, 1, 2, 4, 4, 8]\nn = 2\nif (checkRectangles(arr, n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n","output":"Yes\n","fn_call":"checkRectangles"}
{"text":"count of elements which are not at the correct position | function to return the count of elements which are not in the correct position when sorted ; to store a copy of the original array ; copy the elements of the given array to the new array ; to store the required count ; sort the original array ; if current element was not at the right position ; ","context":"","code":"def cntElements(arr, n):\n    copy_arr = [0] * n\n    for i in range(n):\n        copy_arr[i] = arr[i]\n    count = 0\n    arr .sort()\n    for i in range(n):\n        if (arr[i] != copy_arr[i]):\n            count += 1\n    return count\n","test":"\narr = [1, 2, 6, 2, 4, 5]\nn = len(arr)\nprint(cntElements(arr, n))\n","output":"4\n","fn_call":"cntElements"}
{"text":"find k ordered pairs in array with minimum difference d | function to find the required pairs ; there has to be atleast 2 * k elements ; to store the pairs ; sort the given array ; for every possible pair ; if the current pair is valid ; insert it into the pair vector ; if k pairs are not possible ; print the pairs ; ","context":"","code":"def findPairs(arr, n, k, d):\n    if (n < 2 * k):\n        print(\"-1\")\n        return\n    pairs = []\n    arr = sorted(arr)\n    for i in range(k):\n        if (arr[n - k + i] - arr[i] >= d):\n            pairs .append([arr[i], arr[n - k + i]])\n    if (len(pairs) < k):\n        print(\"-1\")\n        return\n    for v in pairs:\n        print(\"(\", v[0], \", \", v[1], \")\")\n","test":"\narr = [4, 6, 10, 23, 14, 7, 2, 20, 9]\nn = len(arr)\nk = 4\nd = 3\nfindPairs(arr, n, k, d)\n","output":"( 2 ,  10 )\n( 4 ,  14 )\n( 6 ,  20 )\n( 7 ,  23 )\n","fn_call":"findPairs"}
{"text":"count pairs with given sum | set 2 | function to return the count of pairs from arr with the given sum ; to store the count of pairs ; sort the given array ; take two pointers ; if sum is greater ; if sum is lesser ; if sum is equal ; find the frequency of arr [ i ] ; find the frequency of arr [ j ] ; if arr [ i ] and arr [ j ] are same then remove the extra number counted ; return the required answer ; ","context":"","code":"def pairs_count(arr, n, sum):\n    ans = 0\n    arr = sorted(arr)\n    i, j = 0, n - 1\n    while (i < j):\n        if (arr[i] + arr[j] < sum):\n            i += 1\n        elif (arr[i] + arr[j] > sum):\n            j -= 1\n        else:\n            x = arr[i]\n            xx = i\n            while (i < j and arr[i] == x):\n                i += 1\n            y = arr[j]\n            yy = j\n            while (j >= i and arr[j] == y):\n                j -= 1\n            if (x == y):\n                temp = i - xx + yy - j - 1\n                ans += (temp * (temp + 1)) \/\/ 2\n            else:\n                ans += (i - xx) * (yy - j)\n    return ans\n","test":"\narr = [1, 5, 7, 5, -1]\nn = len(arr)\nsum = 6\nprint(pairs_count(arr, n, sum))\n","output":"3\n","fn_call":"pairs_count"}
{"text":"check if the string contains consecutive letters and each letter occurs exactly once | python3 program to implement the above approach ; for all the characters of the string ; find the ascii value of the character ; check if if its a valid character , if not then return false ; calculate sum of all the characters ascii values ; find minimum ascii value from the string ; find maximum ascii value from the string ; to get the previous element of the minimum ascii value ; take the expected sum from the above equation ; check if the expected sum is equals to the calculated sum or not ; ","context":"\nimport sys\n\n","code":"def check(str):\n    min = sys .maxsize\n    max = -sys .maxsize - 1\n    sum = 0\n    for i in range(len(str)):\n        ascii = str[i]\n        if (ord(ascii) < 96 or ord(ascii) > 122):\n            return False\n        sum += ord(ascii)\n        if (min > ord(ascii)):\n            min = ord(ascii)\n        if (max < ord(ascii)):\n            max = ord(ascii)\n    min -= 1\n    eSum = (((max * (max + 1)) \/\/ 2) - ((min * (min + 1)) \/\/ 2))\n    return sum == eSum\n","test":"\nif __name__ == '__main__':\n    str = \"dcef\"\n    if (check(str)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    str1 = \"xyza\"\n    if (check(str1)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\nNo\n","fn_call":"check"}
{"text":"k | function to find the sum of minimum of all subarrays ; insert all the elements in a set ; find the maximum and minimum element ; traverse from the minimum to maximum element ; check if \" i \" is missing ; check if it is kth missing ; if no kth element is missing ; ","context":"","code":"def findKth(arr, n, k):\n    missing = dict()\n    count = 0\n    for i in range(n):\n        missing[arr[i]] = 1\n    maxm = max(arr)\n    minm = min(arr)\n    for i in range(minm + 1, maxm):\n        if (i not in missing .keys()):\n            count += 1\n        if (count == k):\n            return i\n    return -1\n","test":"\narr = [2, 10, 9, 4]\nn = len(arr)\nk = 5\nprint(findKth(arr, n, k))\n","output":"8\n","fn_call":"findKth"}
{"text":"rearrange an array to minimize sum of product of consecutive pair elements | python 3 program to sort an array such that sum of product of alternate element is minimum . ; create evenarr [ ] and oddarr [ ] ; sort main array in ascending order ; put elements in oddarr [ ] and evenarr [ ] as per desired value . ; sort evenarr [ ] in descending order ; merge both sub - array and calculate minimum sum of product of alternate elements ; ","context":"","code":"def minSum(arr, n):\n    evenArr = []\n    oddArr = []\n    arr .sort()\n    for i in range(n):\n        if (i < n \/\/ 2):\n            oddArr .append(arr[i])\n        else:\n            evenArr .append(arr[i])\n    evenArr .sort(reverse=True)\n    i = 0\n    sum = 0\n    for j in range(len(evenArr)):\n        arr[i] = evenArr[j]\n        i += 1\n        arr[i] = oddArr[j]\n        i += 1\n        sum += evenArr[j] * oddArr[j]\n    return sum\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 5, 8, 9, 6, 7, 3, 4, 2, 0]\n    n = len(arr)\n    print(\"Minimum required sum =\", minSum(arr, n))\n    print(\"Sorted array in required format : \", end=\"\")\n    for i in range(n):\n        print(arr[i], end=\" \")\n","output":"Minimum required sum = 60\nSorted array in required format : 9 0 8 1 7 2 6 3 5 4 ","fn_call":"minSum"}
{"text":"minimum time required to print given string from a circular container based on given conditions | function to calculate minimum time to print all characters in the string ; current element where the pointer is pointing ; find index of that element ; calculate absolute difference between pointer index and character index as clockwise distance ; subtract clockwise time from 26 to get anti - clockwise time ; add minimum of both times to the answer ; add one unit time to print the character ; print the final answer ; ","context":"","code":"def minTime(word):\n    ans = 0\n    curr = 0\n    for i in range(len(word)):\n        k = ord(word[i]) - 97\n        a = abs(curr - k)\n        b = 26 - abs(curr - k)\n        ans += min(a, b)\n        ans += 1\n        curr = ord(word[i]) - 97\n    print(ans)\n","test":"\nif __name__ == '__main__':\n    str = \"zjpc\"\n    minTime(str)\n","output":"34\n","fn_call":"minTime"}
{"text":"minimum decrements or division by a proper divisor required to reduce n to 1 | function to find the minimum number of steps required to reduce n to 1 ; stores the number of steps required ; if the value of n is equal to 2 or n is odd ; decrement n by 1 ; increment cnt by 1 ; if n is even ; update n ; increment cnt by 1 ; return the number of steps obtained ; ","context":"","code":"def reduceToOne(N):\n    cnt = 0\n    while (N != 1):\n        if (N == 2 or (N % 2 == 1)):\n            N = N - 1\n            cnt += 1\n        elif (N % 2 == 0):\n            N = N \/ (N \/ 2)\n            cnt += 1\n    return cnt\n","test":"\nif __name__ == '__main__':\n    N = 35\n    print(reduceToOne(N))\n","output":"3\n","fn_call":"reduceToOne"}
{"text":"maximum number of diamonds that can be gained in k minutes | function to find the maximum number of diamonds that can be gained in exactly k minutes ; stores all the array elements ; push all the elements to the priority queue ; stores the required result ; loop while the queue is not empty and k is positive ; store the top element from the pq ; pop it from the pq ; add it to the answer ; divide it by 2 and push it back to the pq ; print the answer ; ","context":"","code":"def maxDiamonds(A, N, K):\n    pq = []\n    for i in range(N):\n        pq .append(A[i])\n    pq .sort()\n    ans = 0\n    while (len(pq) > 0 and K > 0):\n        pq .sort()\n        top = pq[len(pq) - 1]\n        pq = pq[0:len(pq) - 1]\n        ans += top\n        top = top \/\/ 2\n        pq .append(top)\n        K -= 1\n    print(ans)\n","test":"\nif __name__ == '__main__':\n    A = [2, 1, 7, 4, 2]\n    K = 3\n    N = len(A)\n    maxDiamonds(A, N, K)\n","output":"14\n","fn_call":"maxDiamonds"}
{"text":"minimize cost of increments or decrements such that same indexed elements become multiple of each other | function to find the minimum cost to make a [ i ] multiple of b [ i ] or vice - versa for every array element ; stores the minimum cost ; traverse the array ; case 1 : update a [ i ] ; case 2 : update b [ i ] ; add the minimum of the above two cases ; return the resultant cost ; ","context":"","code":"def MinimumCost(A, B, N):\n    totalCost = 0\n    for i in range(N):\n        mod_A = B[i] % A[i]\n        totalCost_A = min(mod_A, A[i] - mod_A)\n        mod_B = A[i] % B[i]\n        totalCost_B = min(mod_B, B[i] - mod_B)\n        totalCost += min(totalCost_A, totalCost_B)\n    return totalCost\n","test":"\nA = [3, 6, 3]\nB = [4, 8, 13]\nN = len(A)\nprint(MinimumCost(A, B, N))\n","output":"4\n","fn_call":"MinimumCost"}
{"text":"largest number divisible by 50 that can be formed from a given set of n digits consisting of 0 s and 7 s only | print the largest number divisible by 50 ; counting number of 0 s and 7 s ; if count of 7 is divisible by 50 ; if count of 7 is less than 5 ; if count of 7 is not divisible by 50 ; count of groups of 5 in which count of 7 s can be grouped ; ","context":"","code":"def printLargestDivisible(arr, N):\n    count0 = 0\n    count7 = 0\n    for i in range(N):\n        if (arr[i] == 0):\n            count0 += 1\n        else:\n            count7 += 1\n    if (count7 % 50 == 0):\n        while (count7):\n            count7 -= 1\n            print(7, end=\"\")\n        while (count0):\n            count0 -= 1\n            print(count0, end=\"\")\n    elif (count7 < 5):\n        if (count0 == 0):\n            print(\"No\", end=\"\")\n        else:\n            print(\"0\", end=\"\")\n    else:\n        count7 = count7 - count7 % 5\n        while (count7):\n            count7 -= 1\n            print(7, end=\"\")\n        while (count0):\n            count0 -= 1\n            print(0, end=\"\")\n","test":"\nif __name__ == \"__main__\":\n    arr = [0, 7, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 7, 7, 7]\n    N = len(arr)\n    printLargestDivisible(arr, N)\n","output":"7777700000000","fn_call":"printLargestDivisible"}
{"text":"rearrange array to maximize sum of gcd of array elements with their respective indices | function to find the maximum sum of gcd ( arr [ i ] , i ) by rearranging the array ; sort the array in ascending order ; stores maximum sum of gcd ( arr [ i ] , i ) by rearranging the array elements ; generate all possible permutations of the array ; stores sum of gcd ( arr [ i ] , i ) ; traverse the array ; update sum ; update res ; ","context":"","code":"def __gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return __gcd(b, a % b)\n\n\ndef next_permutation(p):\n    for a in range(len(p) - 2, -1, -1):\n        if (p[a] < p[a + 1]):\n            b = len(p) - 1\n            while True:\n                if (p[b] > p[a]):\n                    t = p[a]\n                    p[a] = p[b]\n                    p[b] = t\n                    a += 1\n                    b = len(p) - 1\n                    while a < b:\n                        t = p[a]\n                        p[a] = p[b]\n                        p[b] = t\n                        a += 1\n                        b -= 1\n                    return True\n                b -= 1\n    return False\n\ndef findMaxValByRearrArr(arr, N):\n    arr .sort()\n    res = 0\n    while (True):\n        Sum = 0\n        for i in range(N):\n            Sum += __gcd(i + 1, arr[i])\n        res = max(res, Sum)\n        if (not next_permutation(arr)):\n            break\n    return res\n","test":"\narr = [3, 2, 1]\nN = len(arr)\nprint(findMaxValByRearrArr(arr, N))\n","output":"6\n","fn_call":"findMaxValByRearrArr"}
{"text":"minimum removals required to make frequency of each array element equal to its value | function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ] ; stores frequency of each element of the array ; traverse the array ; update frequency of arr [ i ] ; stores minimum count of removals ; traverse the map ; stores key value of the map ; if frequency of i is less than i ; update cntminrem ; if frequency of i is greater than i ; update cntminrem ; ","context":"","code":"def min_elements(arr, N):\n    mp = {}\n    for i in range(N):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n    cntMinRem = 0\n    for it in mp:\n        i = it\n        if (mp[i] < i):\n            cntMinRem += mp[i]\n        elif (mp[i] > i):\n            cntMinRem += (mp[i] - i)\n    return cntMinRem\n","test":"\nif __name__ == \"__main__\":\n    arr = [2, 4, 1, 4, 2]\n    N = len(arr)\n    print(min_elements(arr, N))\n","output":"2\n","fn_call":"min_elements"}
{"text":"minimum increments to make all array elements equal with sum same as the given array after exactly one removal | function to check if an array of equal elements with sum equal to the given array can be obtained or not ; base case ; stores sum of array elements ; stores second largest array element ; stores the largest array element ; traverse the array ; update secmax ; update max ; update secmax ; update totalsum ; if totalsum is less than secmax * ( n - 1 ) ) ; if totalsum is not divisible by ( n - 1 ) ; ","context":"","code":"def CheckAllarrayEqual(arr, N):\n    if (N == 1):\n        return True\n    totalSum = arr[0]\n    secMax = -10 ** 19\n    Max = arr[0]\n    for i in range(1, N):\n        if (arr[i] >= Max):\n            secMax = Max\n            Max = arr[i]\n        elif (arr[i] > secMax):\n            secMax = arr[i]\n        totalSum += arr[i]\n    if ((secMax * (N - 1)) > totalSum):\n        return False\n    if (totalSum % (N - 1)):\n        return False\n    return True\n","test":"\nif __name__ == '__main__':\n    arr = [6, 2, 2, 2]\n    N = len(arr)\n    if (CheckAllarrayEqual(arr, N)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"CheckAllarrayEqual"}
{"text":"count ways to make bitwise xor of odd and even indexed elements equal by removing an array element | function to count ways to make bitwise xor of odd and even indexed elements equal by removing an array element ; stores xor of odd and even indexed elements from the end ; stores xor of odd and even indexed elements from the start ; stores the required count ; traverse the array in reverse ; if i is odd ; if i is even ; traverse the array ; if i is odd ; if i is even ; removing arr [ i ] , post_even stores xor of odd indexed elements ; removing arr [ i ] , post_odd stores xor of even indexed elements ; check if they are equal ; if i is odd , xor it with curr_odd ; if i is even , xor it with curr_even ; finally print res ; ","context":"","code":"def Remove_one_element(arr, n):\n    post_odd = 0\n    post_even = 0\n    curr_odd = 0\n    curr_even = 0\n    res = 0\n    for i in range(n - 1, -1, -1):\n        if (i % 2):\n            post_odd ^= arr[i]\n        else:\n            post_even ^= arr[i]\n    for i in range(n):\n        if (i % 2):\n            post_odd ^= arr[i]\n        else:\n            post_even ^= arr[i]\n        X = curr_odd ^ post_even\n        Y = curr_even ^ post_odd\n        if (X == Y):\n            res += 1\n        if (i % 2):\n            curr_odd ^= arr[i]\n        else:\n            curr_even ^= arr[i]\n    print(res)\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 0, 1, 0, 1]\n    N = len(arr)\n    Remove_one_element(arr, N)\n","output":"3\n","fn_call":"Remove_one_element"}
{"text":"count ways to make sum of odd and even indexed elements equal by removing an array element | function to count array indices whose removal makes sum of odd and even indexed elements equal ; if size of the array is 1 ; if size of the array is 2 ; stores sum of even - indexed elements of the given array ; stores sum of odd - indexed elements of the given array ; traverse the array ; if i is an even number ; update sumeven ; if i is an odd number ; update sumodd ; stores sum of even - indexed array elements till i - th index ; stores sum of odd - indexed array elements till i - th index ; stores count of indices whose removal makes sum of odd and even indexed elements equal ; stores sum of even - indexed elements after removing the i - th element ; stores sum of odd - indexed elements after removing the i - th element ; traverse the array ; if i is an odd number ; update currodd ; update newevensum ; update newoddsum ; if i is an even number ; update curreven ; update newoddsum ; update newevensum ; if newevensum is equal to newoddsum ; increase the count ; if sum of even - indexed and odd - indexed elements is equal by removing the first element ; increase the count ; if length of the array is an odd number ; if sum of even - indexed and odd - indexed elements is equal by removing the last element ; increase the count ; if length of the array is an even number ; if sum of even - indexed and odd - indexed elements is equal by removing the last element ; increase the count ; ","context":"","code":"def cntIndexesToMakeBalance(arr, n):\n    if (n == 1):\n        return 1\n    if (n == 2):\n        return 0\n    sumEven = 0\n    sumOdd = 0\n    for i in range(n):\n        if (i % 2 == 0):\n            sumEven += arr[i]\n        else:\n            sumOdd += arr[i]\n    currOdd = 0\n    currEven = arr[0]\n    res = 0\n    newEvenSum = 0\n    newOddSum = 0\n    for i in range(1, n - 1):\n        if (i % 2):\n            currOdd += arr[i]\n            newEvenSum = (currEven + sumOdd - currOdd)\n            newOddSum = (currOdd + sumEven - currEven - arr[i])\n        else:\n            currEven += arr[i]\n            newOddSum = (currOdd + sumEven - currEven)\n            newEvenSum = (currEven + sumOdd - currOdd - arr[i])\n        if (newEvenSum == newOddSum):\n            res += 1\n    if (sumOdd == sumEven - arr[0]):\n        res += 1\n    if (n % 2 == 1):\n        if (sumOdd == sumEven - arr[n - 1]):\n            res += 1\n    else:\n        if (sumEven == sumOdd - arr[n - 1]):\n            res += 1\n    return res\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 1, 1]\n    n = len(arr)\n    print(cntIndexesToMakeBalance(arr, n))\n","output":"3\n","fn_call":"cntIndexesToMakeBalance"}
{"text":"find two numbers from their sum and xor | set 2 | function to find the value of a and b whose sum is x and xor is y ; initialize the two numbers ; case 1 : x < y ; case 2 : x - y is odd ; case 3 : if both sum and xor are equal ; case 4 : if above cases fails ; update the value of a ; check if a & y value is 0 ; if true , update b ; otherwise assign - 1 to a , - 1 to b ; prthe numbers a and b ; ","context":"","code":"def findNums(X, Y):\n    A = 0\n    B = 0\n    if (X < Y):\n        A = -1\n        B = -1\n    elif (((abs(X - Y)) & 1) != 0):\n        A = -1\n        B = -1\n    elif (X == Y):\n        A = 0\n        B = Y\n    else:\n        A = (X - Y) \/\/ 2\n        if ((A & Y) == 0):\n            B = (A + Y)\n        else:\n            A = -1\n            B = -1\n    print(A)\n    print(B)\n","test":"\nif __name__ == '__main__':\n    X = 17\n    Y = 13\n    findNums(X, Y)\n","output":"2\n15\n","fn_call":"findNums"}
{"text":"queries to check if count of increasing and decreasing subarrays is same in given range | function to check if given range have equal number of increasing as well as decreasing subarrays ; traverse each query ; for 0 - based indexing ; condition for same count of increasing & decreasing subarray ; ","context":"","code":"def checkCount(A, Q, q):\n    for i in range(q):\n        L = Q[i][0]\n        R = Q[i][1]\n        L -= 1\n        R -= 1\n        if ((A[L] < A[L + 1]) != (A[R - 1] < A[R])):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n","test":"\nif __name__ == '__main__':\n    arr = [11, 13, 12, 14]\n    Q = [[1, 4], [2, 4]]\n    q = len(Q)\n    checkCount(arr, Q, q)\n","output":"No\nYes\n","fn_call":"checkCount"}
{"text":"mean of array generated by products of all pairs of the given array | function to find the mean of pair product array of arr ; store product of pairs ; generate all unordered pairs ; store product of pairs ; size of pairarray ; store sum of pairarray ; stores the mean of pairarray ; find mean of pairarray ; return the resultant mean ; ","context":"","code":"def pairProductMean(arr, N):\n    pairArray = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairProduct = arr[i] * arr[j]\n            pairArray .append(pairProduct)\n    length = len(pairArray)\n    sum = 0\n    for i in range(length):\n        sum += pairArray[i]\n    mean = 0\n    if (length != 0):\n        mean = sum \/ length\n    else:\n        mean = 0\n    return mean\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 4, 8]\n    N = len(arr)\n    print(\"{0:.2f}\".format(pairProductMean(arr, N)))\n","output":"11.67\n","fn_call":"pairProductMean"}
{"text":"smallest number exceeding n whose kth bit is set | function to find the number greater than n whose kth bit is set ; iterate from n + 1 ; check if kth bit is set or not ; increment m for next number ; return the minimum value ; ","context":"","code":"def find_next(n, k):\n    M = n + 1\n    while (True):\n        if ((M & (1 << k)) > 0):\n            break\n        M += 1\n    return M\n","test":"\nif __name__ == '__main__':\n    N = 15\n    K = 2\n    print(find_next(N, K))\n","output":"20\n","fn_call":"find_next"}
{"text":"smallest number exceeding n whose kth bit is set | function to find the number greater than n whose kth bit is set ; stores the resultant number ; if kth bit is not set ; cur will be the sum of all powers of 2 < k ; if the current bit is set ; add kth power of 2 to n and subtract the all powers of 2 less than k that are set ; if the kth bit is set ; first unset bit position ; sum of bits that are set ; add kth power of 2 to n and subtract the all powers of 2 less than k that are set ; if kth bit became unset then set it again ; return the resultant number ; ","context":"","code":"def find_next(n, k):\n    ans = 0\n    if ((n & (1 << k)) == 0):\n        cur = 0\n        for i in range(k):\n            if (n & (1 << i)):\n                cur += 1 << i\n        ans = n - cur + (1 << k)\n    else:\n        first_unset_bit, cur = -1, 0\n        for i in range(64):\n            if ((n & (1 << i)) == 0):\n                first_unset_bit = i\n                break\n            else:\n                cur += (1 << i)\n        ans = n - cur + (1 << first_unset_bit)\n        if ((ans & (1 << k)) == 0):\n            ans += (1 << k)\n    return ans\n","test":"\nN, K = 15, 2\nprint(find_next(N, K))\n","output":"20\n","fn_call":"find_next"}
{"text":"lexicographically largest possible string after removal of k characters | python3 program to implement the above approach ; final result string ; if the current char exceeds the character at the top of the stack ; remove from the end of the string ; decrease k for the removal ; insert current character ; perform remaining k deletions from the end of the string ; return the string ; ","context":"","code":"def largestString(num, k):\n    ans = []\n    for i in range(len(num)):\n        while (len(ans) and ans[-1] < num[i] and k > 0):\n            ans .pop()\n            k -= 1\n        ans .append(num[i])\n    while (len(ans) and k):\n        k -= 1\n        ans .pop()\n    return ans\n","test":"\nstr = \"zyxedcba\"\nk = 1\nprint(*largestString(str, k), sep=\"\")\n","output":"zyxedcb\n","fn_call":"largestString"}
{"text":"maximum length of subarray consisting of same type of element on both halves of sub | function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array ; to store continuous occurence of the element ; to store continuous forward occurence ; to store continuous backward occurence ; to store the maximum length ; find maximum length ; print the result ; ","context":"","code":"def maxLengthSubArray(A, N):\n    forward = [0] * N\n    backward = [0] * N\n    for i in range(N):\n        if i == 0 or A[i] != A[i - 1]:\n            forward[i] = 1\n        else:\n            forward[i] = forward[i - 1] + 1\n    for i in range(N - 1, -1, -1):\n        if i == N - 1 or A[i] != A[i + 1]:\n            backward[i] = 1\n        else:\n            backward[i] = backward[i + 1] + 1\n    ans = 0\n    for i in range(N - 1):\n        if (A[i] != A[i + 1]):\n            ans = max(ans, min(forward[i], backward[i + 1]) * 2)\n    print(ans)\n","test":"\narr = [1, 2, 3, 4, 4, 4, 6, 6, 6, 9]\nN = len(arr)\nmaxLengthSubArray(arr, N)\n","output":"6\n","fn_call":"maxLengthSubArray"}
{"text":"smallest n digit number divisible by all possible prime digits | python3 implementation of the above approach ; function to find the minimum number of n digits divisible by all prime digits . ; ","context":"\nfrom math import *\n\n","code":"def minNum(n):\n    if n < 3:\n        print(-1)\n    else:\n        print(210 * (10 ** (n - 1) \/\/ 210 + 1))\n","test":"\nn = 5\nminNum(n)\n","output":"10080\n","fn_call":"minNum"}
{"text":"smallest number greater than y with sum of digits equal to x | function to return the minimum string of length d having the sum of digits s ; return a string of length d ; greedily put 9 's  in the end ; put remaining sum ; function to find the smallest number greater than y whose sum of digits is x ; convert number y to string ; maintain prefix sum of digits ; iterate over y from the back where k is current length of suffix ; stores current digit ; increase current digit ; sum upto current prefix ; return answer if remaining sum can be obtained in suffix ; find suffix of length k having sum of digits x - r ; append current character ; return the result ; ","context":"","code":"def helper(d, s):\n    ans = ['0'] * d\n    for i in range(d - 1, -1, -1):\n        if (s >= 9):\n            ans[i] = '9'\n            s -= 9\n        else:\n            c = chr(s + ord('0'))\n            ans[i] = c\n            s = 0\n    return ''.join(ans)\n\n\ndef findMin(x, Y):\n    y = str(Y)\n    n = len(y)\n    p = [0] * n\n    for i in range(n):\n        p[i] = (ord(y[i]) - ord('0'))\n        if (i > 0):\n            p[i] += p[i - 1]\n    n - 1\n    k = 0\n    while True:\n        d = 0\n        if (i >= 0):\n            d = (ord(y[i]) - ord('0'))\n        for j in range(d + 1, 10):\n            r = ((i > 0) * p[i - 1] + j)\n            if (x - r >= 0 and x - r <= 9 * k):\n                suf = helper(k, x - r)\n                pre = \"\"\n                if (i > 0):\n                    pre = y[0:i]\n                cur = chr(j + ord('0'))\n                pre += cur\n                return pre + suf\n        i -= 1\n        k += 1\n","test":"\nif __name__ == \"__main__\":\n    x = 18\n    y = 99\n    print(findMin(x, y))\n","output":"189\n","fn_call":"findMin"}
{"text":"largest number made up of x and y with count of x divisible by y and of y by x | function to generate and return the largest number ; store the smaller in y ; store the larger in x ; stores respective counts ; if n is divisible by y ; append x , n times to the answer ; reduce n to zero ; reduce n by x ; append y , x times to the answer ; if number can be formed ; otherwise ; ","context":"","code":"def largestNumber(n, X, Y):\n    maxm = max(X, Y)\n    Y = X + Y - maxm\n    X = maxm\n    Xs = 0\n    Ys = 0\n    while (n > 0):\n        if (n % Y == 0):\n            Xs += n\n            n = 0\n        else:\n            n -= X\n            Ys += X\n    if (n == 0):\n        while (Xs > 0):\n            Xs -= 1\n            print(X, end='')\n        while (Ys > 0):\n            Ys -= 1\n            print(Y, end='')\n    else:\n        print(\"-1\")\n","test":"\nn = 19\nX = 7\nY = 5\nlargestNumber(n, X, Y)\n","output":"7777755555555555555","fn_call":"largestNumber"}
{"text":"minimum flips required to generate continuous substrings of 0 \u00e2 \u20ac\u2122 s and 1 \u00e2 \u20ac\u2122 s | python3 implementation of the above approach ; traverse input string and store the count of 0 ; traverse the input string again to find minimum number of flips ; ","context":"","code":"def minChanges(str, N):\n    count0 = 0\n    count1 = 0\n    for x in str:\n        count0 += (x == '0')\n    res = count0\n    for x in str:\n        count0 -= (x == '0')\n        count1 += (x == '1')\n        res = min(res, count1 + count0)\n    return res\n","test":"\nN = 9\nstr = \"000101001\"\nprint(minChanges(str, N))\n","output":"2\n","fn_call":"minChanges"}
{"text":"missing occurrences of a number in an array such that maximum absolute difference of adjacent elements is minimum | python3 implementation of the missing number such that maximum absolute difference between adjacent element is minimum ; function to find the missing number such that maximum absolute difference is minimum ; loop to find the maximum and minimum adjacent element to missing number ; ","context":"\nimport sys\n\n","code":"def missingnumber(n, arr) -> int:\n    mn = sys .maxsize\n    mx = -sys .maxsize - 1\n    for i in range(n):\n        if (i > 0 and arr[i] == -1 and arr[i - 1] != -1):\n            mn = min(mn, arr[i - 1])\n            mx = max(mx, arr[i - 1])\n        if (i < (n - 1) and arr[i] == -1 and arr[i + 1] != -1):\n            mn = min(mn, arr[i + 1])\n            mx = max(mx, arr[i + 1])\n    res = (mx + mn) \/ 2\n    return res\n","test":"\nif __name__ == '__main__':\n    n = 5\n    arr = [-1, 10, -1, 12, -1]\n    res = missingnumber(n, arr)\n    print(res)\n","output":"11.0\n","fn_call":"missingnumber"}
{"text":"maximize [ length ( x ) \/ 2 ^ ( xor ( x , y ) ) ] by choosing substrings x and y from string a and b respectively | function to find the length of the longest common substring of the string x and y ; lcsuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings ; itearate over strings a and b ; if first row or column ; if matching is found ; otherwise , if matching is not found ; finally , return the resultant maximum value lcs ; ","context":"","code":"def LCSubStr(A, B, m, n):\n    LCSuff = [[0 for i in range(n + 1)]for j in range(m + 1)]\n    result = 0\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if (i == 0 or j == 0):\n                LCSuff[i][j] = 0\n            elif (A[i - 1] == B[j - 1]):\n                LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1\n                result = max(result, LCSuff[i][j])\n            else:\n                LCSuff[i][j] = 0\n    return result\n","test":"\nif __name__ == '__main__':\n    A = \"0110\"\n    B = \"1101\"\n    M = len(A)\n    N = len(B)\n    print(LCSubStr(A, B, M, N))\n","output":"3\n","fn_call":"LCSubStr"}
{"text":"count ways to split array into pair of subsets with difference between their sum equal to k | python program for the above approach ; to store the states of dp ; function to find count of subsets with a given sum ; base case ; if an already computed subproblem occurs ; set the state as solved ; recurrence relation ; function to count ways to split array into pair of subsets with difference k ; store the total sum of element of the array ; traverse the array ; calculate sum of array elements ; store the required sum ; prthe number of subsets with sum equal to s1 ; ","context":"\nmaxN = 20\nmaxSum = 50\nminSum = 50\nBase = 50\ndp = [[0 for i in range(maxSum + minSum)]for j in range(maxN)]\nv = [[False for i in range(maxSum + minSum)]for j in range(maxN)]\n\n","code":"def findCnt(arr, i, required_sum, n):\n    if (i == n):\n        if (required_sum == 0):\n            return 1\n        else:\n            return 0\n    if (v[i][required_sum + Base]):\n        return dp[i][required_sum + Base]\n    v[i][required_sum + Base] = True\n    dp[i][required_sum + Base] = findCnt(arr,\n                                         i + 1,\n                                         required_sum,\n                                         n) + findCnt(arr,\n                                                      i + 1,\n                                                      required_sum - arr[i],\n                                                      n)\n    return dp[i][required_sum + Base]\n\n\ndef countSubsets(arr, K, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    S1 = (sum + K) \/\/ 2\n    print(findCnt(arr, 0, S1, n))\n","test":"\nif __name__ == '__main__':\n    arr = [1, 1, 2, 3]\n    N = len(arr)\n    K = 1\n    countSubsets(arr, K, N)\n","output":"3\n","fn_call":"countSubsets"}
{"text":"probability that the sum of all numbers obtained on throwing a dice n times lies between two given integers | python program for above approach ; function to calculate the probability for the given sum to be equal to sum in n throws of dice ; base cases ; ","context":"\ndp = [[0 for i in range(605)]for j in range(105)]\n\n","code":"def find(N, sum):\n    if (N < 0 | sum < 0):\n        return 0\n    if (dp[N][sum] > 0):\n        return dp[N][sum]\n    if (sum > 6 * N or sum < N):\n        return 0\n    if (N == 1):\n        if (sum >= 1 and sum <= 6):\n            return (float)(1.0 \/ 6)\n        else:\n            return 0\n    for i in range(1, 7):\n        dp[N][sum] = dp[N][sum] + find(N - 1, sum - i) \/ 6\n    return dp[N][sum]\n","test":"\nif __name__ == '__main__':\n    N = 4\n    a = 13\n    b = 17\n    probability = 0.0\n    f = 0\n    for sum in range(a, b + 1):\n        probability = probability + find(N, sum)\n    print(\"%.6f\" % probability)\n","output":"0.505401\n","fn_call":"find"}
{"text":"minimum steps to reduce n to 0 by given operations | function to find the minimum number to steps to reduce n to 0 ; dictionary for storing the precomputed sum ; bases cases ; check if n is not in dp then only call the function so as to reduce no of recursive calls ; return the answer ; ","context":"","code":"def count(n):\n    dp = dict()\n    dp[0] = 0\n    dp[1] = 1\n    if n not in dp:\n        dp[n] = 1 + min(n % 2 + count(n \/\/ 2), n % 3 + count(n \/\/ 3))\n    return dp[n]\n","test":"\nN = 6\nprint(str(count(N)))\n","output":"3\n","fn_call":"count"}
{"text":"minimum count of increment of k size subarrays required to form a given array | function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array ; declaring the difference array of size n ; number of operations ; first update the d [ i ] value with the previous value ; the index i has to be incremented ; we have to perform ( b [ i ] - d [ i ] ) operations more ; increment the range i to i + k by need ; check if i + k is valid index ; ","context":"","code":"def find_minimum_operations(n, b, k):\n    d = [0 for i in range(n + 1)]\n    operations = 0\n    for i in range(n):\n        d[i] += d[i - 1]\n        if b[i] > d[i]:\n            operations += (b[i] - d[i])\n            need = (b[i] - d[i])\n            d[i] += need\n            if i + k <= n:\n                d[i + k] -= need\n    return operations\n","test":"\nif __name__ == \"__main__\":\n    n = 5\n    b = [1, 2, 3, 4, 5]\n    k = 2\n    print(find_minimum_operations(n, b, k))\n","output":"9\n","fn_call":"find_minimum_operations"}
{"text":"product of all sorted subsets of size k using elements whose index divide k completely | python3 implementation of the above approach ; iterative function to calculate ( x ^ y ) % p in o ( log y ) ; if y is odd , multiply x with result ; y must be even now ; iterative function to calculate ( ncr ) % p and save in f [ n ] [ r ] ; if j > i then c ( i , j ) = 0 ; if i is equal to j then c ( i , j ) = 1 ; function calculate the final answer ; initialize ans ; x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides k completely . ; finding the count of arr [ i ] by placing it at index which divides k completely ; by fermat 's theorem ; ","context":"\np = 1000000007\n\n","code":"def power(x, y, p):\n    res = 1\n    x = x % p\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef nCr(n, p, f, m):\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if (j > i):\n                f[i][j] = 0\n            elif (j == 0 or j == i):\n                f[i][j] = 1\n            else:\n                f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % p\n\n\ndef ProductOfSubsets(arr, n, m):\n    f = [[0 for i in range(100)]for j in range(n + 1)]\n    nCr(n, p - 1, f, m)\n    arr .sort(reverse=False)\n    ans = 1\n    for i in range(n):\n        x = 0\n        for j in range(1, m + 1, 1):\n            if (m % j == 0):\n                x = ((x + (f[n - i - 1][m - j] * f[i][j - 1]) %\n                     (p - 1)) % (p - 1))\n        ans = ((ans * power(arr[i], x, p)) % p)\n    print(ans)\n","test":"\nif __name__ == '__main__':\n    arr = [4, 5, 7, 9, 3]\n    K = 4\n    N = len(arr)\n    ProductOfSubsets(arr, N, K)\n","output":"808556639\n","fn_call":"ProductOfSubsets"}
{"text":"number of ways to write n as a sum of k non | function to count the number of ways to write n as sum of k non - negative integers ; initialise dp [ ] [ ] array ; only 1 way to choose the value with sum k ; initialise sum ; count the ways from previous states ; update the sum ; return the final count of ways ; ","context":"","code":"def countWays(n, m):\n    dp = [[0 for i in range(n + 1)]for i in range(m + 1)]\n    for i in range(n + 1):\n        dp[1][i] = 1\n    sum = 0\n    for i in range(2, m + 1):\n        for j in range(n + 1):\n            sum = 0\n            for k in range(j + 1):\n                sum += dp[i - 1][k]\n            dp[i][j] = sum\n    return dp[m][n]\n","test":"\nif __name__ == '__main__':\n    N = 2\n    K = 3\n    print(countWays(N, K))\n","output":"6\n","fn_call":"countWays"}
{"text":"number of ways to write n as a sum of k non | function to count the number of ways to write n as sum of k non - negative integers ; initialise dp [ ] [ ] array ; fill the dp [ ] [ ] with sum = m ; iterate the dp [ ] [ ] to fill the dp [ ] [ ] array ; condition for first column ; else fill the dp [ ] [ ] with sum till ( i , j ) ; if reach the end , then return the value ; update at current index ; ","context":"","code":"def countWays(n, m):\n    dp = [[0 for i in range(n + 1)]for j in range(m + 1)]\n    for i in range(n + 1):\n        dp[1][i] = 1\n        if (i != 0):\n            dp[1][i] += dp[1][i - 1]\n    for i in range(2, m + 1):\n        for j in range(n + 1):\n            if (j == 0):\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n                if (i == m and j == n):\n                    return dp[i][j]\n                dp[i][j] += dp[i][j - 1]\n","test":"\nN = 2\nK = 3\nprint(countWays(N, K))\n","output":"6\n","fn_call":"countWays"}
{"text":"longest subsequence such that every element in the subsequence is formed by multiplying previous element with a prime | python3 program to implement the above approach ; function to pre - store primes ; sieve method to check if prime or not ; multiples ; pre - store all the primes ; function to find the longest subsequence ; hash map ; call the function to pre - store the primes ; initialize last element with 1 as that is the longest possible ; iterate from the back and find the longest ; get the number ; initialize dp [ i ] as 1 as the element will only me in the subsequence ; iterate in all the primes and multiply to get the next element ; next element if multiplied with it ; if exceeds the last element then break ; if the number is there in the array ; get the maximum most element ; hash the element ; find the longest ; ","context":"\nfrom math import sqrt\n\n","code":"def SieveOfEratosthenes(MAX, primes):\n    prime = [True] * (MAX + 1)\n    for p in range(2, int(sqrt(MAX)) + 1):\n        if (prime[p]):\n            for i in range(p ** 2, MAX + 1, p):\n                prime[i] = False\n    for i in range(2, MAX + 1):\n        if (prime[i]):\n            primes .append(i)\n\n\ndef findLongest(A, n):\n    mpp = {}\n    primes = []\n    SieveOfEratosthenes(A[n - 1], primes)\n    dp = [0] * n\n    dp[n - 1] = 1\n    mpp[A[n - 1]] = n - 1\n    for i in range(n - 2, -1, -1):\n        num = A[i]\n        dp[i] = 1\n        maxi = 0\n        for it in primes:\n            xx = num * it\n            if (xx > A[n - 1]):\n                break\n            elif xx in mpp:\n                dp[i] = max(dp[i], 1 + dp[mpp[xx]])\n        mpp[A[i]] = i\n    ans = 1\n    for i in range(n):\n        ans = max(ans, dp[i])\n    return ans\n","test":"\nif __name__ == \"__main__\":\n    a = [1, 2, 5, 6, 12, 35, 60, 385]\n    n = len(a)\n    print(findLongest(a, n))\n","output":"5\n","fn_call":"findLongest"}
{"text":"number of binary strings of length n with k adjacent set bits | function to find the number of bit strings of length n with k adjacent set bits ; base case when we form bit string of length n ; if f ( bit string ) = k , count this way ; check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset ; set the bit at currentindex ; unset the bit at currentindex ; ","context":"","code":"def waysToKAdjacentSetBits(n, k, currentIndex, adjacentSetBits, lastBit):\n    if (currentIndex == n):\n        if (adjacentSetBits == k):\n            return 1\n        return 0\n    noOfWays = 0\n    if (lastBit == 1):\n        noOfWays += waysToKAdjacentSetBits(n,\n                                           k,\n                                           currentIndex + 1,\n                                           adjacentSetBits + 1,\n                                           1)\n        noOfWays += waysToKAdjacentSetBits(n,\n                                           k,\n                                           currentIndex + 1,\n                                           adjacentSetBits,\n                                           0)\n    elif (lastBit != 1):\n        noOfWays += waysToKAdjacentSetBits(n,\n                                           k,\n                                           currentIndex + 1,\n                                           adjacentSetBits,\n                                           1)\n        noOfWays += waysToKAdjacentSetBits(n,\n                                           k,\n                                           currentIndex + 1,\n                                           adjacentSetBits,\n                                           0)\n    return noOfWays\n","test":"\nn = 5\nk = 2\ntotalWays = (\n    waysToKAdjacentSetBits(\n        n,\n        k,\n        1,\n        0,\n        1) +\n    waysToKAdjacentSetBits(\n        n,\n        k,\n        1,\n        0,\n        0))\nprint(\"Number of ways =\", totalWays)\n","output":"Number of ways = 6\n","fn_call":"waysToKAdjacentSetBits"}
{"text":"sum of products of all combination taken ( 1 to n ) at a time | find the postfix sum array ; modify the array such that we don 't have to compute the products which are obtained before ; finding sum of all combination taken 1 to n at a time ; sum taken 1 at time is simply sum of 1 - n ; for sum of products for all combination ; finding postfix array ; sum of products taken i + 1 at a time ; modify the array for overlapping problem ; ","context":"","code":"def postfix(a, n):\n    for i in range(n - 1, 1, -1):\n        a[i - 1] = a[i - 1] + a[i]\n\n\ndef modify(a, n):\n    for i in range(1, n):\n        a[i - 1] = i * a[i]\n\n\ndef allCombination(a, n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i\n    print(\"f(1) --> \", sum)\n    for i in range(1, n):\n        postfix(a, n - i + 1)\n        sum = 0\n        for j in range(1, n - i + 1):\n            sum += (j * a[j])\n        print(\"f(\", i + 1, \") --> \", sum)\n        modify(a, n)\n","test":"\nif __name__ == \"__main__\":\n    n = 5\n    a = [0] * n\n    for i in range(n):\n        a[i] = i + 1\n    allCombination(a, n)\n","output":"f(1) -->  15\nf( 2 ) -->  85\nf( 3 ) -->  225\nf( 4 ) -->  274\nf( 5 ) -->  120\n","fn_call":"allCombination"}
{"text":"count ways to reach the nth stair using step 1 , 2 or 3 | returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; ","context":"","code":"def findStep(n):\n    if (n == 1 or n == 0):\n        return 1\n    elif (n == 2):\n        return 2\n    else:\n        return findStep(n - 3) + findStep(n - 2) + findStep(n - 1)\n","test":"\nn = 4\nprint(findStep(n))\n","output":"7\n","fn_call":"findStep"}
{"text":"partition problem | dp | a utility function that returns true if there is a subset of arr [ ] with sun equal to given sum ; base cases ; if last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; calculate sum of the elements in array ; if sum is odd , there cannot be two subsets with equal sum ; find if there is subset with sum equal to half of total sum ; ","context":"","code":"def isSubsetSum(arr, n, sum):\n    if sum == 0:\n        return True\n    if n == 0 and sum != 0:\n        return False\n    if arr[n - 1] > sum:\n        return isSubsetSum(arr, n - 1, sum)\n    return isSubsetSum(arr, n - 1, sum) or isSubsetSum(arr,\n                                                       n - 1, sum - arr[n - 1])\n\n\ndef findPartion(arr, n):\n    sum = 0\n    for i in range(0, n):\n        sum += arr[i]\n    if sum % 2 != 0:\n        return false\n    return isSubsetSum(arr, n, sum \/\/ 2)\n","test":"\narr = [3, 1, 5, 9, 12]\nn = len(arr)\nif findPartion(arr, n):\n    print(\"Can be divided into two subsets of equal sum\")\nelse:\n    print(\"Can not be divided into two subsets of equal sum\")\n","output":"Can be divided into two subsets of equal sum\n","fn_call":"findPartion"}
{"text":"partition problem | dp | returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; calculate sum of all elements ; initialize the part array as 0 ; fill the partition table in bottom up manner ; the element to be included in the sum cannot be greater than the sum ; check if sum - arr [ i ] could be formed from a subset using elements before index i ; ","context":"","code":"def findPartiion(arr, n):\n    Sum = 0\n    for i in range(n):\n        Sum += arr[i]\n    if (Sum % 2 != 0):\n        return 0\n    part = [0] * ((Sum \/\/ 2) + 1)\n    for i in range((Sum \/\/ 2) + 1):\n        part[i] = 0\n    for i in range(n):\n        for j in range(Sum \/\/ 2, arr[i] - 1, -1):\n            if (part[j - arr[i]] == 1 or j == arr[i]):\n                part[j] = 1\n    return part[Sum \/\/ 2]\n","test":"\narr = [1, 3, 3, 2, 3, 2]\nn = len(arr)\nif (findPartiion(arr, n) == 1):\n    print(\"Can be divided into two subsets of equal sum\")\nelse:\n    print(\"Can not be divided into two subsets of equal sum\")\n","output":"Can be divided into two subsets of equal sum\n","fn_call":"findPartiion"}
{"text":"binomial coefficient | dp | function to find binomial coefficient ; getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007 ; for 1 \/ ( r ! ) part ; for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part ; ","context":"","code":"def binomialCoeff(n, r):\n    if (r > n):\n        return 0\n    m = 1000000007\n    inv = [0 for i in range(r + 1)]\n    inv[0] = 1\n    if r + 1 >= 2:\n        inv[1] = 1\n    for i in range(2, r + 1):\n        inv[i] = m - (m \/\/ i) * inv[m % i] % m\n    ans = 1\n    for i in range(2, r + 1):\n        ans = ((ans % m) * (inv[i] % m)) % m\n    for i in range(n, n - r, -1):\n        ans = ((ans % m) * (i % m)) % m\n    return ans\n","test":"\nn = 5\nr = 2\nprint(\"Value of C(\", n, \", \", r, \") is \", binomialCoeff(n, r))\n","output":"Value of C( 5 ,  2 ) is  10\n","fn_call":"binomialCoeff"}
{"text":"check if it is possible to reach ( x , y ) from ( 1 , 1 ) by given steps | function to find the gcd of two numbers ; base case ; recurse ; function to print the answer ; gcd of x and y ; if gcd is power of 2 ; ","context":"","code":"def gcd(a, b):\n    if (a < b):\n        t = a\n        a = b\n        b = t\n    if (a % b == 0):\n        return b\n    return gcd(b, a % b)\n\n\ndef printAnswer(x, y):\n    val = gcd(x, y)\n    if ((val & (val - 1)) == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","test":"\nif __name__ == \"__main__\":\n    x = 4\n    y = 7\n    printAnswer(x, y)\n","output":"Yes\n","fn_call":"printAnswer"}
{"text":"find the element in the matrix generated by given rules | function to return the element in the rth row and cth column from the required matrix ; condition for lower half of matrix ; condition if element is in first row ; starting element of ap in row r ; common difference of ap in row r ; position of element to find in ap in row r ; ","context":"","code":"def getElement(N, r, c):\n    if (r > c):\n        return 0\n    if (r == 1):\n        return c\n    a = (r + 1) * pow(2, r - 2)\n    d = pow(2, r - 1)\n    c = c - r\n    element = a + d * c\n    return element\n","test":"\nif __name__ == \"__main__\":\n    N = 4\n    R = 3\n    C = 4\n    print(getElement(N, R, C))\n","output":"12\n","fn_call":"getElement"}
{"text":"find smallest number formed by inserting given digit | function to insert x in n and return the minimum value string ; variable to store length of string n ; variable to denote the position where x must be added ; if the given string n represent a negative value ; x must be place at the last index where is greater than n [ i ] ; for positive numbers , x must be placed at the last index where it is smaller than n [ i ] ; insert x at that position ; return the string ; ","context":"","code":"def MinValue(N, X):\n    N = list(N)\n    ln = len(N)\n    position = ln + 1\n    if (N[0] == '-'):\n        for i in range(ln - 1, 0, -1):\n            if ((ord(N[i]) - ord('0')) < X):\n                position = i\n    else:\n        for i in range(ln - 1, -1, -1):\n            if ((ord(N[i]) - ord('0')) > X):\n                position = i\n    c = chr(X + ord('0'))\n    str = N .insert(position, c)\n    return ''.join(N)\n","test":"\nN = \"89\"\nX = 1\nprint(MinValue(N, X))\n","output":"189\n","fn_call":"MinValue"}
{"text":"check if decimal representation of given binary string is divisible by k or not | function to check the binary number is divisible by k ; array poweroftwo will store pow ( 2 , i ) % k ; initializing the first element in array ; storing every pow ( 2 , i ) % k value in the array ; to store the remaining ; iterating till n ; if current bit is 1 ; updating rem ; if completely divisible ; if not completely divisible ; ","context":"","code":"def divisibleByk(s, n, k):\n    poweroftwo = [0 for i in range(n)]\n    poweroftwo[0] = 1 % k\n    for i in range(1, n, 1):\n        poweroftwo[i] = (poweroftwo[i - 1] * (2 % k)) % k\n    rem = 0\n    for i in range(n):\n        if (s[n - i - 1] == '1'):\n            rem += (poweroftwo[i])\n            rem %= k\n    if (rem == 0):\n        return \"Yes\"\n    else:\n        return \"No\"\n","test":"\nif __name__ == '__main__':\n    s = \"1010001\"\n    k = 9\n    n = len(s)\n    print(divisibleByk(s, n, k))\n","output":"Yes\n","fn_call":"divisibleByk"}
{"text":"count removal of pairs required to be empty all balanced parenthesis subsequences | function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis ; stores count of pairs of balanced parenthesis ; stores count of curly balanced parenthesis ; stores count of small balanced parenthesis ; stores count of square balanced parenthesis ; iterate over characters of the string ; update cntcurly ; update cntsml ; update cntsqr ; update cntcurly ; update cntpairs ; update cntsml ; update cntpairs ; update cntsml ; update cntpairs ; ","context":"","code":"def cntBalancedParenthesis(s, N):\n    cntPairs = 0\n    cntCurly = 0\n    cntSml = 0\n    cntSqr = 0\n    for i in range(N):\n        if (ord(s[i]) == ord('{')):\n            cntCurly += 1\n        elif (ord(s[i]) == ord('(')):\n            cntSml += 1\n        elif (ord(s[i]) == ord('[')):\n            cntSqr += 1\n        elif (ord(s[i]) == ord('}') and cntCurly > 0):\n            cntCurly -= 1\n            cntPairs += 1\n        elif (ord(s[i]) == ord(')') and cntSml > 0):\n            cntSml -= 1\n            cntPairs += 1\n        elif (ord(s[i]) == ord(']') and cntSqr > 0):\n            cntSqr -= 1\n            cntPairs += 1\n    print(cntPairs)\n","test":"\nif __name__ == '__main__':\n    s = \"{(})\"\n    N = len(s)\n    cntBalancedParenthesis(s, N)\n","output":"2\n","fn_call":"cntBalancedParenthesis"}
{"text":"count of strings that does not contain arc intersection | function to check if there is arc intersection or not ; traverse the string s ; insert all the elements in the stack one by one ; extract the top element ; pop out the top element ; check if the top element is same as the popped element ; otherwise ; if the stack is empty ; function to check if there is arc intersection or not for the given array of strings ; stores count of string not having arc intersection ; iterate through array ; length of every string ; function call ; print the desired count ; ","context":"","code":"def arcIntersection(S, lenn):\n    stk = []\n    for i in range(lenn):\n        stk .append(S[i])\n        if (len(stk) >= 2):\n            temp = stk[-1]\n            del stk[-1]\n            if (stk[-1] == temp):\n                del stk[-1]\n            else:\n                stk .append(temp)\n    if (len(stk) == 0):\n        return 1\n    return 0\n\n\ndef countString(arr, N):\n    count = 0\n    for i in range(N):\n        lenn = len(arr[i])\n        count += arcIntersection(arr[i], lenn)\n    print(count)\n","test":"\nif __name__ == '__main__':\n    arr = [\"0101\", \"0011\", \"0110\"]\n    N = len(arr)\n    countString(arr, N)\n","output":"2\n","fn_call":"countString"}
{"text":"check if decimal representation of binary string is divisible by 9 or not | function to convert the binary string into octal representation ; stores binary representation of the decimal value [ 0 - 7 ] ; stores the decimal values of binary strings [ 0 - 7 ] ; stores length of s ; update s ; update s ; update n ; stores octal representation of the binary string ; traverse the binary string ; stores 3 consecutive characters of the binary string ; append octal representation of temp ; function to check if binary string is divisible by 9 or not ; stores octal representation of s ; stores sum of elements present at odd positions of oct ; stores sum of elements present at odd positions of oct ; stores length of oct ; traverse the string oct ; update oddsum ; traverse the string oct ; update evensum ; stores cotal representation of 9 ; if absolute value of ( oddsum - evensum ) is divisible by oct_9 ; ","context":"","code":"def ConvertequivalentBase8(S):\n    mp = {}\n    mp[\"000\"] = '0'\n    mp[\"001\"] = '1'\n    mp[\"010\"] = '2'\n    mp[\"011\"] = '3'\n    mp[\"100\"] = '4'\n    mp[\"101\"] = '5'\n    mp[\"110\"] = '6'\n    mp[\"111\"] = '7'\n    N = len(S)\n    if (N % 3 == 2):\n        S = \"0\" + S\n    elif (N % 3 == 1):\n        S = \"00\" + S\n    N = len(S)\n    octal = \"\"\n    for i in range(0, N, 3):\n        temp = S[i:i + 3]\n        if temp in mp:\n            octal += (mp[temp])\n    return octal\n\n\ndef binString_div_9(S, N):\n    octal = ConvertequivalentBase8(S)\n    oddSum = 0\n    evenSum = 0\n    M = len(octal)\n    for i in range(0, M, 2):\n        oddSum += ord(octal[i]) - ord('0')\n    for i in range(1, M, 2):\n        evenSum += ord(octal[i]) - ord('0')\n    Oct_9 = 11\n    if (abs(oddSum - evenSum) % Oct_9 == 0):\n        return \"Yes\"\n    return \"No\"\n","test":"\nif __name__ == \"__main__\":\n    S = \"1010001\"\n    N = len(S)\n    print(binString_div_9(S, N))\n","output":"Yes\n","fn_call":"binString_div_9"}
{"text":"minimum cost to remove the spaces between characters of a string by rearranging the characters | function to calculate the minimum cost ; stores the minimum cost ; stores the count of characters found ; stores the count of blank spaces found ; stores the count of total characters ; if the count of characters is equal to 1 ; iterate over the string ; consider the previous character together with current character ; if not together already ; add the cost to group them together ; increase count of characters found ; otherwise ; increase count of spaces found ; return the total cost obtained ; ","context":"","code":"def min_cost(S):\n    cost = 0\n    F = 0\n    B = 0\n    n = len(S) - S .count(' ')\n    if n == 1:\n        return cost\n    for char in S:\n        if char != ' ':\n            if B != 0:\n                cost += min(n - F, F) * B\n                B = 0\n            F += 1\n        else:\n            B += 1\n    return cost\n","test":"\nS = \" @TABSYMBOL$\"\nprint(min_cost(S))\n","output":"0\n","fn_call":"min_cost"}
{"text":"minimize cost to replace all the vowels of a given string by a single vowel | function that return true if the given character is a vowel ; function to return the minimum cost to convert all the vowels of a string to a single one ; stores count of respective vowels ; iterate through the string ; if a vowel is encountered ; calculate the cost ; return the minimum cost ; ","context":"","code":"def isVowel(ch):\n    if (ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u'):\n        return True\n    else:\n        return False\n\n\ndef minCost(S):\n    cA = 0\n    cE = 0\n    cI = 0\n    cO = 0\n    cU = 0\n    for i in range(len(S)):\n        if (isVowel(S[i])):\n            cA += abs(ord(S[i]) - ord('a'))\n            cE += abs(ord(S[i]) - ord('e'))\n            cI += abs(ord(S[i]) - ord('i'))\n            cO += abs(ord(S[i]) - ord('o'))\n            cU += abs(ord(S[i]) - ord('u'))\n    return min(min(min(min(cA, cE), cI), cO), cU)\n","test":"\nS = \"geeksforgeeks\"\nprint(minCost(S))\n","output":"10\n","fn_call":"minCost"}
{"text":"generate a string whose all k | function to return the required required string ; iterate the given string ; append the first character of every substring of length k ; consider all characters from the last substring ; ","context":"","code":"def decode_String(st, K):\n    ans = \"\"\n    for i in range(0, len(st), K):\n        ans += st[i]\n    for i in range(len(st) - (K - 1), len(st)):\n        ans += st[i]\n    print(ans)\n","test":"\nif __name__ == \"__main__\":\n    K = 3\n    st = \"abcbcscsesesesd\"\n    decode_String(st, K)\n","output":"abcsesd\n","fn_call":"decode_String"}
{"text":"lexicographically smallest k | function that prints the lexicographically smallest k - length substring containing maximum number of vowels ; store the length of the string ; initialize a prefix sum array ; loop through the string to create the prefix sum array ; store 1 at the index if it is a vowel ; otherwise , store 0 ; process the prefix array ; initialize the variable to store maximum count of vowels ; initialize the variable to store substring with maximum count of vowels ; loop through the prefix array ; store the current count of vowels ; update the result if current count is greater than maximum count ; update lexicographically smallest substring if the current count is equal to the maximum count ; return the result ; ","context":"","code":"def maxVowelSubString(str1, K):\n    N = len(str1)\n    pref = [0 for i in range(N)]\n    for i in range(N):\n        if (str1[i] == 'a' or str1[i] == 'e' or str1[i]\n                == 'i' or str1[i] == 'o' or str1[i] == 'u'):\n            pref[i] = 1\n        else:\n            pref[i] = 0\n        if (i):\n            pref[i] += pref[i - 1]\n    maxCount = pref[K - 1]\n    res = str1[0:K]\n    for i in range(K, N):\n        currCount = pref[i] - pref[i - K]\n        if (currCount > maxCount):\n            maxCount = currCount\n            res = str1[i - K + 1:i + 1]\n        elif (currCount == maxCount):\n            temp = str1[i - K + 1:i + 1]\n            if (temp < res):\n                res = temp\n    return res\n","test":"\nif __name__ == '__main__':\n    str1 = \"ceebbaceeffo\"\n    K = 3\n    print(maxVowelSubString(str1, K))\n","output":"ace\n","fn_call":"maxVowelSubString"}
{"text":"decode the string encoded with the given algorithm | function to decode and print the original string ; to store the decoded string ; getting the mid element ; storing the first element of the string at the median position ; if the length is even then store the second element also ; k represents the number of characters that are already stored in the c [ ] ; if string length is odd ; if it is even ; print the decoded string ; ","context":"","code":"def decodeStr(str, len):\n    c = [\"\"for i in range(len)]\n    pos = 1\n    if (len % 2 == 1):\n        med = int(len \/ 2)\n    else:\n        med = int(len \/ 2 - 1)\n    c[med] = str[0]\n    if (len % 2 == 0):\n        c[med + 1] = str[1]\n    if (len & 1):\n        k = 1\n    else:\n        k = 2\n    for i in range(k, len, 2):\n        c[med - pos] = str[i]\n        if (len % 2 == 1):\n            c[med + pos] = str[i + 1]\n        else:\n            c[med + pos + 1] = str[i + 1]\n        pos += 1\n    print(*c, sep=\"\")\n","test":"\nstr = \"ofrsgkeeeekgs\"\nlen = len(str)\ndecodeStr(str, len)\n","output":"geeksforgeeks\n","fn_call":"decodeStr"}
{"text":"count of distinct characters in a substring by given range for q queries | python3 program for naive approach ; counter to count distinct char ; initializing frequency array to count characters as the appear in substring s [ l : r ] ; iterating over s [ l ] to s [ r ] ; incrementing the count of s [ i ] character in frequency array ; if frequency of any character is > 0 then increment the counter ; ","context":"","code":"def findCount(s, L, R):\n    distinct = 0\n    frequency = [0 for i in range(26)]\n    for i in range(L, R + 1, 1):\n        frequency[ord(s[i]) - ord('a')] += 1\n    for i in range(26):\n        if (frequency[i] > 0):\n            distinct += 1\n    print(distinct)\n","test":"\nif __name__ == '__main__':\n    s = \"geeksforgeeksisacomputerscienceportal\"\n    queries = 3\n    Q = [[0, 10], [15, 18], [12, 20]]\n    for i in range(queries):\n        findCount(s, Q[i][0], Q[i][1])\n","output":"7\n4\n8\n","fn_call":"findCount"}
{"text":"string obtained by reversing and complementing a binary string k times | function to perform k operations upon the string and find modified string ; number of reverse operations ; number of complement operations ; if rev is odd parity ; if complement is odd parity ; complementing each position ; return the modified string ; ","context":"","code":"def ReverseComplement(s, n, k):\n    rev = (k + 1) \/\/ 2\n    complement = k - rev\n    if (rev % 2):\n        s = s[::-1]\n    if (complement % 2):\n        for i in range(n):\n            if (s[i] == '0'):\n                s[i] = '1'\n            else:\n                s[i] = '0'\n    return s\n","test":"\nif __name__ == '__main__':\n    str1 = \"10011\"\n    k = 5\n    n = len(str1)\n    print(ReverseComplement(str1, n, k))\n","output":"11001\n","fn_call":"ReverseComplement"}
{"text":"check if any permutation of string is a k times repeated string | function to check that permutation of the given string is a k times repeating string ; if length of string is not divisible by k ; frequency array ; initially frequency of each character is 0 ; computing the frequency of each character in the string ; loop to check that frequency of every character of the string is divisible by k ; ","context":"","code":"def repeatingString(s, n, k):\n    if (n % k != 0):\n        return False\n    frequency = [0 for i in range(123)]\n    for i in range(123):\n        frequency[i] = 0\n    for i in range(n):\n        frequency[s[i]] += 1\n    repeat = n \/\/ k\n    for i in range(123):\n        if (frequency[i] % repeat != 0):\n            return False\n    return True\n","test":"\nif __name__ == '__main__':\n    s = \"abcdcba\"\n    n = len(s)\n    k = 3\n    if (repeatingString(s, n, k)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"No\n","fn_call":"repeatingString"}
{"text":"find the last two missing digits of the given phone number | function to find the last two digits of the number and print the complete number ; sum of the first eight digits of the number ; if sum < 10 , then the two digits are '0' and the value of sum ; if sum > 10 , then the two digits are the value of sum ; ","context":"","code":"def findPhoneNumber(n):\n    temp = n\n    sum = 0\n    while (temp != 0):\n        sum += temp % 10\n        temp = temp \/\/ 10\n    if (sum < 10):\n        print(n, \"0\", sum)\n    else:\n        n = str(n)\n        sum = str(sum)\n        n += sum\n        print(n)\n","test":"\nif __name__ == '__main__':\n    n = 98765432\n    findPhoneNumber(n)\n","output":"9876543244\n","fn_call":"findPhoneNumber"}
{"text":"number of ways to split a binary number such that every part is divisible by 2 | function to return the required count ; if the splitting is not possible ; to store the count of zeroes ; counting the number of zeroes ; return the final answer ; ","context":"","code":"def cntSplits(s):\n    if (s[len(s) - 1] == '1'):\n        return 0\n    c_zero = 0\n    for i in range(len(s)):\n        c_zero += (s[i] == '0')\n    return int(pow(2, c_zero - 1))\n","test":"\nif __name__ == \"__main__\":\n    s = \"10010\"\n    print(cntSplits(s))\n","output":"4\n","fn_call":"cntSplits"}
{"text":"count number of substrings of a string consisting of same characters | function to return the number of substrings of same characters ; size of the string ; initialize count to 1 ; initialize left to 0 and right to 1 to traverse the string ; checking if consecutive characters are same and increment the count ; when we encounter a different characters ; increment the result ; to repeat the whole process set left equals right and count variable to 1 ; store the final value of result ; ","context":"","code":"def findNumbers(s):\n    n = len(s)\n    count = 1\n    result = 0\n    left = 0\n    right = 1\n    while (right < n):\n        if (s[left] == s[right]):\n            count += 1\n        else:\n            result += count * (count + 1) \/\/ 2\n            left = right\n            count = 1\n        right += 1\n    result += count * (count + 1) \/\/ 2\n    print(result)\n","test":"\ns = \"bbbcbb\"\nfindNumbers(s)\n","output":"10\n","fn_call":"findNumbers"}
{"text":"program to duplicate vowels in string | function to check for the vowel ; function to get the resultant string with vowels duplicated ; another to store the resultant string ; loop to check for each character ; ","context":"","code":"def isVowel(ch):\n    ch = ch .upper()\n    if (ch == 'A' or ch == 'E' or ch == 'I' or ch == 'O' or ch == 'U'):\n        return True\n    else:\n        return False\n\n\ndef duplicateVowels(S):\n    t = len(S)\n    res = \"\"\n    for i in range(t):\n        if (isVowel(S[i])):\n            res += S[i]\n        res += S[i]\n    return res\n","test":"\nS = \"helloworld\"\nprint(\"Original String: \", S)\nres = duplicateVowels(S)\nprint(\"String with Vowels duplicated: \", res)\n","output":"Original String:  helloworld\nString with Vowels duplicated:  heelloowoorld\n","fn_call":"duplicateVowels"}
{"text":"convert a string to an integer using recursion | recursive function to convert string to integer ; if the number represented as a string contains only a single digit then returns its value ; recursive call for the sub - string starting at the second character ; first digit of the number ; first digit multiplied by the appropriate power of 10 and then add the recursive result for example , xy = ( ( x * 10 ) + y ) ; ","context":"","code":"def stringToInt(str):\n    if (len(str) == 1):\n        return ord(str[0]) - ord('0')\n    y = stringToInt(str[1:])\n    x = ord(str[0]) - ord('0')\n    x = x * (10 ** (len(str) - 1)) + y\n    return int(x)\n","test":"\nif __name__ == '__main__':\n    str = \"1235\"\n    print(stringToInt(str))\n","output":"1235\n","fn_call":"stringToInt"}
{"text":"longest subsequence with at least one character appearing in every string | python3 implementation of the approach ; function to return the length of the longest sub - sequence with at least one common character in every string ; count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . . ; for every string ; hash array to set which character is present in the current string ; if current character appears in the string then update its count ; ","context":"\nMAX = 26\n\n","code":"def largestSubSeq(arr, n):\n    count = [0] * MAX\n    for i in range(n):\n        string = arr[i]\n        _hash = [False] * MAX\n        for j in range(len(string)):\n            _hash[ord(string[j]) - ord('a')] = True\n        for j in range(MAX):\n            if _hash[j]:\n                count[j] += 1\n    return max(count)\n","test":"\nif __name__ == \"__main__\":\n    arr = [\"ab\", \"bc\", \"de\"]\n    n = len(arr)\n    print(largestSubSeq(arr, n))\n","output":"2\n","fn_call":"largestSubSeq"}
{"text":"generate number with given operation and check if it is palindrome | function that returns true if str is a palindrome ; function that returns true if the generated string is a palindrome ; sub contains n as a string ; calculate the sum of the digits ; repeat the substring until the length of the resultant string < sum ; if length of the resultant string exceeded sum then take substring from 0 to sum - 1 ; if the generated string is a palindrome ; ","context":"","code":"def isPalindrome(s):\n    l = len(s)\n    for i in range(l \/\/ 2):\n        if (s[i] != s[l - 1 - i]):\n            return False\n    return True\n\n\ndef createStringAndCheckPalindrome(N):\n    sub = \"\" + chr(N)\n    res_str = \"\"\n    sum = 0\n    while (N > 0):\n        digit = N % 10\n        sum += digit\n        N = N \/\/ 10\n    while (len(res_str) < sum):\n        res_str += sub\n    if (len(res_str) > sum):\n        res_str = res_str[0:sum]\n    if (isPalindrome(res_str)):\n        return True\n    return False\n","test":"\nif __name__ == \"__main__\":\n    N = 10101\n    if (createStringAndCheckPalindrome(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\n","fn_call":"createStringAndCheckPalindrome"}
{"text":"minimize the length of string by removing occurrence of only one character | function to find the minimum length ; count the frequency of each alphabet ; find the alphabets with maximum frequency ; subtract the frequency of character from length of string ; ","context":"","code":"def minimumLength(s):\n    maxOcc = 0\n    n = len(s)\n    arr = [0] * 26\n    for i in range(n):\n        arr[ord(s[i]) - ord('a')] += 1\n    for i in range(26):\n        if arr[i] > maxOcc:\n            maxOcc = arr[i]\n    return n - maxOcc\n","test":"\nif __name__ == \"__main__\":\n    str = \"afddewqd\"\n    print(minimumLength(str))\n","output":"5\n","fn_call":"minimumLength"}
{"text":"remove all characters other than alphabets from string | function to remove characters and pr new string ; finding the character whose ascii value fall under this range ; erase function to erase the character ; ","context":"","code":"def removeSpecialCharacter(s):\n    i = 0\n    while i < len(s):\n        if (ord(s[i]) < ord('A') or ord(s[i]) > ord('Z')\n                and ord(s[i]) < ord('a') or ord(s[i]) > ord('z')):\n            del s[i]\n            i -= 1\n        i += 1\n    print(\"\".join(s))\n","test":"\nif __name__ == '__main__':\n    s = \"$Gee*k;s..fo, r'Ge^eks?\"\n    s = [i for i in s]\n    removeSpecialCharacter(s)\n","output":"GeeksforGeeks\n","fn_call":"removeSpecialCharacter"}
{"text":"remove all characters other than alphabets from string | function to remove special characters and store it in another variable ; store only valid characters ; ","context":"","code":"def removeSpecialCharacter(s):\n    t = \"\"\n    for i in s:\n        if (i >= 'A' and i <= 'Z') or (i >= 'a' and i <= 'z'):\n            t += i\n    print(t)\n","test":"\ns = \"$Gee*k;s..fo, r'Ge^eks?\"\nremoveSpecialCharacter(s)\n","output":"GeeksforGeeks\n","fn_call":"removeSpecialCharacter"}
{"text":"find repeated character present first in a string | python3 program to find the first character that is repeated ; this is o ( n ^ 2 ) method ; ","context":"","code":"def findRepeatFirstN2(s):\n    p = -1\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if (s[i] == s[j]):\n                p = i\n                break\n        if (p != -1):\n            break\n    return p\n","test":"\nif __name__ == \"__main__\":\n    str = \"geeksforgeeks\"\n    pos = findRepeatFirstN2(str)\n    if (pos == -1):\n        print(\"Not found\")\n    else:\n        print(str[pos])\n","output":"g\n","fn_call":"findRepeatFirstN2"}
{"text":"print characters and their frequencies in order of occurrence | python3 implementation to print the characters and frequencies in order of its occurrence ; store all characters and their frequencies in dictionary ; print characters and their frequencies in same order of their appearance ; print only if this character is not printed before . ; ","context":"","code":"def prCharWithFreq(str):\n    d = {}\n    for i in str:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    for i in str:\n        if d[i] != 0:\n            print(\"{}{}\".format(i, d[i]), end=\" \")\n            d[i] = 0\n","test":"\nif __name__ == \"__main__\":\n\n    str = \"geeksforgeeks\"\n    prCharWithFreq(str)\n","output":"g2 e4 k2 s2 f1 o1 r1 ","fn_call":"prCharWithFreq"}
{"text":"count number of strings ( made of r , g and b ) using given combination | function to calculate number of strings ; store factorial of numbers up to n for further computation ; find the remaining values to be added ; make all possible combinations of r , b and g for the remaining value ; compute permutation of each combination one by one and add them . ; return total no . of strings \/ permutation ; ","context":"","code":"def possibleStrings(n, r, b, g):\n    fact = [0 for i in range(n + 1)]\n    fact[0] = 1\n    for i in range(1, n + 1, 1):\n        fact[i] = fact[i - 1] * i\n    left = n - (r + g + b)\n    sum = 0\n    for i in range(0, left + 1, 1):\n        for j in range(0, left - i + 1, 1):\n            k = left - (i + j)\n            sum = (sum + fact[n] \/ (fact[i + r] * fact[j + b] * fact[k + g]))\n    return sum\n","test":"\nif __name__ == '__main__':\n    n = 4\n    r = 2\n    b = 0\n    g = 1\n    print(int(possibleStrings(n, r, b, g)))\n","output":"22\n","fn_call":"possibleStrings"}
{"text":"remove minimum number of characters so that two strings become anagram | python 3 program to find minimum number of characters to be removed to make two strings anagram . ; function to calculate minimum numbers of characters to be removed to make two strings anagram ; make hash array for both string and calculate frequency of each character ; count frequency of each character in first string ; count frequency of each character in second string ; traverse count arrays to find number of characters to be removed ; ","context":"\nCHARS = 26\n\n","code":"def remAnagram(str1, str2):\n    count1 = [0] * CHARS\n    count2 = [0] * CHARS\n    i = 0\n    while i < len(str1):\n        count1[ord(str1[i]) - ord('a')] += 1\n        i += 1\n    i = 0\n    while i < len(str2):\n        count2[ord(str2[i]) - ord('a')] += 1\n        i += 1\n    result = 0\n    for i in range(26):\n        result += abs(count1[i] - count2[i])\n    return result\n","test":"\nif __name__ == \"__main__\":\n    str1 = \"bcadeh\"\n    str2 = \"hea\"\n    print(remAnagram(str1, str2))\n","output":"3\n","fn_call":"remAnagram"}
{"text":"check if a string has all characters with same frequency with one variation allowed | assuming only lower case characters ; to check a string s can be converted to a valid string by removing less than or equal to one character . ; freq [ ] : stores the frequency of each character of a string ; find first character with non - zero frequency ; find a character with frequency different from freq1 . ; if we find a third non - zero frequency or count of both frequencies become more than 1 , then return false ; if we find a third non - zero freq ; if counts of both frequencies is more than 1 ; return true if we reach here ; ","context":"\nCHARS = 26\n\n","code":"def isValidString(str):\n    freq = [0] * CHARS\n    for i in range(len(str)):\n        freq[ord(str[i]) - ord('a')] += 1\n    freq1 = 0\n    count_freq1 = 0\n    for i in range(CHARS):\n        if (freq[i] != 0):\n            freq1 = freq[i]\n            count_freq1 = 1\n            break\n    freq2 = 0\n    count_freq2 = 0\n    for j in range(i + 1, CHARS):\n        if (freq[j] != 0):\n            if (freq[j] == freq1):\n                count_freq1 += 1\n            else:\n                count_freq2 = 1\n                freq2 = freq[j]\n                break\n    for k in range(j + 1, CHARS):\n        if (freq[k] != 0):\n            if (freq[k] == freq1):\n                count_freq1 += 1\n            if (freq[k] == freq2):\n                count_freq2 += 1\n            else:\n                return False\n        if (count_freq1 > 1 and count_freq2 > 1):\n            return False\n    return True\n","test":"\nif __name__ == \"__main__\":\n    str = \"abcbc\"\n    if (isValidString(str)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"isValidString"}
{"text":"check if a string has all characters with same frequency with one variation allowed | to check a string s can be converted to a variation string ; run loop form 0 to length of string ; declaration of variables ; if first is true than countofval1 increase ; if second is true than countofval2 increase ; ","context":"","code":"def checkForVariation(strr):\n    if (len(strr) == 0):\n        return True\n    mapp = {}\n    for i in range(len(strr)):\n        if strr[i] in mapp:\n            mapp[strr[i]] += 1\n        else:\n            mapp[strr[i]] = 1\n    first = True\n    second = True\n    val1 = 0\n    val2 = 0\n    countOfVal1 = 0\n    countOfVal2 = 0\n    for itr in mapp:\n        i = itr\n        if (first):\n            val1 = i\n            first = False\n            countOfVal1 += 1\n            continue\n        if (i == val1):\n            countOfVal1 += 1\n            continue\n        if (second):\n            val2 = i\n            countOfVal2 += 1\n            second = False\n            continue\n        if (i == val2):\n            countOfVal2 += 1\n            continue\n    if (countOfVal1 > 1 and countOfVal2 > 1):\n        return False\n    else:\n        return True\n","test":"\nprint(checkForVariation(\"abcbc\"))\n","output":"True\n","fn_call":"checkForVariation"}
{"text":"pairs of complete strings in two sets of strings | returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ] ; con_s1 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in set1 [ i ] . similarly con_s2 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in set2 [ i ] ; process all strings in set1 [ ] ; initializing all bits to 0 ; setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; process all strings in set2 [ ] ; initializing all bits to 0 ; setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer . ; assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1 ; now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete . ; if all bits are set , the strings are complete ! ; ","context":"","code":"def countCompletePairs(set1, set2, n, m):\n    result = 0\n    con_s1, con_s2 = [0] * n, [0] * m\n    for i in range(n):\n        con_s1[i] = 0\n        for j in range(len(set1[i])):\n            con_s1[i] = con_s1[i] | (1 << (ord(set1[i][j]) - ord('a')))\n    for i in range(m):\n        con_s2[i] = 0\n        for j in range(len(set2[i])):\n            con_s2[i] = con_s2[i] | (1 << (ord(set2[i][j]) - ord('a')))\n    complete = (1 << 26) - 1\n    for i in range(n):\n        for j in range(m):\n            if ((con_s1[i] | con_s2[j]) == complete):\n                result += 1\n    return result\n","test":"\nif __name__ == '__main__':\n    set1 = [\"abcdefgh\", \"geeksforgeeks\", \"lmnopqrst\", \"abc\"]\n    set2 = [\n        \"ijklmnopqrstuvwxyz\",\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"defghijklmnopqrstuvwxyz\"]\n    n = len(set1)\n    m = len(set2)\n    print(countCompletePairs(set1, set2, n, m))\n","output":"7\n","fn_call":"countCompletePairs"}
{"text":"find all strings that match specific pattern in a dictionary | function to encode given string ; for each character in given string ; if the character is occurring for the first time , assign next unique number to that char ; append the number associated with current character into the output string ; function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; len is length of the pattern ; encode the string ; for each word in the dictionary array ; if size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word ; ","context":"","code":"def encodeString(Str):\n    map = {}\n    res = \"\"\n    i = 0\n    for ch in Str:\n        if ch not in map:\n            map[ch] = i\n            i += 1\n        res += str(map[ch])\n    return res\n\n\ndef findMatchedWords(dict, pattern):\n    Len = len(pattern)\n    hash = encodeString(pattern)\n    for word in dict:\n        if (len(word) == Len and encodeString(word) == hash):\n            print(word, end=\" \")\n","test":"\ndict = [\"abb\", \"abc\", \"xyz\", \"xyy\"]\npattern = \"foo\"\nfindMatchedWords(dict, pattern)\n","output":"abb xyy ","fn_call":"findMatchedWords"}
{"text":"find all strings that match specific pattern in a dictionary | python3 program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary ; len is length of the pattern ; for each word in the dictionary ; ","context":"","code":"def check(pattern, word):\n    if (len(pattern) != len(word)):\n        return False\n    ch = [0 for i in range(128)]\n    Len = len(word)\n    for i in range(Len):\n        if (ch[ord(pattern[i])] == 0):\n            ch[ord(pattern[i])] = word[i]\n        elif (ch[ord(pattern[i])] != word[i]):\n            return False\n    return True\n\n\ndef findMatchedWords(Dict, pattern):\n    Len = len(pattern)\n    for word in range(len(Dict) - 1, -1, -1):\n        if (check(pattern, Dict[word])):\n            print(Dict[word], end=\" \")\n","test":"\nDict = [\"abb\", \"abc\", \"xyz\", \"xyy\"]\npattern = \"foo\"\nfindMatchedWords(Dict, pattern)\n","output":"xyy abb ","fn_call":"findMatchedWords"}
{"text":"reverse words in a given string | reverse the string ; check if number of words is even ; find the middle word ; starting from the middle start swapping words at jth position and l - 1 - j position ; check if number of words is odd ; find the middle word ; starting from the middle start swapping the words at jth position and l - 1 - j position ; return the reversed sentence ; ","context":"","code":"def RevString(s, l):\n    if l % 2 == 0:\n        j = int(l \/ 2)\n        while (j <= l - 1):\n            s[j], s[l - j - 1] = s[l - j - 1], s[j]\n            j += 1\n    else:\n        j = int(l \/ 2 + 1)\n        while (j <= l - 1):\n            s[j], s[l - 1 - j] = s[l - j - 1], s[j]\n            j += 1\n        return s\n","test":"\ns = 'getting good at coding needs a lot of practice'\nstring = s .split(' ')\nstring = RevString(string, len(string))\nprint(\" \".join(string))\n","output":"practice of lot a needs coding at good getting\n","fn_call":"RevString"}
{"text":"print path from root to all nodes in a complete binary tree | function to print path of all the nodes nth node represent as given node kth node represents as left and right node ; base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return ; storing node into res ; print the path from root to node ; store left path of a tree so for left we will go node ( kthnode * 2 ) ; right path of a tree and for right we will go node ( kthnode * 2 + 1 ) ; function to print path from root to all of the nodes ; res is for store the path from root to particulate node ; print path from root to all node . third argument 1 because of we have to consider root node is 1 ; ","context":"","code":"def printPath(res, nThNode, kThNode):\n    if kThNode > nThNode:\n        return\n    res .append(kThNode)\n    for i in range(0, len(res)):\n        print(res[i], end=\" \")\n    print()\n    printPath(res[:], nThNode, kThNode * 2)\n    printPath(res[:], nThNode, kThNode * 2 + 1)\n\n\ndef printPathToCoverAllNodeUtil(nThNode):\n    res = []\n    printPath(res, nThNode, 1)\n","test":"\nif __name__ == \"__main__\":\n    nThNode = 7\n    printPathToCoverAllNodeUtil(nThNode)\n","output":"1 \n1 2 \n1 2 4 \n1 2 5 \n1 3 \n1 3 6 \n1 3 7 \n","fn_call":"printPathToCoverAllNodeUtil"}
{"text":"maximum number of region in which n non | function to find the maximum number of regions on a plane ; print the maximum number of regions ; ","context":"","code":"def maxRegions(n):\n    num = n * (n + 1) \/\/ 2 + 1\n    print(num)\n","test":"\nn = 10\nmaxRegions(n)\n","output":"56\n","fn_call":"maxRegions"}
{"text":"check whether jigsaw puzzle solveable or not | function to check if the jigsaw puzzle is solveable or not ; base case ; by placing the blank tabs as a chain ; ","context":"","code":"def checkSolveable(n, m):\n    if n == 1 or m == 1:\n        print(\"YES\")\n    elif m == 2 and n == 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","test":"\nif __name__ == \"__main__\":\n    n = 1\n    m = 3\n    checkSolveable(n, m)\n","output":"YES\n","fn_call":"checkSolveable"}
{"text":"check if it is possible to reach ( x , y ) from ( 1 , 0 ) by given steps | function to find the gcd of two numbers a and b ; base case ; recursively find the gcd ; function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves ; if gcd is 1 , then pr \" yes \" ; ","context":"","code":"def GCD(a, b):\n    if (b == 0):\n        return a\n    else:\n        return GCD(b, a % b)\n\n\ndef check(x, y):\n    if (GCD(x, y) == 1):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","test":"\nif __name__ == '__main__':\n    X = 2\n    Y = 7\n    check(X, Y)\n","output":"Yes\n","fn_call":"check"}
{"text":"largest odd divisor game to check which player wins | python3 implementation to find the largest odd divisor game to check which player wins ; function to find the largest odd divisor game to check which player wins ; check if n == 1 then player 2 will win ; check if n == 2 or n is odd ; while n is greater than k and divisible by 2 keep incrementing tha val ; loop to find greatest odd divisor ; check if n is a power of 2 ; check if cnt is not one then player 1 wins ; ","context":"\nimport math\n\n","code":"def findWinner(n, k):\n    cnt = 0\n    if (n == 1):\n        print(\"No\")\n    elif ((n & 1) or n == 2):\n        print(\"Yes\")\n    else:\n        tmp = n\n        val = 1\n        while (tmp > k and tmp % 2 == 0):\n            tmp \/\/= 2\n            val *= 2\n        for i in range(3, int(math .sqrt(tmp)) + 1):\n            while (tmp % i == 0):\n                cnt += 1\n                tmp \/\/= i\n        if (tmp > 1):\n            cnt += 1\n        if (val == n):\n            print(\"No\")\n        elif (n \/ tmp == 2 and cnt == 1):\n            print(\"No\")\n        else:\n            print(\"Yes\")\n","test":"\nif __name__ == \"__main__\":\n    n = 1\n    k = 1\n    findWinner(n, k)\n","output":"No\n","fn_call":"findWinner"}
{"text":"find all numbers up to n which are both pentagonal and hexagonal | python3 program of the above approach ; function to print numbers upto n which are both pentagonal as well as hexagonal numbers ; calculate i - th pentagonal number ; check if the pentagonal number pn is hexagonal or not ; ","context":"\nimport math\n\n","code":"def pen_hex(n):\n    pn = 1\n    for i in range(1, N):\n        pn = (int)(i * (3 * i - 1) \/ 2)\n        if (pn > n):\n            break\n        seqNum = (1 + math .sqrt(8 * pn + 1)) \/ 4\n        if (seqNum == (int)(seqNum)):\n            print(pn, end=\", \")\n","test":"\nN = 1000000\npen_hex(N)\n","output":"1, 40755, ","fn_call":"pen_hex"}
{"text":"check if row | function to check if row - major order traversal of the matrix is is palindrome ; loop to check if the matrix is matrix is palindrome or not ; ","context":"","code":"def isPal(a, n, m):\n    for i in range(0, n \/\/ 2):\n        for j in range(0, m - 1):\n            if (a[i][j] != a[n - 1 - i][m - 1 - j]):\n                return False\n    return True\n","test":"\nif __name__ == '__main__':\n    n = 3\n    m = 3\n    a = [[1, 2, 3], [4, 5, 4], [3, 2, 1]]\n    if (isPal(a, n, m)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"isPal"}
{"text":"find the smallest number whose sum of digits is n | function to get sum of digits ; function to find the smallest number whose sum of digits is also n ; checking if number has sum of digits = n ; ","context":"","code":"def getSum(n):\n    sum1 = 0\n    while (n != 0):\n        sum1 = sum1 + n % 10\n        n = n \/\/ 10\n    return sum1\n\n\ndef smallestNumber(N):\n    i = 1\n    while (1):\n        if (getSum(i) == N):\n            print(i)\n            break\n        i += 1\n","test":"\nN = 10\nsmallestNumber(N)\n","output":"19\n","fn_call":"smallestNumber"}
{"text":"rare numbers | python3 implementation to check if n is a rare number ; iterative function to reverse digits of num ; function to check if n is perfect square ; find floating point value of square root of x . ; if square root is an integer ; function to check if n is an rare number ; find reverse of n ; number should be non - palindromic ; ","context":"\nimport math\n\n","code":"def reversDigits(num):\n    rev_num = 0\n    while (num > 0):\n        rev_num = rev_num * 10 + num % 10\n        num = num \/\/ 10\n    return rev_num\n\n\ndef isPerfectSquare(x):\n    sr = math .sqrt(x)\n    return ((sr - int(sr)) == 0)\n\n\ndef isRare(N):\n    reverseN = reversDigits(N)\n    if (reverseN == N):\n        return False\n    return (isPerfectSquare(N + reverseN) and isPerfectSquare(N - reverseN))\n","test":"\nN = 65\nif (isRare(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n","output":"Yes\n","fn_call":"isRare"}
{"text":"count numbers from range whose prime factors are only 2 and 3 using arrays | set 2 | function which will calculate the elements in the given range ; store the current power of 2 ; store the current power of 3 ; power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r ; insert in power23 ] [ ] only if mul <= r ; store the required answer ; print the result ; ","context":"","code":"def calc_ans(l, r):\n    power2 = []\n    power3 = []\n    mul2 = 1\n    while (mul2 <= r):\n        power2 .append(mul2)\n        mul2 *= 2\n    mul3 = 1\n    while (mul3 <= r):\n        power3 .append(mul3)\n        mul3 *= 3\n    power23 = []\n    for x in range(len(power2)):\n        for y in range(len(power3)):\n            mul = power2[x] * power3[y]\n            if (mul == 1):\n                continue\n            if (mul <= r):\n                power23 .append(mul)\n    ans = 0\n    for x in power23:\n        if (x >= l and x <= r):\n            ans += 1\n    print(ans)\n","test":"\nif __name__ == \"__main__\":\n    l = 1\n    r = 10\n    calc_ans(l, r)\n","output":"6\n","fn_call":"calc_ans"}
{"text":"count of k length subsequence whose product is even | function to calculate ncr ; returns factorial of n ; function for finding number of k length subsequences whose product is even number ; counting odd numbers in the array ; ","context":"","code":"def nCr(n, r):\n    if (r > n):\n        return 0\n    return fact(n) \/\/ (fact(r) * fact(n - r))\n\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef countSubsequences(arr, n, k):\n    countOdd = 0\n    for i in range(n):\n        if (arr[i] & 1):\n            countOdd += 1\n    ans = nCr(n, k) - nCr(countOdd, k)\n    return ans\n","test":"\narr = [2, 4]\nK = 1\nN = len(arr)\nprint(countSubsequences(arr, N, K))\n","output":"2\n","fn_call":"countSubsequences"}
{"text":"find most significant bit of a number x in base y | python3 program to find the first digit of x in base y ; function to find the first digit of x in base y ; calculating number of digits of x in base y ; finding first digit of x in base y ; ","context":"\nimport math\n\n","code":"def first_digit(x, y):\n    length = int(math .log(x) \/ math .log(y) + 1)\n    first_digit = x \/ math .pow(y, length - 1)\n    print(int(first_digit))\n","test":"\nX = 55\nY = 3\nfirst_digit(X, Y)\n","output":"2\n","fn_call":"first_digit"}
{"text":"curzon numbers | function to check if a number is a curzon number or not ; find 2 ^ n + 1 ; find 2 * n + 1 ; check for divisibility ; ","context":"","code":"def checkIfCurzonNumber(N):\n    powerTerm, productTerm = 0, 0\n    powerTerm = pow(2, N) + 1\n    productTerm = 2 * N + 1\n    if (powerTerm % productTerm == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","test":"\nif __name__ == '__main__':\n    N = 5\n    checkIfCurzonNumber(N)\n    N = 10\n    checkIfCurzonNumber(N)\n","output":"Yes\nNo\n","fn_call":"checkIfCurzonNumber"}
{"text":"minimum count of numbers required ending with 7 to sum as a given number | function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n ; hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i ; its always possible to write numbers > 69 to write as numbers ending with 7 ; if the number is atleast equal to the sum of minimum numbers ending with 7 ; ","context":"","code":"def minCount(n):\n    hasharr = [10, 3, 6, 9, 2, 5, 8, 1, 4, 7]\n    if (n > 69):\n        return hasharr[n % 10]\n    else:\n        if (n >= hasharr[n % 10] * 7):\n            return hasharr[n % 10]\n        else:\n            return -1\n","test":"\nn = 38\nprint(minCount(n))\n","output":"4\n","fn_call":"minCount"}
{"text":"program to print modified binary triangle pattern | function to print the modified binary pattern ; loop to traverse the rows ; loop to traverse the numbers in each row ; check if j is 1 or i in either case print 1 ; else print 0 ; change the cursor to next line after each row ; ","context":"","code":"def modifiedBinaryPattern(n):\n    for i in range(1, n + 1, 1):\n        for j in range(1, i + 1, 1):\n            if (j == 1 or j == i):\n                print(1, end=\"\")\n            else:\n                print(0, end=\"\")\n        print('', end=\"\")\n","test":"\nif __name__ == '__main__':\n    n = 7\n    modifiedBinaryPattern(n)\n","output":"1111011001100011000011000001","fn_call":"modifiedBinaryPattern"}
{"text":"find the real and imaginary part of a complex number | function to find real and imaginary parts of a complex number ; string length stored in variable l ; variable for the index of the separator ; storing the index of '+ ; else storing the index of '- ; finding the real part of the complex number ; finding the imaginary part of the complex number ; ","context":"","code":"def findRealAndImag(s):\n    l = len(s)\n    i = 0\n    if (s.find('+') != -1):\n        i = s.find('+')\n    else:\n        i = s.find('-')\n    real = s[:i]\n    imaginary = s[i + 1:l - 1]\n\n    print(\"Real part:\", real)\n    print(\"Imaginary part:\", imaginary)\n","test":"\ns = \"3+4i\"\n\nfindRealAndImag(s)\n","output":"Real part: 3\nImaginary part: 4\n","fn_call":"findRealAndImag"}
{"text":"distinct powers of a number n such that the sum is equal to k | python 3 implementation to find distinct powers of n that add up to k ; function to return the highest power of n not exceeding k ; loop to find the highest power less than k ; initializing the powerarray with all 0 's. ; function to print the distinct powers of n that add upto k ; getting the highest power of n before k ; to check if the power is being used twice or not ; print - 1 if power is being used twice ; if the power is not visited , then mark the power as visited ; decrementing the value of k ; printing the powers of n that sum up to k ; ","context":"\nfrom math import pow\n\n","code":"def highestPower(n, k):\n    i = 0\n    a = pow(n, i)\n    while (a <= k):\n        i += 1\n        a = pow(n, i)\n    return i - 1\n\n\nb = [0 for i in range(50)]\n\n\ndef PowerArray(n, k):\n    while (k):\n        t = highestPower(n, k)\n        if (b[t]):\n            print(-1)\n            return 0\n        else:\n            b[t] = 1\n        k -= pow(n, t)\n    for i in range(50):\n        if (b[i]):\n            print(i, end=', ')\n","test":"\nif __name__ == '__main__':\n    N = 3\n    K = 40\n    PowerArray(N, K)\n","output":"0, 1, 2, 3, ","fn_call":"PowerArray"}
{"text":"sum of elements in an array having composite frequency | python3 program to find sum of elements in an array having composite frequency ; function to create sieve to check primes ; if composite [ p ] is not changed , then it is a prime ; update all multiples of p , set them to composite ; function to return the sum of elements in an array having composite frequency ; map is used to store element frequencies ; to store sum ; traverse the map using iterators ; count the number of elements having composite frequencies ; ","context":"\nN = 100005\n\n","code":"def SieveOfEratosthenes(composite):\n    for p in range(2, N):\n        if p * p > N:\n            break\n        if (composite[p] == False):\n            for i in range(2 * p, N, p):\n                composite[i] = True\n\n\ndef sumOfElements(arr, n):\n    composite = [False] * N\n    SieveOfEratosthenes(composite)\n    m = dict()\n    for i in range(n):\n        m[arr[i]] = m .get(arr[i], 0) + 1\n    sum = 0\n    for it in m:\n        if (composite[m[it]]):\n            sum += (it)\n    return sum\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 1, 1, 1, 3, 3, 2, 4]\n    n = len(arr)\n    print(sumOfElements(arr, n))\n","output":"1\n","fn_call":"sumOfElements"}
{"text":"delete all odd frequency elements from an array | function that removes the elements which have odd frequencies in the array ; create a map to store the frequency of each element ; remove the elements which have odd frequencies ; if the element has odd frequency then skip ; ","context":"","code":"def remove(arr, n):\n    m = dict .fromkeys(arr, 0)\n    for i in range(n):\n        m[arr[i]] += 1\n    for i in range(n):\n        if ((m[arr[i]] & 1)):\n            continue\n        print(arr[i], end=\", \")\n","test":"\nif __name__ == \"__main__\":\n    arr = [3, 3, 3, 2, 2, 4, 7, 7]\n    n = len(arr)\n    remove(arr, n)\n","output":"2, 2, 7, 7, ","fn_call":"remove"}
{"text":"maximize the first element of the array such that average remains constant | maximum value of the first array element that can be attained ; variable to store the sum ; loop to find the sum of array ; desired maximum value ; ","context":"","code":"def getmax(arr, n, x):\n    s = 0\n    for i in range(n):\n        s = s + arr[i]\n    print(min(s, x))\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    x = 5\n    arr_size = len(arr)\n    getmax(arr, arr_size, x)\n","output":"5\n","fn_call":"getmax"}
{"text":"minimum length of the shortest path of a triangle | function to get the minimum length of the shorter side of the triangle ; traversing through each points on the plane ; if sum of a points is greater than the previous one , the maximum gets replaced ; print the length ; ","context":"","code":"def shortestLength(n, x, y):\n    answer = 0\n    i = 0\n    while n > 0:\n        if (x[i] + y[i] > answer):\n            answer = x[i] + y[i]\n        i += 1\n        n -= 1\n    print(\"Length -> \" + str(answer))\n    print(\"Path -> \" + \"( 1, \" + str(answer) + \" )\" +\n          \"and ( \" + str(answer) + \", 1 )\")\n","test":"\nif __name__ == \"__main__\":\n    n = 4\n    x = [1, 4, 2, 1]\n    y = [4, 1, 1, 2]\n    shortestLength(n, x, y)\n","output":"Length -> 5\nPath -> ( 1, 5 )and ( 5, 1 )\n","fn_call":"shortestLength"}
{"text":"intersecting rectangle when bottom | function to find intersection rectangle of given two rectangles . ; gives bottom - left point of intersection rectangle ; gives top - right point of intersection rectangle ; no intersection ; gives top - left point of intersection rectangle ; gives bottom - right point of intersection rectangle ; ","context":"","code":"def FindPoints(x1, y1, x2, y2, x3, y3, x4, y4):\n    x5 = max(x1, x3)\n    y5 = max(y1, y3)\n    x6 = min(x2, x4)\n    y6 = min(y2, y4)\n    if (x5 > x6 or y5 > y6):\n        print(\"No intersection\")\n        return\n    print(\"(\", x5, \", \", y5, \") \", end=\" \")\n    print(\"(\", x6, \", \", y6, \") \", end=\" \")\n    x7 = x5\n    y7 = y6\n    print(\"(\", x7, \", \", y7, \") \", end=\" \")\n    x8 = x6\n    y8 = y5\n    print(\"(\", x8, \", \", y8, \") \")\n","test":"\nif __name__ == \"__main__\":\n    x1 = 0\n    y1 = 0\n    x2 = 10\n    y2 = 8\n    x3 = 2\n    y3 = 3\n    x4 = 7\n    y4 = 9\n    FindPoints(x1, y1, x2, y2, x3, y3, x4, y4)\n","output":"( 2 ,  3 )  ( 7 ,  8 )  ( 2 ,  8 )  ( 7 ,  3 ) \n","fn_call":"FindPoints"}
{"text":"find corners of rectangle using mid points | python3 program to find corner points of a rectangle using given length and middle points . ; structure to represent a co - ordinate point ; this function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle ; horizontal rectangle ; vertical rectangle ; slanted rectangle ; calculate slope of the side ; calculate displacements along axes ; ","context":"\nimport math\n\n\nclass Point:\n    def __init__(self, a=0, b=0):\n        self .x = a\n        self .y = b\n\n","code":"def printCorners(p, q, l):\n    a, b, c, d = Point(), Point(), Point(), Point()\n    if (p .x == q .x):\n        a .x = p .x - (l \/ 2.0)\n        a .y = p .y\n        d .x = p .x + (l \/ 2.0)\n        d .y = p .y\n        b .x = q .x - (l \/ 2.0)\n        b .y = q .y\n        c .x = q .x + (l \/ 2.0)\n        c .y = q .y\n    elif (p .y == q .y):\n        a .y = p .y - (l \/ 2.0)\n        a .x = p .x\n        d .y = p .y + (l \/ 2.0)\n        d .x = p .x\n        b .y = q .y - (l \/ 2.0)\n        b .x = q .x\n        c .y = q .y + (l \/ 2.0)\n        c .x = q .x\n    else:\n        m = (p .x - q .x) \/ (q .y - p .y)\n        dx = (l \/ math .sqrt(1 + (m * m))) * 0.5\n        dy = m * dx\n        a .x = p .x - dx\n        a .y = p .y - dy\n        d .x = p .x + dx\n        d .y = p .y + dy\n        b .x = q .x - dx\n        b .y = q .y - dy\n        c .x = q .x + dx\n        c .y = q .y + dy\n    print(int(a .x), \", \", int(a .y), sep=\"\")\n    print(int(b .x), \", \", int(b .y), sep=\"\")\n    print(int(c .x), \", \", int(c .y), sep=\"\")\n    print(int(d .x), \", \", int(d .y), sep=\"\")\n    print()\n","test":"\np1 = Point(1, 0)\nq1 = Point(1, 2)\nprintCorners(p1, q1, 2)\np = Point(1, 1)\nq = Point(-1, -1)\nprintCorners(p, q, 2 * math .sqrt(2))\n","output":"0, 0\n0, 2\n2, 2\n2, 0\n\n0, 2\n-2, 0\n0, -2\n2, 0\n\n","fn_call":"printCorners"}
{"text":"minimize cost to modify the array such that even indices have even elements and vice versa | function to find the minimum cost to modify the array according to the given criteria ; count of wrong positioned odd and even elements ; odd count ; even count ; swapping cost ; decrementing cost after swapping ; only decrementing cost ; return the minimum cost of the two cases ; ","context":"","code":"def minimumCost(arr, N, X, Y):\n    even_count = 0\n    odd_count = 0\n    for i in range(0, N):\n        if ((arr[i] & 1) and (i % 2 == 0)):\n            odd_count += 1\n        if ((arr[i] % 2) == 0 and (i & 1)):\n            even_count += 1\n    cost1 = X * min(odd_count, even_count)\n    cost2 = Y * (max(odd_count, even_count) - min(odd_count, even_count))\n    cost3 = (odd_count + even_count) * Y\n    return min(cost1 + cost2, cost3)\n","test":"\nif __name__ == \"__main__\":\n    arr = [5, 3, 7, 2, 1]\n    X = 10\n    Y = 2\n    N = len(arr)\n    print(minimumCost(arr, N, X, Y))\n","output":"8\n","fn_call":"minimumCost"}
{"text":"minimum product of maximum and minimum element over all possible subarrays | function to find the minimum product of the minimum and maximum among all the possible subarrays ; stores resultant minimum product ; traverse the given array arr [ ] ; min of product of all two pair of consecutive elements ; return the resultant value ; ","context":"","code":"def findMinMax(a):\n    min_val = 1000000000\n    for i in range(1, len(a)):\n        min_val = min(min_val, a[i] * a[i - 1])\n    return min_val\n","test":"\nif __name__ == (\"__main__\"):\n    arr = [6, 4, 5, 6, 2, 4, 1]\n    print(findMinMax(arr))\n","output":"4\n","fn_call":"findMinMax"}
{"text":"find nth item distributed from infinite items of infinite types based on given conditions | function to find the type of the item given out according to the given rules ; stores the count of item given out at each step ; iterate over the days from 1 ; iterate over type of item on that day ; count of items given out should exceed n ; ","context":"","code":"def itemType(n):\n    count = 0\n    day = 1\n    while (True):\n        for type in range(day, 0, -1):\n            count += type\n            if (count >= n):\n                return type\n","test":"\nN = 10\nprint(itemType(N))\n","output":"1\n","fn_call":"itemType"}
{"text":"find the sum of all array elements that are equidistant from two consecutive powers of 2 | python3 program for the above approach ; function to prthe sum of array elements that are equidistant from two consecutive powers of 2 ; stores the resultant sum of the array elements ; traverse the array arr [ ] ; stores the power of 2 of the number arr [ i ] ; stores the number which is power of 2 and lesser than or equal to arr [ i ] ; stores the number which is power of 2 and greater than or equal to arr [ i ] ; if arr [ i ] - lesservalue is the same as largervalue - arr [ i ] ; increment res by arr [ i ] ; return the resultant sum res ; ","context":"\nfrom math import log2\n\n","code":"def FindSum(arr, N):\n    res = 0\n    for i in range(N):\n        power = int(log2(arr[i]))\n        LesserValue = pow(2, power)\n        LargerValue = pow(2, power + 1)\n        if ((arr[i] - LesserValue) == (LargerValue - arr[i])):\n            res += arr[i]\n    return res\n","test":"\nif __name__ == '__main__':\n    arr = [10, 24, 17, 3, 8]\n    N = len(arr)\n    print(FindSum(arr, N))\n","output":"27\n","fn_call":"FindSum"}
{"text":"find the person who will finish last | function to find the person who will finish last ; to keep track of rows and columns having 1 ; available rows and columns ; minimum number of choices we have ; if number of choices are odd ; p1 will finish last ; otherwise , p2 will finish last ; ","context":"","code":"def findLast(mat):\n    m = len(mat)\n    n = len(mat[0])\n    rows = set()\n    cols = set()\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j]:\n                rows .add(i)\n                cols .add(j)\n    avRows = m - len(list(rows))\n    avCols = n - len(list(cols))\n    choices = min(avRows, avCols)\n    if choices & 1:\n        print('P1')\n    else:\n        print('P2')\n","test":"\nmat = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\nfindLast(mat)\n","output":"P1\n","fn_call":"findLast"}
{"text":"sum of decimals that are binary representations of first n natural numbers | python3 program for the above approach ; function to find the sum of first n natural numbers represented in binary representation ; stores the resultant sum ; iterate until the value of n is greater than 0 ; if n is less than 2 ; store the msb position of n ; iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 ) ; update the value of the cur and add ; add the cur to ans ; store the remaining numbers ; add the contribution by msb by the remaining numbers ; the next iteration will be repeated for 2 ^ x - 1 ; print the result ; ","context":"\nfrom math import log2, pow\nMOD = 1000000007\n\n","code":"def sumOfBinaryNumbers(n):\n    ans = 0\n    one = 1\n    while (1):\n        if (n <= 1):\n            ans = (ans + n) % MOD\n            break\n        x = int(log2(n))\n        cur = 0\n        add = (one << (x - 1))\n        for i in range(1, x + 1, 1):\n            cur = (cur + add) % MOD\n            add = (add * 10 % MOD)\n        ans = (ans + cur) % MOD\n        rem = n - (one << x) + 1\n        p = pow(10, x)\n        p = (p * (rem % MOD)) % MOD\n        ans = (ans + p) % MOD\n        n = rem - 1\n    print(int(ans))\n","test":"\nif __name__ == '__main__':\n    N = 3\n    sumOfBinaryNumbers(N)\n","output":"22\n","fn_call":"sumOfBinaryNumbers"}
{"text":"nearest fibonacci number to n | function to find the fibonacci number which is nearest to n ; base case ; initialize the first & second terms of the fibonacci series ; store the third term ; iterate until the third term is less than or equal to num ; update the first ; update the second ; update the third ; store the fibonacci number having smaller difference with n ; print the result ; ","context":"","code":"def nearestFibonacci(num):\n    if (num == 0):\n        print(0)\n        return\n    first = 0\n    second = 1\n    third = first + second\n    while (third <= num):\n        first = second\n        second = third\n        third = first + second\n    if (abs(third - num) >= abs(second - num)):\n        ans = second\n    else:\n        ans = third\n    print(ans)\n","test":"\nif __name__ == '__main__':\n    N = 17\n    nearestFibonacci(N)\n","output":"13\n","fn_call":"nearestFibonacci"}
{"text":"permutation of first n natural numbers having given array as the prefix maximum array | python3 program for the above approach ; function to check if the maximum prefix array of ans [ ] is equal to array arr [ ] ; initialize a variable , max ; traverse the array , ans [ ] ; store the maximum value upto index i ; if it is not equal to a [ i ] , then return false ; otherwise return false ; function to find the permutation of the array whose prefix maximum array is same as the given array a [ ] ; stores the required permutation ; stores the index of first occurrence of elements ; traverse the array a [ ] ; if a [ i ] is not present in um , then store it in um ; update the ans [ i ] to a [ i ] ; stores the unvisited numbers ; fill the array , v [ ] ; store the index ; traverse the array , ans [ ] ; fill v [ j ] at places where ans [ i ] is 0 ; check if the current permutation maximum prefix array is same as the given array a [ ] ; if true , the print the permutation ; otherwise , print - 1 ; ","context":"\nimport sys\n\n","code":"def checkPermutation(ans, a, n):\n    Max = -sys .maxsize - 1\n    for i in range(n):\n        Max = max(Max, ans[i])\n        if (Max != a[i]):\n            return False\n    return True\n\n\ndef findPermutation(a, n):\n    ans = [0] * n\n    um = {}\n    for i in range(n):\n        if (a[i]not in um):\n            ans[i] = a[i]\n            um[a[i]] = i\n    v = []\n    j = 0\n    for i in range(1, n + 1):\n        if (i not in um):\n            v .append(i)\n    for i in range(n):\n        if (ans[i] == 0):\n            ans[i] = v[j]\n            j += 1\n    if (checkPermutation(ans, a, n)):\n        for i in range(n):\n            print(ans[i], end=\" \")\n    else:\n        print(\"-1\")\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 3, 4, 5, 5]\n    N = len(arr)\n    findPermutation(arr, N)\n","output":"1 3 4 5 2 ","fn_call":"findPermutation"}
{"text":"count pairs of equal elements possible by excluding each array element once | function to count the number of required pairs for every array element ; initialize a map ; update the frequency of every element ; stores the count of pairs ; traverse the map ; count the number of ways to select pairs consisting of equal elements only ; traverse the array ; print the count for every array element ; ","context":"","code":"def countEqualElementPairs(arr, N):\n    mp = {}\n    for i in range(N):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n    total = 0\n    for key, value in mp .items():\n        total += (value * (value - 1)) \/ 2\n    for i in range(N):\n        print(int(total - (mp[arr[i]] - 1)), end=\" \")\n","test":"\nif __name__ == '__main__':\n    arr = [1, 1, 2, 1, 2]\n    N = len(arr)\n    countEqualElementPairs(arr, N)\n","output":"2 2 3 2 3 ","fn_call":"countEqualElementPairs"}
{"text":"count of octal numbers upto n digits | function to return the count of natural octal numbers upto n digits ; loop to iterate from 1 to n and calculating number of octal numbers for every ' i ' th digit . ; ","context":"","code":"def count(N):\n    sum = 0\n    for i in range(N + 1):\n        sum += 7 * (8 ** (i - 1))\n    return int(sum)\n","test":"\nif __name__ == \"__main__\":\n    N = 4\n    print(count(N))\n","output":"4095\n","fn_call":"count"}
{"text":"palindromic divisors of a number | python3 program to find all the palindromic divisors of a number ; function to check is num is palindromic or not ; convert n to string str ; starting and ending index of string str ; if char at s and e are not equals then return false ; function to find palindromic divisors ; to sore the palindromic divisors of number n ; if n is divisible by i ; check if number is a perfect square ; check divisor is palindromic , then store it ; check if divisors are palindrome ; check if n \/ divisors is palindromic or not ; print all palindromic divisors in sorted order ; ","context":"\nfrom math import sqrt\n\n","code":"def isPalindrome(n):\n    string = str(n)\n    s = 0\n    e = len(string) - 1\n    while (s < e):\n        if (string[s] != string[e]):\n            return False\n        s += 1\n        e -= 1\n    return True\n\n\ndef palindromicDivisors(n):\n    PalindromDivisors = []\n    for i in range(1, int(sqrt(n))):\n        if (n % i == 0):\n            if (n \/\/ i == i):\n                if (isPalindrome(i)):\n                    PalindromDivisors .append(i)\n            else:\n                if (isPalindrome(i)):\n                    PalindromDivisors .append(i)\n                if (isPalindrome(n \/\/ i)):\n                    PalindromDivisors .append(n \/\/ i)\n    PalindromDivisors .sort()\n    for i in range(len(PalindromDivisors)):\n        print(PalindromDivisors[i], end=\" \")\n","test":"\nif __name__ == \"__main__\":\n    n = 66\n    palindromicDivisors(n)\n","output":"1 2 3 6 11 22 33 66 ","fn_call":"palindromicDivisors"}
{"text":"remove minimum numbers from the array to get minimum or value | python3 implementation of the approach ; function to return the minimum deletions to get minimum or ; to store the minimum element ; find the minimum element from the array ; to store the frequency of the minimum element ; find the frequency of the minimum element ; return the final answer ; ","context":"\nimport sys\n\n","code":"def findMinDel(arr, n):\n    min_num = sys .maxsize\n    for i in range(n):\n        min_num = min(arr[i], min_num)\n    cnt = 0\n    for i in range(n):\n        if (arr[i] == min_num):\n            cnt += 1\n    return n - cnt\n","test":"\nif __name__ == \"__main__\":\n    arr = [3, 3, 2]\n    n = len(arr)\n    print(findMinDel(arr, n))\n","output":"2\n","fn_call":"findMinDel"}
{"text":"program to print prime numbers from 1 to n . | function to print first n prime numbers ; declare the variables ; print display message ; traverse each number from 1 to n with the help of for loop ; skip 0 and 1 as they are neither prime nor composite ; flag variable to tell if i is prime or not ; flag = 1 means i is prime and flag = 0 means i is not prime ; ","context":"","code":"def print_primes_till_N(N):\n    i, j, flag = 0, 0, 0\n    print(\"Prime numbers between 1 and \", N, \" are:\")\n    for i in range(1, N + 1, 1):\n        if (i == 1 or i == 0):\n            continue\n        flag = 1\n        for j in range(2, ((i \/\/ 2) + 1), 1):\n            if (i % j == 0):\n                flag = 0\n                break\n        if (flag == 1):\n            print(i, end=\" \")\n","test":"\nN = 100\nprint_primes_till_N(N)\n","output":"Prime numbers between 1 and  100  are:\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 ","fn_call":"print_primes_till_N"}
{"text":"maximize the expression ( a and x ) * ( b and x ) | bit manipulation | python3 implementation of the approach ; function to find x according to the given conditions ; int can have 32 bits ; temporary ith bit ; compute ith bit of x according to given conditions expression below is the direct conclusion from the illustration we had taken earlier ; add the ith bit of x to x ; ","context":"\nMAX = 32\n\n","code":"def findX(A, B):\n    X = 0\n    for bit in range(MAX):\n        tempBit = 1 << bit\n        bitOfX = A & B & tempBit\n        X += bitOfX\n    return X\n","test":"\nif __name__ == \"__main__\":\n    A = 11\n    B = 13\n    print(findX(A, B))\n","output":"9\n","fn_call":"findX"}
{"text":"number of subsets whose mean is maximum | function to return the count of subsets with the maximum mean ; maximum value from the array ; to store the number of times maximum element appears in the array ; return the count of valid subsets ; ","context":"","code":"def cntSubSets(arr, n):\n    maxVal = max(arr)\n    cnt = 0\n    for i in range(n):\n        if (arr[i] == maxVal):\n            cnt += 1\n    return ((2 ** cnt) - 1)\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 2, 1, 2]\n    n = len(arr)\n    print(cntSubSets(arr, n))\n","output":"3\n","fn_call":"cntSubSets"}
{"text":"probability that a random pair chosen from an array ( a [ i ] , a [ j ] ) has the maximum sum | python3 implementation of the approach ; function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array ; initialize the maximum sum , its count and the count of total pairs ; for every single pair ; get the sum of the current pair ; if the sum is equal to the current maximum sum so far ; increment its count ; if the sum is greater than the current maximum ; update the current maximum and re - initialize the count to 1 ; find the required probability ; ","context":"\nimport sys\n\n","code":"def findProb(arr, n):\n    maxSum = -(sys .maxsize - 1)\n    maxCount = 0\n    totalPairs = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            sum = arr[i] + arr[j]\n            if (sum == maxSum):\n                maxCount += 1\n            elif (sum > maxSum):\n                maxSum = sum\n                maxCount = 1\n            totalPairs += 1\n    prob = maxCount \/ totalPairs\n    return prob\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 1, 1, 2, 2, 2]\n    n = len(arr)\n    print(findProb(arr, n))\n","output":"0.2\n","fn_call":"findProb"}
{"text":"maximum count of common divisors of a and b such that all are co | python3 implementation of the approach ; function to return the count of common factors of a and b such that all the elements are co - prime to one another ; gcd of a and b ; include 1 initially ; find all the prime factors of the gcd ; if gcd is prime ; return the required answer ; ","context":"\nimport math\n\n","code":"def maxCommonFactors(a, b):\n    gcd = math .gcd(a, b)\n    ans = 1\n    i = 2\n    while (i * i <= gcd):\n        if (gcd % i == 0):\n            ans += 1\n            while (gcd % i == 0):\n                gcd = gcd \/\/ i\n        i += 1\n    if (gcd != 1):\n        ans += 1\n    return ans\n","test":"\na = 12\nb = 18\nprint(maxCommonFactors(a, b))\n","output":"3\n","fn_call":"maxCommonFactors"}
{"text":"find the day number in the current year for the given date | python3 implementation of the approach ; function to return the day number of the year for the given date ; extract the year , month and the day from the date string ; if current year is a leap year and the date given is after the 28 th of february then it must include the 29 th february ; add the days in the previous months ; ","context":"\ndays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n","code":"def dayOfYear(date):\n    year = (int)(date[0:4])\n    month = (int)(date[5:7])\n    day = (int)(date[8:])\n    if (month > 2 and year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)):\n        day += 1\n    month -= 1\n    while (month > 0):\n        day = day + days[month - 1]\n        month -= 1\n    return day\n","test":"\nif __name__ == '__main__':\n    date = \"2019-01-09\"\n    print(dayOfYear(date))\n","output":"9\n","fn_call":"dayOfYear"}
{"text":"find the number of cells in the table contains x | function to find number of cells in the table contains x ; ","context":"","code":"def Cells(n, x):\n    ans = 0\n    for i in range(1, n + 1):\n        if (x % i == 0 and x \/ i <= n):\n            ans += 1\n    return ans\n","test":"\nif __name__ == '__main__':\n    n = 6\n    x = 12\n    print(Cells(n, x))\n","output":"4\n","fn_call":"Cells"}
{"text":"smallest power of 4 greater than or equal to n | python3 implementation of above approach ; function to return the smallest power of 4 greater than or equal to n ; if n is itself is a power of 4 then return n ; ","context":"\nimport math\n\n","code":"def nextPowerOfFour(n):\n    x = math .floor((n ** (1 \/ 2))**(1 \/ 2))\n    if ((x ** 4) == n):\n        return n\n    else:\n        x = x + 1\n        return (x ** 4)\n","test":"\nn = 122\nprint(nextPowerOfFour(n))\n","output":"256\n","fn_call":"nextPowerOfFour"}
{"text":"minimum operations required to convert x to y by multiplying x with the given co | function to return the minimum operations required ; not possible ; to store the greatest power of p that divides d ; while divible by p ; to store the greatest power of q that divides d ; while divible by q ; if d > 1 ; since , d = p ^ a * q ^ b ; ","context":"","code":"def minOperations(x, y, p, q):\n    if (y % x != 0):\n        return -1\n    d = y \/\/ x\n    a = 0\n    while (d % p == 0):\n        d \/\/= p\n        a += 1\n    b = 0\n    while (d % q == 0):\n        d \/\/= q\n        b += 1\n    if (d != 1):\n        return -1\n    return (a + b)\n","test":"\nx = 12\ny = 2592\np = 2\nq = 3\nprint(minOperations(x, y, p, q))\n","output":"6\n","fn_call":"minOperations"}
{"text":"number of quadruples with gcd equal to k | python3 implementation of the approach ; function to calculate nc4 ; base case to calculate nc4 ; function to return the count of required quadruples using inclusion exclusion ; effective n ; iterate over 2 to m ; number of divisors of i till m ; count stores the number of prime divisors occurring exactly once ; to prevent repetition of prime divisors ; if repetition of prime divisors present ignore this number ; if prime divisor count is odd subtract it from answer else add ; ","context":"\nfrom math import sqrt\n\n","code":"def nCr(n):\n    if (n < 4):\n        return 0\n    answer = n * (n - 1) * (n - 2) * (n - 3)\n    answer \/\/= 24\n    return answer\n\n\ndef countQuadruples(N, K):\n    M = N \/\/ K\n    answer = nCr(M)\n    for i in range(2, M):\n        j = i\n        temp2 = M \/\/ i\n        count = 0\n        check = 0\n        temp = j\n        while (j % 2 == 0):\n            count += 1\n            j \/\/= 2\n            if (count >= 2):\n                break\n        if (count >= 2):\n            check = 1\n        for k in range(3, int(sqrt(temp)), 2):\n            cnt = 0\n            while (j % k == 0):\n                cnt += 1\n                j \/\/= k\n                if (cnt >= 2):\n                    break\n            if (cnt >= 2):\n                check = 1\n                break\n            elif (cnt == 1):\n                count += 1\n        if (j > 2):\n            count += 1\n        if (check):\n            continue\n        else:\n            if (count % 2 == 1):\n                answer -= nCr(temp2)\n            else:\n                answer += nCr(temp2)\n    return answer\n","test":"\nif __name__ == \"__main__\":\n    N = 10\n    K = 2\n    print(countQuadruples(N, K))\n","output":"5\n","fn_call":"countQuadruples"}
{"text":"find the number which when added to the given ratio a : b , the ratio changes to c : d | function to return the required number x ; ","context":"","code":"def getX(a, b, c, d):\n    X = (b * c - a * d) \/\/ (d - c)\n    return X\n","test":"\na = 2\nb = 3\nc = 4\nd = 5\nprint(getX(a, b, c, d))\n","output":"2\n","fn_call":"getX"}
{"text":"number of ways to arrange a word such that no vowels occur together | function to check if a character is vowel or consonent ; function to calculate factorial of a number ; calculating no of ways for arranging vowels ; iterate the map and count the number of vowels and calculate no of ways to arrange vowels ; calculating no of ways to arrange the given word such that vowels come together ; calculate no of ways to arrange vowels ; to store denominator of fraction ; count of consonents ; calculate the number of ways to arrange the word such that vowels come together ; to calculate total number of permutations ; to store length of the given word ; denominator of fraction ; return total number of permutations of the given word ; function to calculate number of permutations such that no vowels come together ; to store frequency of character ; count frequency of acharacters ; calculate total number of permutations ; calculate total number of permutations such that vowels come together ; substrat vwl_tgthr from total to get the result ; return the result ; ","context":"","code":"def isVowel(ch):\n    if (ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u'):\n        return True\n    else:\n        return False\n\n\ndef fact(n):\n    if (n < 2):\n        return 1\n    return n * fact(n - 1)\n\n\ndef only_vowels(freq):\n    denom = 1\n    cnt_vwl = 0\n    for itr in freq:\n        if (isVowel(itr)):\n            denom *= fact(freq[itr])\n            cnt_vwl += freq[itr]\n    return fact(cnt_vwl) \/\/ denom\n\n\ndef all_vowels_together(freq):\n    vow = only_vowels(freq)\n    denom = 1\n    cnt_cnst = 0\n    for itr in freq:\n        if (isVowel(itr) == False):\n            denom *= fact(freq[itr])\n            cnt_cnst += freq[itr]\n    ans = fact(cnt_cnst + 1) \/\/ denom\n    return (ans * vow)\n\n\ndef total_permutations(freq):\n    cnt = 0\n    denom = 1\n    for itr in freq:\n        denom *= fact(freq[itr])\n        cnt += freq[itr]\n    return fact(cnt) \/\/ denom\n\n\ndef no_vowels_together(word):\n    freq = dict()\n    for i in word:\n        ch = i .lower()\n        freq[ch] = freq .get(ch, 0) + 1\n    total = total_permutations(freq)\n    vwl_tgthr = all_vowels_together(freq)\n    res = total - vwl_tgthr\n    return res\n","test":"\nword = \"allahabad\"\nans = no_vowels_together(word)\nprint(ans)\nword = \"geeksforgeeks\"\nans = no_vowels_together(word)\nprint(ans)\nword = \"abcd\"\nans = no_vowels_together(word)\nprint(ans)\n","output":"7200\n32205600\n0\n","fn_call":"no_vowels_together"}
{"text":"program to find the number of men initially | function to return the number of men initially ; ","context":"","code":"def numberOfMen(D, m, d):\n    Men = (m * (D - d)) \/ d\n    return int(Men)\n","test":"\nD = 5\nm = 4\nd = 4\nprint(numberOfMen(D, m, d))\n","output":"1\n","fn_call":"numberOfMen"}
{"text":"area of triangle formed by the axes of co | function to find area ; ","context":"","code":"def area(a, b, c):\n    d = abs((c * c) \/ (2 * a * b))\n    return d\n","test":"\na = -2\nb = 4\nc = 3\nprint(area(a, b, c))\n","output":"0.5625\n","fn_call":"area"}
{"text":"sum of two numbers where one number is represented as array of digits | function to return the vector containing the answer ; vector v is to store each digits sum and vector ans is to store the answer ; no carry in the beginning ; start loop from the end and take element one by one ; array index and last digit of number ; maintain carry of summation ; push the digit value into the array ; k value is greater then 0 ; push digits of k one by one in the array ; also maintain carry with summation ; reverse the elements of vector v and store it in vector ans ; ","context":"","code":"def addToArrayForm(A, K):\n    v, ans = [], []\n    rem, i = 0, 0\n    for i in range(len(A) - 1, -1, -1):\n        my = A[i] + (K % 10) + rem\n        if my > 9:\n            rem = 1\n            v .append(my % 10)\n        else:\n            v .append(my)\n            rem = 0\n        K = K \/\/ 10\n    while K > 0:\n        my = (K % 10) + rem\n        v .append(my % 10)\n        if my \/\/ 10 > 0:\n            rem = 1\n        else:\n            rem = 0\n        K = K \/\/ 10\n    if rem > 0:\n        v .append(rem)\n    for i in range(len(v) - 1, -1, -1):\n        ans .append(v[i])\n    return ans\n","test":"\nif __name__ == \"__main__\":\n    A = [2, 7, 4]\n    K = 181\n    ans = addToArrayForm(A, K)\n    for i in range(0, len(ans)):\n        print(ans[i], end=\"\")\n","output":"455","fn_call":"addToArrayForm"}
{"text":"compute maximum of the function efficiently over all sub | python3 implementation of the above approach ; function to return maximum sum of a sub - array ; function to return maximum value of function f ; compute arrays b [ ] and c [ ] ; find maximum sum sub - array of both of the arrays and take maximum among them ; ","context":"\nMAX = 100005\n\n","code":"def kadaneAlgorithm(ar, n):\n    sum = 0\n    maxSum = 0\n    for i in range(n):\n        sum += ar[i]\n        if (sum < 0):\n            sum = 0\n        maxSum = max(maxSum, sum)\n    return maxSum\n\n\ndef maxFunction(arr, n):\n    b = [0] * MAX\n    c = [0] * MAX\n    for i in range(n - 1):\n        if (i & 1):\n            b[i] = abs(arr[i + 1] - arr[i])\n            c[i] = -b[i]\n        else:\n            c[i] = abs(arr[i + 1] - arr[i])\n            b[i] = -c[i]\n    ans = kadaneAlgorithm(b, n - 1)\n    ans = max(ans, kadaneAlgorithm(c, n - 1))\n    return ans\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 5, 4, 7]\n    n = len(arr)\n    print(maxFunction(arr, n))\n","output":"6\n","fn_call":"maxFunction"}
{"text":"third last digit in 5 ^ n for given n | function to find the element ; if n < 3 ; if n is even return 6 if n is odd return 1 ; ","context":"","code":"def findThirdDigit(n):\n    if n < 3:\n        return 0\n    return 1 if n and 1 else 6\n","test":"\nn = 7\nprint(findThirdDigit(n))\n","output":"1\n","fn_call":"findThirdDigit"}
{"text":"probability of a winning the match when individual probabilities of hitting the target given | function to return the probability of a winning ; p and q store the values of fractions a \/ b and c \/ d ; to store the winning probability of a ; ","context":"","code":"def getProbability(a, b, c, d):\n    p = a \/ b\n    q = c \/ d\n    ans = p * (1 \/ (1 - (1 - q) * (1 - p)))\n    return round(ans, 5)\n","test":"\nif __name__ == \"__main__\":\n    a = 1\n    b = 2\n    c = 10\n    d = 11\n    print(getProbability(a, b, c, d))\n","output":"0.52381\n","fn_call":"getProbability"}
{"text":"largest palindromic number in an array | function to check if n is palindrome ; find the appropriate divisor to extract the leading digit ; if first and last digits are not same then return false ; removing the leading and trailing digits from the number ; reducing divisor by a factor of 2 as 2 digits are dropped ; function to find the largest palindromic number ; if a palindrome larger than the currentmax is found ; return the largest palindromic number from the array ; ","context":"","code":"def isPalindrome(n):\n    divisor = 1\n    while (int(n \/ divisor) >= 10):\n        divisor *= 10\n    while (n != 0):\n        leading = int(n \/ divisor)\n        trailing = n % 10\n        if (leading != trailing):\n            return False\n        n = int((n % divisor) \/ 10)\n        divisor = int(divisor \/ 100)\n    return True\n\n\ndef largestPalindrome(A, n):\n    currentMax = -1\n    for i in range(0, n, 1):\n        if (A[i] > currentMax and isPalindrome(A[i])):\n            currentMax = A[i]\n    return currentMax\n","test":"\nif __name__ == '__main__':\n    A = [1, 232, 54545, 999991]\n    n = len(A)\n    print(largestPalindrome(A, n))\n","output":"54545\n","fn_call":"largestPalindrome"}
{"text":"reduce the array to a single element with the given operation | function to return the final element ; ","context":"","code":"def getFinalElement(n):\n    finalNum = 2\n    while finalNum * 2 <= n:\n        finalNum *= 2\n    return finalNum\n","test":"\nif __name__ == \"__main__\":\n    N = 12\n    print(getFinalElement(N))\n","output":"8\n","fn_call":"getFinalElement"}
{"text":"sum of elements in an array having prime frequency | python3 program to find sum of elements in an array having prime frequency ; function to create sieve to check primes ; false here indicates that it is not prime ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p , set them to non - prime ; function to return the sum of elements in an array having prime frequency ; map is used to store element frequencies ; traverse the map using iterators ; count the number of elements having prime frequencies ; ","context":"\nimport math as mt\n\n","code":"def SieveOfEratosthenes(prime, p_size):\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, mt .ceil(mt .sqrt(p_size + 1))):\n        if (prime[p]):\n            for i in range(p * 2, p_size + 1, p):\n                prime[i] = False\n\n\ndef SumOfElements(arr, n):\n    prime = [True for i in range(n + 1)]\n    SieveOfEratosthenes(prime, n + 1)\n    i, j = 0, 0\n    m = dict()\n    for i in range(n):\n        if arr[i] in m .keys():\n            m[arr[i]] += 1\n        else:\n            m[arr[i]] = 1\n    Sum = 0\n    for i in m:\n        if (prime[m[i]]):\n            Sum += (i)\n    return Sum\n","test":"\narr = [5, 4, 6, 5, 4, 6]\nn = len(arr)\nprint(SumOfElements(arr, n))\n","output":"15\n","fn_call":"SumOfElements"}
{"text":"sum of all odd length palindromic numbers within the range [ l , r ] | function that returns true if the given number is a palindrome ; here we are generating a new number ( reverse_num ) by reversing the digits of original input number ; if the original input number ( num ) is equal to its reverse ( reverse_num ) then its palindrome else it is not . ; function that returns true if the given number is of odd length ; function to return the sum of all odd length palindromic numbers within the given range ; if number is palindrome and of odd length ; ","context":"","code":"def isPalindrome(num):\n    reverse_num = 0\n    temp = num\n    while (temp != 0):\n        remainder = temp % 10\n        reverse_num = reverse_num * 10 + remainder\n        temp = int(temp \/ 10)\n    if (reverse_num == num):\n        return True\n    return False\n\n\ndef isOddLength(num):\n    count = 0\n    while (num > 0):\n        num = int(num \/ 10)\n        count += 1\n    if (count % 2 != 0):\n        return True\n    return False\n\n\ndef sumOfAllPalindrome(L, R):\n    sum = 0\n    if (L <= R):\n        for i in range(L, R + 1, 1):\n            if (isPalindrome(i) and isOddLength(i)):\n                sum += i\n    return sum\n","test":"\nif __name__ == '__main__':\n    L = 110\n    R = 1130\n    print(sumOfAllPalindrome(L, R))\n","output":"49399\n","fn_call":"sumOfAllPalindrome"}
{"text":"number of ways to arrange a word such that all vowels occur together | factorial of a number ; calculating ways for arranging consonants ; ignore vowels ; calculating ways for arranging vowels ; function to count total no . of ways ; count vowels and consonant ; total no . of ways ; ","context":"","code":"def fact(n):\n    f = 1\n    for i in range(2, n + 1):\n        f = f * i\n    return f\n\n\ndef waysOfConsonants(size1, freq):\n    ans = fact(size1)\n    for i in range(26):\n        if (i == 0 or i == 4 or i == 8 or i == 14 or i == 20):\n            continue\n        else:\n            ans = ans \/\/ fact(freq[i])\n    return ans\n\n\ndef waysOfVowels(size2, freq):\n    return (fact(size2) \/\/\n            (fact(freq[0]) *\n             fact(freq[4]) *\n             fact(freq[8]) *\n             fact(freq[14]) *\n             fact(freq[20])))\n\n\ndef countWays(str1):\n    freq = [0] * 26\n    for i in range(len(str1)):\n        freq[ord(str1[i]) - ord('a')] += 1\n    vowel = 0\n    consonant = 0\n    for i in range(len(str1)):\n        if (str1[i] != 'a' and str1[i] != 'e' and str1[i]\n                != 'i' and str1[i] != 'o' and str1[i] != 'u'):\n            consonant += 1\n        else:\n            vowel += 1\n    return (waysOfConsonants(consonant + 1, freq) * waysOfVowels(vowel, freq))\n","test":"\nif __name__ == \"__main__\":\n    str1 = \"geeksforgeeks\"\n    print(countWays(str1))\n","output":"226800\n","fn_call":"countWays"}
{"text":"sum of fibonacci numbers with alternate negatives | computes value of first fibonacci numbers and stores their alternate sum ; initialize result ; add remaining terms ; for even terms ; for odd terms ; return the alternating sum ; ","context":"","code":"def calculateAlternateSum(n):\n    if (n <= 0):\n        return 0\n    fibo = [0] * (n + 1)\n    fibo[0] = 0\n    fibo[1] = 1\n    sum = pow(fibo[0], 2) + pow(fibo[1], 2)\n    for i in range(2, n + 1):\n        fibo[i] = fibo[i - 1] + fibo[i - 2]\n        if (i % 2 == 0):\n            sum -= fibo[i]\n        else:\n            sum += fibo[i]\n    return sum\n","test":"\nif __name__ == \"__main__\":\n    n = 8\n    print(\"Alternating Fibonacci Sum upto \", n,\n          \" terms: \", calculateAlternateSum(n))\n","output":"Alternating Fibonacci Sum upto  8  terms:  -12\n","fn_call":"calculateAlternateSum"}
{"text":"Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Function that will return nth term ; Get n ; Get the value ; Get n ; Get the value","context":"","code":"def getValue(n):\n    i = 0\n    k = 1\n    while (i < n):\n        i = i + k\n        k = k * 2\n    return int(k \/ 2)\n","test":"\nn = 9\nprint(getValue(n))\nn = 1025\nprint(getValue(n))\n","output":"8\n1024\n","fn_call":"getValue"}
{"text":"construct a frequency array of digits of the values obtained from x ^ 1 , x ^ 2 , ... ... . . , x ^ n | python 3 implementation of above approach ; function that traverses digits in a number and modifies frequency count array ; array to keep count of digits ; traversing through x ^ 1 to x ^ n ; for power function , both its parameters are to be in double ; calling countdigits function on x ^ i ; printing count of digits 0 - 9 ; ","context":"\nimport math\n\n","code":"def countDigits(val, arr):\n    while (val > 0):\n        digit = val % 10\n        arr[int(digit)] += 1\n        val = val \/\/ 10\n    return\n\n\ndef countFrequency(x, n):\n    freq_count = [0] * 10\n    for i in range(1, n + 1):\n        val = math .pow(x, i)\n        countDigits(val, freq_count)\n    for i in range(10):\n        print(freq_count[i], end=\" \")\n","test":"\nif __name__ == \"__main__\":\n    x = 15\n    n = 3\n    countFrequency(x, n)\n","output":"0 1 2 2 0 3 0 1 0 0 ","fn_call":"countFrequency"}
{"text":"number of values of b such that a = b + ( a ^ b ) | function to return the number of solutions ; check for every possible value ; ","context":"","code":"def countSolutions(a):\n    count = 0\n    for i in range(a + 1):\n        if (a == (i + (a ^ i))):\n            count += 1\n    return count\n","test":"\nif __name__ == \"__main__\":\n    a = 3\n    print(countSolutions(a))\n","output":"4\n","fn_call":"countSolutions"}
{"text":"number of values of b such that a = b + ( a ^ b ) | function to return the number of solutions ; ","context":"","code":"def countSolutions(a):\n    count = bin(a).count('1')\n    return 2 ** count\n","test":"\nif __name__ == \"__main__\":\n    a = 3\n    print(countSolutions(a))\n","output":"4\n","fn_call":"countSolutions"}
{"text":"sum of area of all possible square inside a rectangle | function to calculate the sum of area of all possible squares that comes inside the rectangle ; square with max size possible ; calculate total square of a given size ; calculate area of squares of a particular size ; total area ; increment size ; ","context":"","code":"def calculateAreaSum(l, b):\n    size = 1\n    maxSize = min(l, b)\n    totalArea = 0\n    for i in range(1, maxSize + 1):\n        totalSquares = ((l - size + 1) * (b - size + 1))\n        area = (totalSquares * size * size)\n        totalArea += area\n        size += 1\n    return totalArea\n","test":"\nif __name__ == \"__main__\":\n    l = 4\n    b = 3\n    print(calculateAreaSum(l, b))\n","output":"54\n","fn_call":"calculateAreaSum"}
{"text":"hyperfactorial of a number | function to calculate the value of hyperfactorial ; initialise the val to 1 ; returns the hyperfactorial of a number ; ","context":"","code":"def boost_hyperfactorial(num):\n    val = 1\n    for i in range(1, num + 1):\n        val = val * pow(i, i)\n    return val\n","test":"\nnum = 5\nprint(boost_hyperfactorial(num))\n","output":"86400000\n","fn_call":"boost_hyperfactorial"}
{"text":"hyperfactorial of a number | function to calculate the value of hyperfactorial ; initialise the val to 1 ; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . . ; returns the hyperfactorial of a number ; ","context":"","code":"def boost_hyperfactorial(num):\n    val = 1\n    for i in range(1, num + 1):\n        for j in range(1, i + 1):\n            val *= i\n    return val\n","test":"\nnum = 5\nprint(boost_hyperfactorial(num))\n","output":"86400000\n","fn_call":"boost_hyperfactorial"}
{"text":"subtract 1 without arithmetic operators | python 3 code to subtract one from a given number ; flip all the set bits until we find a 1 ; flip the rightmost 1 bit ; ","context":"","code":"def subtractOne(x):\n    m = 1\n    while ((x & m) == False):\n        x = x ^ m\n        m = m << 1\n    x = x ^ m\n    return x\n","test":"\nif __name__ == '__main__':\n    print(subtractOne(13))\n","output":"12\n","fn_call":"subtractOne"}
{"text":"find the mean vector of a matrix | python3 program to find mean vector of given matrix ; function to find mean vector ; loop to traverse each column ; to calculate mean of each row ; to store sum of elements of a column ; ","context":"\nrows = 3\ncols = 3\n\n","code":"def meanVector(mat):\n    print(\"[ \", end=\"\")\n    for i in range(rows):\n        mean = 0.00\n        sum = 0\n        for j in range(cols):\n            sum = sum + mat[j][i]\n            mean = int(sum \/ rows)\n            print(mean, end=\" \")\n            print(\"]\")\n","test":"\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmeanVector(mat)\n","output":"[ 0 ]\n1 ]\n4 ]\n0 ]\n2 ]\n5 ]\n1 ]\n3 ]\n6 ]\n","fn_call":"meanVector"}
{"text":"hoax number | python3 code to check if a number is a hoax number or not . ; function to find distinct prime factors of given number n ; n is odd at this point , since it is no longer divisible by 2. so we can test only for the odd numbers , whether they are factors of n ; check if i is prime factor ; this condition is to handle the case when n is a prime number greater than 2 ; function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained ; distinct prime factors of n are being stored in vector pf ; if n is a prime number , it cannot be a hoax number ; finding sum of digits of distinct prime factors of the number n ; finding sum of digits in current prime factor pf [ i ] . ; finding sum of digits of number n ; comparing the two calculated sums ; ","context":"\nimport math\n\n","code":"def primeFactors(n):\n    res = []\n    if (n % 2 == 0):\n        while (n % 2 == 0):\n            n = int(n \/ 2)\n        res .append(2)\n    for i in range(3, int(math .sqrt(n)), 2):\n        if (n % i == 0):\n            while (n % i == 0):\n                n = int(n \/ i)\n            res .append(i)\n    if (n > 2):\n        res .append(n)\n    return res\n\n\ndef isHoax(n):\n    pf = primeFactors(n)\n    if (pf[0] == n):\n        return False\n    all_pf_sum = 0\n    for i in range(0, len(pf)):\n        pf_sum = 0\n        while (pf[i] > 0):\n            pf_sum += pf[i] % 10\n            pf[i] = int(pf[i] \/ 10)\n        all_pf_sum += pf_sum\n    sum_n = 0\n    while (n > 0):\n        sum_n += n % 10\n        n = int(n \/ 10)\n    return sum_n == all_pf_sum\n","test":"\nn = 84\nif (isHoax(n)):\n    print(\"AHoaxNumber\")\nelse:\n    print(\"NotaHoaxNumber\")\n","output":"AHoaxNumber\n","fn_call":"isHoax"}
{"text":"primality test | set 5 ( using lucas | function to find out first n terms ( considering 4 as 0 th term ) of lucas - lehmer series . ; the 0 th term of the series is 4. ; create an array to store the terms . ; compute each term and add it to the array . ; print out the terms one by one . ; ","context":"","code":"def LucasLehmer(n):\n    current_val = 4\n    series = []\n    series .append(current_val)\n    for i in range(n):\n        current_val = current_val * current_val - 2\n        series .append(current_val)\n    for i in range(n + 1):\n        print(\"Term\", i, \":\", series[i])\n","test":"\nif __name__ == '__main__':\n    n = 5\n    LucasLehmer(n)\n","output":"Term 0 : 4\nTerm 1 : 14\nTerm 2 : 194\nTerm 3 : 37634\nTerm 4 : 1416317954\nTerm 5 : 2005956546822746114\n","fn_call":"LucasLehmer"}
{"text":"modular multiplicative inverse from 1 to n | a naive method to find modular multiplicative inverse of ' a ' under modulo 'prime ; ","context":"","code":"def modInverse(a, prime):\n    a = a % prime\n    for x in range(1, prime):\n        if ((a * x) % prime == 1):\n            return x\n    return -1\n\n\ndef printModIverses(n, prime):\n    for i in range(1, n + 1):\n        print(modInverse(i, prime), end=\"\")\n","test":"\nn = 10\nprime = 17\nprintModIverses(n, prime)\n","output":"1961373515212","fn_call":"printModIverses"}
{"text":"convert to number with digits as 3 and 8 only | function for minimum operation ; remainder and operations count ; count digits not equal to 3 or 8 ; ","context":"","code":"def minOp(num):\n    count = 0\n    while (num):\n        rem = num % 10\n        if (not (rem == 3 or rem == 8)):\n            count = count + 1\n        num = num \/\/ 10\n    return count\n","test":"\nnum = 234198\nprint(\"Minimum Operations =\", minOp(num))\n","output":"Minimum Operations = 4\n","fn_call":"minOp"}
{"text":"biggest integer which has maximum digit sum in range from 1 to n | function to calculate the sum of digits of a number . ; returns the maximum number with maximum sum of digits . ; initializing b as 1 and initial max sum to be of n ; iterates from right to left in a digit ; while iterating this is the number from right to left ; calls the function to check if sum of cur is more then of ans ; reduces the number to one unit less ; ","context":"","code":"def sumOfDigits(a):\n    sm = 0\n    while (a != 0):\n        sm = sm + a % 10\n        a = a \/\/ 10\n    return sm\n\n\ndef findMax(x):\n    b = 1\n    ans = x\n    while (x != 0):\n        cur = (x - 1) * b + (b - 1)\n        if (sumOfDigits(cur) > sumOfDigits(ans) or (\n                sumOfDigits(cur) == sumOfDigits(ans) and cur > ans)):\n            ans = cur\n        x = x \/\/ 10\n        b = b * 10\n    return ans\n","test":"\nn = 521\nprint(findMax(n))\n","output":"499\n","fn_call":"findMax"}
{"text":"largest palindromic number in an array | function to check if n is palindrome ; find the appropriate divisor to extract the leading digit ; if first and last digits are not same then return false ; removing the leading and trailing digits from the number ; reducing divisor by a factor of 2 as 2 digits are dropped ; function to find the largest palindromic number ; sort the array ; if number is palindrome ; if no palindromic number found ; ","context":"","code":"def isPalindrome(n):\n    divisor = 1\n    while (n \/ divisor >= 10):\n        divisor *= 10\n    while (n != 0):\n        leading = n \/\/ divisor\n        trailing = n % 10\n        if (leading != trailing):\n            return False\n        n = (n % divisor) \/\/ 10\n        divisor = divisor \/\/ 100\n    return True\n\n\ndef largestPalindrome(A, n):\n    A .sort()\n    for i in range(n - 1, -1, -1):\n        if (isPalindrome(A[i])):\n            return A[i]\n    return -1\n","test":"\nif __name__ == \"__main__\":\n    A = [1, 232, 54545, 999991]\n    n = len(A)\n    print(largestPalindrome(A, n))\n","output":"54545\n","fn_call":"largestPalindrome"}
{"text":"sum of the multiples of two numbers below n | function to return the sum of all the integers below n which are multiples of either a or b ; if i is a multiple of a or b ; ","context":"","code":"def findSum(n, a, b):\n    sum = 0\n    for i in range(0, n, 1):\n        if (i % a == 0 or i % b == 0):\n            sum += i\n    return sum\n","test":"\nif __name__ == '__main__':\n    n = 10\n    a = 3\n    b = 5\n    print(findSum(n, a, b))\n","output":"23\n","fn_call":"findSum"}
{"text":"subtract 1 without arithmetic operators | ''","context":"","code":"def subtractOne(x):\n    return ((x << 1) + (~x))\n","test":"\nprint(subtractOne(13))\n","output":"12\n","fn_call":"subtractOne"}
{"text":"pell number | calculate nth pell number ; ","context":"","code":"def pell(n):\n    if (n <= 2):\n        return n\n    return (2 * pell(n - 1) + pell(n - 2))\n","test":"\nn = 4\nprint(pell(n))\n","output":"12\n","fn_call":"pell"}
{"text":"finding lcm of more than two ( or array ) numbers without using gcd | returns lcm of arr [ 0. . n - 1 ] ; find the maximum value in arr [ ] ; initialize result ; find all factors that are present in two or more array elements . x = 2 ; current factor . ; to store indexes of all array elements that are divisible by x . ; if there are 2 or more array elements that are divisible by x . ; reduce all array elements divisible by x . ; then multiply all reduced array elements ; ","context":"","code":"def LCM(arr, n):\n    max_num = 0\n    for i in range(n):\n        if (max_num < arr[i]):\n            max_num = arr[i]\n    res = 1\n    x = 2\n    while (x <= max_num):\n        indexes = []\n        for j in range(n):\n            if (arr[j] % x == 0):\n                indexes.append(j)\n        if (len(indexes) >= 2):\n            for j in range(len(indexes)):\n                arr[indexes[j]] = int(arr[indexes[j]] \/ x)\n\n            res = res * x\n        else:\n            x += 1\n    for i in range(n):\n        res = res * arr[i]\n\n    return res\n","test":"\narr = [1, 2, 3, 4, 5, 10, 20, 35]\nn = len(arr)\nprint(LCM(arr, n))\n","output":"420\n","fn_call":"LCM"}
{"text":"find politeness of a number | python program for the above approach ; function to find politeness ; sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0 ; ","context":"\nimport math\n\n","code":"def politness(n):\n    count = 0\n    for i in range(2, int(math .sqrt(2 * n)) + 1):\n        if ((2 * n) % i != 0):\n            continue\n        a = 2 * n\n        a = a \/ i\n        a = a - (i - 1)\n        if (a % 2 != 0):\n            continue\n        a \/= 2\n        if (a > 0):\n            count = count + 1\n    return count\n","test":"\nn = 90\nprint(\"Politness of \", n, \" = \", politness(n))\nn = 15\nprint(\"Politness of \", n, \" = \", politness(n))\n","output":"Politness of  90  =  5\nPolitness of  15  =  3\n","fn_call":"politness"}
{"text":"k | python program to print kth prime factor ; a function to generate prime factors of a given number n and return k - th prime factor ; find the number of 2 's that divide k ; n must be odd at this point . so we can skip one element ( note i = i + 2 ) ; while i divides n , store i and divide n ; this condition is to handle the case where n is a prime number greater than 2 ; ","context":"\nimport math\n\n","code":"def kPrimeFactor(n, k):\n    while (n % 2 == 0):\n        k = k - 1\n        n = n \/ 2\n        if (k == 0):\n            return 2\n    i = 3\n    while i <= math .sqrt(n):\n        while (n % i == 0):\n            if (k == 1):\n                return i\n            k = k - 1\n            n = n \/ i\n        i = i + 2\n    if (n > 2 and k == 1):\n        return n\n    return -1\n","test":"\nn = 12\nk = 3\nprint(kPrimeFactor(n, k))\nn = 14\nk = 3\nprint(kPrimeFactor(n, k))\n","output":"3.0\n-1\n","fn_call":"kPrimeFactor"}
{"text":"find sum of divisors of all the divisors of a natural number | python3 program to find sum of divisors of all the divisors of a natural number . ; returns sum of divisors of all the divisors of n ; calculating powers of prime factors and storing them in a map mp [ ] . ; if n is a prime number ; for each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) \/ ( p - 1 ) and adding it to answer . ; ","context":"\nimport math as mt\n\n","code":"def sumDivisorsOfDivisors(n):\n    mp = dict()\n    for j in range(2, mt .ceil(mt .sqrt(n))):\n        count = 0\n        while (n % j == 0):\n            n \/\/= j\n            count += 1\n        if (count):\n            mp[j] = count\n    if (n != 1):\n        mp[n] = 1\n    ans = 1\n    for it in mp:\n        pw = 1\n        summ = 0\n        for i in range(mp[it] + 1, 0, -1):\n            summ += (i * pw)\n            pw *= it\n        ans *= summ\n    return ans\n","test":"\nn = 10\nprint(sumDivisorsOfDivisors(n))\n","output":"28\n","fn_call":"sumDivisorsOfDivisors"}
{"text":"find recurring sequence in a fraction | this function returns repeating sequence of a fraction . if repeating sequence doesn 't exits, then returns empty string ; initialize result ; create a map to store already seen remainders . remainder is used as key and its position in result is stored as value . note that we need position for cases like 1 \/ 6. in this case , the recurring sequence doesn 't start  from first remainder. ; find first remainder ; keep finding remainder until either remainder becomes 0 or repeats ; store this remainder ; multiply remainder with 10 ; append rem \/ denr to result ; update remainder ; ","context":"","code":"def fractionToDecimal(numr, denr):\n    res = \"\"\n    mp = {}\n    rem = numr % denr\n    while ((rem != 0) and (rem not in mp)):\n        mp[rem] = len(res)\n        rem = rem * 10\n        res_part = rem \/\/ denr\n        res += str(res_part)\n        rem = rem % denr\n    if (rem == 0):\n        return \"\"\n    else:\n        return res[mp[rem]:]\n","test":"\nnumr, denr = 50, 22\nres = fractionToDecimal(numr, denr)\nif (res == \"\"):\n    print(\"No recurring sequence\")\nelse:\n    print(\"Recurring sequence is\", res)\n","output":"Recurring sequence is 27\n","fn_call":"fractionToDecimal"}
{"text":"count numbers having 0 as a digit | returns 1 if x has 0 , else 0 ; traverse through all digits of x to check if it has 0. ; if current digit is 0 , return true ; returns count of numbers from 1 to n with 0 as digit ; initialize count of numbers having 0 as digit . ; traverse through all numbers and for every number check if it has 0. ; ","context":"","code":"def has0(x):\n    while (x != 0):\n        if (x % 10 == 0):\n            return 1\n        x = x \/\/ 10\n    return 0\n\n\ndef getCount(n):\n    count = 0\n    for i in range(1, n + 1):\n        count = count + has0(i)\n    return count\n","test":"\nn = 107\nprint(\"Count of numbers from 1\", \" to \", n, \" is \", getCount(n))\n","output":"Count of numbers from 1  to  107  is  17\n","fn_call":"getCount"}
{"text":"euler 's criterion (check if square root under modulo p exists) | returns true if square root of n under modulo p exists ; one by one check all numbers from 2 to p - 1 ; ","context":"","code":"def squareRootExists(n, p):\n    n = n % p\n    for x in range(2, p, 1):\n        if ((x * x) % p == n):\n            return True\n    return False\n","test":"\nif __name__ == '__main__':\n    p = 7\n    n = 2\n    if (squareRootExists(n, p)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\n","fn_call":"squareRootExists"}
{"text":"legendre 's formula (given p and n, find the largest x such that p^x divides n!) | returns largest power of p that divides n ! ; initialize result ; calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... . ; ","context":"","code":"def largestPower(n, p):\n    x = 0\n    while n:\n        n \/= p\n        x += n\n    return x\n","test":"\nn = 10\np = 3\nprint(\"Thelargestpowerof%dthatdivides%d!is%d\" % (p, n, largestPower(n, p)))\n","output":"Thelargestpowerof3thatdivides10!is4\n","fn_call":"largestPower"}
{"text":"program for factorial of a number | python 3 program to find factorial of given number ; single line to find factorial ; ","context":"","code":"def factorial(n):\n    return 1 if (n == 1 or n == 0)else n * factorial(n - 1)\n","test":"\nnum = 5\nprint(\"Factorial of\", num, \"is\", factorial(num))\n","output":"Factorial of 5 is 120\n","fn_call":"factorial"}
{"text":"sum of bitwise and of each array element with the elements of another array | function to compute the and sum for each element of an array ; declaring an array of size 32 for storing the count of each bit ; traverse the array arr2 [ ] and store the count of a bit in frequency array ; current bit position ; while num is greater than 0 ; checks if ith bit is set or not ; increment the count of bit by one ; increment the bit position by one ; right shift the num by one ; traverse in the arr2 [ ] ; store the ith bit value ; total required sum ; traverse in the range [ 0 , 31 ] ; checks if current bit is set ; increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ; right shift num by one ; left shift vale_at_that_bit by one ; print sum obtained for ith number in arr1 [ ] ; ","context":"","code":"def Bitwise_AND_sum_i(arr1, arr2, M, N):\n    frequency = [0] * 32\n    for i in range(N):\n        bit_position = 0\n        num = arr1[i]\n        while (num):\n            if (num & 1):\n                frequency[bit_position] += 1\n            bit_position += 1\n            num >>= 1\n    for i in range(M):\n        num = arr2[i]\n        value_at_that_bit = 1\n        bitwise_AND_sum = 0\n        for bit_position in range(32):\n            if (num & 1):\n                bitwise_AND_sum += frequency[bit_position] * value_at_that_bit\n            num >>= 1\n            value_at_that_bit <<= 1\n        print(bitwise_AND_sum, end=\" \")\n    return\n","test":"\nif __name__ == '__main__':\n    arr1 = [1, 2, 3]\n    arr2 = [1, 2, 3]\n    N = len(arr1)\n    M = len(arr2)\n    Bitwise_AND_sum_i(arr1, arr2, M, N)\n","output":"2 4 6 ","fn_call":"Bitwise_AND_sum_i"}
{"text":"turn off the rightmost set bit | set 2 | unsets the rightmost set bit of n and returns the result ; checking whether bit position is set or not ; if bit position is found set , we flip this bit by xoring given number and number with bit position set ; ","context":"","code":"def FlipBits(n):\n    for bit in range(32):\n        if ((n >> bit) & 1):\n            n = n ^ (1 << bit)\n            break\n    print(\"The number after unsetting the\", end=\" \")\n    print(\"rightmost set bit\", n)\n","test":"\nif __name__ == '__main__':\n    N = 12\n    FlipBits(N)\n","output":"The number after unsetting the rightmost set bit 8\n","fn_call":"FlipBits"}
{"text":"bitwise and of all the odd numbers from 1 to n | function to return the bitwise and of all the odd integers from the range [ 1 , n ] ; initialize result to 1 ; starting from 3 , bitwise and all the odd integers less than or equal to n ; ","context":"","code":"def bitwiseAndOdd(n):\n    result = 1\n    for i in range(3, n + 1, 2):\n        result = (result & i)\n    return result\n","test":"\nif __name__ == \"__main__\":\n    n = 10\n    print(bitwiseAndOdd(n))\n","output":"1\n","fn_call":"bitwiseAndOdd"}
{"text":"bitwise and of all the odd numbers from 1 to n | function to return the bitwise and of all the odd integers from the range [ 1 , n ] ; ","context":"","code":"def bitwiseAndOdd(n):\n    return 1\n","test":"\nn = 10\nprint(bitwiseAndOdd(n))\n","output":"1\n","fn_call":"bitwiseAndOdd"}
{"text":"ways to split array into two groups of same xor value | return the count of number of ways to split array into two groups such that each group has equal xor value . ; we can split only if xor is 0. since xor of all is 0 , we can consider all subsets as one group . ; ","context":"","code":"def countgroup(a, n):\n    xs = 0\n    for i in range(n):\n        xs = xs ^ a[i]\n    if xs == 0:\n        return (1 << (n - 1)) - 1\n    return 0\n","test":"\na = [1, 2, 3]\nn = len(a)\nprint(countgroup(a, n))\n","output":"3\n","fn_call":"countgroup"}
{"text":"extract ' k ' bits from a ","context":"","code":"def bitExtracted(number, k, p):\n    return (((1 << k) - 1) & (number >> (p - 1)))\n","test":"\nnumber = 171\nk = 5\np = 2\nprint(\"The extracted number is \", bitExtracted(number, k, p))\n","output":"The extracted number is  21\n","fn_call":"bitExtracted"}
{"text":"maximize a given unsigned number number by swapping bits at it 's extreme positions. | python 3 program to find maximum number by swapping extreme bits . ; traverse bits from both extremes ; obtaining i - th and j - th bits ; swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number ; ","context":"","code":"def findMax(num):\n    num_copy = num\n    j = 4 * 8 - 1\n    i = 0\n    while (i < j):\n        m = (num_copy >> i) & 1\n        n = (num_copy >> j) & 1\n        if (m > n):\n            x = (1 << i | 1 << j)\n            num = num ^ x\n        i += 1\n        j -= 1\n    return num\n","test":"\nif __name__ == \"__main__\":\n    num = 4\n    print(findMax(num))\n","output":"536870912\n","fn_call":"findMax"}
{"text":"efficiently check whether n is a multiple of 4 or not | function to check whether ' n ' is a multiple of 4 or not ; if true , then ' n ' is a multiple of 4 ; else ' n ' is not a multiple of 4 ; ","context":"","code":"def isAMultipleOf4(n):\n    if ((n & 3) == 0):\n        return \"Yes\"\n    return \"No\"\n","test":"\nif __name__ == \"__main__\":\n    n = 16\n    print(isAMultipleOf4(n))\n","output":"Yes\n","fn_call":"isAMultipleOf4"}
{"text":"calculate square of a number without using * , \/ and pow ( ) | simple solution to calculate square without using * and pow ( ) ; handle negative input ; initialize result ; add n to res n - 1 times ; ","context":"","code":"def square(n):\n    if (n < 0):\n        n = -n\n    res = n\n    for i in range(1, n):\n        res += n\n    return res\n","test":"\nfor n in range(1, 6):\n    print(\"n =\", n, end=\", \")\n    print(\"n^2 =\", square(n))\n","output":"n = 1, n^2 = 1\nn = 2, n^2 = 4\nn = 3, n^2 = 9\nn = 4, n^2 = 16\nn = 5, n^2 = 25\n","fn_call":"square"}
{"text":"find a point that lies inside exactly k given squares | python 3 implementation of the above approach ; ","context":"","code":"def PointInKSquares(n, a, k):\n    a .sort()\n    return a[n - k]\n","test":"\nif __name__ == \"__main__\":\n    k = 2\n    a = [1, 2, 3, 4]\n    n = len(a)\n    x = PointInKSquares(n, a, k)\n    print(\"(\", x, \",\", x, \")\")\n","output":"( 3 , 3 )\n","fn_call":"PointInKSquares"}
{"text":"number of n digit stepping numbers | space optimized solution | function that calculates the answer ; dp [ j ] stores count of i digit stepping numbers ending with digit j . ; to store resu1lt of length i - 1 before updating dp [ j ] for length i . ; if n is 1 then answer will be 10. ; initialize values for count of digits equal to 1. ; compute values for count of digits more than 1. ; if ending digit is 0 ; if ending digit is 9 ; for other digits . ; stores the final answer ; ","context":"","code":"def answer(n):\n    dp = [0] * 10\n    prev = [0] * 10\n    if (n == 1):\n        return 10\n    for j in range(0, 10):\n        dp[j] = 1\n    for i in range(2, n + 1):\n        for j in range(0, 10):\n            prev[j] = dp[j]\n        for j in range(0, 10):\n            if (j == 0):\n                dp[j] = prev[j + 1]\n            elif (j == 9):\n                dp[j] = prev[j - 1]\n            else:\n                dp[j] = prev[j - 1] + prev[j + 1]\n    sum = 0\n    for j in range(1, 10):\n        sum = sum + dp[j]\n    return sum\n","test":"\nn = 2\nprint(answer(n))\n","output":"17\n","fn_call":"answer"}
{"text":"minimum changes required to make a catalan sequence | python3 implementation of the approach ; to store first n catalan numbers ; function to find first n catalan numbers ; initialize first two values in table ; fill entries in catalan [ ] using recursive formula ; function to return the minimum changes required ; find first n catalan numbers ; a and b are first two catalan sequence numbers ; insert first n catalan elements to set ; if catalan element is present in the array then remove it from set ; return the remaining number of elements in the set ; ","context":"\nMAX = 100000\ncatalan = [0] * MAX\n\n","code":"def catalanDP(n):\n    catalan[0] = catalan[1] = 1\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += (catalan[j] * catalan[i - j - 1])\n\n\ndef CatalanSequence(arr, n):\n    catalanDP(n)\n    s = set()\n    a = 1\n    b = 1\n    s .add(a)\n    if (n >= 2):\n        s .add(b)\n    for i in range(2, n):\n        s .add(catalan[i])\n    temp = set()\n    for i in range(n):\n        if arr[i] in s:\n            temp .add(arr[i])\n    s = s - temp\n    return len(s)\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 1, 2, 5, 41]\n    n = len(arr)\n    print(CatalanSequence(arr, n))\n","output":"1\n","fn_call":"CatalanSequence"}
{"text":"sum of all the composite numbers from odd indices of the given array | function to print the sum of all composite numbers in the array ; iterate for odd indices in the array ; check if the number is composite then add it to sum ; return the sum ; function to check for composite numbers ; check if the factors are greater than 2 ; check if the number is composite or not ; ","context":"","code":"def composite(n):\n    flag = 0\n    c = 0\n    for j in range(1, n + 1):\n        if (n % j == 0):\n            c += 1\n    if (c >= 3):\n        flag = 1\n    return flag\n\n\ndef odd_indices(arr):\n    sum = 0\n    for k in range(0, len(arr), 2):\n        check = composite(arr[k])\n        sum += arr[k]if check == 1 else 0\n    print(sum)\n","test":"\nif __name__ == \"__main__\":\n    arr = [13, 5, 8, 16, 25]\n    odd_indices(arr)\n","output":"33\n","fn_call":"odd_indices"}
{"text":"count of numbers of length n having prime numbers at odd indices and odd numbers at even indices | python program for above approach ; no of odd indices in n - digit number ; no of even indices in n - digit number ; no of ways of arranging prime number digits in odd indices ; no of ways of arranging odd number digits in even indices ; returning the total number of ways ; ","context":"","code":"def count(N):\n    odd_indices = N \/\/ 2\n    even_indices = N \/\/ 2 + N % 2\n    arrange_odd = 4 ** odd_indices\n    arrange_even = 5 ** even_indices\n    return arrange_odd * arrange_even\n","test":"\nif __name__ == \"__main__\":\n    N = 4\n    print(count(N))\n","output":"400\n","fn_call":"count"}
{"text":"check if a given array is sorted in spiral manner or not | function to check if the array is spirally sorted or not ; stores start index of the array ; stores end index of an array ; if arr [ start ] greater than arr [ end ] ; update start ; if arr [ end ] greater than arr [ start ] ; update end ; ","context":"","code":"def isSpiralSorted(arr, n):\n    start = 0\n    end = n - 1\n    while (start < end):\n        if (arr[start] > arr[end]):\n            return False\n        start += 1\n        if (arr[end] > arr[start]):\n            return False\n        end -= 1\n    return True\n","test":"\nif __name__ == \"__main__\":\n    arr = [1, 10, 14, 20, 18, 12, 5]\n    N = len(arr)\n    if (isSpiralSorted(arr, N)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"isSpiralSorted"}
{"text":"print all strings from given array that can be typed using keys from a single row of a qwerty keyboard | function to print all strings that can be typed using keys of a single row in a qwerty keyboard ; stores row number of all possible character of the strings ; traverse the array ; if current string is not an empty string ; sets true \/ false if a string can be typed using keys of a single row or not ; stores row number of the first character of current string ; stores length of word ; traverse current string ; if current character can 't be  typed using keys of rownum only ; update flag ; if current string can be typed using keys from rownum only ; print the string ; ","context":"","code":"def findWordsSameRow(arr):\n    mp = {'q': 1, 'w': 1, 'e': 1, 'r': 1,\n          't': 1, 'y': 1, 'u': 1, 'o': 1,\n          'p': 1, 'i': 1, 'a': 2, 's': 2,\n          'd': 2, 'f': 2, 'g': 2, 'h': 2,\n          'j': 2, 'k': 2, 'l': 2, 'z': 3,\n          'x': 3, 'c': 3, 'v': 3, 'b': 3,\n          'n': 3, 'm': 3}\n    for word in arr:\n        if (len(word) != 0):\n            flag = True\n\n            rowNum = mp[word[0].lower()]\n            M = len(word)\n            for i in range(1, M):\n                if (mp[word[i].lower()] != rowNum):\n                    flag = False\n                    break\n            if (flag):\n                print(word, end=' ')\n","test":"\nwords = [\"Yeti\", \"Had\", \"GFG\", \"comment\"]\n\nfindWordsSameRow(words)\n","output":"Yeti Had GFG ","fn_call":"findWordsSameRow"}
{"text":"count quadruples of given type from given array | python3 program of the above approach ; function to find the count of the subsequence of given type ; stores the count of quadruples ; generate all possible combinations of quadruples ; check if 1 st element is equal to 3 rd element ; check if 2 nd element is equal to 4 th element ; ","context":"\nmaxN = 2002\n\n","code":"def countSubsequece(a, n):\n    answer = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if (a[j] == a[l] and a[i] == a[k]):\n                        answer += 1\n    return answer\n","test":"\nif __name__ == '__main__':\n    a = [1, 2, 3, 2, 1, 3, 2]\n    print(countSubsequece(a, 7))\n","output":"5\n","fn_call":"countSubsequece"}
{"text":"smallest character in a string having minimum sum of distances between consecutive repetitions | python3 program for the above approach ; function to find the character repeats with minimum distance ; stores the first and last index ; intialize with - 1 ; get the values of last and first occurence ; update the first index ; update the last index ; intialize the min ; get the minimum ; values must not be same ; update the minimum distance ; return ans ; ","context":"\nimport sys\n\n","code":"def minDistChar(s):\n    n = len(s)\n    first = []\n    last = []\n    for i in range(26):\n        first .append(-1)\n        last .append(-1)\n    for i in range(n):\n        if (first[ord(s[i]) - ord('a')] == -1):\n            first[ord(s[i]) - ord('a')] = i\n        last[ord(s[i]) - ord('a')] = i\n    min = sys .maxsize\n    ans = '1'\n    for i in range(26):\n        if (last[i] == first[i]):\n            continue\n        if (min > last[i] - first[i]):\n            min = last[i] - first[i]\n            ans = i + ord('a')\n    return chr(ans)\n","test":"\nif __name__ == \"__main__\":\n    str = \"geeksforgeeks\"\n    print(minDistChar(str))\n","output":"g\n","fn_call":"minDistChar"}
{"text":"minimum steps required to reach the end of a matrix | set 2 | python 3 implementation of the approach ; function to return the minimum steps required to reach the end of the matrix ; array to determine whether a cell has been visited before ; queue for bfs ; to store the depth of search ; bfs algorithm ; current queue size ; top - most element of queue ; to store index of cell for simplicity ; base case ; if we reach ( n - 1 , n - 1 ) ; marking the cell visited ; pushing the adjacent cells in the queue that can be visited from the current cell ; ","context":"\nn = 3\n\n","code":"def minSteps(arr):\n    v = [[0 for i in range(n)]for j in range(n)]\n    q = [[0, 0]]\n    depth = 0\n    while (len(q) != 0):\n        x = len(q)\n        while (x > 0):\n            y = q[0]\n            i = y[0]\n            j = y[1]\n            q .remove(q[0])\n            x -= 1\n            if (v[i][j]):\n                continue\n            if (i == n - 1 and j == n - 1):\n                return depth\n            v[i][j] = 1\n            if (i + arr[i][j] < n):\n                q .append([i + arr[i][j], j])\n            if (j + arr[i][j] < n):\n                q .append([i, j + arr[i][j]])\n        depth += 1\n    return -1\n","test":"\nif __name__ == '__main__':\n    arr = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    print(minSteps(arr))\n","output":"4\n","fn_call":"minSteps"}
{"text":"largest gap in an array | a python 3 program to find largest gap between two elements in an array . ; function to solve the given problem ; ","context":"\nimport sys\n\n","code":"def solve(a, n):\n    max1 = -sys .maxsize - 1\n    for i in range(0, n, 1):\n        for j in range(0, n, 1):\n            if (abs(a[i] - a[j]) > max1):\n                max1 = abs(a[i] - a[j])\n    return max1\n","test":"\nif __name__ == '__main__':\n    arr = [-1, 2, 3, -4, -10, 22]\n    size = len(arr)\n    print(\"Largest gap is :\", solve(arr, size))\n","output":"Largest gap is : 32\n","fn_call":"solve"}
{"text":"largest gap in an array | function to solve the given problem ; finding maximum and minimum of an array ; ","context":"","code":"def solve(a, n):\n    min1 = a[0]\n    max1 = a[0]\n    for i in range(n):\n        if (a[i] > max1):\n            max1 = a[i]\n        if (a[i] < min1):\n            min1 = a[i]\n    return abs(min1 - max1)\n","test":"\nif __name__ == \"__main__\":\n    arr = [-1, 2, 3, 4, -10]\n    size = len(arr)\n    print(\"Largest gap is : \", solve(arr, size))\n","output":"Largest gap is :  14\n","fn_call":"solve"}
{"text":"print reverse string after removing vowels | function for replacing the string ; initialize a string of length n ; traverse through all characters of string ; assign the value to string r from last index of string s ; if s [ i ] is a consonant then print r [ i ] ; ","context":"","code":"def replaceOriginal(s, n):\n    r = [' '] * n\n    for i in range(n):\n        r[i] = s[n - 1 - i]\n        if (s[i] != 'a' and s[i] != 'e' and\n            s[i] != 'i' and s[i] != 'o' and\n                s[i] != 'u'):\n            print(r[i], end=\"\")\n    print()\n","test":"\nif __name__ == \"__main__\":\n    s = \"geeksforgeeks\"\n    n = len(s)\n    replaceOriginal(s, n)\n","output":"segrfseg\n","fn_call":"replaceOriginal"}
{"text":"check if a string can be made equal to another string by swapping or replacement of characters | function to find if given strings are same or not ; base condition ; stores frequency of characters of the str1 and str2 ; traverse strings str1 & str2 and store frequencies in a [ ] and b [ ] ; check if both strings have same characters or not ; if a character is present in one and is not in another string , return false ; sort the array a [ ] and b [ ] ; check arrays a and b contain the same frequency or not ; if the frequencies are not the same after sorting ; at this point , str1 can be converted to str2 ; ","context":"","code":"def sameStrings(str1, str2):\n    N = len(str1)\n    M = len(str2)\n    if (N != M):\n        return False\n    a, b = [0] * 256, [0] * 256\n    for i in range(N):\n        a[ord(str1[i]) - ord('a')] += 1\n        b[ord(str2[i]) - ord('a')] += 1\n    i = 0\n    while (i < 256):\n        if ((a[i] == 0 and b[i] == 0) or (a[i] != 0 and b[i] != 0)):\n            i += 1\n        else:\n            return False\n    a = sorted(a)\n    b = sorted(b)\n    for i in range(256):\n        if (a[i] != b[i]):\n            return False\n    return True\n","test":"\nif __name__ == '__main__':\n    S1, S2 = \"cabbba\", \"abbccc\"\n    if (sameStrings(S1, S2)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n","output":"YES\n","fn_call":"sameStrings"}
{"text":"reduce given three numbers by decrementing in pairs | function to find the minimum number operations ; insert the three numbers in array ; sort the array ; case 2 ; case 1 ; ","context":"","code":"def solution(A, B, C):\n    arr = [0] * 3\n    arr[0] = A\n    arr[1] = B\n    arr[2] = C\n    arr = sorted(arr)\n    if (arr[2] < arr[0] + arr[1]):\n        return ((arr[0] + arr[1] + arr[2]) \/\/ 2)\n    else:\n        return (arr[0] + arr[1])\n","test":"\nif __name__ == '__main__':\n    A = 8\n    B = 1\n    C = 5\n    print(solution(A, B, C))\n","output":"6\n","fn_call":"solution"}
{"text":"search an element in a sorted and rotated array with duplicates | function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1 ; the tricky case , just update left and right ; if arr [ l ... mid ] is sorted ; as this subarray is sorted , we can quickly check if key lies in any of the halves ; if key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half ; if arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray ; ","context":"","code":"def search(arr, l, h, key):\n    if (l > h):\n        return -1\n    mid = (l + h) \/\/ 2\n    if (arr[mid] == key):\n        return mid\n    if ((arr[l] == arr[mid]) and (arr[h] == arr[mid])):\n        l += 1\n        h -= 1\n        return search(arr, l, h, key)\n    if (arr[l] <= arr[mid]):\n        if (key >= arr[l] and key <= arr[mid]):\n            return search(arr, l, mid - 1, key)\n        return search(arr, mid + 1, h, key)\n    if (key >= arr[mid] and key <= arr[h]):\n        return search(arr, mid + 1, h, key)\n    return search(arr, l, mid - 1, key)\n","test":"\nif __name__ == \"__main__\":\n    arr = [3, 3, 1, 2, 3, 3]\n    n = len(arr)\n    key = 3\n    print(search(arr, 0, n - 1, key))\n","output":"4\n","fn_call":"search"}
{"text":"case | function to return the sorted string ; vectors to store the lowercase and uppercase characters ; sort both the vectors ; if current character is lowercase then pick the lowercase character from the sorted list ; else pick the uppercase character ; return the sorted string ; ","context":"","code":"def getSortedString(s, n):\n    v1 = []\n    v2 = []\n    for i in range(n):\n        if (s[i] >= 'a' and s[i] <= 'z'):\n            v1 .append(s[i])\n        if (s[i] >= 'A' and s[i] <= 'Z'):\n            v2 .append(s[i])\n    v1 = sorted(v1)\n    v2 = sorted(v2)\n    i = 0\n    j = 0\n    for k in range(n):\n        if (s[k] >= 'a' and s[k] <= 'z'):\n            s[k] = v1[i]\n            i += 1\n        elif (s[k] >= 'A' and s[k] <= 'Z'):\n            s[k] = v2[j]\n            j += 1\n    return \"\".join(s)\n","test":"\ns = \"gEeksfOrgEEkS\"\nss = [i for i in s]\nn = len(ss)\nprint(getSortedString(ss, n))\n","output":"eEfggkEkrEOsS\n","fn_call":"getSortedString"}
{"text":"check if the string contains consecutive letters and each letter occurs exactly once | function to check if the condition holds ; get the length of the string ; sort the given string ; iterate for every index and check for the condition ; if are not consecutive ; ","context":"","code":"def check(s):\n    l = len(s)\n    s = ''.join(sorted(s))\n    for i in range(1, l):\n        if ord(s[i]) - ord(s[i - 1]) != 1:\n            return False\n    return True\n","test":"\nif __name__ == \"__main__\":\n    string = \"dcef\"\n    if check(string):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    string = \"xyza\"\n    if check(string):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n","output":"Yes\nNo\n","fn_call":"check"}
{"text":"smallest subset with sum greater than all other elements | function to find minimum elements needed . ; calculating half of array sum ; sort the array in descending order . ; current sum greater than sum ; ","context":"","code":"def minElements(arr, n):\n    halfSum = 0\n    for i in range(n):\n        halfSum = halfSum + arr[i]\n    halfSum = int(halfSum \/ 2)\n    arr .sort(reverse=True)\n    res = 0\n    curr_sum = 0\n    for i in range(n):\n        curr_sum += arr[i]\n        res += 1\n        if curr_sum > halfSum:\n            return res\n    return res\n","test":"\narr = [3, 1, 7, 1]\nn = len(arr)\nprint(minElements(arr, n))\n","output":"1\n","fn_call":"minElements"}
{"text":"minimum increment and decrement by k of each pair elements required to make all array elements equal | function to check if its possible to make all array elements equal or not ; stores the sum of the array ; traverse the array ; if sum is divisible by n ; otherwise , not possible to make all array elements equal ; ","context":"","code":"def arrayElementEqual(arr, N):\n    sum = 0\n    for i in range(N):\n        sum += arr[i]\n    if (sum % N == 0):\n        print('Yes')\n    else:\n        print(\"No\")\n","test":"\narr = [1, 5, 6, 4]\nN = len(arr)\narrayElementEqual(arr, N)\n","output":"Yes\n","fn_call":"arrayElementEqual"}
{"text":"rearrange array to maximize sum of gcd of array elements with their respective indices | function to find the maximum sum of gcd ( arr [ i ] , i ) by rearranging the array ; stores maximum sum of gcd ( arr [ i ] , i ) by rearranging the array elements ; update res ; ","context":"","code":"def findMaxValByRearrArr(arr, N):\n    res = 0\n    res = (N * (N + 1)) \/\/ 2\n    return res\n","test":"\nif __name__ == '__main__':\n    arr = [3, 2, 1]\n    N = len(arr)\n    print(findMaxValByRearrArr(arr, N))\n","output":"6\n","fn_call":"findMaxValByRearrArr"}
{"text":"polygon with maximum sides that can be inscribed in an n | function to find the maximum sided polygon that can be inscribed ; base case ; return n \/ 2 if n is even otherwise , return - 1 ; ","context":"","code":"def MaximumSides(n):\n    if (n < 4):\n        return -1\n    if n % 2 == 0:\n        return n \/\/ 2\n    return -1\n","test":"\nif __name__ == '__main__':\n    N = 8\n    print(MaximumSides(N))\n","output":"4\n","fn_call":"MaximumSides"}
{"text":"mean of array generated by products of all pairs of the given array | function to find the mean of pair product array of arr [ ] ; initializing suffix sum array ; build suffix sum array ; size of pairproductarray ; stores sum of pairproductarray ; store the mean ; find mean of pairproductarray ; return the resultant mean ; ","context":"","code":"def pairProductMean(arr, N):\n    suffixSumArray = [0] * N\n    suffixSumArray[N - 1] = arr[N - 1]\n    for i in range(N - 2, -1, -1):\n        suffixSumArray[i] = suffixSumArray[i + 1] + arr[i]\n    length = (N * (N - 1)) \/\/ 2\n    res = 0\n    for i in range(N - 1):\n        res += arr[i] * suffixSumArray[i + 1]\n    mean = 0\n    if (length != 0):\n        mean = res \/ length\n    else:\n        mean = 0\n    return mean\n","test":"\nif __name__ == '__main__':\n    arr = [1, 2, 4, 8]\n    N = len(arr)\n    print(round(pairProductMean(arr, N), 2))\n","output":"11.67\n","fn_call":"pairProductMean"}
{"text":"minimize count of unique paths from top left to bottom right of a matrix by placing k 1 s | function to return the value of binomial coefficient c ( n , k ) ; since c ( n , k ) = c ( n , n - k ) ; calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ] ; function to find the minimum count of paths from top left to bottom right by placing k 1 s in the matrix ; count of ways without 1 s ; count of paths from starting poto mid point ; count of paths from mid poto end point ; ","context":"","code":"def ncr(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(k):\n        res *= (n - i)\n        res \/\/= (i + 1)\n    return res\n\n\ndef countPath(N, M, K):\n    answer = 0\n    if (K >= 2):\n        answer = 0\n    elif (K == 0):\n        answer = ncr(N + M - 2, N - 1)\n    else:\n        answer = ncr(N + M - 2, N - 1)\n        X = (N - 1) \/\/ 2 + (M - 1) \/\/ 2\n        Y = (N - 1) \/\/ 2\n        midCount = ncr(X, Y)\n        X = ((N - 1) - (N - 1) \/\/ 2)+((M - 1) - (M - 1) \/\/ 2)\n        Y = ((N - 1) - (N - 1) \/\/ 2)\n        midCount *= ncr(X, Y)\n        answer -= midCount\n    return answer\n","test":"\nif __name__ == '__main__':\n    N = 3\n    M = 3\n    K = 1\n    print(countPath(N, M, K))\n","output":"2\n","fn_call":"countPath"}
{"text":"maximum number of operations required such that no pairs from a matrix overlap | function to find maximum count of operations ; initialize count by 0 ; iterate over remaining pairs ; check if first operation is applicable ; check if 2 nd operation is applicable ; otherwise ; return the count of operations ; ","context":"","code":"def find_max(v, n):\n    count = 0\n    if (n >= 2):\n        count = 2\n    else:\n        count = 1\n    for i in range(1, n - 1):\n        if (v[i - 1][0] > (v[i][0] + v[i][1])):\n            count += 1\n        elif (v[i + 1][0] > (v[i][0] + v[i][1])):\n            count += 1\n            v[i][0] = v[i][0] + v[i][1]\n        else:\n            continue\n    return count\n","test":"\nn = 3\nv = []\nv .append([10, 20])\nv .append([15, 10])\nv .append([20, 16])\nprint(find_max(v, n))\n","output":"2\n","fn_call":"find_max"}
{"text":"count of substrings formed using a given set of characters only | function to find the number of substrings that can be formed using given characters ; boolean array for storing the available characters ; mark indices of all available characters as 1 ; initialize lastpos as - 1 ; initialize ans with the total no of possible substrings ; traverse the string from left to right ; if the current character is not present in b ; subtract the total possible substrings ; update the value of lastpos to current index ; print the final answer ; given string ; ","context":"","code":"def numberofsubstrings(str, k, charArray):\n    N = len(str)\n    available = [0] * 26\n    for i in range(0, k):\n        available[ord(charArray[i]) - ord('a')] = 1\n    lastPos = -1\n    ans = (N * (N + 1)) \/ 2\n    for i in range(0, N):\n        if (available[ord(str[i]) - ord('a')] == 0):\n            ans -= ((i - lastPos) * (N - i))\n            lastPos = i\n    print(int(ans))\n","test":"\nstr = \"abcb\"\nk = 2\ncharArray = ['a', 'b']\nnumberofsubstrings(str, k, charArray)\n","output":"4\n","fn_call":"numberofsubstrings"}
{"text":"minimum cost to reach a point n from 0 with two different operations allowed | function to return minimum cost to reach destination ; initialize cost to 0 ; going backwards until we reach initial position ; if 2 * x jump is better than x + 1 ; if x + 1 jump is better ; ","context":"","code":"def minCost(N, P, Q):\n    cost = 0\n    while (N > 0):\n        if (N & 1):\n            cost += P\n            N -= 1\n        else:\n            temp = N \/\/ 2\n            if (temp * P > Q):\n                cost += Q\n            else:\n                cost += P * temp\n            N \/\/= 2\n    return cost\n","test":"\nN = 9\nP = 5\nQ = 1\nprint(minCost(N, P, Q))\n","output":"13\n","fn_call":"minCost"}
{"text":"number of ways to reach at starting node after travelling through exactly k edges in a complete graph | function to find number of ways to reach from node 1 to 1 again , after moving exactly k edges ; initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node ; base case ; iterate for the number of edges moved ; sum will store number of ways to reach all the nodes ; iterate for every possible state for the current step ; update the value of the dp array after travelling each edge ; print dp [ 0 ] as the answer ; ","context":"","code":"def numberOfWays(n, k):\n    dp = [0 for i in range(1000)]\n    dp[0] = 1\n    for i in range(1, k + 1, 1):\n        numWays = 0\n        for j in range(n):\n            numWays += dp[j]\n        for j in range(n):\n            dp[j] = numWays - dp[j]\n    print(dp[0])\n","test":"\nif __name__ == '__main__':\n    N = 5\n    K = 3\n    numberOfWays(N, K)\n","output":"12\n","fn_call":"numberOfWays"}
{"text":"minimum cost of purchasing at least x chocolates | function to calculate minimum cost of buying least x chocolates ; base case ; include the i - th box ; exclude the i - th box ; return the minimum of the above two cases ; ","context":"","code":"def findMinCost(arr, X, n, i=0):\n    if (X <= 0):\n        return 0\n    if (i >= n):\n        return 10 ** 8\n    inc = findMinCost(arr, X - arr[i][0], n, i + 1)\n    if (inc != 10 ** 8):\n        inc += arr[i][1]\n    exc = findMinCost(arr, X, n, i + 1)\n    return min(inc, exc)\n","test":"\nif __name__ == '__main__':\n    arr = [[4, 3], [3, 2], [2, 4], [1, 3], [4, 2]]\n    X = 7\n    n = len(arr)\n    ans = findMinCost(arr, X, n)\n    if (ans != 10 ** 8):\n        print(ans)\n    else:\n        print(-1)\n","output":"4\n","fn_call":"findMinCost"}
{"text":"probability that the sum of all numbers obtained on throwing a dice n times lies between two given integers | function to calculate the probability for the given sum to be equal to sum in n throws of dice ; base cases ; ","context":"","code":"def find(N, sum):\n    if (sum > 6 * N or sum < N):\n        return 0\n    if (N == 1):\n        if (sum >= 1 and sum <= 6):\n            return 1.0 \/ 6\n        else:\n            return 0\n    s = 0\n    for i in range(1, 7):\n        s = s + find(N - 1, sum - i) \/ 6\n    return s\n","test":"\nif __name__ == \"__main__\":\n    N = 4\n    a = 13\n    b = 17\n    probability = 0.0\n    for sum in range(a, b + 1):\n        probability = probability + find(N, sum)\n    print(round(probability, 6))\n","output":"0.505401\n","fn_call":"find"}
{"text":"minimum steps to reduce n to 0 by given operations | function to find the minimum number to steps to reduce n to 0 ; base case ; recursive call to count the minimum steps needed ; return the answer ; ","context":"","code":"def minDays(n):\n    if n < 1:\n        return n\n    cnt = 1 + min(n % 2 + minDays(n \/\/ 2), n % 3 + minDays(n \/\/ 3))\n    return cnt\n","test":"\nN = 6\nprint(str(minDays(N)))\n","output":"4\n","fn_call":"minDays"}
