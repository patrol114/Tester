[
    {
        "text": "closest greater element for every array element from another array | python implementation to find result from target array for closest element ; function for printing resultant array ; sort list for ease ; list for result ; calculate resultant array ; check location of upper bound element ; if no element found push - 1 ; else puch the element ; add to resultant ; ",
        "context": "\nimport bisect\n\n",
        "code": "def closestResult(a, b, n):\n    a .sort()\n    c = []\n    for i in range(n):\n        up = bisect .bisect_right(a, b[i])\n        if up == n:\n            c .append(-1)\n        else:\n            c .append(a[up])\n    print(\"Result = \", end=\"\")\n    for i in c:\n        print(i, end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 5, 6, 1, 8, 9]\n    b = [2, 1, 0, 5, 4, 9]\n    n = len(a)\n    closestResult(a, b, n)\n",
        "output": "Result = 5 2 1 6 5 -1 ",
        "fn_call": "closestResult"
    },
    {
        "text": "difference between sum of cubes and sum of first n natural numbers | python3 program to find the difference between the sum of the cubes of the first n natural numbers and the sum of the first n natural number ; sum of first n natural numbers ; find the required difference ; ",
        "context": "",
        "code": "def difference(n):\n    S = (n * (n + 1)) // 2\n    res = S * (S - 1)\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    print(difference(n))\n",
        "output": "210\n",
        "fn_call": "difference"
    },
    {
        "text": "path with maximum average value | maximum number of rows and / or columns ; method returns maximum average of all path of cost matrix ; initialize first column of total cost ( dp ) array ; initialize first row of dp array ; construct rest of the dp array ; divide maximum sum by constant path length : ( 2 n - 1 ) for getting average ; ",
        "context": "\nM = 100\n\n",
        "code": "def maxAverageOfPath(cost, N):\n    dp = [[0 for i in range(N + 1)]for j in range(N + 1)]\n    dp[0][0] = cost[0][0]\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n    return dp[N - 1][N - 1] / (2 * N - 1)\n",
        "test": "\ncost = [[1, 2, 3], [6, 5, 4], [7, 3, 9]]\nprint(maxAverageOfPath(cost, 3))\n",
        "output": "5.2\n",
        "fn_call": "maxAverageOfPath"
    },
    {
        "text": "find the number of jumps to reach x in the number line from zero | utility function to calculate sum of numbers from 1 to x ; function to find the number of jumps to reach x in the number line from zero ; first make number positive answer will be same either it is positive or negative ; to store the required answer ; continue till number is lesser or not in same parity ; return the required answer ; ",
        "context": "",
        "code": "def getsum(x):\n    return int((x * (x + 1)) / 2)\n\n\ndef countJumps(n):\n    n = abs(n)\n    ans = 0\n    while (getsum(ans) < n or (getsum(ans) - n) & 1):\n        ans += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 9\n    print(countJumps(n))\n",
        "output": "5\n",
        "fn_call": "countJumps"
    },
    {
        "text": "special prime numbers | python3 program to check whether there exist at least k or not in range [ 2. . n ] ; generating all the prime numbers from 2 to n . ; if a prime number is special prime number , then we increments the value of k . ; if at least k special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; ",
        "context": "\nprimes = []\n\n",
        "code": "def SieveofEratosthenes(n):\n    visited = [False] * (n + 2)\n    for i in range(2, n + 2):\n        if (visited[i] == False):\n            for j in range(i * i, n + 2, i):\n                visited[j] = True\n            primes .append(i)\n\n\ndef specialPrimeNumbers(n, k):\n    SieveofEratosthenes(n)\n    count = 0\n    for i in range(len(primes)):\n        for j in range(i - 1):\n            if (primes[j] + primes[j + 1] + 1 == primes[i]):\n                count += 1\n                break\n        if (count == k):\n            return True\n    return False\n",
        "test": "\nn = 27\nk = 2\nif (specialPrimeNumbers(n, k)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "specialPrimeNumbers"
    },
    {
        "text": "egg dropping puzzle | dp |  ; function to get minimum number of trials needed in worst case with n eggs and k floors ; if there are no floors , then no trials needed . or if there is one floor , one trial needed . ; we need k trials for one egg and k floors ; consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; ",
        "context": "\nimport sys\n\n",
        "code": "def eggDrop(n, k):\n    if (k == 1 or k == 0):\n        return k\n    if (n == 1):\n        return k\n    min = sys .maxsize\n    for x in range(1, k + 1):\n        res = max(eggDrop(n - 1, x - 1), eggDrop(n, k - x))\n        if (res < min):\n            min = res\n    return min + 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 2\n    k = 10\n    print(\"Minimum number of trials in worst case with\",\n          n, \"eggs and\", k, \"floors is\", eggDrop(n, k))\n",
        "output": "Minimum number of trials in worst case with 2 eggs and 10 floors is 4\n",
        "fn_call": "eggDrop"
    },
    {
        "text": "length of longest palindrome substring | function to obtain the length of the longest palindromic substring ; length of given string ; stores the maximum length ; iterate over the string ; iterate over the string ; check for palindrome ; if string [ i , j - i + 1 ] is palindromic ; return length of lps ; ",
        "context": "",
        "code": "def longestPalSubstr(str):\n    n = len(str)\n    maxLength = 1\n    start = 0\n    for i in range(len(str)):\n        for j in range(i, len(str), 1):\n            flag = 1\n            for k in range((j - i + 1) // 2):\n                if (str[i + k] != str[j - k]):\n                    flag = 0\n            if (flag != 0 and (j - i + 1) > maxLength):\n                start = i\n                maxLength = j - i + 1\n    return maxLength\n",
        "test": "\nstr = \"forgeeksskeegfor\"\nprint(longestPalSubstr(str))\n",
        "output": "10\n",
        "fn_call": "longestPalSubstr"
    },
    {
        "text": "find whether a given number is a power of 4 or not | python3 program to check if given number is power of 4 or not ; ",
        "context": "",
        "code": "def isPowerOfFour(n):\n    return (n != 0 and ((n & (n - 1)) == 0) and not (n & 0xAAAAAAAA))\n",
        "test": "\ntest_no = 64\nif (isPowerOfFour(test_no)):\n    print(test_no, \"is a power of 4\")\nelse:\n    print(test_no, \"is not a power of 4\")\n",
        "output": "64 is a power of 4\n",
        "fn_call": "isPowerOfFour"
    },
    {
        "text": "length of longest subarray of length at least 2 with maximum gcd | function to calculate gcd of two numbers ; function to find maximum size subarray having maximum gcd ; base case ; let the maximum gcd be 1 initially ; loop through array to find maximum gcd of subarray with size 2 ; traverse the array ; is a multiple of k , increase cnt ; else update maximum length with consecutive element divisible by k set cnt to 0 ; update the maxlength ; return the maxlength ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef maxGcdSubarray(arr, n):\n    if n == 1:\n        return 0\n    k = 1\n    for i in range(1, n):\n        k = max(k, gcd(arr[i], arr[i - 1]))\n    cnt = 0\n    maxLength = 0\n    for i in range(n):\n        if arr[i] % k == 0:\n            cnt += 1\n        else:\n            maxLength = max(maxLength, cnt)\n            cnt = 0\n    maxLength = max(maxLength, cnt)\n    return maxLength\n",
        "test": "\narr = [18, 3, 6, 9]\nn = len(arr)\nprint(maxGcdSubarray(arr, n))\n",
        "output": "4\n",
        "fn_call": "maxGcdSubarray"
    },
    {
        "text": "smallest submatrix with kth maximum xor | function to print smallest index of kth maximum xor value of submatrices ; dimensions of matrix ; stores xor values for every index ; min heap to find the kth maximum xor value ; stores indices for corresponding xor values ; traversing matrix to calculate xor values ; insert calculated value in min heap ; if size exceeds k ; remove the minimum ; store smallest index containing xor [ i , j ] ; stores the kth maximum element ; print the required index ; ",
        "context": "",
        "code": "def smallestPosition(m, k):\n    n = len(m)\n    mm = len(m[1])\n    xor = [[0 for i in range(mm)]for j in range(n)]\n    minHeap = []\n    Map = {}\n    for i in range(n):\n        for j in range(mm):\n            if i - 1 >= 0:\n                a = xor[i - 1][j]\n            else:\n                a = 0\n            if j - 1 >= 0:\n                b = xor[i][j - 1]\n            else:\n                b = 0\n            if i - 1 >= 0 and j - 1 >= 0:\n                c = xor[i - 1][j - 1]\n            else:\n                c = 0\n            xor[i][j] = m[i][j] ^ a ^ b ^ c\n            minHeap .append(xor[i][j])\n            minHeap .sort()\n            if (len(minHeap) > k):\n                del minHeap[0]\n            if xor[i][j]not in Map:\n                Map[xor[i][j]] = [i, j]\n    minHeap .sort()\n    kth_max_e = minHeap[0]\n    print((Map[kth_max_e][0] + 1), (Map[kth_max_e][1] + 1))\n",
        "test": "\nm = [[1, 2, 3], [2, 2, 1], [2, 4, 2]]\nk = 1\nsmallestPosition(m, k)\n",
        "output": "3 2\n",
        "fn_call": "smallestPosition"
    },
    {
        "text": "find the lexicographically smallest string which satisfies the given condition | function to return the required string ; first character will always be 'a ; to store the resultant string ; since length of the string should be greater than 0 and first element of array should be 1 ; check one by one all element of given prefix array ; if the difference between any two consecutive elements of the prefix array is greater than 1 then there will be no such string possible that satisfies the given array . also , string cannot have more than 26 distinct characters ; if difference is 0 then the ( i + 1 ) th character will be same as the ith character ; if difference is 1 then the ( i + 1 ) th character will be different from the ith character ; return the resultant string ; ",
        "context": "",
        "code": "def smallestString(N, A):\n\n    ch = 'a'\n    S = \"\"\n    if (N < 1 or A[0] != 1):\n        S = \"-1\"\n        return S\n    S += str(ch)\n    ch = chr(ord(ch) + 1)\n    for i in range(1, N):\n        diff = A[i] - A[i - 1]\n        if (diff > 1 or diff  26):\n            S = \"-1\"\n            return S\n        elif (diff == 0):\n            S += 'a'\n        else:\n            S += ch\n            ch = chr(ord(ch) + 1)\n    return S\n",
        "test": "\narr = [1, 1, 2, 3, 3]\nn = len(arr)\nprint(smallestString(n, arr))\n",
        "output": "aabca\n",
        "fn_call": "smallestString"
    },
    {
        "text": "find the smallest positive number missing from an unsorted array | set 1 | utility function that puts all non - positive ( 0 and negative ) numbers on left side of arr [ ] and return count of such numbers ; increment count of non - positive integers ; find the smallest positive missing number in an array that contains all positive integers ; mark arr [ i ] as visited by making arr [ arr [ i ] - 1 ] negative . note that 1 is subtracted because index start from 0 and positive numbers start from 1 ; return the first index value at which is positive ; 1 is added because indexes start from 0 ; find the smallest positive missing number in an array that contains both positive and negative integers ; first separate positive and negative numbers ; shift the array and call findmissingpositive for positive part ; ",
        "context": "",
        "code": "def segregate(arr, size):\n    j = 0\n    for i in range(size):\n        if (arr[i] <= 0):\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    return j\n\n\ndef findMissingPositive(arr, size):\n    for i in range(size):\n        if (abs(arr[i]) - 1  0):\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n    for i in range(size):\n        if (arr[i] > 0):\n            return i + 1\n    return size + 1\n\n\ndef findMissing(arr, size):\n    shift = segregate(arr, size)\n    return findMissingPositive(arr[shift:], size - shift)\n",
        "test": "\narr = [0, 10, 2, -10, -20]\narr_size = len(arr)\nmissing = findMissing(arr, arr_size)\nprint(\"The smallest positive missing number is \", missing)\n",
        "output": "The smallest positive missing number is  1\n",
        "fn_call": "findMissing"
    },
    {
        "text": "check if a string is suffix of another | python 3 program to find if a string is suffix of another ; ",
        "context": "",
        "code": "def isSuffix(s1, s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    if (n1 > n2):\n        return False\n    for i in range(n1):\n        if (s1[n1 - i - 1] != s2[n2 - i - 1]):\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"geeks\"\n    s2 = \"geeksforgeeks\"\n    result = isSuffix(s1, s2)\n    if (result):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isSuffix"
    },
    {
        "text": "Count minimum bits to flip such that XOR of A and B equal to C | Python code to find minimum bits to be flip ; If both A [ i ] and B [ i ] are equal ; if A [ i ] and B [ i ] are unequal ; N represent total count of Bits",
        "context": "",
        "code": "def totalFlips(A, B, C, N):\n    count = 0\n    for i in range(N):\n        if A[i] == B[i] and C[i] == '1':\n            count = count + 1\n        elif A[i] != B[i] and C[i] == '0':\n            count = count + 1\n    return count\n",
        "test": "\nN = 5\na = \"10100\"\nb = \"00010\"\nc = \"10011\"\nprint(totalFlips(a, b, c, N))\n",
        "output": "2\n",
        "fn_call": "totalFlips"
    },
    {
        "text": "bottom view of a binary tree | tree node class ; constructor of tree node ; method that prints the bottom view . ; initialize a variable ' hd ' with 0 for the root element . ; treemap which stores key value pair sorted on key value ; queue to store tree nodes in level order traversal ; assign initialized horizontal distance value to root node and add it to the queue . ; in stl , append ( ) is used enqueue an item ; loop until the queue is empty ( standard level order loop ) ; in stl , pop ( ) is used dequeue an item ; extract the horizontal distance value from the dequeued tree node . ; put the dequeued tree node to treemap having key as horizontal distance . every time we find a node having same horizontal distance we need to replace the data in the map . ; if the dequeued node has a left child , add it to the queue with a horizontal distance hd - 1. ; if the dequeued node has a right child , add it to the queue with a horizontal distance hd + 1. ; traverse the map elements using the iterator . ; ",
        "context": "\nclass Node:\n    def __init__(self, key):\n        self .data = key\n        self .hd = 1000000\n        self .left = None\n        self .right = None\n\n",
        "code": "def bottomView(root):\n    if (root is None):\n        return\n    hd = 0\n    m = dict()\n    q = []\n    root .hd = hd\n    q .append(root)\n    while (len(q) != 0):\n        temp = q[0]\n        q .pop(0)\n        hd = temp .hd\n        m[hd] = temp .data\n        if (temp .left is not None):\n            temp .left .hd = hd - 1\n            q .append(temp .left)\n        if (temp .right is not None):\n            temp .right .hd = hd + 1\n            q .append(temp .right)\n    for i in sorted(m .keys()):\n        print(m[i], end=' ')\n",
        "test": "\nif __name__ == '__main__':\n    root = Node(20)\n    root .left = Node(8)\n    root .right = Node(22)\n    root .left .left = Node(5)\n    root .left .right = Node(3)\n    root .right .left = Node(4)\n    root .right .right = Node(25)\n    root .left .right .left = Node(10)\n    root .left .right .right = Node(14)\n    print(\"Bottom view of the given binary tree :\")\n    bottomView(root)\n",
        "output": "Bottom view of the given binary tree :\n5 10 4 14 25 ",
        "fn_call": "bottomView"
    },
    {
        "text": "count all pairs of an array which differ in k bits | utility function to count total ones in a number ; function to count pairs of k different bits ; initialize final answer ; check for k differ bit ; ",
        "context": "",
        "code": "def bitCount(n):\n    count = 0\n    while (n):\n        if (n & 1):\n            count += 1\n        n >>= 1\n    return count\n\n\ndef countPairsWithKDiff(arr, n, k):\n    ans = 0\n    for i in range(0, n - 1, 1):\n        for j in range(i + 1, n, 1):\n            xoredNum = arr[i] ^ arr[j]\n            if (k == bitCount(xoredNum)):\n                ans += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    k = 2\n    arr = [2, 4, 1, 3, 1]\n    n = len(arr)\n    print(\"Total pairs for k =\", k, \"are\", countPairsWithKDiff(arr, n, k))\n",
        "output": "Total pairs for k = 2 are 5\n",
        "fn_call": "countPairsWithKDiff"
    },
    {
        "text": "check if string follows order of characters defined by a pattern or not | set 2 | python3 program to check if characters of a string follow pattern defined by given pattern . ; insert all characters of pattern in a hash set , ; build modified string ( string with characters only from pattern are taken ) ; remove more than one consecutive occurrences of pattern characters from modified string . ; after above modifications , the length of modified string must be same as pattern length ; and pattern characters must also be same as modified string characters ; ",
        "context": "",
        "code": "def followsPattern(string, pattern):\n    patternSet = set()\n    for i in range(len(pattern)):\n        patternSet .add(pattern[i])\n    modifiedString = string\n    for i in range(len(string) - 1, -1, -1):\n        if not modifiedString[i] in patternSet:\n            modifiedString = modifiedString[:i] + modifiedString[i + 1:]\n    for i in range(len(modifiedString) - 1, 0, -1):\n        if modifiedString[i] == modifiedString[i - 1]:\n            modifiedString = modifiedString[:i] + modifiedString[i + 1:]\n    if len(pattern) != len(modifiedString):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] != modifiedString[i]:\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"engineers rock\"\n    pattern = \"er\"\n    print(\"Expected: true, Actual:\", followsPattern(string, pattern))\n    string = \"engineers rock\"\n    pattern = \"egr\"\n    print(\"Expected: false, Actual:\", followsPattern(string, pattern))\n    string = \"engineers rock\"\n    pattern = \"gsr\"\n    print(\"Expected: false, Actual:\", followsPattern(string, pattern))\n    string = \"engineers rock\"\n    pattern = \"eger\"\n    print(\"Expected: true, Actual:\", followsPattern(string, pattern))\n",
        "output": "Expected: true, Actual: True\nExpected: false, Actual: False\nExpected: false, Actual: False\nExpected: true, Actual: True\n",
        "fn_call": "followsPattern"
    },
    {
        "text": "theft at world bank | python3 program for the above approach ; custom comparator ; function to find the maximum profit ; stores the pairs of elements of b and a at the same index ; iterate over the range [ 0 , n ] ; if current integer is perfect square ; push the pair of b [ i ] and a [ i ] in vector v ; sort the vector using the custom comparator ; stores the maximum profit ; traverse the vector v ; if v [ i ] [ 1 ] is less than w ; increment profit by v [ i ] [ 0 ] ; decrement v [ i ] [ 0 ] from w ; otherwise ; update profit ; return the value of profit ; ",
        "context": "\nimport math\nfrom functools import cmp_to_key\n\n",
        "code": "def comparator(p1, p2):\n    a = p1[0]\n    b = p1[1]\n    c = p2[0]\n    d = p2[1]\n    val1 = a / b\n    val2 = c / d\n    return val1 > val2\n\n\ndef maximumProfit(A, B, N, W):\n    V = []\n    for i in range(0, N):\n        temp = int(math .sqrt(A[i]))\n        if temp * temp == A[i]:\n            continue\n        V .append([B[i], A[i]])\n    V = sorted(V, key=cmp_to_key(comparator))\n    profit = 0.00\n    k = len(V)\n    for i in range(k):\n        if V[i][1] <= W:\n            profit += V[i][0]\n            W -= V[i][1]\n        else:\n            profit += (V[i][0] * W) / V[i][1]\n            break\n    return profit\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    W = 10\n    A = [4, 5, 7]\n    B = [8, 5, 4]\n    print(round(maximumProfit(A, B, N, W), 5))\n",
        "output": "7.85714\n",
        "fn_call": "maximumProfit"
    },
    {
        "text": "find two fibonacci numbers whose sum can be represented as n | function to create hash table to check fibonacci numbers ; storing the first two numbers in the hash ; finding fibonacci numbers up to n and storing them in the hash ; function to find the fibonacci pair with the given sum ; creating a set containing all fibonacci numbers ; traversing all numbers to find first pair ; if both i and ( n - i ) are fibonacci ; printing the pair because i + ( n - i ) = n ; if no fibonacci pair is found whose sum is equal to n ; ",
        "context": "",
        "code": "def createHash(hash1, maxElement):\n    prev, curr = 0, 1\n    hash1 .add(prev)\n    hash1 .add(curr)\n    while (curr < maxElement):\n        temp = curr + prev\n        hash1 .add(temp)\n        prev = curr\n        curr = temp\n\n\ndef findFibonacciPair(n):\n    hash1 = set()\n    createHash(hash1, n)\n    for i in range(n):\n        if (i in hash1 and (n - i) in hash1):\n            print(i, \", \", (n - i))\n            return\n    print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 90\n    findFibonacciPair(N)\n",
        "output": "1 ,  89\n",
        "fn_call": "findFibonacciPair"
    },
    {
        "text": "find the previous fibonacci number | python3 implementation of the approach ; function to return the previous fibonacci number ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def previousFibonacci(n):\n    a = n / ((1 + sqrt(5)) / 2.0)\n    return round(a)\n",
        "test": "\nn = 8\nprint(previousFibonacci(n))\n",
        "output": "5\n",
        "fn_call": "previousFibonacci"
    },
    {
        "text": "check if any permutation of array contains sum of every adjacent pair not divisible by 3 | function to checks if any permutation of the array exists whose sum of adjacent pairs is not divisible by 3 ; count remainder 0 ; count remainder 1 ; count remainder 2 ; condition for valid arrangements ; ",
        "context": "",
        "code": "def factorsOf3(arr, N):\n    a = 0\n    b = 0\n    c = 0\n    for i in range(N):\n        if (arr[i] % 3 == 0):\n            a += 1\n        elif (arr[i] % 3 == 1):\n            b += 1\n        elif (arr[i] % 3 == 2):\n            c += 1\n    if (a >= 1 and a <= b + c + 1):\n        print(\"Yes\")\n    elif (a == 0 and b == 0 and c > 0):\n        print(\"Yes\")\n    elif (a == 0 and c == 0 and b > 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\narr = [1, 2, 3, 3]\nN = len(arr)\nfactorsOf3(arr, N)\n",
        "output": "Yes\n",
        "fn_call": "factorsOf3"
    },
    {
        "text": "check if the n | python3 program to check if the nth is odd or even in a sequence where each term is sum of previous two term ; return if the nth term is even or odd . ; return true if odd ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def findNature(a, b, n):\n    seq = [0] * MAX\n    seq[0] = a\n    seq[1] = b\n    for i in range(2, n + 1):\n        seq[i] = seq[i - 1] + seq[i - 2]\n    return (seq[n] & 1)\n",
        "test": "\na = 2\nb = 4\nn = 3\nif (findNature(a, b, n)):\n    print(\"Odd\")\nelse:\n    print(\"Even\")\n",
        "output": "Even\n",
        "fn_call": "findNature"
    },
    {
        "text": "minimum operations to make gcd of array a multiple of k | python 3 program to make gcd of array a multiple of k . ; if array value is not 1 and it is greater than k then we can increase the or decrease the remainder obtained by dividing k from the ith value of array so that we get the number which is either closer to k or its multiple ; else we only have one choice which is to increment the value to make equal to k ; ",
        "context": "",
        "code": "def MinOperation(a, n, k):\n    result = 0\n    for i in range(n):\n        if (a[i] != 1 and a[i] > k):\n            result = (result + min(a[i] % k, k - a[i] % k))\n        else:\n            result = result + k - a[i]\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 5, 6]\n    n = len(arr)\n    k = 5\n    print(MinOperation(arr, n, k))\n",
        "output": "2\n",
        "fn_call": "MinOperation"
    },
    {
        "text": "maximum index a pointer can reach in n steps by avoiding a given index b | set 2 | function to find the maximum index the pointer can reach ; initialize two pointers ; stores number of steps ; stores sum of first n natural numbers ; increment i with j ; increment j with 1 ; increment count ; if i points to b ; break ; print the pointer index ; ",
        "context": "",
        "code": "def maximumIndex(N, B):\n    i, j = 0, 1\n    cnt = 0\n    sum = N * (N + 1) // 2\n    flag = False\n    while (cnt < N):\n        i += j\n        j += 1\n        cnt += 1\n        if (i == B):\n            flag = True\n            break\n    if (not flag):\n        print(sum)\n    else:\n        print(sum - 1)\n",
        "test": "\nif __name__ == '__main__':\n    N, B = 4, 6\n    maximumIndex(N, B)\n",
        "output": "9\n",
        "fn_call": "maximumIndex"
    },
    {
        "text": "number of pairs whose sum is a power of 2 | set 2 | python3 program to implement the above approach ; function to count all pairs whose sum is a power of two ; stores the frequency of each element of the array ; update frequency of array elements ; stores count of required pairs ; current power of 2 ; traverse the array ; if pair does not exist ; increment count of pairs ; return the count of pairs ; ",
        "context": "\nfrom math import pow\n\n",
        "code": "def countPair(arr, n):\n    m = {}\n    for i in range(n):\n        m[arr[i]] = m .get(arr[i], 0) + 1\n    ans = 0\n    for i in range(31):\n        key = int(pow(2, i))\n        for j in range(n):\n            k = key - arr[j]\n            if k not in m:\n                continue\n            else:\n                ans += m .get(k, 0)\n            if (k == arr[j]):\n                ans += 1\n    return ans // 2\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 8, 2, 10, 6]\n    n = len(arr)\n    print(countPair(arr, n))\n",
        "output": "5\n",
        "fn_call": "countPair"
    },
    {
        "text": "maximum tip calculator | function that finds the maximum tips from the given arrays as per the given conditions ; base condition ; if both have non - zero count then return max element from both array ; traverse first array , as y count has become 0 ; traverse 2 nd array , as x count has become 0 ; ",
        "context": "",
        "code": "def maximumTip(arr1, arr2, n, x, y):\n    if n == 0:\n        return 0\n    if x != 0 and y != 0:\n        return max(arr1[n - 1] + maximumTip(arr1, arr2, n - 1, x - 1, y),\n                   arr2[n - 1] + maximumTip(arr1, arr2, n - 1, x, y - 1))\n    if y == 0:\n        return arr1[n - 1] + maximumTip(arr1, arr2, n - 1, x - 1, y)\n    else:\n        return arr2[n - 1] + maximumTip(arr1, arr2, n - 1, x, y - 1)\n",
        "test": "\nN = 5\nX = 3\nY = 3\nA = [1, 2, 3, 4, 5]\nB = [5, 4, 3, 2, 1]\nprint(maximumTip(A, B, N, X, Y))\n",
        "output": "21\n",
        "fn_call": "maximumTip"
    },
    {
        "text": "count permutations of first n natural numbers having sum of adjacent elements equal to a perfect square | python program for the above approach ; function to count total number of permutation of the first n natural number having the sum of adjacent elements as perfect square ; create an adjacency matrix ; bcount elements whose indegree bis 1 ; bgenerate adjacency matrix ; find the sum of i and j ; if sum is perfect square . then move from i to j ; add it in adjacency list of i ; if any list is of size 1 , then the indegree is 1 ; if there is no element whose indegree is 1 , then n such permutations are possible ; if there is 1 or 2 elements whose indegree is 1 , then 2 permutations are possible ; if there are more than 2 elements whose indegree is 1 , then return 0 ; ",
        "context": "\nfrom math import sqrt, floor, ceil\n\n",
        "code": "def countPermutations(N):\n    adj = [[]for i in range(105)]\n    indeg = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if (i == j):\n                continue\n            sum = i + j\n            if (ceil(sqrt(sum)) == floor(sqrt(sum))):\n                adj[i].append(j)\n        if (len(adj[i]) == 1):\n            indeg += 1\n    if (indeg == 0):\n        return N\n    elif (indeg <= 2):\n        return 2\n    else:\n        return 0\n",
        "test": "\nif __name__ == '__main__':\n    N = 17\n    print(countPermutations(N))\n",
        "output": "2\n",
        "fn_call": "countPermutations"
    },
    {
        "text": "minimum elements to be removed such that sum of adjacent elements is always odd | returns the minimum number of eliminations ; stores the previous element ; stores the new value ; check if the previous and current values are of same parity ; previous value is now the current value ; return the counter variable ; ",
        "context": "",
        "code": "def min_elimination(n, arr):\n    count = 0\n    prev_val = arr[0]\n    for i in range(1, n):\n        curr_val = arr[i]\n        if (curr_val % 2 == prev_val % 2):\n            count = count + 1\n        prev_val = curr_val\n    return count\n",
        "test": "\narr = [1, 2, 3, 7, 9]\nn = len(arr)\nprint(min_elimination(n, arr))\n",
        "output": "2\n",
        "fn_call": "min_elimination"
    },
    {
        "text": "distance between two nodes of binary tree with node values from 1 to n | python 3 program to find minimum distance between two nodes in binary tree ; function to get minimum path distance ; find the 1 st dis - similar bit count bit length of n1 and n2 ; find bit difference and maxbit ; calculate result by formula ; ",
        "context": "\nfrom math import log2\n\n",
        "code": "def minDistance(n1, n2):\n    bitCount1 = int(log2(n1)) + 1\n    bitCount2 = int(log2(n2)) + 1\n    bitDiff = abs(bitCount1 - bitCount2)\n    maxBitCount = max(bitCount1, bitCount2)\n    if (bitCount1 > bitCount2):\n        n2 = int(n2 * pow(2, bitDiff))\n    else:\n        n1 = int(n1 * pow(2, bitDiff))\n    xorValue = n1 ^ n2\n    if xorValue == 0:\n        bitCountXorValue = 1\n    else:\n        bitCountXorValue = int(log2(xorValue)) + 1\n    disSimilarBitPosition = (maxBitCount - bitCountXorValue)\n    result = (bitCount1 + bitCount2 - 2 * disSimilarBitPosition)\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    n1 = 12\n    n2 = 5\n    print(minDistance(n1, n2))\n",
        "output": "5\n",
        "fn_call": "minDistance"
    },
    {
        "text": "maximize the last array element as per the given conditions | function to find the maximum possible value that can be placed at the last index ; sort the array elements in ascending order ; if the first element is is not equal to 1 ; traverse the array to make difference between adjacent elements <= 1 ; ",
        "context": "",
        "code": "def maximizeFinalElement(arr, n):\n    arr .sort()\n    if (arr[0] != 1):\n        arr[0] = 1\n    for i in range(1, n):\n        if (arr[i] - arr[i - 1] > 1):\n            arr[i] = arr[i - 1] + 1\n    return arr[n - 1]\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    arr = [3, 1, 3, 4]\n    max = maximizeFinalElement(arr, n)\n    print(max)\n",
        "output": "4\n",
        "fn_call": "maximizeFinalElement"
    },
    {
        "text": "minimum number of flips required such that a binary matrix doesn 't contain any path from the top left to the bottom right consisting only of 0s | the four direction coordinates changes from the current cell ; function that returns true if there exists any path from the top - left to the bottom - right cell of 0 s ; if the bottom - right cell is reached ; update the cell to 1 ; traverse in all four directions ; find the new coordinates ; if the new cell is valid ; recursively call dfs ; if path exists , then return true ; return false , if there doesn 't  exists any such path ; function to flip the minimum number of cells such that there doesn 't exists any such path from (0, 0) to (n - 1, m - 1) cell consisting of 0s ; case 1 : if no such path exists already ; case 2 : if there exists only one path ; case 3 : if there exists two - path ; ",
        "context": "\ndirection = [[-1, 0], [0, 1], [0, -1], [1, 0]]\n\n",
        "code": "def dfs(i, j, N, M):\n    global matrix\n    if (i == N - 1 and j == M - 1):\n        return True\n    matrix[i][j] = 1\n    for k in range(4):\n        newX = i + direction[k][0]\n        newY = j + direction[k][1]\n        if (newX >= 0 and newX =\n                0 and newY < M and matrix[newX][newY] == 0):\n            if (dfs(newX, newY, N, M)):\n                return True\n    return False\n\n\ndef solve():\n    global matrix\n    N = len(matrix)\n    M = len(matrix[0])\n    if (not dfs(0, 0, N, M)):\n        return 0\n    if (not dfs(0, 0, N, M)):\n        return 1\n    return 2\n",
        "test": "\nif __name__ == '__main__':\n    matrix = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\n    print(solve())\n",
        "output": "1\n",
        "fn_call": "solve"
    },
    {
        "text": "count number of ways to partition a set into k subsets | returns count of different partitions of n elements in k subsets ; table to store results of subproblems ; base cases ; fill rest of the entries in dp [ ] [ ] in bottom up manner ; ",
        "context": "",
        "code": "def countP(n, k):\n    dp = [[0 for i in range(k + 1)]for j in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(k + 1):\n        dp[0][k] = 0\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if (j == 1 or i == j):\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1])\n    return dp[n][k]\n",
        "test": "\nif __name__ == '__main__':\n    print(countP(5, 2))\n",
        "output": "15\n",
        "fn_call": "countP"
    },
    {
        "text": "first non | '' python3 implementation to find non repeating character using 1d array and one traversal ; the function returns index of the first non - repeating character in a string . if all characters are repeating then returns int_max ; initialize all character as absent ; after below loop , the value of arr [ x ] is going to be index of of x if x appears only once . else the value is going to be either - 1 or - 2. ; if this character occurs only once and appears before the current result , then update the result ; ",
        "context": "\nimport math as mt\nNO_OF_CHARS = 256\n\n",
        "code": "def firstNonRepeating(string):\n    arr = [-1 for i in range(NO_OF_CHARS)]\n    for i in range(len(string)):\n        if arr[ord(string[i])] == -1:\n            arr[ord(string[i])] = i\n        else:\n            arr[ord(string[i])] = -2\n    res = 10 ** 18\n    for i in range(NO_OF_CHARS):\n        if arr[i] >= 0:\n            res = min(res, arr[i])\n    return res\n",
        "test": "\nstring = \"geeksforgeeks\"\nindex = firstNonRepeating(string)\nif index == 10 ** 18:\n    print(\"Either all characters are repeating or string is empty\")\nelse:\n    print(\"First non-repeating character is\", string[index])\n",
        "output": "First non-repeating character is f\n",
        "fn_call": "firstNonRepeating"
    },
    {
        "text": "print all array elements appearing more than n / k times | function to + find the upper_bound of an array element ; stores minimum index in which k lies ; stores maximum index in which k lies ; calculate the upper bound of k ; stores mid element of l and r ; if arr [ mid ] is less than or equal to k ; right subarray ; left subarray ; function to prall array elements whose frequency is greater than n / k ; sort the array arr ; stores index of an array element ; traverse the array ; stores upper bound of arr [ i ] ; if frequency of arr [ i ] is greater than n / 4 ; update i ; ",
        "context": "",
        "code": "def upperBound(arr, N, K):\n    l = 0\n    r = N\n    while (l < r):\n        mid = (l + r) // 2\n        if (arr[mid] <= K):\n            l = mid + 1\n        else:\n            r = mid\n    return l\n\n\ndef NDivKWithFreq(arr, N, K):\n    arr .sort()\n    i = 0\n    while (i < N):\n        X = upperBound(arr, N, arr[i])\n        if ((X - i) > N // 4):\n            print(arr[i], end=\"\")\n        i = X\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 2, 6, 6, 6, 6, 7, 10]\n    N = len(arr)\n    K = 4\n    NDivKWithFreq(arr, N, K)\n",
        "output": "6",
        "fn_call": "NDivKWithFreq"
    },
    {
        "text": "number of occurrences of 2 as a digit in numbers from 0 to n | counts the number of '2' digits in a single number ; counts the number of '2' digits between 0 and n ; initialize result ; count 2 's in every number  from 2 to n ; ",
        "context": "",
        "code": "def number0f2s(n):\n    count = 0\n    while (n > 0):\n        if (n % 10 == 2):\n            count = count + 1\n        n = n // 10\n    return count\n\n\ndef numberOf2sinRange(n):\n    count = 0\n    for i in range(2, n + 1):\n        count = count + number0f2s(i)\n    return count\n",
        "test": "\nprint(numberOf2sinRange(22))\nprint(numberOf2sinRange(100))\n",
        "output": "6\n20\n",
        "fn_call": "numberOf2sinRange"
    },
    {
        "text": "maximum power of jump required to reach the end of string | function to calculate the maximum power of the jump ; initialize the count with 1 ; find the character at last index ; start traversing the string ; check if the current char is equal to the last character ; max_so_far stores maximum value of the power of the jump from starting to ith position ; reset the count to 1 ; else , increment the number of jumps / count ; return the maximum number of jumps ; ",
        "context": "",
        "code": "def powerOfJump(s):\n    count = 1\n    max_so_far = 0\n    ch = s[-1]\n    for i in range(0, len(s)):\n        if s[i] == ch:\n            if count > max_so_far:\n                max_so_far = count\n            count = 1\n        else:\n            count += 1\n    return max_so_far\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"1010101\"\n    print(powerOfJump(st))\n",
        "output": "2\n",
        "fn_call": "powerOfJump"
    },
    {
        "text": "analysis of algorithms | big | function to print all possible pairs ; ",
        "context": "",
        "code": "def printt(a, n):\n    for i in range(n):\n        for j in range(n):\n            if (i != j):\n                print(a[i], \"\", a[j])\n",
        "test": "\na = [1, 2, 3]\nn = len(a)\nprintt(a, n)\n",
        "output": "1  2\n1  3\n2  1\n2  3\n3  1\n3  2\n",
        "fn_call": "printt"
    },
    {
        "text": "friends pairing problem | returns count of ways n people can remain single or paired up . ; filling dp [ ] in bottom - up manner using recursive formula explained above . ; ",
        "context": "",
        "code": "def countFriendsPairings(n):\n    dp = [0 for i in range(n + 1)]\n    for i in range(n + 1):\n        if (i <= 2):\n            dp[i] = i\n        else:\n            dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]\n    return dp[n]\n",
        "test": "\nn = 4\nprint(countFriendsPairings(n))\n",
        "output": "10\n",
        "fn_call": "countFriendsPairings"
    },
    {
        "text": "maximize shortest path between given vertices by adding a single edge | function that performs bfs traversal ; fill initially each distance as inf fill ( dist , dist + n , inf ) ; perform bfs ; traverse the current edges ; update the distance ; insert in queue ; function that maximizes the shortest path between source and destination vertex by adding a single edge between given selected nodes ; to update the shortest distance between node 1 to other vertices ; to update the shortest distance between node n to other vertices ; store the values x [ i ] - y [ i ] ; sort all the vectors of pairs ; traverse data [ ] ; maximize x [ a ] - y [ b ] ; prminimum cost ; ",
        "context": "",
        "code": "def bfs(x, s):\n    global edges, dist\n    q = [0 for i in range(200000)]\n    qh, qt = 0, 0\n    q[qh] = s\n    qh += 1\n    dist[x][s] = 0\n    while (qt < qh):\n        xx = q[qt]\n        qt += 1\n        for y in edges[xx]:\n            if (dist[x][y] == 10 ** 18):\n                dist[x][y] = dist[x][xx] + 1\n                q[qh] = y\n                qh += 1\n\n\ndef shortestPathCost(selected, K):\n    global dist, edges\n    data = []\n    bfs(0, 0)\n    bfs(1, N - 1)\n    for i in range(K):\n        data .append([dist[0][selected[i]] - dist[1]\n                     [selected[i]], selected[i]])\n    data = sorted(data)\n    best = 0\n    MAX = -10 ** 18\n    for it in data:\n        a = it[1]\n        best = max(best, MAX + dist[1][a])\n        MAX = max(MAX, dist[0][a])\n    print(min(dist[0][N - 1], best + 1))\n",
        "test": "\nif __name__ == '__main__':\n    edges = [[]for i in range(5)]\n    dist = [[10 ** 18 for i in range(1000005)]for i in range(2)]\n    N, M = 5, 4\n    K = 2\n    selected = [1, 3]\n    selected = sorted(selected)\n    edges[0].append(1)\n    edges[1].append(0)\n    edges[1].append(2)\n    edges[2].append(1)\n    edges[2].append(3)\n    edges[3].append(2)\n    edges[3].append(4)\n    edges[4].append(3)\n    shortestPathCost(selected, K)\n",
        "output": "3\n",
        "fn_call": "shortestPathCost"
    },
    {
        "text": "maximum area of quadrilateral | python3 program to find maximum area of a quadrilateral ; calculating the semi - perimeter of the given quadrilateral ; applying brahmagupta 's formula to  get maximum area of quadrilateral ; ",
        "context": "\nimport math\n\n",
        "code": "def maxArea(a, b, c, d):\n    semiperimeter = (a + b + c + d) / 2\n    return math .sqrt((semiperimeter - a) * (semiperimeter - b)\n                      * (semiperimeter - c) * (semiperimeter - d))\n",
        "test": "\na = 1\nb = 2\nc = 1\nd = 2\nprint(\"%.2f\" % maxArea(a, b, c, d))\n",
        "output": "2.00\n",
        "fn_call": "maxArea"
    },
    {
        "text": "check if elements of given array can be rearranged such that ( arr [ i ] + i * k ) % n = i for all values of i in range [ 0 , n | function to check if it is possible to generate all numbers in range [ 0 , n - 1 ] using the sum of elements + in the multiset a and b mod n ; if no more pair of elements can be selected ; if the number of elements in c = n , then return true ; otherwise return false ; stores the value of final answer ; iterate through all the pairs in the given multiset a and b ; stores the set a without x ; stores the set a without y ; stores the set a without x + y % n ; recursive call ; return answer ; function to check if it is possible to rearrange array elements such that ( arr [ i ] + i * k ) % n = i ; stores the values of arr [ ] modulo n ; stores all the values of i * k modulo n ; print answer ; ",
        "context": "",
        "code": "def isPossible(A, B, C, N):\n    if (len(A) == 0 or len(B) == 0):\n        if (len(C) == N):\n            return True\n        else:\n            return False\n    ans = False\n    for x in A:\n        for y in B:\n            _A = A\n            _A .remove(x)\n            _B = B\n            _B .remove(y)\n            _C = C\n            _C .add((x + y) % N)\n            ans = (ans or isPossible(_A, _B, _C, N))\n    return ans\n\n\ndef rearrangeArray(arr, N, K):\n    A = []\n    for i in range(N):\n        A .append(arr[i] % N)\n    A .sort()\n    B = []\n    for i in range(N):\n        B .append((i * K) % N)\n    B .sort()\n    C = set()\n    if isPossible(A, B, C, N):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\narr = [1, 2, 0]\nK = 5\nN = len(arr)\nrearrangeArray(arr, N, K)\n",
        "output": "YES\n",
        "fn_call": "rearrangeArray"
    },
    {
        "text": "queries to find sum of distance of a given node to every leaf node in a weighted tree | max size ; graph with { destination , weight } ; for storing the sum for ith node ; leaves in subtree of ith . ; dfs to find sum of distance of leaves in the subtree of a node ; flag is the node is leaf or not ; skipping if parent ; setting flag to false ; doing dfs call ; doing calculation in postorder . ; if the node is leaf then we just increment the no . of leaves under the subtree of a node ; adding num of leaves ; calculating answer for the sum in the subtree ; dfs function to find the sum of distance of leaves outside the subtree ; number of leaves other than the leaves in the subtree of i ; adding the contribution of leaves outside to the ith node ; adding the leafs outside to ith node 's leaves. ; calculating the sum of distance of leaves in the subtree of a node assuming the root of the tree is 1 ; calculating the sum of distance of leaves outside the subtree of node assuming the root of the tree is 1 ; answering the queries ; ",
        "context": "\nN = 10 ** 5 + 5\nv = [[]for i in range(N)]\ndp = [0] * N\nleaves = [0] * (N)\nn = 0\n\n",
        "code": "def dfs(a, par):\n    leaf = 1\n    for i in v[a]:\n        if (i[0] == par):\n            continue\n        leaf = 0\n        dfs(i[0], a)\n    if (leaf == 1):\n        leaves[a] += 1\n    else:\n        for i in v[a]:\n            if (i[0] == par):\n                continue\n            leaves[a] += leaves[i[0]]\n            dp[a] = (dp[a] + dp[i[0]] + leaves[i[0]] * i[1])\n\n\ndef dfs2(a, par):\n    for i in v[a]:\n        if (i[0] == par):\n            continue\n        leafOutside = leaves[a] - leaves[i[0]]\n        dp[i[0]] += (dp[a] - dp[i[0]])\n        dp[i[0]] += i[1] * (leafOutside - leaves[i[0]])\n        leaves[i[0]] += leafOutside\n        dfs2(i[0], a)\n\n\ndef answerQueries(queries):\n    dfs(1, 0)\n    dfs2(1, 0)\n    for i in range(len(queries)):\n        print(dp[queries[i]])\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    v[1].append([4, 4])\n    v[4].append([1, 4])\n    v[1].append([2, 2])\n    v[2].append([1, 2])\n    v[2].append([3, 3])\n    v[3].append([2, 3])\n    v[2].append([5, 5])\n    v[5].append([2, 5])\n    queries = [1, 3, 5]\n    answerQueries(queries)\n",
        "output": "16\n17\n19\n",
        "fn_call": "answerQueries"
    },
    {
        "text": "minimum number of blocks required to form hollow rectangular prism | function to display output ; function to return minimum no of layers required to form the hollow prism ; function to calculate no of blocks required for each layer ; no of blocks required for each row ; check for no of layers is minimum ; ",
        "context": "",
        "code": "def disp(row_no, block):\n    print(row_no * block)\n\n\ndef row(ht, h):\n    return ht // h\n\n\ndef calculate(l, w, h, a, ht):\n    no_block = (4 * a) // l\n    if (h < w):\n        row_no = row(ht, w)\n    else:\n        row_no = row(ht, h)\n    disp(row_no, no_block)\n",
        "test": "\nif __name__ == '__main__':\n    l = 50\n    w = 20\n    h = 35\n    a = 700\n    ht = 140\n    calculate(l, w, h, a, ht)\n",
        "output": "224\n",
        "fn_call": "calculate"
    },
    {
        "text": "program for nth catalan number | a dynamic programming based function to find nth catalan number ; table to store results of subproblems ; initialize first two values in table ; fill entries in catalan [ ] using recursive formula ; return last entry ; ",
        "context": "",
        "code": "def catalan(n):\n    if (n == 0 or n == 1):\n        return 1\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[n]\n",
        "test": "\nfor i in range(10):\n    print(catalan(i), end=\" \")\n",
        "output": "1 1 2 5 14 42 132 429 1430 4862 ",
        "fn_call": "catalan"
    },
    {
        "text": "sum of all divisors from 1 to n | python3 code to find sum of all divisor of number up to 'n ; utility function to find sum of all divisor of number up to 'n ; ",
        "context": "",
        "code": "def divisorSum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += int(n / i) * i\n    return int(sum)\n",
        "test": "\nn = 4\nprint(divisorSum(n))\nn = 5\nprint(divisorSum(n))\n",
        "output": "15\n21\n",
        "fn_call": "divisorSum"
    },
    {
        "text": "sum of the series 1 / ( 1 * 2 ) + 1 / ( 2 * 3 ) + 1 / ( 3 * 4 ) + 1 / ( 4 * 5 ) + . . . . . | function to find the sum of given series ; computing sum term by term ; ",
        "context": "",
        "code": "def sumOfTheSeries(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += 1.0 / (i * (i + 1))\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    ans = sumOfTheSeries(10)\n    print(round(ans, 6))\n",
        "output": "0.909091\n",
        "fn_call": "sumOfTheSeries"
    },
    {
        "text": "index of character depending on frequency count in string | python3 implementation of the approach ; function to perform the queries ; l [ i ] [ j ] stores the largest i such that ith character appears exactly jth times in str [ 0. . . i ] ; f [ i ] [ j ] stores the smallest i such that ith character appears exactly jth times in str [ 0. . . i ] ; to store the frequency of each of the character of str ; current character of str ; update its frequency ; for every lowercase character of the english alphabet ; if it is equal to the character under consideration then update l [ ] [ ] and r [ ] [ ] as it is cnt [ j ] th occurrence of character k ; only update l [ ] [ ] as k has not been occurred so only index has to be incremented ; perform the queries ; type 1 query ; type 2 query ; ",
        "context": "\nimport numpy as np\nMAX = 26\n\n",
        "code": "def performQueries(string, q, type_arr, ch, freq):\n    n = len(string)\n    L = np .zeros((MAX, n))\n    F = np .zeros((MAX, n))\n    cnt = [0] * MAX\n    for i in range(n):\n        k = ord(string[i]) - ord('a')\n        cnt[k] += 1\n        for j in range(MAX):\n            if (k == j):\n                L[j][cnt[j]] = i\n                F[j][cnt[j]] = i\n            else:\n                L[j][cnt[j]] = L[j][cnt[j]] + 1\n    for i in range(q):\n        if (type_arr[i] == 1):\n            print(L[ord(ch[i]) - ord('a')][freq[i]], end=\"\")\n        else:\n            print(F[ord(ch[i]) - ord('a')][freq[i]], end=\"\")\n        print()\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    type_arr = [1, 2]\n    ch = ['e', 'k']\n    freq = [2, 2]\n    q = len(type_arr)\n    performQueries(string, q, type_arr, ch, freq)\n",
        "output": "8.0\n11.0\n",
        "fn_call": "performQueries"
    },
    {
        "text": "sum of the series 5 + 55 + 555 + . . up to n terms | function which return the the sum of series ; ",
        "context": "",
        "code": "def sumOfSeries(n):\n    return (int)(0.6172 * (pow(10, n) - 1) - 0.55 * n)\n",
        "test": "\nn = 2\nprint(sumOfSeries(n))\n",
        "output": "60\n",
        "fn_call": "sumOfSeries"
    },
    {
        "text": "check if given string satisfies the following conditions | python3 program for the above approach ; function to check if given string satisfies the given conditions ; dimensions ; left diagonal ; right diagonal ; conditions not satisfied ; print yes ; ",
        "context": "\nimport math\n\n",
        "code": "def isValid(s):\n    n = int(math .sqrt(len(s)))\n    check = s[0]\n    for i in range(n):\n        x = i\n        y = i\n        while (x >= 0 and y < n):\n            if (s[n * x + y] != check or s[n * x + x] != check):\n                print(\"No\")\n                return\n            x -= 1\n            y += 1\n    print(\"Yes\")\n",
        "test": "\nstr = \"abacdaeaafaghaia\"\nisValid(str)\n",
        "output": "Yes\n",
        "fn_call": "isValid"
    },
    {
        "text": "minimize length of prefix of string s containing all characters of another string t | python3 program for the above approach ; base case - if t is empty , it matches 0 length prefix ; convert strings to lower case for uniformity ; update dictcount to the letter count of t ; if new character is found , initialize its entry , and increase nunique ; increase count of ch ; iterate from 0 to n ; i - th character ; skip if ch not in targetstr ; decrease count ; if the count of ch reaches 0 , we do not need more ch , and can decrease nunique ; if nunique reaches 0 , we have found required prefix ; otherwise ; ",
        "context": "",
        "code": "def getPrefixLength(srcStr, targetStr):\n    if (len(targetStr) == 0):\n        return 0\n    srcStr = srcStr .lower()\n    targetStr = targetStr .lower()\n    dictCount = dict([])\n    nUnique = 0\n    for ch in targetStr:\n        if (ch not in dictCount):\n            nUnique += 1\n            dictCount[ch] = 0\n        dictCount[ch] += 1\n    for i in range(len(srcStr)):\n        ch = srcStr[i]\n        if (ch not in dictCount):\n            continue\n        dictCount[ch] -= 1\n        if (dictCount[ch] == 0):\n            nUnique -= 1\n        if (nUnique == 0):\n            return (i + 1)\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"MarvoloGaunt\"\n    T = \"Tom\"\n    print(getPrefixLength(S, T))\n",
        "output": "12\n",
        "fn_call": "getPrefixLength"
    },
    {
        "text": "count of triplets in an array such that a [ i ] * a [ j ] = a [ k ] and i < j < k | python3 program for the above approach ; returns total number of valid triplets possible ; stores the count ; map to store frequency of array elements ; increment the frequency of a [ j + 1 ] as it can be a valid a [ k ] ; if target exists in the map ; return the final count ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def countTriplets(A, N):\n    ans = 0\n    map = defaultdict(lambda: 0)\n    for j in range(N - 2, 0, -1):\n        map[A[j + 1]] += 1\n        for i in range(j):\n            target = A[i] * A[j]\n            if (target in map .keys()):\n                ans += map[target]\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    A = [2, 3, 4, 6, 12]\n    print(countTriplets(A, N))\n",
        "output": "3\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "check if an octal number is even or odd | check if the number is odd or even ; check if the last digit is either '0' , '2' , '4' , or '6 ; ",
        "context": "",
        "code": "def even_or_odd(N):\n    l = len(N)\n\n    if (N[l - 1] == '0' or N[l - 1] ==\n            '2' or N[l - 1] == '4' or N[l - 1] == '6'):\n        return (\"Even\")\n    else:\n        return (\"Odd\")\n",
        "test": "\nN = \"735\"\nprint(even_or_odd(N))\n",
        "output": "Odd\n",
        "fn_call": "even_or_odd"
    },
    {
        "text": "stepping numbers | prints all stepping numbers reachable from num and in range [ n , m ] ; queue will contain all the stepping numbers ; get the front element and pop from the queue ; if the stepping number is in the range [ n , m ] then display ; if stepping number is 0 or greater than m , no need to explore the neighbors ; get the last digit of the currently visited stepping number ; there can be 2 cases either digit to be appended is lastdigit + 1 or lastdigit - 1 ; if lastdigit is 0 then only possible digit after 0 can be 1 for a stepping number ; if lastdigit is 9 then only possible digit after 9 can be 8 for a stepping number ; prints all stepping numbers in range [ n , m ] using bfs . ; for every single digit number ' i ' find all the stepping numbers starting with i ; ",
        "context": "",
        "code": "def bfs(n, m, num):\n    q = []\n    q .append(num)\n    while len(q) > 0:\n        stepNum = q[0]\n        q .pop(0)\n        if (stepNum = n):\n            print(stepNum, end=\" \")\n        if (num == 0 or stepNum > m):\n            continue\n        lastDigit = stepNum % 10\n        stepNumA = stepNum * 10 + (lastDigit - 1)\n        stepNumB = stepNum * 10 + (lastDigit + 1)\n        if (lastDigit == 0):\n            q .append(stepNumB)\n        elif (lastDigit == 9):\n            q .append(stepNumA)\n        else:\n            q .append(stepNumA)\n            q .append(stepNumB)\n\n\ndef displaySteppingNumbers(n, m):\n    for i in range(10):\n        bfs(n, m, i)\n",
        "test": "\nn, m = 0, 21\ndisplaySteppingNumbers(n, m)\n",
        "output": "0 1 10 12 2 21 3 4 5 6 7 8 9 ",
        "fn_call": "displaySteppingNumbers"
    },
    {
        "text": "bitwise and of n binary strings | python3 implementation of the above approach ; function to find the bitwise and of all the binary strings ; to store the largest and the smallest string ' s \u2581 size , \u2581 we \u2581 need \u2581 this \u2581 to \u2581 add \u2581 ' 0 's  in the resultant string ; reverse each string since we need to perform and operation on bits from right to left ; update the respective length values ; traverse bits from 0 to smallest string 's size ; if at this bit position , there is a 0 in any of the given strings then and operation on current bit position will be 0 ; add resultant bit to result ; add 0 's to the string. ; reverse the string since we started from left to right ; return the resultant string ; ",
        "context": "\nimport sys\n\n",
        "code": "def strBitwiseAND(arr, n):\n    res = \"\"\n    smallest_size = sys .maxsize\n    largest_size = -(sys .maxsize - 1)\n    for i in range(n):\n        arr[i] = arr[i][::-1]\n        smallest_size = min(smallest_size, len(arr[i]))\n        largest_size = max(largest_size, len(arr[i]))\n    for i in range(smallest_size):\n        all_ones = True\n        for j in range(n):\n            if (arr[j][i] == '0'):\n                all_ones = False\n                break\n        if all_ones:\n            res += '1'\n        else:\n            res += '0'\n    for i in range(largest_size - smallest_size):\n        res += '0'\n    res = res[::-1]\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"101\", \"110110\", \"111\"]\n    n = len(arr)\n    print(strBitwiseAND(arr, n))\n",
        "output": "000100\n",
        "fn_call": "strBitwiseAND"
    },
    {
        "text": "check if the xor of an array of integers is even or odd | function to check if the xor of an array of integers is even or odd ; count the number of odd elements ; if count of odd elements is odd , then xor will be odd ; else even ; ",
        "context": "",
        "code": "def check(arr, n):\n    count = 0\n    for i in range(n):\n        if (arr[i] & 1):\n            count = count + 1\n    if (count & 1):\n        return \"Odd\"\n    else:\n        return \"Even\"\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 9, 12, 13, 15]\n    n = len(arr)\n    print(check(arr, n))\n",
        "output": "Even\n",
        "fn_call": "check"
    },
    {
        "text": "minimize cost to convert all characters of a binary string to 0 s | function to get the minimum cost to convert all characters of given string to 0 s ; stores the range of indexes of characters that need to be flipped ; stores the number of times current character is flipped ; stores minimum cost to get the required string ; traverse the given string ; remove all value from pq whose value is less than i ; update flip ; get the current number ; if current character is flipped odd times ; if current character contains non - zero value ; update flip ; update cost ; append r [ i ] into pq ; ",
        "context": "",
        "code": "def minCost(s, R, C, N):\n    ch = list(s)\n    pq = []\n    flip = 0\n    cost = 0\n    for i in range(N):\n        while (len(pq) > 0 and pq[0] < i):\n            pq .pop(0)\n            flip -= 1\n        cn = ord(ch[i]) - ord('0')\n        if (flip % 2 == 1):\n            cn = 1 - cn\n        if (cn == 1):\n            flip += 1\n            cost += C[i]\n            pq .append(R[i])\n    return cost\n",
        "test": "\nN = 4\ns = \"1010\"\nR = [1, 2, 2, 3]\nC = [3, 1, 2, 3]\nprint(minCost(s, R, C, N))\n",
        "output": "4\n",
        "fn_call": "minCost"
    },
    {
        "text": "minimum integer that can be obtained by swapping adjacent digits of different parity | function to return the minimum number ; store the elements which are divisible by two in stack1 ; store the elements which are not divisible by two in stack2 . ; concatenate the answer with smaller value of the topmost elements of both the stacks and then pop that element ; concatenate the answer with remaining values of stack1 . ; concatenate the answer with remaining values of stack2 . ; ",
        "context": "",
        "code": "def minimumNo(n):\n    ans = 0\n    stack1 = []\n    stack2 = []\n    while (n != 0):\n        r = n % 10\n        if (r % 2 == 0):\n            stack1 .append(r)\n        else:\n            stack2 .append(r)\n        n = n // 10\n    while (len(stack1) > 0 and len(stack2) > 0):\n        if (stack1[-1] < stack2[-1]):\n            ans = ans * 10 + stack1[-1]\n            del stack1[-1]\n        else:\n            ans = ans * 10 + stack2[-1]\n            del stack2[-1]\n    while (len(stack1) > 0):\n        ans = ans * 10 + stack1[-1]\n        del stack1[-1]\n    while (len(stack2) > 0):\n        ans = ans * 10 + stack2[-1]\n        del stack2[-1]\n    return ans\n",
        "test": "\nn1 = 64432\nprint(minimumNo(n1))\nn2 = 3137\nprint(minimumNo(n2))\n",
        "output": "36442\n3137\n",
        "fn_call": "minimumNo"
    },
    {
        "text": "temple offerings | returns minimum offerings required ; go through all templs one by one ; go to left while height keeps increasing ; go to right while height keeps increasing ; this temple should offer maximum of two values to follow the rule . ; ",
        "context": "",
        "code": "def offeringNumber(n, templeHeight):\n    sum = 0\n    for i in range(n):\n        left = 0\n        right = 0\n        for j in range(i - 1, -1, -1):\n            if (templeHeight[j] < templeHeight[j + 1]):\n                left += 1\n            else:\n                break\n        for j in range(i + 1, n):\n            if (templeHeight[j] < templeHeight[j - 1]):\n                right += 1\n            else:\n                break\n        sum += max(right, left) + 1\n    return sum\n",
        "test": "\narr1 = [1, 2, 2]\nprint(offeringNumber(3, arr1))\narr2 = [1, 4, 3, 6, 2, 1]\nprint(offeringNumber(6, arr2))\n",
        "output": "4\n10\n",
        "fn_call": "offeringNumber"
    },
    {
        "text": "logarithm | python 3 program to find log ( n ) using recursion ; ",
        "context": "",
        "code": "def Log2n(n):\n    return 1 + Log2n(n / 2)if (n > 1)else 0\n",
        "test": "\nn = 32\nprint(Log2n(n))\n",
        "output": "5\n",
        "fn_call": "Log2n"
    },
    {
        "text": "program to check if n is a hexagonal number or not | python3 program to check if n is a hexagonal number ; function to check if number is hexagonal ; calculate the value for n ; check if n - floor ( n ) is equal to 0 ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isHexagonal(N):\n    val = 8 * N + 1\n    x = 1 + sqrt(val)\n    n = x / 4\n    if ((n - int(n)) == 0):\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == '__main__':\n    N = 14\n    if (isHexagonal(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isHexagonal"
    },
    {
        "text": "maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | function to find the maximum possible prefix of the string ; hash map to store the frequency of the characters in the string ; iterate over the string to find the occurence of each character ; minimum frequency of the characters ; loop to find the count of minimum frequency in the hash - map ; loop to find the maximum possible length of the prefix in the string ; condition to check if the frequency is greater than minimum possible freq ; maxprefix string and its length . ; ",
        "context": "",
        "code": "def MaxPrefix(string):\n    Dict = {}\n    maxprefix = 0\n    for i in string:\n        Dict[i] = Dict .get(i, 0) + 1\n    minfrequency = min(Dict .values())\n    countminFrequency = 0\n    for x in Dict:\n        if (Dict[x] == minfrequency):\n            countminFrequency += 1\n    mapper = {}\n    indi = 0\n    for i in string:\n        mapper[i] = mapper .get(i, 0) + 1\n        if (mapper[i] > countminFrequency):\n            break\n        indi += 1\n    print(string[:indi])\n",
        "test": "\nif __name__ == '__main__':\n    str = 'aabcdaab'\n    MaxPrefix(str)\n",
        "output": "aabcd\n",
        "fn_call": "MaxPrefix"
    },
    {
        "text": "floor and ceil from a bst | a binary tree node has key , . left child and right child ; helper function to find floor and ceil of a given key in bst ; display the floor and ceil of a given key in bst . if key is less than the min key in bst , floor will be - 1 ; if key is more than the max key in bst , ceil will be - 1 ; ; variables ' floor ' and ' ceil ' are passed by reference ; ",
        "context": "\nclass Node:\n    def __init__(self, x):\n        self .data = x\n        self .left = None\n        self .right = None\n\n",
        "code": "def floorCeilBSTHelper(root, key):\n    global floor, ceil\n    while (root):\n        if (root .data == key):\n            ceil = root .data\n            floor = root .data\n            return\n        if (key > root .data):\n            floor = root .data\n            root = root .right\n        else:\n            ceil = root .data\n            root = root .left\n\n\ndef floorCeilBST(root, key):\n    global floor, ceil\n    floor = -1\n    ceil = -1\n    floorCeilBSTHelper(root, key)\n    print(key, floor, ceil)\n",
        "test": "\nif __name__ == '__main__':\n    floor, ceil = -1, -1\n    root = Node(8)\n    root .left = Node(4)\n    root .right = Node(12)\n    root .left .left = Node(2)\n    root .left .right = Node(6)\n    root .right .left = Node(10)\n    root .right .right = Node(14)\n    for i in range(16):\n        floorCeilBST(root, i)\n",
        "output": "0 -1 2\n1 -1 2\n2 2 2\n3 2 4\n4 4 4\n5 4 6\n6 6 6\n7 6 8\n8 8 8\n9 8 10\n10 10 10\n11 10 12\n12 12 12\n13 12 14\n14 14 14\n15 14 -1\n",
        "fn_call": "floorCeilBST"
    },
    {
        "text": "number of sink nodes in a graph | return the number of sink nodes . ; array for marking the non - sink node . ; marking the non - sink node . ; counting the sink nodes . ; ",
        "context": "",
        "code": "def countSink(n, m, edgeFrom, edgeTo):\n    mark = [0] * (n + 1)\n    for i in range(m):\n        mark[edgeFrom[i]] = 1\n    count = 0\n    for i in range(1, n + 1):\n        if (not mark[i]):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    m = 2\n    edgeFrom = [2, 4]\n    edgeTo = [3, 3]\n    print(countSink(n, m, edgeFrom, edgeTo))\n",
        "output": "2\n",
        "fn_call": "countSink"
    },
    {
        "text": "find the value of n xor 'ed to itself k times | function to return n ^ n ^ ... k times ; find the result ; ",
        "context": "",
        "code": "def xorK(n, k):\n    res = n\n    for i in range(1, k):\n        res = (res ^ n)\n    return n\n",
        "test": "\nn = 123\nk = 3\nprint(xorK(n, k))\n",
        "output": "123\n",
        "fn_call": "xorK"
    },
    {
        "text": "split n into maximum composite numbers | function to calculate the maximum number of composite numbers adding upto n ; 4 is the smallest composite number ; stores the remainder when n is divided n is divided by 4 ; if remainder is 0 , then it is perfectly divisible by 4. ; if the remainder is 1 ; if the number is less then 9 , that is 5 , then it cannot be expressed as 4 is the only composite number less than 5 ; if the number is greater then 8 , and has a remainder of 1 , then express n as n - 9 a and it is perfectly divisible by 4 and for 9 , count 1. ; when remainder is 2 , just subtract 6 from n , so that n is perfectly divisible by 4 and count 1 for 6 which is subtracted . ; if the number is 7 , 11 which cannot be expressed as sum of any composite numbers ; when the remainder is 3 , then subtract 15 from it and n becomes perfectly divisible by 4 and we add 2 for 9 and 6 , which is getting subtracted to make n perfectly divisible by 4. ; ",
        "context": "",
        "code": "def count(n):\n    if (n < 4):\n        return -1\n    rem = n % 4\n    if (rem == 0):\n        return n // 4\n    if (rem == 1):\n        if (n < 9):\n            return -1\n        return (n - 9) // 4 + 1\n    if (rem == 2):\n        return (n - 6) // 4 + 1\n    if (rem == 3):\n        if (n < 15):\n            return -1\n        return (n - 15) // 4 + 2\n",
        "test": "\nn = 90\nprint(count(n))\nn = 143\nprint(count(n))\n",
        "output": "22\n34\n",
        "fn_call": "count"
    },
    {
        "text": "product of absolute difference of every pair in given array | function to return the product of abs diff of all pairs ( x , y ) ; to store product ; iterate all possible pairs ; find the product ; return product ; ",
        "context": "",
        "code": "def getProduct(a, n):\n    p = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            p *= abs(a[i] - a[j])\n    return p\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4]\n    N = len(arr)\n    print(getProduct(arr, N))\n",
        "output": "12\n",
        "fn_call": "getProduct"
    },
    {
        "text": "longest reverse bitonic sequence | function to return the length of the longest reverse bitonic subsequence in the array ; allocate memory for lis [ ] and initialize lis values as 1 for all indexes ; compute lis values from left to right ; allocate memory for lds and initialize lds values for all indexes ; compute lds values from right to left loop from n - 2 downto 0 ; loop from n - 1 downto i - 1 ; return the maximum value of ( lis [ i ] + lds [ i ] - 1 ) ; ",
        "context": "",
        "code": "def ReverseBitonic(arr):\n    N = len(arr)\n    lds = [1 for i in range(N + 1)]\n    for i in range(1, N):\n        for j in range(0, i):\n            if ((arr[i] < arr[j]) and (lds[i] < lds[j] + 1)):\n                lds[i] = lds[j] + 1\n    lis = [1 for i in range(N + 1)]\n    for i in reversed(range(N - 1)):\n        for j in reversed(range(i - 1, N)):\n            if (arr[i] < arr[j] and lis[i] < lis[j] + 1):\n                lis[i] = lis[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, N):\n        maximum = max((lis[i] + lds[i] - 1), maximum)\n    return maximum\n",
        "test": "\narr = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\nprint(\"Length of LBS is\", ReverseBitonic(arr))\n",
        "output": "Length of LBS is 7\n",
        "fn_call": "ReverseBitonic"
    },
    {
        "text": "minimum number of cubes whose sum equals to given number n | function to return the minimum number of cubes whose sum is k ; if k is less than the 2 ^ 3 ; initialize with the maximum number of cubes required ; ",
        "context": "",
        "code": "def MinOfCubed(k):\n    if (k < 8):\n        return k\n    res = k\n    for i in range(1, k + 1):\n        if ((i * i * i) > k):\n            return res\n        res = min(res, MinOfCubed(k - (i * i * i)) + 1)\n    return res\n",
        "test": "\nnum = 15\nprint(MinOfCubed(num))\n",
        "output": "8\n",
        "fn_call": "MinOfCubed"
    },
    {
        "text": "divide array into two arrays which does not contain any pair with sum k | function to split the given array into two separate arrays satisfying given condition ; stores resultant arrays ; traverse the array ; if a [ i ] is smaller than or equal to k / 2 ; print first array ; print second array ; ",
        "context": "",
        "code": "def splitArray(a, n, k):\n    first = []\n    second = []\n    for i in range(n):\n        if (a[i] <= k // 2):\n            first .append(a[i])\n        else:\n            second .append(a[i])\n    for i in range(len(first)):\n        print(first[i], end=\" \")\n    print(\"\",  end=\"\")\n    for i in range(len(second)):\n        print(second[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    k = 5\n    a = [0, 1, 3, 2, 4, 5, 6, 7, 8, 9, 10]\n    n = len(a)\n    splitArray(a, n, k)\n",
        "output": "0 1 2 3 4 5 6 7 8 9 10 ",
        "fn_call": "splitArray"
    },
    {
        "text": "print the sequence of size n in which every term is sum of previous k terms | function to generate the series in the form of array ; pick a starting point ; find the sum of all elements till count < k ; find the value of sum at i position ; ",
        "context": "",
        "code": "def sumOfPrevK(N, K):\n    arr = [0 for i in range(N)]\n    arr[0] = 1\n    for i in range(1, N):\n        j = i - 1\n        count = 0\n        sum = 0\n        while (j >= 0 and count < K):\n            sum = sum + arr[j]\n            j = j - 1\n            count = count + 1\n        arr[i] = sum\n    for i in range(0, N):\n        print(arr[i])\n",
        "test": "\nN = 10\nK = 4\nsumOfPrevK(N, K)\n",
        "output": "1\n1\n2\n4\n8\n15\n29\n56\n108\n208\n",
        "fn_call": "sumOfPrevK"
    },
    {
        "text": "maximum number on 7 | function to find the maximum number that can be displayed using the n segments ; condition to check base case ; condition to check if the number is even ; condition to check if the number is odd ; ",
        "context": "",
        "code": "def segments(n):\n    if (n == 1 or n == 0):\n        return\n    if (n % 2 == 0):\n        print(\"1\", end=\"\")\n        segments(n - 2)\n    elif (n % 2 == 1):\n        print(\"7\", end=\"\")\n        segments(n - 3)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 11\n    segments(n)\n",
        "output": "71111",
        "fn_call": "segments"
    },
    {
        "text": "given a binary string , count number of substrings that start and end with 1. | a python3 program to count number of substrings starting and ending with 1 ; count of 1 's in input string ; traverse input string and count of 1 's in it ; return count of possible pairs among m 1 's ; ",
        "context": "",
        "code": "def countSubStr(st, n):\n    m = 0\n    for i in range(0, n):\n        if (st[i] == '1'):\n            m = m + 1\n    return m * (m - 1) // 2\n",
        "test": "\nst = \"00100101\"\nlist(st)\nn = len(st)\nprint(countSubStr(st, n), end=\"\")\n",
        "output": "3",
        "fn_call": "countSubStr"
    },
    {
        "text": "merge two sorted arrays in o ( 1 ) extra space using quicksort partition | function to perform the partition around the pivot element ; stores index of each element of the array , arr [ ] ; stores index of each element of the array , brr [ ] ; traverse both the array ; if pivot is smaller than arr [ l ] ; if pivot is greater than brr [ r ] ; if either arr [ l ] > pivot or brr [ r ] < pivot ; function to merge the two sorted array ; stores index of each element of the array arr [ ] ; stores index of each element of the array brr [ ] ; stores index of each element the final sorted array ; stores the pivot element ; traverse both the array ; if pivot element is not found or index < n ; if pivot element is not found or index < n ; place the first n elements of the sorted array into arr [ ] and the last m elements of the sorted array into brr [ ] ; sort both the arrays ; print the first n elements in sorted order ; print the last m elements in sorted order ; ",
        "context": "",
        "code": "def partition(arr, N, brr, M, Pivot):\n    l = N - 1\n    r = 0\n    while (l >= 0 and r < M):\n        if (arr[l] < Pivot):\n            l -= 1\n        elif (brr[r] > Pivot):\n            r += 1\n        else:\n            arr[l], brr[r] = brr[r], arr[l]\n            l -= 1\n            r += 1\n\n\ndef Merge(arr, N, brr, M):\n    l = 0\n    r = 0\n    index = -1\n    Pivot = 0\n    while (index < N and l < N and r < M):\n        if (arr[l] < brr[r]):\n            Pivot = arr[l]\n            l += 1\n        else:\n            Pivot = brr[r]\n            r += 1\n        index += 1\n    while (index < N and l < N):\n        Pivot = arr[l]\n        l += 1\n        index += 1\n    while (index < N and r < M):\n        Pivot = brr[r]\n        r += 1\n        index += 1\n    partition(arr, N, brr, M, Pivot)\n    arr = sorted(arr)\n    brr = sorted(brr)\n    for i in range(N):\n        print(arr[i], end=\" \")\n    for i in range(M):\n        print(brr[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 5, 9]\n    brr = [2, 4, 7, 10]\n    N = len(arr)\n    M = len(brr)\n    Merge(arr, N, brr, M)\n",
        "output": "1 2 4 5 7 9 10 ",
        "fn_call": "Merge"
    },
    {
        "text": "minimum number of pairs required to make two strings same | python3 implementation of the approach ; function which will check if there is a path between a and b by using bfs ; function to return the minimum number of pairs ; to store the count of pairs ; iterating through the strings ; check if we can add an edge in the graph ; return the count of pairs ; ",
        "context": "\nfrom collections import defaultdict, deque\n\n",
        "code": "def Check_Path(a, b, G):\n    visited = defaultdict(bool)\n    queue = deque()\n    queue .append(a)\n    visited[a] = True\n    while queue:\n        n = queue .popleft()\n        if n == b:\n            return True\n        for i in list(G[n]):\n            if not visited[i]:\n                queue .append(i)\n                visited[i] = True\n    return False\n\n\ndef countPairs(s1, s2, G):\n    name = defaultdict(bool)\n    count = 0\n    for i in range(x):\n        a = s1[i]\n        b = s2[i]\n        if a in G and b not in G and a != b:\n            G[a].append(b)\n            G[b].append(a)\n            count += 1\n        elif b in G and a not in G and a != b:\n            G[b].append(a)\n            G[a].append(b)\n            count += 1\n        elif a not in G and b not in G and a != b:\n            G[a].append(b)\n            G[b].append(a)\n            count += 1\n        else:\n            if not Check_Path(a, b, G) and a != b:\n                G[a].append(b)\n                G[b].append(a)\n                count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"abb\"\n    s2 = \"dad\"\n    x = len(s1)\n    G = defaultdict(list)\n    print(countPairs(s1, s2, G))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "aspiring number | function to calculate sum of all proper divisors ; 1 is a proper divisor ; note that this loop runs till square root of n ; if divisors are equal , take only one of them ; otherwise take both ; calculate sum of all proper divisors only ; function to get last number of aliquot sequence . ; calculate next term from previous term ; returns true if n is perfect ; to store sum of divisors ; find all divisors and add them ; if sum of divisors is equal to n , then n is a perfect number ; returns true if n is aspiring else returns false ; checking condition for aspiring ; ",
        "context": "",
        "code": "def getSum(n):\n    sum = 0\n    for i in range(1, int((n) ** (1 / 2)) + 1):\n        if not n % i:\n            if n // i == i:\n                sum += i\n            else:\n                sum += i\n                sum += (n // i)\n    return sum - n\n\n\ndef getAliquot(n):\n\n    s = set()\n    s.add(n)\n    next = 0\n\n    while (n > 0):\n        n = getSum(n)\n\n        if n not in s:\n            return n\n\n        s.add(n)\n\n    return 0\n\n\ndef isPerfect(n):\n    sum = 1\n    for i in range(2, int((n ** (1 / 2))) + 1):\n        if not n % i:\n            sum += (i + n // i)\n    if sum == n and n != 1:\n        return True\n\n    return False\n\n\ndef isAspiring(n):\n    alq = getAliquot(n)\n    if (isPerfect(alq) and not isPerfect(n)):\n        return True\n    else:\n        return False\n",
        "test": "\nn = 25\nif (isAspiring(n)):\n    print(\"Aspiring\")\nelse:\n    print(\"Not Aspiring\")\n",
        "output": "Aspiring\n",
        "fn_call": "isAspiring"
    },
    {
        "text": "check if any point exists in a plane whose manhattan distance is at most k from n given points | function to check if there exists any point with at most k distance from n given points ; traverse the given n points ; stores the count of pairs of coordinates having manhattan distance <= k ; for the same coordinate ; calculate manhattan distance ; if manhattan distance <= k ; if all coordinates can meet ; if all coordinates can 't meet ; ",
        "context": "",
        "code": "def find(a, b, N, K):\n    for i in range(N):\n        count = 0\n        for j in range(N):\n            if (i == j):\n                continue\n            dis = abs(a[i] - a[j]) + abs(b[i] - b[j])\n            if (dis <= K):\n                count = count + 1\n            if (count == N - 1):\n                return \"Yes\"\n        return \"No\"\n",
        "test": "\nN = 5\nA = [1, 0, 2, 1, 1]\nB = [1, 1, 1, 0, 2]\nK = 1\nprint(find(A, B, N, K))\n",
        "output": "Yes\n",
        "fn_call": "find"
    },
    {
        "text": "nth character in concatenated decimal string | method to get dth digit of number n ; method to return nth character in concatenated decimal string ; sum will store character escaped till now ; dist will store numbers escaped till now ; loop for number lengths ; nine * len will be incremented characters and nine will be incremented numbers ; restore variables to previous correct state ; get distance from last one digit less maximum number ; d will store dth digit of current number ; method will return dth numbered digit of ( dist + diff ) number ; ",
        "context": "",
        "code": "def getDigit(N, d):\n    string = str(N)\n    return string[d - 1]\n\n\ndef getNthChar(N):\n    sum = 0\n    nine = 9\n    dist = 0\n    for len in range(1, N):\n        sum += nine * len\n        dist += nine\n        if (sum >= N):\n            sum -= nine * len\n            dist -= nine\n            N -= sum\n            break\n        nine *= 10\n    diff = (N / len) + 1\n    d = N % len\n    if (d == 0):\n        d = len\n    return getDigit(dist + diff, d)\n",
        "test": "\nN = 251\nprint(getNthChar(N))\n",
        "output": "2\n",
        "fn_call": "getNthChar"
    },
    {
        "text": "length of largest subsequence consisting of a pair of alternating digits | function to find the length of the largest subsequence consisting of a pair of alternating digits ; variable initialization ; nested loops for iteration ; check if i is not equal to j ; initialize length as 0 ; iterate from 0 till the size of the string ; increment length ; increment length ; update maxi ; check if maxi is not equal to 1 the print otherwise pr0 ; ",
        "context": "",
        "code": "def largestSubsequence(s):\n    maxi = 0\n    for i in range(10):\n        for j in range(10):\n            if (i != j):\n                lenn = 0\n                prev1 = chr(j + ord('0'))\n                for k in range(len(s)):\n                    if (s[k] == chr(i + ord('0'))\n                            and prev1 == chr(j + ord('0'))):\n                        prev1 = s[k]\n                        lenn += 1\n                    elif (s[k] == chr(j + ord('0')) and prev1 == chr(i + ord('0'))):\n                        prev1 = s[k]\n                        lenn += 1\n                maxi = max(lenn, maxi)\n    if (maxi != 1):\n        print(maxi)\n    else:\n        print(0)\n",
        "test": "\nif __name__ == '__main__':\n    s = \"1542745249842\"\n    largestSubsequence(s)\n",
        "output": "6\n",
        "fn_call": "largestSubsequence"
    },
    {
        "text": "minimum number of deletions so that no two consecutive are same | function for counting deletions ; if two consecutive characters are the same , delete one of them . ; ",
        "context": "",
        "code": "def countDeletions(string):\n    ans = 0\n    for i in range(len(string) - 1):\n        if (string[i] == string[i + 1]):\n            ans += 1\n    return ans\n",
        "test": "\nstring = \"AAABBB\"\nprint(countDeletions(string))\n",
        "output": "4\n",
        "fn_call": "countDeletions"
    },
    {
        "text": "sort 3 numbers | python3 program to sort an array of size 3 ; insert arr [ 1 ] ; insert arr [ 2 ] ; ",
        "context": "",
        "code": "def sort3(arr):\n    if (arr[1] < arr[0]):\n        arr[0], arr[1] = arr[1], arr[0]\n    if (arr[2] < arr[1]):\n        arr[1], arr[2] = arr[2], arr[1]\n        if (arr[1] < arr[0]):\n            arr[1], arr[0] = arr[0], arr[1]\n",
        "test": "\na = [10, 12, 5]\nsort3(a)\nfor i in range(3):\n    print(a[i], end=\" \")\n",
        "output": "5 10 12 ",
        "fn_call": "sort3"
    },
    {
        "text": "longest subsequence of a number having same left and right rotation | python3 program to implement the above approach ; function to find the longest subsequence having equal left and right rotation ; length of the string ; iterate for all possible combinations of a two - digit numbers ; check for alternate occurrence of current combination ; increment the current value ; increment the current value ; if alternating sequence is obtained of odd length ; reduce to even length ; update answer to store the maximum ; return the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def findAltSubSeq(s):\n    n = len(s)\n    ans = -sys .maxsize - 1\n    for i in range(10):\n        for j in range(10):\n            cur, f = 0, 0\n            for k in range(n):\n                if (f == 0 and ord(s[k]) - ord('0') == i):\n                    f = 1\n                    cur += 1\n                elif (f == 1 and ord(s[k]) - ord('0') == j):\n                    f = 0\n                    cur += 1\n            if i != j and cur % 2 == 1:\n                cur -= 1\n            ans = max(cur, ans)\n    return ans\n",
        "test": "\ns = \"100210601\"\nprint(findAltSubSeq(s))\n",
        "output": "4\n",
        "fn_call": "findAltSubSeq"
    },
    {
        "text": "minimum number greater than the maximum of array which cannot be formed using the numbers in the array | function that returns the minimum number greater than maximum of the array that cannot be formed using the elements of the array ; sort the given array ; maximum number in the array ; table [ i ] will store the minimum number of elements from the array to form i ; calculate the minimum number of elements from the array required to form the numbers from 1 to ( 2 * max ) ; if there exists a number greater than the maximum element of the array that can be formed using the numbers of array ; ",
        "context": "",
        "code": "def findNumber(arr, n):\n    arr = sorted(arr)\n    Max = arr[n - 1]\n    table = [10 ** 9 for i in range((2 * Max) + 1)]\n    table[0] = 0\n    ans = -1\n    for i in range(1, 2 * Max + 1):\n        for j in range(n):\n            if (arr[j] <= i):\n                res = table[i - arr[j]]\n                if (res != 10 ** 9 and res + 1 < table[i]):\n                    table[i] = res + 1\n        if (i > arr[n - 1] and table[i] == 10 ** 9):\n            ans = i\n            break\n    return ans\n",
        "test": "\narr = [6, 7, 15]\nn = len(arr)\nprint(findNumber(arr, n))\n",
        "output": "16\n",
        "fn_call": "findNumber"
    },
    {
        "text": "make the intervals non | function to assign the intervals to two different processors ; loop to pair the interval with their indices ; sorting the interval by their startb times ; loop to iterate over the intervals with their start time ; condition to check if there is a possible solution ; form = ''.join(form) ; ",
        "context": "",
        "code": "def assignIntervals(interval, n):\n    for i in range(n):\n        interval[i].append(i)\n    interval .sort(key=lambda x: x[0])\n    firstEndTime = -1\n    secondEndTime = -1\n    fin = ''\n    flag = False\n    for i in range(n):\n        if interval[i][0] >= firstEndTime:\n            firstEndTime = interval[i][1]\n            interval[i].append('S')\n        elif interval[i][0] >= secondEndTime:\n            secondEndTime = interval[i][1]\n            interval[i].append('F')\n        else:\n            flag = True\n            break\n    if flag:\n        print(-1)\n    else:\n        form = [''] * n\n        for i in range(n):\n            indi = interval[i][2]\n            form[indi] = interval[i][3]\n        print(form, \", \")\n",
        "test": "\nif __name__ == \"__main__\":\n    intervals = [[360, 480], [420, 540], [600, 660]]\n    assignIntervals(intervals, len(intervals))\n",
        "output": "['S', 'F', 'S'] , \n",
        "fn_call": "assignIntervals"
    },
    {
        "text": "find nth number of the series 1 , 6 , 15 , 28 , 45 , ... . . | function for calculating nth term of series ; ",
        "context": "",
        "code": "def NthTerm(N):\n    x = (2 * N*N) % 1000000009\n    return ((x - N + 1000000009) % 1000000009)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    print(NthTerm(N))\n",
        "output": "28\n",
        "fn_call": "NthTerm"
    },
    {
        "text": "count lexicographically increasing k | function to count k - length strings from first n alphabets ; to keep track of column sum in dp ; auxiliary 2d dp array ; initialize dp [ 0 ] [ i ] = 1 and update the column_sum ; iterate for k times ; iterate for n times ; dp [ i ] [ j ] : stores the number of ways to form i - length strings consisting of j letters ; update the column_sum ; print number of ways to arrange k - length strings with n alphabets ; ",
        "context": "",
        "code": "def waysToArrangeKLengthStrings(N, K):\n    column_sum = [0 for i in range(N + 1)]\n    i = 0\n    j = 0\n    dp = [[0 for i in range(N + 1)]for j in range(K + 1)]\n    for i in range(N + 1):\n        dp[0][i] = 1\n        column_sum[i] = 1\n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            dp[i][j] += column_sum[j - 1]\n            column_sum[j] += dp[i][j]\n    print(dp[K][N])\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    K = 2\n    waysToArrangeKLengthStrings(N, K)\n",
        "output": "15\n",
        "fn_call": "waysToArrangeKLengthStrings"
    },
    {
        "text": "check if array can be converted into strictly decreasing sequence | function to check that array can be converted into a strictly decreasing sequence ; loop to check that each element is greater than the ( n - index ) ; if element is less than ( n - index ) ; if array can be converted ; ",
        "context": "",
        "code": "def check(arr, n):\n    flag = True\n    for i in range(n):\n        if (arr[i] < n - i):\n            flag = False\n    if (flag):\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == '__main__':\n    arr1 = [11, 11, 11, 11]\n    n1 = len(arr1)\n    if (check(arr1, n1)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "count of numbers in range where the number does not contain more than k non zero digits | this function returns the count of required numbers from 0 to num ; last position ; if count of non zero digits is less than or equal to k ; if this result is already computed simply return it ; maximum limit upto which we can place digit . if tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; if the current digit is nonzero increment currcnt ; at this position , number becomes smaller ; next recursive call ; this function converts a number into its digit vector and uses above function to compute the answer ; initialize dp ; ",
        "context": "",
        "code": "def countInRangeUtil(pos, cnt, tight, num):\n    if pos == len(num):\n        if cnt <= K:\n            return 1\n        return 0\n    if dp[pos][cnt][tight] != -1:\n        return dp[pos][cnt][tight]\n    ans = 0\n    limit = 9 if tight else num[pos]\n    for dig in range(limit + 1):\n        currCnt = cnt\n        if dig != 0:\n            currCnt += 1\n        currTight = tight\n        if dig < num[pos]:\n            currTight = 1\n        ans += countInRangeUtil(pos + 1, currCnt, currTight, num)\n    dp[pos][cnt][tight] = ans\n    return dp[pos][cnt][tight]\n\n\ndef countInRange(x):\n    global dp, K, M\n    num = []\n    while x:\n        num .append(x % 10)\n        x //= 10\n    num .reverse()\n    dp = [[[-1, -1]for i in range(M)]for j in range(M)]\n    return countInRangeUtil(0, 0, 0, num)\n",
        "test": "\nif __name__ == \"__main__\":\n    dp = []\n    M = 20\n    K = 0\n    L = 1\n    R = 1000\n    K = 3\n    print(countInRange(R) - countInRange(L - 1))\n    L = 9995\n    R = 10005\n    K = 2\n    print(countInRange(R) - countInRange(L - 1))\n",
        "output": "1000\n6\n",
        "fn_call": "countInRange"
    },
    {
        "text": "camelcase pattern matching | function that prints the camel case pattern matching ; map to store the hashing of each words with every uppercase letter found ; traverse the words array that contains all the string ; initialise str as empty ; length of string words [ i ] ; for every uppercase letter found map that uppercase to original words ; traverse the map for pattern matching ; if pattern matches then print the corresponding mapped words ; if word not found print \" no \u2581 match \u2581 found \" ; ",
        "context": "",
        "code": "def CamelCase(words, pattern):\n    map = dict .fromkeys(words, None)\n    for i in range(len(words)):\n        string = \"\"\n        l = len(words[i])\n        for j in range(l):\n            if (words[i][j] >= 'A' and words[i][j] <= 'Z'):\n                string += words[i][j]\n                if string not in map:\n                    map[string] = [words[i]]\n                elif map[string] is None:\n                    map[string] = [words[i]]\n                else:\n                    map[string].append(words[i])\n    wordFound = False\n    for key, value in map .items():\n        if (key == pattern):\n            wordFound = True\n            for itt in value:\n                print(itt)\n    if (not wordFound):\n        print(\"No match found\")\n",
        "test": "\nif __name__ == \"__main__\":\n    words = [\n        \"Hi\",\n        \"Hello\",\n        \"HelloWorld\",\n        \"HiTech\",\n        \"HiGeek\",\n        \"HiTechWorld\",\n        \"HiTechCity\",\n        \"HiTechLab\"]\n    pattern = \"HT\"\n    CamelCase(words, pattern)\n",
        "output": "HiTech\nHiTechWorld\nHiTechCity\nHiTechLab\n",
        "fn_call": "CamelCase"
    },
    {
        "text": "minimum value to be added to the prefix sums at each array indices to make them positive | function to find minimum startvalue for positive prefix sum at each index ; store the minimum prefix sum ; stores prefix sum at each index ; traverse over the array ; update the prefix sum ; update the minvalue ; return the positive start value ; ",
        "context": "",
        "code": "def minStartValue(nums):\n    minValue = 0\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        minValue = min(minValue, sum)\n    startValue = 1 - minValue\n    return startValue\n",
        "test": "\nif __name__ == '__main__':\n    nums = [-3, 2, -3, 4, 2]\n    print(minStartValue(nums))\n",
        "output": "5\n",
        "fn_call": "minStartValue"
    },
    {
        "text": "eggs dropping puzzle ( binomial coefficient and binary search solution ) | find sum of binomial coefficients xci ( where i varies from 1 to n ) . if the sum becomes more than k ; do binary search to find minimum number of trials in worst case . ; initialize low and high as 1 st and last floors ; do binary search , for every mid , find sum of binomial coefficients and check if the sum is greater than k or not . ; ",
        "context": "",
        "code": "def binomialCoeff(x, n, k):\n    sum = 0\n    term = 1\n    i = 1\n    while (i <= n and sum < k):\n        term *= x - i + 1\n        term /= i\n        sum += term\n        i += 1\n    return sum\n\n\ndef minTrials(n, k):\n    low = 1\n    high = k\n    while (low < high):\n        mid = int((low + high) / 2)\n        if (binomialCoeff(mid, n, k) < k):\n            low = mid + 1\n        else:\n            high = mid\n    return int(low)\n",
        "test": "\nprint(minTrials(2, 10))\n",
        "output": "4\n",
        "fn_call": "minTrials"
    },
    {
        "text": "count of numbers in range [ l , r ] with lsb as 0 in their binary representation | function to return the count of required numbers ; if rightmost bit is 0 ; return the required count ; ",
        "context": "",
        "code": "def countNumbers(l, r):\n    count = 0\n    for i in range(l, r + 1):\n        if ((i & 1) == 0):\n            count += 1\n    return count\n",
        "test": "\nl = 10\nr = 20\nprint(countNumbers(l, r))\n",
        "output": "6\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "check whether the binary equivalent of a number ends with given string or not | function returns true if s1 is suffix of s2 ; function to check if binary equivalent of a number ends in \"111\" or not ; to store the binary number ; count used to store exponent value ; ",
        "context": "",
        "code": "def isSuffix(s1, s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    if (n1 > n2):\n        return False\n    for i in range(n1):\n        if (s1[n1 - i - 1] != s2[n2 - i - 1]):\n            return False\n    return True\n\n\ndef CheckBinaryEquivalent(N, s):\n    B_Number = 0\n    cnt = 0\n    while (N != 0):\n        rem = N % 2\n        c = pow(10, cnt)\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    bin = str(B_Number)\n    return isSuffix(s, bin)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 23\n    s = \"111\"\n    if (CheckBinaryEquivalent(N, s)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "CheckBinaryEquivalent"
    },
    {
        "text": "count number of subsets whose median is also present in the same subset | python 3 implementation of the approach ; function to return the factorial of a number ; function to return the value of ncr ; function to return ' a ' raised to the power n with complexity o ( log ( n ) ) ; function to return the number of sub - sets whose median is also present in the set ; number of odd length sub - sets ; sort the array ; checking each element for leftmost middle element while they are equal ; calculate the number of elements in right of rightmost middle element ; calculate the number of elements in left of leftmost middle element ; add selected even length subsets to the answer ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef nCr(n, r):\n    return int(fact(n) / (fact(r) * fact(n - r)))\n\n\ndef powmod(a, n):\n    if (n == 0):\n        return 1\n    pt = powmod(a, int(n / 2))\n    pt = (pt * pt) % mod\n    if (n % 2):\n        return (pt * a) % mod\n    else:\n        return pt\n\n\ndef CountSubset(arr, n):\n    ans = powmod(2, n - 1)\n    arr .sort(reverse=False)\n    for i in range(n):\n        j = i + 1\n        while (j < n and arr[j] == arr[i]):\n            r = n - 1 - j\n            l = i\n            ans = (ans + nCr(l + r, l)) % mod\n            j += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 2]\n    n = len(arr)\n    print(CountSubset(arr, n))\n",
        "output": "5\n",
        "fn_call": "CountSubset"
    },
    {
        "text": "find all possible pairs with given bitwise or and bitwise xor values | function to find pairs with xor equal to a and or equal to b ; iterate from 1 to b ; check if ( i or y ) is b ; ",
        "context": "",
        "code": "def findPairs(A, B):\n    for i in range(1, B + 1):\n        y = A ^ i\n        if (y > 0 and (i | y) == B):\n            print(i, \" \", y)\n",
        "test": "\nA = 8\nB = 10\nfindPairs(A, B)\n",
        "output": "2   10\n10   2\n",
        "fn_call": "findPairs"
    },
    {
        "text": "maximize value of ( a + b ) such that ( a * a | function to maximize the value of ( a + b ) such that ( a * a - b * b = n ) ; ",
        "context": "",
        "code": "def maxValue(n):\n    return n\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 1\n    print(maxValue(n))\n",
        "output": "1\n",
        "fn_call": "maxValue"
    },
    {
        "text": "check whether an array of strings can correspond to a particular number x | function to find the maximum base possible for the number n ; function to find the decimal equivalent of the number ; condition to check if the number is convertible to another base ; function to check that the array can correspond to a number x ; counter to count the numbers those are convertible to x ; loop to iterate over the array ; convert the current string to every base for checking whether it will correspond to x from any base ; condition to check if every number of the array can be converted to x ; ",
        "context": "",
        "code": "def val(c):\n    if (c >= '0' and c <= '9'):\n        return int(c)\n    else:\n        return c - 'A' + 10\n\n\ndef toDeci(strr, base):\n    lenn = len(strr)\n    power = 1\n    num = 0\n    for i in range(lenn - 1, -1, -1):\n        if (val(strr[i]) >= base):\n            return -1\n        num += val(strr[i]) * power\n        power = power * base\n    return num\n\n\ndef checkCorrespond(strr, x):\n    counter = 0\n    n = len(strr)\n    for i in range(n):\n        for j in range(2, 37):\n            if (toDeci(strr[i], j) == x):\n                counter += 1\n                break\n    if (counter == n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nx = 16\nstrr = [\"10000\", \"20\", \"16\"]\ncheckCorrespond(strr, x)\n",
        "output": "YES\n",
        "fn_call": "checkCorrespond"
    },
    {
        "text": "find the nth term of the series 2 + 6 + 13 + 23 + . . . | calculate nth term of given series ; ",
        "context": "",
        "code": "def Nth_Term(n):\n    return (3 * pow(n, 2) - n + 2) // (2)\n",
        "test": "\nN = 5\nprint(Nth_Term(N))\n",
        "output": "36\n",
        "fn_call": "Nth_Term"
    },
    {
        "text": "find multiples of 2 or 3 or 5 less than or equal to n | function to count number of multiples of 2 or 3 or 5 less than or equal to n ; as we have to check divisibility by three numbers , so we can implement bit masking ; we check whether jth bit is set or not , if jth bit is set , simply multiply to prod ; check for set bit ; check multiple of product ; ",
        "context": "",
        "code": "def countMultiples(n):\n    multiple = [2, 3, 5]\n    count = 0\n    mask = int(pow(2, 3))\n    for i in range(1, mask):\n        prod = 1\n        for j in range(3):\n            if (i & (1 << j)):\n                prod = prod * multiple[j]\n        if (bin(i).count('1') % 2 == 1):\n            count = count + n // prod\n        else:\n            count = count - n // prod\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 10\n    print(countMultiples(n))\n",
        "output": "8\n",
        "fn_call": "countMultiples"
    },
    {
        "text": "program for n | function to find the nth odd number ; ",
        "context": "",
        "code": "def nthOdd(n):\n    return (2 * n - 1)\n",
        "test": "\nif __name__ == '__main__':\n    n = 10\n    print(nthOdd(n))\n",
        "output": "19\n",
        "fn_call": "nthOdd"
    },
    {
        "text": "lexicographically smallest numeric string having odd digit counts | function to construct lexicographically smallest numeric string having an odd count of each characters ; stores the resultant string ; if n is even ; otherwise ; ",
        "context": "",
        "code": "def genString(N):\n    ans = \"\"\n    if (N % 2 == 0):\n        ans = \"\".join(\"1\"for i in range(N - 1))\n        ans = ans + \"2\"\n    else:\n        ans = \"\".join(\"1\"for i in range(N))\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    print(genString(N))\n",
        "output": "11111\n",
        "fn_call": "genString"
    },
    {
        "text": "program to calculate the perimeter of a decagon | function for finding the perimeter ; ",
        "context": "",
        "code": "def CalPeri():\n    s = 5\n    Perimeter = 10 * s\n    print(\"The Perimeter of Decagon is : \", Perimeter)\n",
        "test": "\nif __name__ == '__main__':\n    CalPeri()\n",
        "output": "The Perimeter of Decagon is :  50\n",
        "fn_call": "CalPeri"
    },
    {
        "text": "find all distinct subset ( or subsequence ) sums of an array | set | function to print all th distinct sum ; declare a boolean array of size equal to total sum of the array ; fill the first row beforehand ; dp [ j ] will be true only if sum j can be formed by any possible addition of numbers in given array upto index i , otherwise false ; iterate from maxsum to 1 and avoid lookup on any other row ; do not change the dp array for j less than arr [ i ] ; if dp [ j ] is true then print ; function to find the total sum and print the distinct sum ; find the sum of array elements ; function to print all the distinct sum ; ",
        "context": "",
        "code": "def subsetSum(arr, n, maxSum):\n    dp = [False for i in range(maxSum + 1)]\n    dp[arr[0]] = True\n    for i in range(1, n, 1):\n        j = maxSum\n        while (j >= 1):\n            if (arr[i] <= j):\n                if (arr[i] == j or dp[j] or dp[(j - arr[i])]):\n                    dp[j] = True\n                else:\n                    dp[j] = False\n            j -= 1\n    print(0, end=\" \")\n    for j in range(maxSum + 1):\n        if (dp[j]):\n            print(j, end=\" \")\n    print(\"21\")\n\n\ndef printDistinct(a, n):\n    maxSum = 0\n    for i in range(n):\n        maxSum += a[i]\n    subsetSum(a, n, maxSum)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 4, 5, 6]\n    n = len(arr)\n    printDistinct(arr, n)\n",
        "output": "0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 20 21\n",
        "fn_call": "printDistinct"
    },
    {
        "text": "search insert position of k in a sorted array | function to find insert position of k ; lower and upper bounds ; traverse the search space ; if k is found ; return the insert position ; ",
        "context": "",
        "code": "def find_index(arr, n, B):\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == K:\n            return mid\n        elif arr[mid] < K:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return end + 1\n",
        "test": "\narr = [1, 3, 5, 6]\nn = len(arr)\nK = 2\nprint(find_index(arr, n, K))\n",
        "output": "1\n",
        "fn_call": "find_index"
    },
    {
        "text": "maximal disjoint intervals | function to find maximal disjoint set ; sort the list of intervals ; first interval will always be included in set ; end point of first interval ; check if given interval overlap with previously included interval , if not then include this interval and update the end point of last added interval ; ",
        "context": "",
        "code": "def maxDisjointIntervals(list_):\n    list_ .sort(key=lambda x: x[1])\n    print(\"[\", list_[0][0], \", \", list_[0][1], \"]\")\n    r1 = list_[0][1]\n    for i in range(1, len(list_)):\n        l1 = list_[i][0]\n        r2 = list_[i][1]\n        if l1 > r1:\n            print(\"[\", l1, \", \", r2, \"]\")\n            r1 = r2\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    intervals = [[1, 4], [2, 3], [4, 6], [8, 9]]\n    maxDisjointIntervals(intervals)\n",
        "output": "[ 2 ,  3 ]\n[ 4 ,  6 ]\n[ 8 ,  9 ]\n",
        "fn_call": "maxDisjointIntervals"
    },
    {
        "text": "Maximum sum bitonic subarray | Function to find the maximum sum bitonic subarray . ; to store the maximum sum bitonic subarray ; Find the longest increasing subarray starting at i . ; Now we know that a [ i . . j ] is an increasing subarray . Remove non - positive elements from the left side as much as possible . ; Find the longest decreasing subarray starting at j . ; Now we know that a [ j . . k ] is a decreasing subarray . Remove non - positive elements from the right side as much as possible . last is needed to keep the last seen element . ; Compute the max sum of the increasing part . ; Compute the max sum of the decreasing part . ; The overall max sum is the sum of both parts minus the peak element , because it was counted twice . ; If the next element is equal to the current , i . e . arr [ i + 1 ] == arr [ i ] , last == i . To ensure the algorithm has progress , get the max of last and i + 1. ; required maximum sum ; The example from the article , the answer is 19. ; Always increasing , the answer is 15. ; Always decreasing , the answer is 15. ; All are equal , the answer is 5. ; The whole array is bitonic , but the answer is 7. ; The answer is 4 ( the tail ) .",
        "context": "",
        "code": "def maxSumBitonicSubArr(arr, n):\n    max_sum = -10 ** 9\n    i = 0\n    while (i < n):\n        j = i\n        while (j + 1 < n and arr[j] < arr[j + 1]):\n            j += 1\n        while (i < j and arr[i] <= 0):\n            i += 1\n        k = j\n        while (k + 1  arr[k + 1]):\n            k += 1\n        last = k\n        while (k > j and arr[k] <= 0):\n            k -= 1\n        nn = arr[i:j + 1]\n        sum_inc = sum(nn)\n        nn = arr[j:k + 1]\n        sum_dec = sum(nn)\n        sum_all = sum_inc + sum_dec - arr[j]\n        max_sum = max([max_sum, sum_inc, sum_dec, sum_all])\n        i = max(last, i + 1)\n    return max_sum\n",
        "test": "\narr = [5, 3, 9, 2, 7, 6, 4]\nn = len(arr)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr, n))\narr2 = [1, 2, 3, 4, 5]\nn2 = len(arr2)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr2, n2))\narr3 = [5, 4, 3, 2, 1]\nn3 = len(arr3)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr3, n3))\narr4 = [5, 5, 5, 5]\nn4 = len(arr4)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr4, n4))\narr5 = [-1, 0, 1, 2, 3, 1, 0, -1, -10]\nn5 = len(arr5)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr5, n5))\narr6 = [-1, 0, 1, 2, 0, -1, -2, 0, 1, 3]\nn6 = len(arr6)\nprint(\"Maximum Sum = \", maxSumBitonicSubArr(arr6, n6))\n",
        "output": "Maximum Sum =  19\nMaximum Sum =  15\nMaximum Sum =  15\nMaximum Sum =  5\nMaximum Sum =  7\nMaximum Sum =  4\n",
        "fn_call": "maxSumBitonicSubArr"
    },
    {
        "text": "find the n | python 3 program to find n - th number whose binary representation is palindrome . ; finds if the kth bit is set in the binary representation ; returns the position of leftmost set bit in the binary representation ; finds whether the integer in binary representation is palindrome or not ; one by one compare bits ; compare left and right bits and converge ; start from 1 , traverse through all the integers ; if we reach n , break the loop ; ",
        "context": "\nINT_MAX = 2147483647\n\n",
        "code": "def isKthBitSet(x, k):\n    return 1 if (x & (1 << (k - 1)))else 0\n\n\ndef leftmostSetBit(x):\n    count = 0\n    while (x):\n        count += 1\n        x = x >> 1\n    return count\n\n\ndef isBinPalindrome(x):\n    l = leftmostSetBit(x)\n    r = 1\n    while (l > r):\n        if (isKthBitSet(x, l) != isKthBitSet(x, r)):\n            return 0\n        l -= 1\n        r += 1\n    return 1\n\n\ndef findNthPalindrome(n):\n    pal_count = 0\n    i = 0\n    for i in range(1, INT_MAX + 1):\n        if (isBinPalindrome(i)):\n            pal_count += 1\n        if (pal_count == n):\n            break\n    return i\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 9\n    print(findNthPalindrome(n))\n",
        "output": "27\n",
        "fn_call": "findNthPalindrome"
    },
    {
        "text": "minimum initial points to reach destination | python3 program to find minimum initial points to reach destination ; dp [ i ] [ j ] represents the minimum initial points player should have so that when starts with cell ( i , j ) successfully reaches the destination cell ( m - 1 , n - 1 ) ; base case ; fill last row and last column as base to fill entire table ; fill the table in bottom - up fashion ; ",
        "context": "\nimport math as mt\nR = 3\nC = 3\n\n",
        "code": "def minInitialPoints(points):\n    dp = [[0 for x in range(C + 1)]for y in range(R + 1)]\n    m, n = R, C\n    if points[m - 1][n - 1] > 0:\n        dp[m - 1][n - 1] = 1\n    else:\n        dp[m - 1][n - 1] = abs(points[m - 1][n - 1]) + 1\n    for i in range(m - 2, -1, -1):\n        dp[i][n - 1] = max(dp[i + 1][n - 1] - points[i][n - 1], 1)\n    for i in range(2, -1, -1):\n        dp[m - 1][i] = max(dp[m - 1][i + 1] - points[m - 1][i], 1)\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 2, -1, -1):\n            min_points_on_exit = min(dp[i + 1][j], dp[i][j + 1])\n            dp[i][j] = max(min_points_on_exit - points[i][j], 1)\n    return dp[0][0]\n",
        "test": "\npoints = [[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]\nprint(\"Minimum Initial Points Required:\", minInitialPoints(points))\n",
        "output": "Minimum Initial Points Required: 7\n",
        "fn_call": "minInitialPoints"
    },
    {
        "text": "queries to find the maximum xor value between x and the nodes of a given level of a perfect binary tree | python3 implementation of the approach ; function to solve queries of the maximum xor value between the nodes in a given level l of a perfect binary tree and a given value x ; initialize result ; initialize array to store bits ; initialize a copy of x and size of array ; storing the bits of x in the array a [ ] ; filling the array b [ ] ; initializing variable which gives maximum xor ; getting the maximum xor value ; return the result ; ",
        "context": "\nMAXN = 60\n\n",
        "code": "def solveQuery(L, X):\n    res = 0\n    a = [0 for i in range(MAXN)]\n    b = [0 for i in range(MAXN)]\n    ref = X\n    size_a = 0\n    while (ref > 0):\n        a[size_a] = ref % 2\n        ref //= 2\n        size_a += 1\n    for i in range(min(size_a, L)):\n        if (a[i] == 1):\n            b[i] = 0\n        else:\n            b[i] = 1\n    for i in range(min(size_a, L), L):\n        b[i] = 1\n    b[L - 1] = 1\n    temp = 0\n    p = 1\n    for i in range(L):\n        temp += b[i] * p\n        p *= 2\n    res = temp ^ X\n    return res\n",
        "test": "\nqueries = [[2, 5], [3, 15]]\nq = len(queries)\nfor i in range(q):\n    print(solveQuery(queries[i][0], queries[i][1]))\n",
        "output": "7\n11\n",
        "fn_call": "solveQuery"
    },
    {
        "text": "sort 1 to n by swapping adjacent elements | return true if array can be sorted otherwise false ; check bool array b and sorts elements for continuous sequence of 1 ; sort array a from i to j ; check if array is sorted or not ; ",
        "context": "",
        "code": "def sortedAfterSwap(A, B, n):\n    for i in range(0, n - 1):\n        if (B[i] == 1):\n            j = i\n            while (B[j] == 1):\n                j = j + 1\n            A = A[0:i] + sorted(A[i:j + 1]) + A[j + 1:]\n            i = j\n    for i in range(0, n):\n        if (A[i] != i + 1):\n            return False\n    return True\n",
        "test": "\nA = [1, 2, 5, 3, 4, 6]\nB = [0, 1, 1, 1, 0]\nn = len(A)\nif (sortedAfterSwap(A, B, n)):\n    print(\"A can be sorted\")\nelse:\n    print(\"A can not be sorted\")\n",
        "output": "A can be sorted\n",
        "fn_call": "sortedAfterSwap"
    },
    {
        "text": "count of ways to obtain given sum from the given array elements | function to count the number of ways ; base case : reached the end of the array ; sum is equal to the required sum ; recursively check if required sum can be obtained by adding current element or by subtracting the current index element ; function to call dfs ( ) to calculate the number of ways ; ",
        "context": "",
        "code": "def dfs(nums, S, curr_sum, index):\n    if (index == len(nums)):\n        if (S == curr_sum):\n            return 1\n        else:\n            return 0\n    return (dfs(nums,\n                S,\n                curr_sum + nums[index],\n                index + 1) + dfs(nums,\n                                 S,\n                                 curr_sum - nums[index],\n                                 index + 1))\n\n\ndef findWays(nums, S):\n    return dfs(nums, S, 0, 0)\n",
        "test": "\nif __name__ == '__main__':\n    S = 3\n    arr = [1, 2, 3, 4, 5]\n    answer = findWays(arr, S)\n    print(answer)\n",
        "output": "3\n",
        "fn_call": "findWays"
    },
    {
        "text": "maximum xor value of a pair from a range | method to get maximum xor value in range [ l , r ] ; get xor of limits ; loop to get msb position of l ^ r ; construct result by adding 1 , msbpos times ; ",
        "context": "",
        "code": "def maxXORInRange(L, R):\n    LXR = L ^ R\n    msbPos = 0\n    while (LXR):\n        msbPos += 1\n        LXR >>= 1\n    maxXOR, two = 0, 1\n    while (msbPos):\n        maxXOR += two\n        two <<= 1\n        msbPos -= 1\n    return maxXOR\n",
        "test": "\nL, R = 8, 20\nprint(maxXORInRange(L, R))\n",
        "output": "31\n",
        "fn_call": "maxXORInRange"
    },
    {
        "text": "find sum of non | find the sum of all non - repeated elements in an array ; sort all elements of array ; ",
        "context": "",
        "code": "def findSum(arr, n):\n    arr .sort()\n    sum = arr[0]\n    for i in range(0, n - 1):\n        if (arr[i] != arr[i + 1]):\n            sum = sum + arr[i + 1]\n    return sum\n\n\ndef main():\n    arr = [1, 2, 3, 1, 1, 4, 5, 6]\n    n = len(arr)\n    print(findSum(arr, n))\n",
        "test": "\nif __name__ == '__main__':\n    main()\n",
        "output": "21\n",
        "fn_call": "main"
    },
    {
        "text": "minimize ( max ( a [ i ] , b [ j ] , c [ k ] ) | python code for above approach . ; assigning the length - 1 value to each of three variables ; calculating min difference from last index of lists ; checking condition ; calculating max term from list ; moving to smaller value in the array with maximum out of three . ; ",
        "context": "",
        "code": "def solve(A, B, C):\n    i = len(A) - 1\n    j = len(B) - 1\n    k = len(C) - 1\n    min_diff = abs(max(A[i], B[j], C[k]) - min(A[i], B[j], C[k]))\n    while i != -1 and j != -1 and k != -1:\n        current_diff = abs(max(A[i], B[j], C[k]) - min(A[i], B[j], C[k]))\n        if current_diff < min_diff:\n            min_diff = current_diff\n        max_term = max(A[i], B[j], C[k])\n        if A[i] == max_term:\n            i -= 1\n        elif B[j] == max_term:\n            j -= 1\n        else:\n            k -= 1\n    return min_diff\n",
        "test": "\nA = [5, 8, 10, 15]\nB = [6, 9, 15, 78, 89]\nC = [2, 3, 6, 6, 8, 8, 10]\nprint(solve(A, B, C))\n",
        "output": "1\n",
        "fn_call": "solve"
    },
    {
        "text": "minimum cuts required to convert a palindromic string to a different palindromic string | function to check if string is palindrome or not ; function to check if it is possible to get result by making just one cut ; appending last element in front ; removing last element ; checking whether string s2 is palindrome and different from s . ; if length is <= 3 then it is impossible ; array to store frequency of characters ; store count of characters in a array ; condition for edge cases ; return 1 if it is possible to get palindromic string in just one cut . else we can always reached in two cuttings . ; ",
        "context": "",
        "code": "def isPalindrome(s):\n    for i in range(len(s)):\n        if (s[i] != s[len(s) - i - 1]):\n            return False\n    return true\n\n\ndef ans(s):\n    s2 = s\n    for i in range(len(s)):\n        s2 = s2[len(s2) - 1] + s2\n        s2 = s2[0:len(s2) - 1]\n        if (s != s2 and isPalindrome(s2)):\n            return True\n    return False\n\n\ndef solve(s):\n    if (len(s) <= 3):\n        return -1\n    cnt = [0 for i in range(26)]\n    for i in range(len(s)):\n        cnt[ord(s[i]) - ord('a')] += 1\n    max = cnt[0]\n    for i in range(len(cnt)):\n        if cnt[i] > max:\n            max = cnt[i]\n    if (max >= len(s) - 1):\n        return -1\n    else:\n        if ans(s):\n            return 1\n        else:\n            return 2\n",
        "test": "\nif __name__ == '__main__':\n    s = \"nolon\"\n    print(solve(s))\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "remove characters from the first string which are present in the second string | python 3 program to remove duplicates ; we extract every character of string string 2 ; we find char exit or not ; if char exit we simply remove that char ; ",
        "context": "",
        "code": "def removeChars(string1, string2):\n    for i in string2:\n        while i in string1:\n            itr = string1 .find(i)\n            string1 = string1 .replace(i, '')\n    return string1\n",
        "test": "\nif __name__ == \"__main__\":\n    string1 = \"geeksforgeeks\"\n    string2 = \"mask\"\n    print(removeChars(string1, string2))\n",
        "output": "geeforgee\n",
        "fn_call": "removeChars"
    },
    {
        "text": "program for shortest job first ( sjf ) scheduling | set 2 ( preemptive ) | function to find the waiting time for all processes ; copy the burst time into rt [ ] ; process until all processes gets completed ; find process with minimum remaining time among the processes that arrives till the current time ` ; reduce remaining time by one ; update minimum ; if a process gets completely executed ; increment complete ; find finish time of current process ; calculate waiting time ; increment time ; function to calculate turn around time ; calculating turnaround time ; function to calculate average waiting and turn - around times . ; function to find waiting time of all processes ; function to find turn around time for all processes ; display processes along with all details ; ",
        "context": "",
        "code": "def findWaitingTime(processes, n, wt):\n    rt = [0] * n\n    for i in range(n):\n        rt[i] = processes[i][1]\n    complete = 0\n    t = 0\n    minm = 999999999\n    short = 0\n    check = False\n    while (complete != n):\n        for j in range(n):\n            if ((processes[j][2]  0):\n                minm = rt[j]\n                short = j\n                check = True\n        if (check == False):\n            t += 1\n            continue\n        rt[short] -= 1\n        minm = rt[short]\n        if (minm == 0):\n            minm = 999999999\n        if (rt[short] == 0):\n            complete += 1\n            check = False\n            fint = t + 1\n            wt[short] = (fint - proc[short][1] - proc[short][2])\n            if (wt[short] < 0):\n                wt[short] = 0\n        t += 1\n\n\ndef findTurnAroundTime(processes, n, wt, tat):\n    for i in range(n):\n        tat[i] = processes[i][1] + wt[i]\n\n\ndef findavgTime(processes, n):\n    wt = [0] * n\n    tat = [0] * n\n    findWaitingTime(processes, n, wt)\n    findTurnAroundTime(processes, n, wt, tat)\n    print(\"Processes Burst Time Waiting\", \"Time Turn-Around Time\")\n    total_wt = 0\n    total_tat = 0\n    for i in range(n):\n        total_wt = total_wt + wt[i]\n        total_tat = total_tat + tat[i]\n        print(\n            \" \",\n            processes[i][0],\n            \"TABSYMBOLTABSYMBOL\",\n            processes[i][1],\n            \"TABSYMBOLTABSYMBOL\",\n            wt[i],\n            \"TABSYMBOLTABSYMBOL\",\n            tat[i])\n    print(\"Averagewaitingtime=%.5f\" % (total_wt / n))\n    print(\"Average turn around time = \", total_tat / n)\n",
        "test": "\nif __name__ == \"__main__\":\n    proc = [[1, 6, 1], [2, 8, 1], [3, 7, 2], [4, 3, 3]]\n    n = 4\n    findavgTime(proc, n)\n",
        "output": "Processes Burst Time Waiting Time Turn-Around Time\n  1 TABSYMBOLTABSYMBOL 6 TABSYMBOLTABSYMBOL 3 TABSYMBOLTABSYMBOL 9\n  2 TABSYMBOLTABSYMBOL 8 TABSYMBOLTABSYMBOL 16 TABSYMBOLTABSYMBOL 24\n  3 TABSYMBOLTABSYMBOL 7 TABSYMBOLTABSYMBOL 8 TABSYMBOLTABSYMBOL 15\n  4 TABSYMBOLTABSYMBOL 3 TABSYMBOLTABSYMBOL 0 TABSYMBOLTABSYMBOL 3\nAveragewaitingtime=6.75000\nAverage turn around time =  12.75\n",
        "fn_call": "findavgTime"
    },
    {
        "text": "minimum sum of a pair at least k distance apart from an array | python3 program to implement the above approach ; function to find the minimum sum of two elements that are atleast k distance apart ; length of the array ; find the suffix array ; iterate in the array ; update minimum sum ; print the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def findMinSum(A, K):\n    n = len(A)\n    suffix_min = [0] * n\n    suffix_min[n - 1] = A[n - 1]\n    for i in range(n - 2, -1, -1):\n        suffix_min[i] = min(suffix_min[i + 1], A[i])\n    min_sum = sys .maxsize\n    for i in range(n):\n        if (i + K < n):\n            min_sum = min(min_sum, A[i] + suffix_min[i + K])\n    print(min_sum)\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5, 6]\n    K = 2\n    findMinSum(A, K)\n",
        "output": "4\n",
        "fn_call": "findMinSum"
    },
    {
        "text": "number of subarrays having product less than k | python3 program to count subarrays having product less than k . ; counter for single element ; multiple subarray ; if this multiple is less than k , then increment ; ",
        "context": "",
        "code": "def countsubarray(array, n, k):\n    count = 0\n    for i in range(0, n):\n        if array[i] < k:\n            count += 1\n        mul = array[i]\n        for j in range(i + 1, n):\n            mul = mul * array[j]\n            if mul < k:\n                count += 1\n            else:\n                break\n    return count\n",
        "test": "\narray = [1, 2, 3, 4]\nk = 10\nsize = len(array)\ncount = countsubarray(array, size, k)\nprint(count, end=\" \")\n",
        "output": "7 ",
        "fn_call": "countsubarray"
    },
    {
        "text": "find the player with least 0 s after emptying a binary string by removing non | function to find the player who wins the game ; stores total count of 0 s in the string ; stores count of consecutive 1 s ; stores nim - sum on count of consecutive 1 s ; stores length of the string ; traverse the string ; if the current character is 1 ; update cntconone ; update nimsum ; update cntconone ; update cntzero ; update nimsum ; if countzero is an even number ; nimsum is not 0 ; if nimsum is zero ; ",
        "context": "",
        "code": "def FindwinnerOfGame(S):\n    cntZero = 0\n    cntConOne = 0\n    nimSum = 0\n    N = len(S)\n    for i in range(N):\n        if (S[i] == '1'):\n            cntConOne += 1\n        else:\n            nimSum ^= cntConOne\n            cntConOne = 0\n            cntZero += 1\n    nimSum ^= cntConOne\n    if (cntZero % 2 == 0):\n        print(\"Tie\")\n    elif (nimSum):\n        print(\"player 1\")\n    else:\n        print(\"player 2\")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"0110011\"\n    FindwinnerOfGame(S)\n",
        "output": "player 2\n",
        "fn_call": "FindwinnerOfGame"
    },
    {
        "text": "queries to count numbers from a range which does not contain digit k in their decimal or octal representation | function to check if the given digit ' k ' is present in the decimal and octal representations of num or not ; stores if the digit exists or not ; iterate till nums is non - zero ; find the remainder ; if the remainder is k ; function to count the numbers in the range [ 1 , n ] such that it doesn ' t \u2581 contain \u2581 the \u2581 digit \u2581 ' k ' in its decimal and octal representation ; stores count of numbers in the range [ 0 , i ] that contains the digit ' k ' in its octal or decimal representation ; traverse the range [ 0 , 1e6 + 5 ] ; check if i contains the digit ' k ' in its decimal or octal representation ; update pref [ i ] ; print the answer of queries ; ",
        "context": "",
        "code": "def contains(num, K, base):\n    isThere = 0\n    while (num):\n        remainder = num % base\n        if (remainder == K):\n            isThere = 1\n        num //= base\n    return isThere\n\n\ndef count(n, k, v):\n    pref = [0] * 1000005\n    for i in range(1, 10 ** 6 + 5):\n        present = contains(i, k, 10) or contains(i, k, 8)\n        pref[i] += pref[i - 1] + present\n    for i in range(n):\n        print(v[i][1] - v[i][0] + 1 -\n              (pref[v[i][1]] - pref[v[i][0] - 1]), end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    K = 7\n    Q = [[2, 5], [1, 15]]\n    N = len(Q)\n    count(N, K, Q)\n",
        "output": "4 13 ",
        "fn_call": "count"
    },
    {
        "text": "count sequences of given length having non | function to find the binomial coefficient c ( n , r ) ; stores the value c ( n , r ) ; update c ( n , r ) = c ( n , n - r ) ; find c ( n , r ) iteratively ; return the final value ; function to find number of sequence whose prefix sum at each index is always non - negative ; find n ; value of c ( 2 n , n ) ; catalan number ; print the answer ; ",
        "context": "",
        "code": "def binCoff(n, r):\n    val = 1\n    if (r > (n - r)):\n        r = (n - r)\n    for i in range(0, r):\n        val *= (n - i)\n        val //= (i + 1)\n    return val\n\n\ndef findWays(M):\n    n = M // 2\n    a = binCoff(2 * n, n)\n    b = a // (n + 1)\n    print(b)\n",
        "test": "\nif __name__ == '__main__':\n    M = 4\n    X = 5\n    findWays(M)\n",
        "output": "2\n",
        "fn_call": "findWays"
    },
    {
        "text": "find two numbers whose sum is n and does not contain any digit as k | function to find two numbers whose sum is n and do not contain any digit as k ; check every number i and ( n - i ) ; check if i and n - i doesn 't  contain k in them print i and n-i ; check if flag is 0 then print - 1 ; ",
        "context": "",
        "code": "def findAandB(n, k):\n    flag = 0\n    for i in range(1, n):\n        if str(i).count(chr(k + 48)) == 0 and str(n -\n                                                  i).count(chr(k + 48)) == 0:\n            print(i, n - i)\n            flag = 1\n            break\n    if (flag == 0):\n        print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    N = 100\n    K = 0\n    findAandB(N, K)\n",
        "output": "1 99\n",
        "fn_call": "findAandB"
    },
    {
        "text": "minimum number of cubes whose sum equals to given number n | python implementation of the approach ; function to return the minimum number of cubes whose sum is k ; while current perfect cube is less than current element ; if i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; next perfect cube ; re - initialization for next element ; ",
        "context": "\nimport sys\n\n",
        "code": "def MinOfCubedDP(k):\n    DP = [0] * (k + 1)\n    j = 1\n    t = 1\n    DP[0] = 0\n    for i in range(1, k + 1):\n        DP[i] = sys .maxsize\n        while (j <= i):\n            if (j == i):\n                DP[i] = 1\n            elif (DP[i] > DP[i - j]):\n                DP[i] = DP[i - j] + 1\n            t += 1\n            j = t * t * t\n        t = j = 1\n    return DP[k]\n",
        "test": "\nnum = 15\nprint(MinOfCubedDP(num))\n",
        "output": "8\n",
        "fn_call": "MinOfCubedDP"
    },
    {
        "text": "consecutive steps to roof top | python3 code to find maximum number of consecutive steps ; function to count consecutive steps ; count the number of consecutive increasing height building ; ",
        "context": "\nimport math\n\n",
        "code": "def find_consecutive_steps(arr, len):\n    count = 0\n    maximum = 0\n    for index in range(1, len):\n        if (arr[index] > arr[index - 1]):\n            count += 1\n        else:\n            maximum = max(maximum, count)\n            count = 0\n    return max(maximum, count)\n",
        "test": "\narr = [1, 2, 3, 4]\nlen = len(arr)\nprint(find_consecutive_steps(arr, len))\n",
        "output": "3\n",
        "fn_call": "find_consecutive_steps"
    },
    {
        "text": "maximize a value for a semicircle of given radius | function to find the maximum value of f ; using the formula derived for getting the maximum value of f ; ",
        "context": "",
        "code": "def maximumValueOfF(R):\n    return 4 * R * R + 0.25\n",
        "test": "\nR = 3\nprint(maximumValueOfF(R))\n",
        "output": "36.25\n",
        "fn_call": "maximumValueOfF"
    },
    {
        "text": "n | calculate nth term of series ; calculates the n - th term ; ",
        "context": "",
        "code": "def numberSequence(n):\n    num = pow(4, n) - pow(2, n) - 1\n    return num\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    print(numberSequence(n))\n",
        "output": "239\n",
        "fn_call": "numberSequence"
    },
    {
        "text": "find length of longest substring with at most k normal characters | function to find maximum length of normal substrings ; keeps count of normal characters ; indexes of substring ; maintain length of longest substring with at most k normal characters ; get position of character ; check if current character is normal ; check if normal characters count exceeds k ; update answer with substring length ; get position of character ; check if character is normal then decrement count ; ",
        "context": "",
        "code": "def maxNormalSubstring(P, Q, K, N):\n    if (K == 0):\n        return 0\n    count = 0\n    left, right = 0, 0\n    ans = 0\n    while (right < N):\n        while (right < N and count <= K):\n            pos = ord(P[right]) - ord('a')\n            if (Q[pos] == '0'):\n                if (count + 1 > K):\n                    break\n                else:\n                    count += 1\n            right += 1\n            if (count <= K):\n                ans = max(ans, right - left)\n        while (left < right):\n            pos = ord(P[left]) - ord('a')\n            left += 1\n            if (Q[pos] == '0'):\n                count -= 1\n            if (count < K):\n                break\n    return ans\n",
        "test": "\nif (__name__ == \"__main__\"):\n    P = \"giraffe\"\n    Q = \"01111001111111111011111111\"\n    K = 2\n    N = len(P)\n    print(maxNormalSubstring(P, Q, K, N))\n",
        "output": "3\n",
        "fn_call": "maxNormalSubstring"
    },
    {
        "text": "search for an element in a mountain array | function to find the index of the peak element in the array ; stores left most index in which the peak element can be found ; stores right most index in which the peak element can be found ; stores mid of left and right ; if element at mid is less than element at ( mid + 1 ) ; update left ; update right ; function to perform binary search in an a subarray if elements of the subarray are in an ascending order ; stores mid of left and right ; if x found at mid ; if x is greater than mid ; update left ; update right ; function to perform binary search in an a subarray if elements of the subarray are in an ascending order ; stores mid of left and right ; if x found at mid ; update right ; update left ; function to find the smallest index of x ; stores index of peak element in array ; stores index of x in the array ; if x greater than or equal to first element of array and less than the peak element ; update res ; if element not found on left side of peak element ; update res ; print res ; ",
        "context": "",
        "code": "def findPeak(arr):\n    left = 0\n    right = len(arr) - 1\n    while (left < right):\n        mid = left + (right - left) // 2\n        if (arr[mid] < arr[(mid + 1)]):\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n\ndef BS(X, left, right, arr):\n    while (left <= right):\n        mid = left + (right - left) // 2\n        if (arr[mid] == X):\n            return mid\n        elif (X > arr[mid]):\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\ndef reverseBS(X, left, right, arr):\n    while (left <= right):\n        mid = left + (right - left) // 2\n        if (arr[mid] == X):\n            return mid\n        elif (X > arr[mid]):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n\n\ndef findInMA(X, mountainArr):\n    peakIndex = findPeak(mountainArr)\n    res = -1\n    if (X >= mountainArr[0] and X <= mountainArr[peakIndex]):\n        res = BS(X, 0, peakIndex, mountainArr)\n    if (res == -1):\n        res = reverseBS(X, peakIndex + 1, mountainArr .size() - 1, mountainArr)\n    print(res)\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 3\n    arr = [1, 2, 3, 4, 5, 3, 1]\n    findInMA(X, arr)\n",
        "output": "2\n",
        "fn_call": "findInMA"
    },
    {
        "text": "count subarrays of atleast size 3 forming a geometric progression ( gp ) | function to count all the subarrays of size at least 3 forming gp ; if array size is less than 3 ; stores the count of subarray ; stores the count of subarray for each iteration ; traverse the array ; check if l [ i ] forms gp ; otherwise , update count to 0 ; update the final count ; return the final count ; ",
        "context": "",
        "code": "def numberOfGP(L, N):\n    if (N <= 2):\n        return 0\n    count = 0\n    res = 0\n    for i in range(2, N):\n        if (L[i - 1] * L[i - 1] == L[i] * L[i - 2]):\n            count += 1\n        else:\n            count = 0\n        res += count\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 4, 8, 16, 24]\n    N = len(arr)\n    print(numberOfGP(arr, N))\n",
        "output": "6\n",
        "fn_call": "numberOfGP"
    },
    {
        "text": "count points which are revisited while following the path specified by a given string | function to find the number of times already visited position is revisited after starting traversal from { x , y } ; stores the x and y temporarily ; stores the number of times an already visited position is revisited ; initialize hashset ; insert the starting coordinates ; traverse over the string ; update the coordinates according to the current directions ; if the new { x , y } has been visited before , then increment the count by 1 ; otherwise ; insert new { x , y } ; ",
        "context": "",
        "code": "def count(S, X, Y):\n    N = len(S)\n    temp_x, temp_y = 0, 0\n    count = 0\n    s = {}\n    s[(X, Y)] = 1\n    for i in range(N):\n        temp_x = X\n        temp_y = Y\n        if (S[i] == 'U'):\n            X += 1\n        elif (S[i] == 'D'):\n            X -= 1\n        elif (S[i] == 'R'):\n            Y += 1\n        else:\n            Y -= 1\n        if ((temp_x + X, temp_y + Y) in s):\n            count += 1\n        else:\n            s[(temp_x + X, temp_y + Y)] = 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    S = \"RDDUDL\"\n    X, Y = 0, 0\n    print(count(S, X, Y))\n",
        "output": "2\n",
        "fn_call": "count"
    },
    {
        "text": "bitwise xor of all odd numbers from a given range | function to calculate bitwise xor of odd numbers in the range [ 1 , n ] ; n & 3 is equivalent to n % 4 ; if n is multiple of 4 ; if n % 4 gives remainder 1 ; if n % 4 gives remainder 2 ; if n % 4 gives remainder 3 ; function to find the xor of odd numbers less than or equal to n ; if number is even ; prthe answer ; if number is odd ; prthe answer ; ",
        "context": "",
        "code": "def findXOR(n):\n    if (n % 4 == 0):\n        return n\n    elif (n % 4 == 1):\n        return 1\n    elif (n % 4 == 2):\n        return n + 1\n    elif (n % 4 == 3):\n        return 0\n\n\ndef findOddXOR(n):\n    if (n % 2 == 0):\n        print(((findXOR(n)) ^ (2 * findXOR(n // 2))))\n    else:\n        print(((findXOR(n)) ^ (2 * findXOR((n - 1) // 2))))\n",
        "test": "\nif __name__ == '__main__':\n    N = 11\n    findOddXOR(N)\n",
        "output": "2\n",
        "fn_call": "findOddXOR"
    },
    {
        "text": "replace every vowels with lexicographically next vowel in a string | function to replace every vowel with next vowel lexicographically ; storing the vowels in the map with custom numbers showing their index ; iterate over the string ; if the current character is a vowel find the index in hash and replace it with next vowel from hash ; ",
        "context": "",
        "code": "def print_next_vovel_string(st):\n    m = {}\n    m['a'] = 0\n    m['e'] = 1\n    m['i'] = 2\n    m['o'] = 3\n    m['u'] = 4\n    arr = ['a', 'e', 'i', 'o', 'u']\n    N = len(st)\n    for i in range(N):\n        c = st[i]\n        if (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u'):\n            index = m[st[i]] + 1\n            newindex = index % 5\n            st = st .replace(st[i], arr[newindex], 1)\n    return st\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"geeksforgeeks\"\n    print(print_next_vovel_string(st))\n",
        "output": "giiksfurgiiks\n",
        "fn_call": "print_next_vovel_string"
    },
    {
        "text": "program to find the value of p ( n + r ) for a polynomial of a degree n such that p ( i ) = 1 for 1 \u00e3 \u00a2 \u00e2 \u20ac\u00b0\u00a4 i \u00e3 \u00a2 \u00e2 \u20ac\u00b0\u00a4 n and p ( n + 1 ) = a | ''function to calculate factorial of n ; '' base case ; '' otherwise, recursively  calculate the factorial ; ''function to find the value of p(n + r) for polynomial p(x) ; ''stores the value of k ; '' store the required answer ; '' iterate in the range [1, n] and  multiply (n + r - i) with answer ; '' add the constant value c as 1 ; '' return the result ; ''",
        "context": "",
        "code": "def fact(n):\n    if n == 1 or n == 0:\n        return 1\n    else:\n        return n * fact(n - 1)\n\n\ndef findValue(n, r, a):\n    k = (a - 1) // fact(n)\n    answer = k\n    for i in range(1, n + 1):\n        answer = answer * (n + r - i)\n        answer = answer + 1\n    return answer\n",
        "test": "\nN = 1\nA = 2\nR = 3\nprint(findValue(N, R, A))\n",
        "output": "4\n",
        "fn_call": "findValue"
    },
    {
        "text": "program for finding the integral of a given function using boole 's rule | function to return the value of f ( x ) for the given value of x ; function to computes the integrand of y at the given intervals of x with step size h and the initial limit a and final limit b ; number of intervals ; computing the step size ; substituing a = 0 , b = 4 and h = 1 ; ",
        "context": "",
        "code": "def y(x):\n    return (1 / (1 + x))\n\n\ndef BooleRule(a, b):\n    n = 4\n    h = ((b - a) / n)\n    sum = 0\n    bl = (7 * y(a) + 32 * y(a + h) + 12 * y(a + 2 * h) +\n          32 * y(a + 3 * h) + 7 * y(a + 4 * h)) * 2 * h / 45\n    sum = sum + bl\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    lowlimit = 0\n    upplimit = 4\n    print(\"f(x) =\", round(BooleRule(0, 4), 4))\n",
        "output": "f(x) = 1.6178\n",
        "fn_call": "BooleRule"
    },
    {
        "text": "check if all prime factors of number n are unique or not | function that returns the all the distinct prime factors in a vector ; if n is divisible by 2 ; divide n till all factors of 2 ; check for the prime numbers other than 2 ; store i in prime [ ] i is a factor of n ; divide n till all factors of i ; if n is greater than 2 , then n is prime number after n divided by all factors ; returns the vector prime ; function that check whether n is the product of distinct prime factors or not ; returns the vector to store all the distinct prime factors ; to find the product of all distinct prime factors ; find the product ; if product is equals to n , print yes , else print no ; ",
        "context": "",
        "code": "def primeFactors(n):\n    Prime = []\n    if (n % 2 == 0):\n        Prime .append(2)\n    while (n % 2 == 0):\n        n = n // 2\n    for i in range(3, int(n ** (1 / 2)), 2):\n        if (n % i == 0):\n            Prime .append(i)\n        while (n % i == 0):\n            n = n // i\n    if (n > 2):\n        Prime .append(n)\n    return Prime\n\n\ndef checkDistinctPrime(n):\n    Prime = primeFactors(n)\n    product = 1\n    for i in Prime:\n        product *= i\n    if (product == n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 30\n    checkDistinctPrime(N)\n",
        "output": "YES\n",
        "fn_call": "checkDistinctPrime"
    },
    {
        "text": "sum of two large numbers | function for finding sum of larger numbers ; before proceeding further , make sure length of str2 is larger . ; take an empty string for storing result ; calculate length of both string ; initially take carry zero ; traverse from end of both strings ; do school mathematics , compute sum of current digits and carry ; add remaining digits of str2 [ ] ; add remaining carry ; reverse resultant string ; ",
        "context": "",
        "code": "def findSum(str1, str2):\n    if len(str1) > len(str2):\n        temp = str1\n        str1 = str2\n        str2 = temp\n    str3 = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    diff = n2 - n1\n    carry = 0\n    for i in range(n1 - 1, -1, -1):\n        sum = ((ord(str1[i]) - ord('0')) +\n               int((ord(str2[i + diff]) - ord('0'))) + carry)\n        str3 = str3 + str(sum % 10)\n        carry = sum // 10\n    for i in range(n2 - n1 - 1, -1, -1):\n        sum = ((ord(str2[i]) - ord('0')) + carry)\n        str3 = str3 + str(sum % 10)\n        carry = sum // 10\n    if (carry):\n        str3 + str(carry + '0')\n    str3 = str3[::-1]\n    return str3\n",
        "test": "\nif __name__ == \"__main__\":\n    str1 = \"12\"\n    str2 = \"198111\"\n    print(findSum(str1, str2))\n",
        "output": "198123\n",
        "fn_call": "findSum"
    },
    {
        "text": "maximum count of sub | function to return the count of the required sub - strings ; iterate over all characters ; count with current character ; if the substring has a length k then increment count with current character ; update max count ; ",
        "context": "",
        "code": "def maxSubStrings(s, k):\n    maxSubStr = 0\n    n = len(s)\n    for c in range(27):\n        ch = chr(ord('a') + c)\n        curr = 0\n        for i in range(n - k):\n            if (s[i] != ch):\n                continue\n            cnt = 0\n            while (i < n and s[i] == ch and cnt != k):\n                i += 1\n                cnt += 1\n            i -= 1\n            if (cnt == k):\n                curr += 1\n        maxSubStr = max(maxSubStr, curr)\n    return maxSubStr\n",
        "test": "\nif __name__ == '__main__':\n    s = \"aaacaabbaa\"\n    k = 2\n    print(maxSubStrings(s, k))\n",
        "output": "3\n",
        "fn_call": "maxSubStrings"
    },
    {
        "text": "queries to count sum of rows and columns of a matrix present in given ranges | ''python3 program for the above approach ; ''function to preprocess the matrix to execute the queries ; '' stores the sum of each row ; '' stores the sum of each col ; '' traverse the matrix and calculate  sum of each row and column ; '' insert all row sums in sum_list ; '' insert all column sums in sum_list ; '' sort the array in ascending order ; '' traverse the array queries[][] ; '' search the leftmost index of l ; '' search the rightmost index of r ; ''function to search for the leftmost index of given number ; '' initialize low, high and ans ; '' stores mid ; '' if a[mid] >= num ; ''function to search for the rightmost index of given number ; '' initialise low, high and ans ; '' stores mid ; '' if a[mid] <= num ; '' update ans ; '' update mid ; '' update high ; ''",
        "context": "\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\n\n",
        "code": "def left_search(A, num):\n    low, high = 0, len(A) - 1\n    ans = 0\n    while (low <= high):\n        mid = low + (high - low) // 2\n        if (A[mid] >= num):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\n\n\ndef right_search(A, num):\n    low, high = 0, len(A) - 1\n    ans = high\n    while (low <= high):\n        mid = low + (high - low) // 2\n        if (A[mid] <= num):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans\n\ndef totalCount(A, N, M, queries, Q):\n    row_sum = [0] * N\n    col_sum = [0] * M\n    for i in range(N):\n        for j in range(M):\n            row_sum[i] += A[i][j]\n            col_sum[j] += A[i][j]\n    sum_list = []\n    for i in range(N):\n        sum_list .append(row_sum[i])\n    for i in range(M):\n        sum_list .append(col_sum[i])\n    sum_list = sorted(sum_list)\n    for i in range(Q):\n        L = queries[i][0]\n        R = queries[i][1]\n        l = left_search(sum_list, L)\n        r = right_search(sum_list, R)\n        print(r - l + 1, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N, M = 3, 2\n    A = [[13, 3], [9, 4], [6, 10]]\n    Q = 2\n    queries = [[10, 20], [25, 35]]\n    totalCount(A, N, M, queries, Q)\n",
        "output": "4 1 ",
        "fn_call": "totalCount"
    },
    {
        "text": "longest substring with atmost k characters from the given set of characters | function to find the longest substring in the string which contains atmost k characters from the given set of characters ; base condition ; count for characters from set in substring ; two pointers ; loop to iterate until right pointer is not equal to n ; loop to increase the substring length until the characters from set are at most k ; check if current pointer points a character from set ; if the count of the char is exceeding the limit ; update answer with substring length ; increment the left pointer until the count is less than or equal to k ; if the character which comes out then decrement the count by 1 ; ",
        "context": "",
        "code": "def maxNormalSubstring(P, Q, K, N):\n    if (K == 0):\n        return 0\n    count = 0\n    left = 0\n    right = 0\n    ans = 0\n    while (right < N):\n        while (right < N and count <= K):\n            if (P[right] in Q):\n                if (count + 1 > K):\n                    break\n                else:\n                    count += 1\n            right += 1\n            if (count <= K):\n                ans = max(ans, right - left)\n        while (left < right):\n            left += 1\n            if (P[left - 1] in Q):\n                count -= 1\n            if (count < K):\n                break\n    return ans\n",
        "test": "\nP = \"giraffe\"\nQ = {chr}\nQ .add('a')\nQ .add('f')\nQ .add('g')\nQ .add('r')\nK = 2\nN = len(P)\nprint(maxNormalSubstring(P, Q, K, N))\n",
        "output": "3\n",
        "fn_call": "maxNormalSubstring"
    },
    {
        "text": "maximum sum after repeatedly dividing n by a divisor | python 3 implementation of the above approach ; function to find the smallest divisor ; function to find the maximum sum ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def smallestDivisor(n):\n    mx = int(sqrt(n))\n    for i in range(2, mx + 1, 1):\n        if (n % i == 0):\n            return i\n    return n\n\n\ndef maxSum(n):\n    res = n\n    while (n > 1):\n        divi = smallestDivisor(n)\n        n = int(n / divi)\n        res += n\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    n = 34\n    print(maxSum(n))\n",
        "output": "52\n",
        "fn_call": "maxSum"
    },
    {
        "text": "magnanimous numbers | function to check if n is prime ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to check if the number is magnanimous or not ; converting the number to string ; finding length of string ; number should not be of single digit ; loop to find all left and right part of the string ; ",
        "context": "",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0) or (n % 3 == 0):\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef isMagnanimous(N):\n    s = str(N)\n    l = len(s)\n    if (l < 2):\n        return False\n    for i in range(l - 1):\n        left = s[0:i + 1]\n        right = s[i + 1:]\n        x = int(left)\n        y = int(right)\n        if (not isPrime(x + y)):\n            return False\n    return True\n",
        "test": "\nN = 12\nif isMagnanimous(N):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isMagnanimous"
    },
    {
        "text": "program to find the quantity after mixture replacement | function to calculate the remaining amount . ; calculate right hand side ( rhs ) . ; calculate amount left by multiply it with original value . ; ",
        "context": "",
        "code": "def Mixture(X, Y, Z):\n    result = 0.0\n    result1 = 0.0\n    result1 = ((X - Y) / X)\n    result = pow(result1, Z)\n    result = result * X\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 10\n    Y = 2\n    Z = 2\n    print(\"{:.1f}\".format(Mixture(X, Y, Z)) + \" litres\")\n",
        "output": "6.4 litres\n",
        "fn_call": "Mixture"
    },
    {
        "text": "make the string in ap by changing a character | function to modify the given string and find the index where modification is needed ; array to store the ascii values of alphabets ; loop to compute the ascii values of characters a - z ; set to store all the possible differences between consecutive elements ; loop to find out the differences between consecutive elements and storing them in the set ; checks if any character of the string disobeys the pattern ; constructing the strings with all possible values of consecutive difference and comparing them with staring string s . ; ",
        "context": "",
        "code": "def string_modify(s):\n    alphabets = []\n    flag, hold_i = 0, 0\n    hold_l = s[0]\n    for i in range(26):\n        alphabets .append(chr(i + ord('a')))\n    difference = set()\n    reconstruct = \"\"\n    for i in range(1, len(s)):\n        difference .add(ord(s[i]) - ord(s[i - 1]))\n    if (len(difference) == 1):\n        print(\"No modifications required\")\n        return\n    for it in difference:\n        index = ord(s[0]) - ord('a')\n        reconstruct = \"\"\n        flag = 0\n        i = 0\n        while ((i < len(s)) and (flag <= 1)):\n            reconstruct += alphabets[index]\n            index += it\n            if (index < 0):\n                index += 26\n            index %= 26\n            if (reconstruct[i] != s[i]):\n                flag += 1\n                hold_i = i\n                hold_l = s[i]\n            i += 1\n        if (flag == 1):\n            s[hold_i] = reconstruct[hold_i]\n            break\n    if (flag > 1):\n        hold_i = 0\n        hold_l = s[0]\n        temp = (ord(s[1]) - ord('a') - (ord(s[2]) - ord(s[1]))) % 26\n        if (temp < 0):\n            temp += 26\n        s[0] = alphabets[temp]\n    print(hold_i, \"->\", hold_l)\n    print(\"\".join(s))\n",
        "test": "\ns = list(\"aeimqux\")\nstring_modify(s)\n",
        "output": "6 -> x\naeimquy\n",
        "fn_call": "string_modify"
    },
    {
        "text": "minimum rooms for m events of n batches with given schedule | returns minimum number of rooms required to perform classes of n groups in m slots with given schedule . ; store count of classes happening in every slot . ; initialize all values to zero ; number of rooms required is equal to maximum classes happening in a particular slot . ; ",
        "context": "",
        "code": "def findMinRooms(slots, n, m):\n    counts = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if (slots[i][j] == '1'):\n                counts[j] += 1\n    return max(counts)\n",
        "test": "\nn = 3\nm = 7\nslots = [\"0101011\", \"0011001\", \"0110111\"]\nprint(findMinRooms(slots, n, m))\n",
        "output": "3\n",
        "fn_call": "findMinRooms"
    },
    {
        "text": "count of strings in the first array which are smaller than every string in the second array | python3 implementation of the approach ; function to count the number of smaller strings in a for every in b ; count the frequency of all characters ; iterate for all possible strings in a ; increase the frequency of every character ; check for the smallest character 's frequency ; get the smallest character frequency ; insert it in the vector ; sort the count of all the frequency of the smallest character in every string ; iterate for every in b ; hash set every frequency 0 ; count the frequency of every character ; find the frequency of the smallest character ; count the number of strings in a which has the frequency of the smaller character less than the frequency of the smaller character of the in b ; store the answer ; function to print the answer ; get the answer ; print the number of strings for every answer ; ",
        "context": "\nfrom bisect import bisect_left as lower_bound\nMAX = 26\n\n",
        "code": "def findCount(a, b, n, m):\n    freq = [0 for i in range(MAX)]\n    smallestFreq = []\n    for i in range(n):\n        s = a[i]\n        for i in range(MAX):\n            freq[i] = 0\n        for j in range(len(s)):\n            freq[ord(s[j]) - ord('a')] += 1\n        for j in range(MAX):\n            if (freq[j]):\n                smallestFreq .append(freq[j])\n                break\n    smallestFreq = sorted(smallestFreq)\n    ans = []\n    for i in range(m):\n        s = b[i]\n        for i in range(MAX):\n            freq[i] = 0\n        for j in range(len(s)):\n            freq[ord(s[j]) - ord('a')] += 1\n        frequency = 0\n        for j in range(MAX):\n            if (freq[j]):\n                frequency = freq[j]\n                break\n        ind = lower_bound(smallestFreq, frequency)\n        ans .append(ind)\n    return ans\n\n\ndef printAnswer(a, b, n, m):\n    ans = findCount(a, b, n, m)\n    for it in ans:\n        print(it, end=\" \")\n",
        "test": "\nA = [\"aaa\", \"aa\", \"bdc\"]\nB = [\"cccch\", \"cccd\"]\nn = len(A)\nm = len(B)\nprintAnswer(A, B, n, m)\n",
        "output": "3 2 ",
        "fn_call": "printAnswer"
    },
    {
        "text": "sum of square of first n odd numbers | python3 code to find sum of square of first n odd numbers ; ",
        "context": "",
        "code": "def squareSum(n):\n    return int(n * (4 * n * n - 1) / 3)\n",
        "test": "\nans = squareSum(8)\nprint(ans)\n",
        "output": "680\n",
        "fn_call": "squareSum"
    },
    {
        "text": "count of double prime numbers in a given range l to r | array to make sieve where arr [ i ] = 0 indicates non prime and arr [ i ] = 1 indicates prime ; array to find double prime ; function to find the number double prime numbers in range ; assume all numbers as prime ; check if the number is prime ; check for multiples of i ; make all multiples of ith prime as non - prime ; check if number at ith position is prime then increment count ; indicates count of numbers from 1 to i that are also prime and hence double prime ; if number is not a double prime ; finding cumulative sum ; ",
        "context": "\narr = [0] * 1000001\ndp = [0] * 1000001\n\n",
        "code": "def count():\n    maxN = 1000000\n    for i in range(0, maxN):\n        arr[i] = 1\n    arr[0] = 0\n    arr[1] = 0\n    i = 2\n    while (i * i <= maxN):\n        if (arr[i] == 1):\n            for j in range(2 * i, maxN + 1, i):\n                arr[j] = 0\n        i += 1\n    cnt = 0\n    for i in range(0, maxN + 1):\n        if (arr[i] == 1):\n            cnt += 1\n        if (arr[cnt] == 1):\n            dp[i] = 1\n        else:\n            dp[i] = 0\n    for i in range(0, maxN + 1):\n        dp[i] += dp[i - 1]\n",
        "test": "\nL = 4\nR = 12\ncount()\nprint(dp[R] - dp[L - 1])\n",
        "output": "5\n",
        "fn_call": "count"
    },
    {
        "text": "find the date after next half year from a given date | function to find the date after the next half - year ; stores the number of days in the months of a leap year ; list of months ; days in half of a year ; index of current month ; starting day ; decrement the value of cnt by 1 ; increment cur_date ; if cnt is equal to 0 , then break out of the loop ; update cur_month ; update cur_date ; print the resultant date ; ",
        "context": "",
        "code": "def getDate(d, m):\n    days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    month = [\n        'January',\n        'February',\n        'March',\n        'April',\n        'May',\n        'June',\n        'July',\n        'August',\n        'September',\n        'October',\n        'November',\n        'December']\n    cnt = 183\n    cur_month = month .index(m)\n    cur_date = d\n    while (1):\n        while (cnt > 0 and cur_date <= days[cur_month]):\n            cnt -= 1\n            cur_date += 1\n        if (cnt == 0):\n            break\n        cur_month = (cur_month + 1) % 12\n        cur_date = 1\n    print(cur_date, month[cur_month])\n",
        "test": "\nD = 15\nM = \"January\"\ngetDate(D, M)\n",
        "output": "16 July\n",
        "fn_call": "getDate"
    },
    {
        "text": "split n as the sum of k numbers satisfying the given conditions | list to store prime numbers ; function to generate prime numbers using sieveoferatosthenes ; boolean array to store primes ; if p is a prime ; mark all its multiples as non - prime ; print all prime numbers ; function to generate n as the sum of k numbers where atleast k - 1 are distinct and are product of 2 primes ; stores the product of every pair of prime number ; sort the products ; if sum exceeds n ; otherwise , print the k required numbers ; ",
        "context": "\nprimes = []\n\n",
        "code": "def SieveOfEratosthenes():\n    prime = [True] * 10005\n    p = 2\n    while p * p <= 1000:\n        if (prime[p]):\n            for i in range(p * p, 1001, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, 1001):\n        if (prime[p]):\n            primes .append(p)\n\n\ndef generate(n, k):\n    prod = []\n    SieveOfEratosthenes()\n    l = len(primes)\n    for i in range(l):\n        for j in range(i + 1, l):\n            if (primes[i] * primes[j] > 0):\n                prod .append(primes[i] * primes[j])\n    prod .sort()\n    sum = 0\n    for i in range(k - 1):\n        sum += prod[i]\n    if (sum > n):\n        print(\"-1\")\n    else:\n        for i in range(k - 1):\n            print(prod[i], end=\", \")\n        print(n - sum)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 52\n    k = 5\n    generate(n, k)\n",
        "output": "6, 10, 14, 15, 7\n",
        "fn_call": "generate"
    },
    {
        "text": "program to compare m ^ n and n ^ m | python3 program to compare which is greater m ^ n or n ^ m ; function to compare m ^ n and n ^ m ; m ^ n ; n ^ m ; ",
        "context": "\nimport math\n\n",
        "code": "def check(m, n):\n    RHS = m * math .log(n)\n    LHS = n * math .log(m)\n    if (LHS > RHS):\n        print(\"m^n > n^m\")\n    elif (LHS < RHS):\n        print(\"m^n < n^m\")\n    else:\n        print(\"m^n = n^m\")\n",
        "test": "\nm = 987654321\nn = 123456987\ncheck(m, n)\n",
        "output": "m^n < n^m\n",
        "fn_call": "check"
    },
    {
        "text": "xor of major diagonal elements of a 3d matrix | function to find the bitwise xor of both diagonal elements of 3d matrix ; stores the bitwise xor of the major diagonal elements ; print the resultant bitwise xor ; ",
        "context": "",
        "code": "def findXOR(mat, N):\n    XOR = 0\n    for i in range(N):\n        XOR ^= mat[i][i][i]\n        XOR ^= mat[i][i][N - i - 1]\n    print(XOR)\n",
        "test": "\nmat = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\nN = len(mat)\nfindXOR(mat, N)\n",
        "output": "12\n",
        "fn_call": "findXOR"
    },
    {
        "text": "replace every element with the smallest of the others | python3 code for the above approach . ; there should be atleast two elements ; if current element is smaller than firstsmallest then update both firstsmallest and secondsmallest ; if arr [ i ] is in between firstsmallest and secondsmallest then update secondsmallest ; replace every element by smallest of all other elements ; print the modified array . ; ",
        "context": "",
        "code": "def ReplaceElements(arr, n):\n    if (n < 2):\n        print(\"Invalid Input\")\n        return\n    firstSmallest = 10 ** 18\n    secondSmallest = 10 ** 18\n    for i in range(n):\n        if (arr[i] < firstSmallest):\n            secondSmallest = firstSmallest\n            firstSmallest = arr[i]\n        elif (arr[i] < secondSmallest and arr[i] != firstSmallest):\n            secondSmallest = arr[i]\n    for i in range(n):\n        if (arr[i] != firstSmallest):\n            arr[i] = firstSmallest\n        else:\n            arr[i] = secondSmallest\n    for i in arr:\n        print(i, end=\", \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 2, 1, 3]\n    n = len(arr)\n    ReplaceElements(arr, n)\n",
        "output": "1, 1, 2, 1, ",
        "fn_call": "ReplaceElements"
    },
    {
        "text": "maximum possible sum of k even multiples of 5 in a given range | function to find the maximum sum of k even multiples of 5 in the range [ l , r ] ; store the total number of even multiples of 5 in the range [ l , r ] ; check if k > n ; if true , print - 1 and return ; otherwise , divide r by 10 ; store the sum using the formula ; print the sum ; ",
        "context": "",
        "code": "def maxksum(L, R, K):\n    N = (R // 10 - L // 10) + 1\n    if (K > N):\n        print(-1)\n        return\n    R = R // 10\n    X = R - K\n    sum = 10 * ((R * (R + 1)) // 2 - (X * (X + 1)) // 2)\n    print(sum)\n",
        "test": "\nif __name__ == \"__main__\":\n    L = 16\n    R = 60\n    K = 4\n    maxksum(L, R, K)\n",
        "output": "180\n",
        "fn_call": "maxksum"
    },
    {
        "text": "count of quadruplets from range [ l , r ] having gcd equal to k | python 3 implementation of the approach ; function to return the count of quadruplets having gcd = k ; to store the required count ; check every quadruplet pair whether its gcd is k ; return the required count ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def countQuadruplets(l, r, k):\n    count = 0\n    for u in range(l, r + 1, 1):\n        for v in range(l, r + 1, 1):\n            for w in range(l, r + 1, 1):\n                for x in range(l, r + 1, 1):\n                    if (gcd(gcd(u, v), gcd(w, x)) == k):\n                        count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    l = 1\n    r = 10\n    k = 2\n    print(countQuadruplets(l, r, k))\n",
        "output": "607\n",
        "fn_call": "countQuadruplets"
    },
    {
        "text": "distribute r , b beans such that each packet has at least 1 r and 1 b bean with absolute difference at most d | function to check if it is possible to distribute r red and b blue beans in packets such that the difference between the beans in each packet is atmost d ; check for the condition to distributing beans ; print the answer ; distribution is not possible ; ",
        "context": "",
        "code": "def checkDistribution(R, B, D):\n    if (max(R, B) <= min(R, B) * (D + 1)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nR = 1\nB = 1\nD = 0\ncheckDistribution(R, B, D)\n",
        "output": "Yes\n",
        "fn_call": "checkDistribution"
    },
    {
        "text": "count of character pairs at same distance as in english alphabets | function to count pairs ; increment count if characters are at same distance ; ",
        "context": "",
        "code": "def countPairs(str1):\n    result = 0\n    n = len(str1)\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (abs(ord(str1[i]) - ord(str1[j])) == abs(i - j)):\n                result += 1\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    str1 = \"geeksforgeeks\"\n    print(countPairs(str1))\n",
        "output": "4\n",
        "fn_call": "countPairs"
    },
    {
        "text": "count pairs with odd xor | a function will return number of pair whose xor is odd ; to store count of xor pair ; if xor is odd increase count ; return count ; ",
        "context": "",
        "code": "def countXorPair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ((arr[i] ^ arr[j]) % 2 == 1):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3]\n    n = len(arr)\n    print(countXorPair(arr, n))\n",
        "output": "2\n",
        "fn_call": "countXorPair"
    },
    {
        "text": "count substrings that contain all vowels | set 2 | function that returns true if c is a vowel ; function to return the count of sub - strings that contain every vowel at least once and no consonant ; map is used to store count of each vowel ; start index is set to 0 initially ; if substring till now have all vowels atleast once increment start index until there are all vowels present between ( start , i ) and add n - i each time ; function to extract all maximum length sub - strings in s that contain only vowels and then calls the countsubstringsutil ( ) to find the count of valid sub - strings in that string ; if current character is a vowel then append it to the temp string ; the sub - string containing all vowels ends here ; if there was a valid sub - string ; reset temp string ; for the last valid sub - string ; ",
        "context": "",
        "code": "def isVowel(c):\n    return (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u')\n\n\ndef countSubstringsUtil(s):\n    count = 0\n    mp = dict .fromkeys(s, 0)\n    n = len(s)\n    start = 0\n    for i in range(n):\n        mp[s[i]] += 1\n        while (mp['a'] > 0 and mp['e'] > 0 and mp['i']\n               > 0 and mp['o'] > 0 and mp['u'] > 0):\n            count += n - i\n            mp[s[start]] -= 1\n            start += 1\n    return count\n\n\ndef countSubstrings(s):\n    count = 0\n    temp = \"\"\n    for i in range(len(s)):\n        if (isVowel(s[i])):\n            temp += s[i]\n        else:\n            if (len(temp) > 0):\n                count += countSubstringsUtil(temp)\n            temp = \"\"\n    if (len(temp) > 0):\n        count += countSubstringsUtil(temp)\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"aeouisddaaeeiouua\"\n    print(countSubstrings(s))\n",
        "output": "9\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "longest alternating sub | function to calculate alternating sub - array for each index of array elements ; initialize count variable for storing length of sub - array ; initialize ' prev ' variable which indicates the previous element while traversing for index 'i ; if both elements are same , print elements because alternate element is not found for current index ; print count and decrement it . ; increment count for next element ; re - initialize previous variable ; if elements are still available after traversing whole array , print it ; ",
        "context": "",
        "code": "def alternateSubarray(arr, n):\n    count = 1\n    prev = arr[0]\n    for i in range(1, n):\n        if ((arr[i] ^ prev) == 0):\n            while (count):\n                print(count, end=\" \")\n                count -= 1\n        count += 1\n        prev = arr[i]\n    while (count):\n        print(count, end=\" \")\n        count -= 1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 0, 1, 0, 0, 1]\n    n = len(arr)\n    alternateSubarray(arr, n)\n",
        "output": "4 3 2 1 2 1 ",
        "fn_call": "alternateSubarray"
    },
    {
        "text": "level of each node in a tree from source node ( using bfs ) | python3 program to determine level of each node and print level ; function to determine level of each node starting from x using bfs ; array to store level of each node ; create a queue ; enqueue element x ; initialize level of source node to 0 ; marked it as visited ; do until queue is empty ; get the first element of queue ; traverse neighbors of node x ; b is neighbor of node x ; if b is not marked already ; enqueue b in queue ; level of b is level of x + 1 ; mark b ; display all nodes and their levels ; ",
        "context": "\nimport queue\n\n",
        "code": "def printLevels(graph, V, x):\n    level = [None] * V\n    marked = [False] * V\n    que = queue .Queue()\n    que .put(x)\n    level[x] = 0\n    marked[x] = True\n    while (not que .empty()):\n        x = que .get()\n        for i in range(len(graph[x])):\n            b = graph[x][i]\n            if (not marked[b]):\n                que .put(b)\n                level[b] = level[x] + 1\n                marked[b] = True\n    print(\"Nodes\", \" \", \"Level\")\n    for i in range(V):\n        print(\" \", i, \" --> \", level[i])\n",
        "test": "\nif __name__ == '__main__':\n    V = 8\n    graph = [[]for i in range(V)]\n    graph[0].append(1)\n    graph[0].append(2)\n    graph[1].append(3)\n    graph[1].append(4)\n    graph[1].append(5)\n    graph[2].append(5)\n    graph[2].append(6)\n    graph[6].append(7)\n    printLevels(graph, V, 0)\n",
        "output": "Nodes   Level\n  0  -->  0\n  1  -->  1\n  2  -->  1\n  3  -->  2\n  4  -->  2\n  5  -->  2\n  6  -->  2\n  7  -->  3\n",
        "fn_call": "printLevels"
    },
    {
        "text": "tetracontaoctagonal number | function to find the nth tetracontaoctagonal number ; ",
        "context": "",
        "code": "def TetracontaoctagonalNum(n):\n    return (46 * n * n - 44 * n) / 2\n",
        "test": "\nn = 3\nprint(TetracontaoctagonalNum(n))\n",
        "output": "141.0\n",
        "fn_call": "TetracontaoctagonalNum"
    },
    {
        "text": "probability of choosing a random pair with maximum sum in an array | function to get max first and second ; if current element is smaller than first , then update both first and second ; if arr [ i ] is in between first and second then update second ; cnt1 += 1 frequency of first maximum ; cnt2 += 1 frequency of second maximum ; returns probability of choosing a pair with maximum sum . ; ",
        "context": "",
        "code": "def countMaxSumPairs(a, n):\n\n    first = 0\n    second = 0\n    for i in range(n):\n        if (a[i] > first):\n            second = first\n            first = a[i]\n        elif (a[i] > second and a[i] != first):\n            second = a[i]\n\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if (a[i] == first):\n            cnt1 += 1\n        if (a[i] == second):\n            cnt2 += 1\n\n    if (cnt1 == 1):\n        return cnt2\n\n    if (cnt1 > 1):\n        return cnt1 * (cnt1 - 1) / 2\n\n\ndef findMaxSumProbability(a, n):\n\n    total = n * (n - 1) / 2\n    max_sum_pairs = countMaxSumPairs(a, n)\n    return max_sum_pairs / total\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 2, 3]\n    n = len(a)\n    print(findMaxSumProbability(a, n))\n",
        "output": "0.3333333333333333\n",
        "fn_call": "findMaxSumProbability"
    },
    {
        "text": "remove exactly one element from the array such that max | function to calculate max - min ; ",
        "context": "",
        "code": "def max_min(a, n):\n    a .sort()\n    return min(a[n - 2] - a[0], a[n - 1] - a[1])\n",
        "test": "\na = [1, 3, 3, 7]\nn = len(a)\nprint(max_min(a, n))\n",
        "output": "2\n",
        "fn_call": "max_min"
    },
    {
        "text": "minimum and maximum count of elements at d distance from arr [ i ] in either direction | ''function to find the minimum and maximum number of points included in a range of distance d ; '' stores the minimum and maximum  number of points that lies  over the distance of d ; '' iterate the array ; '' count of elements included  to left of point at index i ; '' update the minimum number  of points ; '' update the maximum number  of points ; '' count of elements included  to right of point at index i ; '' update the minimum number  of points ; '' update the maximum number  of points ; '' return the array ; ''function to perform the binary search to the left of arr[i] over the given range ; '' base case ; '' binary search for index to left ; '' update index ; '' return the number of elements  by subtracting indices ; ''function to perform the binary search to the right of arr[i] over the given range ; '' base case ; '' binary search for index to right ; '' update the index ; '' return the number of elements  by subtracting indices ; ''",
        "context": "",
        "code": "def leftSearch(arr, val, i):\n    if (i == 0):\n        return 1\n    left = 0\n    right = i - 1\n    ind = -1\n    while (left <= right):\n        mid = (left + right) // 2\n        if (arr[mid] < val):\n            left = mid + 1\n        else:\n            right = mid - 1\n            ind = mid\n    return i - ind + 1 if ind != -1 else 1\n\n\ndef rightSearch(arr, val, i):\n    if (i == len(arr) - 1):\n        return 1\n    left = i + 1\n    right = len(arr) - 1\n    ind = -1\n    while (left <= right):\n        mid = (left + right) // 2\n        if (arr[mid] > val):\n            right = mid - 1\n        else:\n            left = mid + 1\n            ind = mid\n    return ind - i + 1 if ind != -1 else 1\n\n\ndef minMaxRange(arr, D, N):\n    Max = 1\n    Min = N\n    for i in range(N):\n        dist = leftSearch(arr, arr[i] - D, i)\n        Min = min(Min, dist)\n        Max = max(Max, dist)\n        dist = rightSearch(arr, arr[i] + D, i)\n        Min = min(Min, dist)\n        Max = max(Max, dist)\n    return [Min, Max]\n",
        "test": "arr = [1, 3, 5, 9, 14]\nN = len(arr)\nD = 4\nminMax = minMaxRange(arr, D, N)\nprint(minMax[0], minMax[1])\n",
        "output": "1 3\n",
        "fn_call": "minMaxRange"
    },
    {
        "text": "sum of all subarrays of size k | function to find the sum of all subarrays of size k ; loop to consider every subarray of size k ; initialize sum = 0 ; calculate sum of all elements of current subarray ; prsum of each subarray ; ",
        "context": "",
        "code": "def calcSum(arr, n, k):\n    for i in range(n - k + 1):\n        sum = 0\n        for j in range(i, k + i):\n            sum += arr[j]\n        print(sum, end=\" \")\n",
        "test": "\narr = [1, 2, 3, 4, 5, 6]\nn = len(arr)\nk = 3\ncalcSum(arr, n, k)\n",
        "output": "6 9 12 15 ",
        "fn_call": "calcSum"
    },
    {
        "text": "check whether it is possible to make both arrays equal by modifying a single element | function to check if both sequences can be made equal ; sorting both the arrays ; flag to tell if there are more than one mismatch ; to stores the index of mismatched element ; if there is more than one mismatch then return false ; if there is no mismatch or the difference between the mismatching elements is <= k then return true ; ",
        "context": "",
        "code": "def check(n, k, a, b):\n    a .sort()\n    b .sort()\n    fl = False\n    ind = -1\n    for i in range(n):\n        if (a[i] != b[i]):\n            if (fl):\n                return False\n            fl = True\n            ind = i\n    if (ind == -1 or abs(a[ind] - b[ind]) <= k):\n        return True\n    return False\n",
        "test": "\nn, k = 2, 4\na = [1, 5]\nb = [1, 1]\nif (check(n, k, a, b)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "pairs of strings which on concatenating contains each character of \" string \" | python3 implementation of the approach ; function to return the bitmask for the string ; function to return the count of pairs ; bitmask [ i ] will store the count of strings from the array whose bitmask is i ; to store the count of pairs ; max - 1 = 63 i . e . 111111 in binary ; arr [ i ] cannot make s pair with itself i . e . ( arr [ i ] , arr [ i ] ) ; ",
        "context": "\nMAX = 64\n\n",
        "code": "def getBitmask(s):\n    temp = 0\n    for j in range(len(s)):\n        if (s[j] == 's'):\n            temp = temp | 1\n        elif (s[j] == 't'):\n            temp = temp | 2\n        elif (s[j] == 'r'):\n            temp = temp | 4\n        elif (s[j] == 'i'):\n            temp = temp | 8\n        elif (s[j] == 'n'):\n            temp = temp | 16\n        elif (s[j] == 'g'):\n            temp = temp | 32\n    return temp\n\n\ndef countPairs(arr, n):\n    bitMask = [0 for i in range(MAX)]\n    for i in range(n):\n        bitMask[getBitmask(arr[i])] += 1\n    cnt = 0\n    for i in range(MAX):\n        for j in range(i, MAX):\n            if ((i | j) == (MAX - 1)):\n                if (i == j):\n                    cnt += ((bitMask[i] * bitMask[i] - 1) // 2)\n                else:\n                    cnt += (bitMask[i] * bitMask[j])\n    return cnt\n",
        "test": "\narr = [\"strrr\", \"string\", \"gstrin\"]\nn = len(arr)\nprint(countPairs(arr, n))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "divide a string in n equal parts | function to print n equal parts of string ; check if string can be divided in n equal parts ; calculate the size of parts to find the division points ; ",
        "context": "",
        "code": "def divideString(string, n):\n    str_size = len(string)\n    if str_size % n != 0:\n        print(\"Invalid Input: String size is not divisible by n\")\n        return\n    part_size = str_size/n\n    k = 0\n    for i in string:\n        if k % part_size == 0:\n            print()\n        print(i, end='')\n        k += 1\n",
        "test": "\nstring = \"a_simple_divide_string_quest\"\ndivideString(string, 4)\n",
        "output": "\na_simpl\ne_divid\ne_strin\ng_quest",
        "fn_call": "divideString"
    },
    {
        "text": "game of replacing array elements | function return which player win the game ; create hash that will stores all distinct element ; traverse an array element ; ",
        "context": "",
        "code": "def playGame(arr, n):\n    s = set()\n    for i in range(n):\n        s .add(arr[i])\n    return 1 if len(s) % 2 == 0 else 2\n",
        "test": "\narr = [1, 1, 2, 2, 2, 2]\nn = len(arr)\nprint(\"Player\", playGame(arr, n), \"Wins\")\n",
        "output": "Player 1 Wins\n",
        "fn_call": "playGame"
    },
    {
        "text": "count rotations of n which are odd and even | function to count of all rotations which are odd and even ; ",
        "context": "",
        "code": "def countOddRotations(n):\n    odd_count = 0\n    even_count = 0\n    while n != 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            odd_count += 1\n        else:\n            even_count += 1\n        n = n // 10\n    print(\"Odd =\", odd_count)\n    print(\"Even =\", even_count)\n",
        "test": "\nn = 1234\ncountOddRotations(n)\n",
        "output": "Odd = 2\nEven = 2\n",
        "fn_call": "countOddRotations"
    },
    {
        "text": "divide n segments into two non | function to print the answer if it exists using the concept of merge overlapping segments ; sort the indices based on their corresponding value in v ; resultant array initialise all the values in resultant array with '2' except the first index of ' indices ' which is initialised as '1' initialise maxr to store the maximum of all right values encountered so far ; if the i - th index has any any point in common with the ( i - 1 ) th index classify it as '1' in resultant array and update maxr if necessary else we have found the breakpoint and we can exit the loop ; ",
        "context": "",
        "code": "def printAnswer(v, n):\n    indices = list(range(n))\n    indices .sort(key=lambda i: v[i])\n    res = [2] * n\n    res[indices[0]] = 1\n    maxR = v[indices[0]][1]\n    for i in range(1, n):\n        if maxR >= v[indices[i]][0]:\n            res[indices[i]] = res[indices[i - 1]]\n            maxR = max(maxR, v[indices[i]][1])\n        else:\n            break\n    else:\n        print(\"Not possible\")\n        return\n    print(\" \".join(map(str, res)))\n",
        "test": "\nif __name__ == \"__main__\":\n    v = [[2, 8], [3, 4], [5, 8], [9, 10]]\n    n = len(v)\n    printAnswer(v, n)\n",
        "output": "1 1 1 2\n",
        "fn_call": "printAnswer"
    },
    {
        "text": "highly composite numbers | function to count the number of divisors of the n ; sieve method for prime calculation ; traversing through all prime numbers ; calculate number of divisor with formula total div = ( p1 + 1 ) * ( p2 + 1 ) * ... . . * ( pn + 1 ) where n = ( a1 ^ p1 ) * ( a2 ^ p2 ) . ... * ( an ^ pn ) ai being prime divisor for n and pi are their respective power in factorization ; function to check if a number is a highly composite number ; count number of factors of n ; loop to count number of factors of every number less than n ; if any number less than n has more factors than n , then return false ; ",
        "context": "",
        "code": "def divCount(n):\n    Hash = [True for i in range(n + 1)]\n    p = 2\n    while ((p * p) < n):\n        if bool(Hash[p]):\n            i = p * 2\n            while i < n:\n                Hash[i] = False\n                i += p\n        p += 1\n    total = 1\n    for P in range(2, n + 1):\n        if (bool(Hash[P])):\n            count = 0\n            if (n % P == 0):\n                while (n % P == 0):\n                    n = n // P\n                    count += 1\n                total = total * (count + 1)\n    return total\n\n\ndef isHighlyCompositeNumber(N):\n    NdivCount = divCount(N)\n    for i in range(N):\n        idivCount = divCount(i)\n        if (idivCount >= NdivCount):\n            return bool(False)\n    return bool(True)\n",
        "test": "\nN = 12\nif (bool(isHighlyCompositeNumber(N))):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isHighlyCompositeNumber"
    },
    {
        "text": "find n arithmetic means between a and b | prints n arithmetic means between a and b . ; calculate common difference ( d ) ; for finding n the arithmetic mean between a and b ; ",
        "context": "",
        "code": "def printAMeans(A, B, N):\n    d = (B - A) / (N + 1)\n    for i in range(1, N + 1):\n        print(int(A + i * d), end=\" \")\n",
        "test": "\nA = 20\nB = 32\nN = 5\nprintAMeans(A, B, N)\n",
        "output": "22 24 26 28 30 ",
        "fn_call": "printAMeans"
    },
    {
        "text": "count subsets consisting of each element as a factor of the next element in that subset | function to find number of subsets satisfying the given condition ; stores number of required sets ; stores maximum element of arr [ ] that defines the size of sieve ; iterate through the arr [ ] ; if current element > maxe , then update maxe ; declare an array sieve of size n + 1 ; mark all elements corresponding in the array , by one as there will always exists a singleton set ; iterate from range [ 1 , n ] ; if element is present in array ; traverse through all its multiples <= n ; update them if they are present in array ; iterate from the range [ 1 , n ] ; update the value of cnt ; prthe result ; ",
        "context": "",
        "code": "def countSets(arr, n):\n    cnt = 0\n    maxE = -1\n    for i in range(n):\n        if (maxE < arr[i]):\n            maxE = arr[i]\n    sieve = [0] * (maxE + 1)\n    for i in range(n):\n        sieve[arr[i]] = 1\n    for i in range(1, maxE + 1):\n        if (sieve[i] != 0):\n            for j in range(i * 2, maxE + 1, i):\n                if (sieve[j] != 0):\n                    sieve[j] = (sieve[j] + sieve[i]) % 1000000007\n    for i in range(maxE + 1):\n        cnt = (cnt % 1000000007 + sieve[i] % 1000000007) % 1000000007\n    print(cnt % 1000000007)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [16, 18, 6, 7, 2, 19, 20, 9]\n    N = len(arr)\n    countSets(arr, N)\n",
        "output": "15\n",
        "fn_call": "countSets"
    },
    {
        "text": "queries for counts of array elements with values in given range | function to find first index >= x ; function to find last index <= x ; function to count elements within given range ; initialize result ; ",
        "context": "",
        "code": "def lowerIndex(arr, n, x):\n    l = 0\n    h = n - 1\n    while (l <= h):\n        mid = int((l + h) / 2)\n        if (arr[mid] >= x):\n            h = mid - 1\n        else:\n            l = mid + 1\n    return l\n\n\ndef upperIndex(arr, n, x):\n    l = 0\n    h = n - 1\n    while (l <= h):\n        mid = int((l + h) / 2)\n        if (arr[mid] <= x):\n            l = mid + 1\n        else:\n            h = mid - 1\n    return h\n\n\ndef countInRange(arr, n, x, y):\n    count = 0\n    count = upperIndex(arr, n, y) - lowerIndex(arr, n, x) + 1\n    return count\n",
        "test": "\narr = [1, 3, 4, 9, 10, 3]\nn = len(arr)\narr .sort()\ni = 1\nj = 4\nprint(countInRange(arr, n, i, j))\ni = 9\nj = 12\nprint(countInRange(arr, n, i, j))\n",
        "output": "4\n2\n",
        "fn_call": "countInRange"
    },
    {
        "text": "sum of product of x and y such that floor ( n / x ) = y | return the sum of product x * y ; iterating x from 1 to n ; finding y = n / x . ; adding product of x and y to answer . ; ",
        "context": "",
        "code": "def sumofproduct(n):\n    ans = 0\n    for x in range(1, n + 1):\n        y = int(n / x)\n        ans += (y * x)\n    return ans\n",
        "test": "\nn = 10\nprint(sumofproduct(n))\n",
        "output": "87\n",
        "fn_call": "sumofproduct"
    },
    {
        "text": "number of pairs with maximum sum | python program to count pairs with maximum sum ; traverse through all the pairs ; traverse through all pairs and keep a count of the number of maximum pairs ; ",
        "context": "",
        "code": "def _sum(a, n):\n    maxSum = -9999999\n    for i in range(n):\n        for j in range(n):\n            maxSum = max(maxSum, a[i] + a[j])\n    c = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == maxSum:\n                c += 1\n    return c\n",
        "test": "\narray = [1, 1, 1, 2, 2, 2]\nn = len(array)\nprint(_sum(array, n))\n",
        "output": "3\n",
        "fn_call": "_sum"
    },
    {
        "text": "total number of triplets ( a , b , c ) in which the points b and c are equidistant to a | function to count such triplets ; iterate over all the points ; iterate over all points other than the current point ; compute squared euclidean distance for the current point ; compute np2 that is n * ( n - 1 ) ; return the final result ; ",
        "context": "",
        "code": "def numTrip(points):\n    res = 0\n    for i in range(len(points)):\n        map = {}\n        for j in range(len(points)):\n            if (j == i):\n                continue\n            dy = points[i][1] - points[j][1]\n            dx = points[i][0] - points[j][0]\n            key = dy * dy\n            key += dx * dx\n            map[key] = map .get(key, 0) + 1\n        for p in map:\n            res += map[p] * (map[p] - 1)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[0, 0], [1, 0], [2, 0]]\n    print(numTrip(mat))\n",
        "output": "2\n",
        "fn_call": "numTrip"
    },
    {
        "text": "longest subarray with odd product | function to return length of longest subarray with odd product ; if even element is encountered ; update maximum ; ",
        "context": "",
        "code": "def Maxlen(a, n):\n    ans = 0\n    count = 0\n    for i in range(n):\n        if a[i] % 2 == 0:\n            count = 0\n        else:\n            count += 1\n        ans = max(ans, count)\n    return ans\n",
        "test": "\narr = [1, 7, 2]\nn = len(arr)\nprint(Maxlen(arr, n))\n",
        "output": "2\n",
        "fn_call": "Maxlen"
    },
    {
        "text": "minimum delete operations to make all elements of array same | function to get minimum number of elements to be deleted from array to make array elements equal ; create an dictionary and store frequencies of all array elements in it using element as key and frequency as value ; find maximum frequency among all frequencies . ; to minimize delete operations , we remove all elements but the most frequent element . ; ",
        "context": "",
        "code": "def minDelete(arr, n):\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n    max_freq = 0\n    for i, j in freq .items():\n        max_freq = max(max_freq, j)\n    return n - max_freq\n",
        "test": "\narr = [4, 3, 4, 4, 2, 4]\nn = len(arr)\nprint(minDelete(arr, n))\n",
        "output": "2\n",
        "fn_call": "minDelete"
    },
    {
        "text": "super | function to check if n is a super - d number ; ",
        "context": "",
        "code": "def isSuperdNum(n):\n    for d in range(2, 10):\n        substring = str(d) * d\n        if substring in str(d * pow(n, d)):\n            return True\n    return False\n",
        "test": "\nn = 261\nif isSuperdNum(n):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isSuperdNum"
    },
    {
        "text": "find ' n ' number of solutions with the ",
        "context": "",
        "code": "def findsolution(n, x, y):\n    if ((y - n + 1) * (y - n + 1) + n - 1 < x or y < n):\n        print(\"No solution\")\n        return\n    print(y - n + 1)\n    while (n > 1):\n        print(1)\n        n -= 1\n",
        "test": "\nn = 5\nx = 15\ny = 15\nfindsolution(n, x, y)\n",
        "output": "11\n1\n1\n1\n1\n",
        "fn_call": "findsolution"
    },
    {
        "text": "print last k digits of a ^ b ( a raised to power b ) | iterative function to calculate ( x ^ y ) % p in o ( log y ) ; initialize result ; x = x % p update x if it is more than or equal to p ; if y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; function to calculate number of digits in x ; function to print last k digits of a ^ b ; generating 10 ^ k ; calling modular exponentiation ; printing leftmost zeros . since ( a ^ b ) % k can have digits less then k . in that case we need to print zeros ; if temp is not zero then print temp if temp is zero then already printed ; ",
        "context": "",
        "code": "def power(x, y, p):\n\n    res = 1\n\n    x = x % p\n\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\n\n\ndef numberOfDigits(x):\n\n    i = 0\n    while (x):\n        x //= 10\n        i += 1\n\n    return i\n\n\ndef printLastKDigits(a, b, k):\n\n    print(\"Last \" + str(k)+\" digits of \" +\n          str(a) + \"^\" + str(b), end=\" = \")\n    temp = 1\n    for i in range(1, k + 1):\n        temp *= 10\n    temp = power(a, b, temp)\n    for i in range(k - numberOfDigits(temp)):\n        print(\"0\")\n    if (temp):\n        print(temp)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 11\n    b = 3\n    k = 2\n    printLastKDigits(a, b, k)\n",
        "output": "Last 2 digits of 11^3 = 31\n",
        "fn_call": "printLastKDigits"
    },
    {
        "text": "largest triangle that can be inscribed in a semicircle | function to find the area of the triangle ; the radius cannot be negative ; area of the triangle ; ",
        "context": "",
        "code": "def trianglearea(r):\n    if r < 0:\n        return -1\n    return r * r\n",
        "test": "\nif __name__ == \"__main__\":\n    r = 5\n    print(trianglearea(r))\n",
        "output": "25\n",
        "fn_call": "trianglearea"
    },
    {
        "text": "count of paths in ",
        "context": "",
        "code": "def compute(query):\n    v = [None] * 100001\n    dp = [None] * 100001\n    v[1] = 1\n    v[2] = 0\n    dp[1] = 0\n    dp[2] = 0\n    for i in range(3, 100001):\n        if (i % 2 != 0):\n            if ((i // 2) % 2 == 0):\n                v[i] = 1\n                dp[i] = dp[i - 1]\n            else:\n                v[i] = v[i // 2] + 1\n                dp[i] = dp[i - 1] + v[i] - 1\n        else:\n            v[i] = 0\n            dp[i] = dp[i - 1]\n    for x in query:\n        print(dp[x])\n",
        "test": "\nquery = [5, 2]\ncompute(query)\n",
        "output": "1\n0\n",
        "fn_call": "compute"
    },
    {
        "text": "solve the linear equation of single variable | def to solve the given equation ; traverse the equation ; for cases such as : x , - x , + x ; flip sign once ' = ' is seen ; there may be a number left in the end ; for infinite solutions ; for no solution ; x = total sum / coeff of x ' - ' sign indicates moving numeric value to right hand side ; ",
        "context": "",
        "code": "def solveEquation(equation):\n    n = len(equation)\n    sign = 1\n    coeff = 0\n    total = 0\n    i = 0\n    for j in range(0, n):\n        if (equation[j] == '+' or equation[j] == '-'):\n            if (j > i):\n                total = (total + sign * int(equation[i:j]))\n            i = j\n        elif (equation[j] == 'x'):\n            if ((i == j) or equation[j - 1] == '+'):\n                coeff += sign\n            elif (equation[j - 1] == '-'):\n                coeff = coeff - sign\n            else:\n                coeff = (coeff + sign * int(equation[i:j]))\n            i = j + 1\n        elif (equation[j] == '='):\n            if (j > i):\n                total = (total + sign * int(equation[i:j]))\n            sign = -1\n            i = j + 1\n    if (i < n):\n        total = (total + sign * int(equation[i:len(equation)]))\n    if (coeff == 0 and total == 0):\n        return \"Infinite solutions\"\n    if (coeff == 0 and total):\n        return \"No solution\"\n    ans = -total / coeff\n    return int(ans)\n",
        "test": "\nequation = \"x+5-3+x=6+x-2\"\nprint(\"x = {}\".format(solveEquation(equation)))\n",
        "output": "x = 2\n",
        "fn_call": "solveEquation"
    },
    {
        "text": "Hypercube Graph | function to find power of 2 ; Dricer code",
        "context": "",
        "code": "def power(n):\n    if n == 1:\n        return 2\n    return 2 * power(n - 1)\n",
        "test": "\nn = 4\nprint(power(n))\n",
        "output": "16\n",
        "fn_call": "power"
    },
    {
        "text": "find kth smallest number in range [ 1 , n ] when all the odd numbers are deleted | function to return the kth smallest element from the range [ 1 , n ] after removing all the odd elements ; ",
        "context": "",
        "code": "def kthSmallest(n, k):\n    return 2 * k\n",
        "test": "\nn = 8\nk = 4\nprint(kthSmallest(n, k))\n",
        "output": "8\n",
        "fn_call": "kthSmallest"
    },
    {
        "text": "find nth term of the series 1 , 5 , 32 , 288 ... | function to generate a fixed number ; finding nth term ; ",
        "context": "",
        "code": "def nthTerm(N):\n    nth = 0\n    for i in range(N, 0, -1):\n        nth += pow(i, i)\n    return nth\n",
        "test": "\nN = 3\nprint(nthTerm(N))\n",
        "output": "32\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "given count of digits 1 , 2 , 3 , 4 , find the maximum sum possible | function to find the maximum possible sum ; to store required sum ; number of 234 's can be formed ; sum obtained with 234 s ; remaining 2 's ; sum obtained with 12 s ; return the required sum ; ",
        "context": "",
        "code": "def Maxsum(c1, c2, c3, c4):\n    sum = 0\n    two34 = min(c2, min(c3, c4))\n    sum = two34 * 234\n    c2 -= two34\n    sum += min(c2, c1) * 12\n    return sum\n",
        "test": "\nc1 = 5\nc2 = 2\nc3 = 3\nc4 = 4\nprint(Maxsum(c1, c2, c3, c4))\n",
        "output": "468\n",
        "fn_call": "Maxsum"
    },
    {
        "text": "minimum flips of odd indexed elements from odd length subarrays to make two given arrays equal | function to find the minimum flip of subarrays required at alternate index to make binary arrays equals ; stores count of total operations ; stores count of consecutive unequal elements ; loop to run on odd positions ; incrementing the global counter ; change count to 0 ; if all last elements are equal ; loop to run on even positions ; incrementing the global counter ; change count to 0 ; print minimum operations ; ",
        "context": "",
        "code": "def minOperation(X, Y, n):\n    C = 0\n    count = 0\n    for i in range(1, n, 2):\n        if (X[i] != Y[i]):\n            count += 1\n        else:\n            if (count != 0):\n                C += 1\n            count = 0\n    if (count != 0):\n        C += 1\n    count = 0\n    for i in range(0, n, 2):\n        if (X[i] != Y[i]):\n            count += 1\n        else:\n            if (count != 0):\n                C += 1\n            count = 0\n    if (count != 0):\n        C += 1\n    print(C)\n",
        "test": "\nif __name__ == '__main__':\n    X = [1, 0, 0, 0, 0, 1]\n    Y = [1, 1, 0, 1, 1, 1]\n    N = len(X)\n    minOperation(X, Y, N)\n",
        "output": "2\n",
        "fn_call": "minOperation"
    },
    {
        "text": "maximum number of perfect numbers present in a subarray of size k | function to check a number is perfect number or not ; stores sum of divisors ; find all divisors and add them ; if sum of divisors is equal to n ; function to return maximum sum of a subarray of size k ; if k is greater than n ; compute sum of first window of size k ; compute sums of remaining windows by removing first element of previous window and adding last element of current window ; return the answer ; function to find all the perfect numbers in the array ; the given array is converted into binary array ; ",
        "context": "",
        "code": "def isPerfect(N):\n    sum = 1\n    for i in range(2, N):\n        if i * i > N:\n            break\n        if (N % i == 0):\n            if (i == N // i):\n                sum += i\n            else:\n                sum += i + N // i\n    if (sum == N and N != 1):\n        return 1\n    return 0\n\n\ndef maxSum(arr, N, K):\n    if (N < K):\n        print(\"Invalid\")\n        return -1\n    res = 0\n    for i in range(K):\n        res += arr[i]\n    curr_sum = res\n    for i in range(K, N):\n        curr_sum += arr[i] - arr[i - K]\n        res = max(res, curr_sum)\n    return res\n\n\ndef max_PerfectNumbers(arr, N, K):\n    for i in range(N):\n        if isPerfect(arr[i]):\n            arr[i] = 1\n        else:\n            arr[i] = 0\n    return maxSum(arr, N, K)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [28, 2, 3, 6, 496, 99, 8128, 24]\n    K = 4\n    N = len(arr)\n    print(max_PerfectNumbers(arr, N, K))\n",
        "output": "3\n",
        "fn_call": "max_PerfectNumbers"
    },
    {
        "text": "maximum count of equal numbers in an array after performing given operations | function to find the maximum number of equal numbers in an array ; to store sum of elements ; if sum of numbers is not divisible by n ; ",
        "context": "",
        "code": "def EqualNumbers(a, n):\n    sum = 0\n    for i in range(n):\n        sum += a[i]\n    if (sum % n):\n        return n - 1\n    return n\n",
        "test": "\na = [1, 4, 1]\nn = len(a)\nprint(EqualNumbers(a, n))\n",
        "output": "3\n",
        "fn_call": "EqualNumbers"
    },
    {
        "text": "latin alphabet cipher | function for calculating the encryption ; ",
        "context": "",
        "code": "def cipher(str):\n    for i in range(len(str)):\n        if str[i].isalpha() == 0 and str[i] != \" \":\n            print(\"Enter only alphabets and space\")\n            return\n    print(\"Encrypted Code using Latin Alphabet\")\n    for i in range(len(str)):\n        if str[i] >= \"A\" and str[i] <= \"Z\":\n            print(ord(str[i]) - ord(\"A\") + 1, end=\" \")\n        elif str[i] >= \"a\" and str[i] <= 'z':\n            print(ord(str[i]) - ord(\"a\") + 1, end=\" \")\n        if str[i] == \" \":\n            print(str[i])\n    print()\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"geeksforgeeks\"\n    cipher(str)\n",
        "output": "Encrypted Code using Latin Alphabet\n7 5 5 11 19 6 15 18 7 5 5 11 19 \n",
        "fn_call": "cipher"
    },
    {
        "text": "check if a large number is divisible by 6 or not | function to find that number is divisible by 6 or not ; return false if number is not divisible by 2. ; compute sum of digits ; check if sum of digits is divisible by 3 ; ",
        "context": "",
        "code": "def check(st):\n    n = len(st)\n    if (((int)(st[n - 1]) % 2) != 0):\n        return False\n    digitSum = 0\n    for i in range(0, n):\n        digitSum = digitSum + (int)(st[i])\n    return (digitSum % 3 == 0)\n",
        "test": "\nst = \"1332\"\nif (check(st)):\n    print(\"Yes\")\nelse:\n    print(\"No \")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "minimum number of days to debug all programs | python 3 program for the above approach ; function to calculate the minimum work sessions ; break condition ; all bits are set ; check if already calculated ; store the answer ; check if ith bit is set or unset ; including in current work session ; including in next work session ; resultant answer will be minimum of both ; function to initialize dp array and solve the problem ; initialize dp table with - 1 ; resultant mask ; no . of minimum work sessions is even ; no . of minimum work sessions is odd ; ",
        "context": "\nimport sys\n\n",
        "code": "def minSessions(codeTime, dp, ones, n, mask, currTime, WorkingSessionTime):\n    if (currTime > WorkingSessionTime):\n        return sys .maxsize\n    if (mask == ones):\n        return 1\n    if (dp[mask][currTime] != -1):\n        return dp[mask][currTime]\n    ans = sys .maxsize\n    for i in range(n):\n        if ((mask & (1 << i)) == 0):\n            inc = minSessions(\n                codeTime,\n                dp,\n                ones,\n                n,\n                mask | (\n                    1 << i),\n                currTime +\n                codeTime[i],\n                WorkingSessionTime)\n            inc_next = 1 + minSessions(codeTime,\n                                       dp,\n                                       ones,\n                                       n,\n                                       mask | (1 << i),\n                                       codeTime[i],\n                                       WorkingSessionTime)\n            ans = min([ans, inc, inc_next])\n    dp[mask][currTime] = ans\n    return ans\n\n\ndef solve(codeTime, n, WorkingSessionTime):\n    dp = [[-1 for i in range(15)]for j in range(1 << 14)]\n    ones = (1 << n) - 1\n    ans = minSessions(codeTime, dp, ones, n, 0, 0, WorkingSessionTime)\n    if (WorkingSessionTime < 6):\n        if (ans % 2 == 0):\n            ans = ans // 2\n        else:\n            ans = (ans / 2) + 1\n    return int(ans)\n",
        "test": "\nif __name__ == '__main__':\n    codeTime = [1, 2, 3, 1, 1, 3]\n    n = len(codeTime)\n    WorkingSessionTime = 4\n    print(solve(codeTime, n, WorkingSessionTime))\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "count n | python3 program for the above approach ; function for calculate ( x ^ y ) % mod in o ( log y ) ; base condition ; transition state of power function ; function for counting total numbers that can be formed such that digits x , y are present in each number ; calculate the given expression ; return the final answer ; ",
        "context": "\nmod = 1e9 + 7\n\n",
        "code": "def power(x, y):\n    if (y == 0):\n        return 1\n    p = power(x, y // 2) % mod\n    p = (p * p) % mod\n    if (y & 1):\n        p = (x * p) % mod\n    return p\n\n\ndef TotalNumber(N):\n    ans = (power(10, N) - 2 * power(9, N) + power(8, N) + 2 * mod) % mod\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    X = 3\n    Y = 4\n    print(TotalNumber(N))\n",
        "output": "100172994.0\n",
        "fn_call": "TotalNumber"
    },
    {
        "text": "minimize cost to empty a given string by removing characters alphabetically | function to find the minimum cost required to remove each character of the string in alphabetical order ; stores the frequency of characters of the string ; iterate through the string ; count the number of characters smaller than the present character ; if no smaller character precedes current character ; increase the frequency of the current character ; return the total cost ; ",
        "context": "",
        "code": "def minSteps(str, N):\n    cost = 0\n    f = [0] * 26\n    for i in range(N):\n        curr_ele = ord(str[i]) - ord('a')\n        smaller = 0\n        for j in range(curr_ele + 1):\n            if (f[j]):\n                smaller += f[j]\n        if (smaller == 0):\n            cost += (i + 1)\n        else:\n            cost += (i - smaller + 1)\n        f[ord(str[i]) - ord('a')] += 1\n    return cost\n",
        "test": "\nstr = \"abcab\"\nN = len(str)\nprint(minSteps(str, N))\n",
        "output": "8\n",
        "fn_call": "minSteps"
    },
    {
        "text": "count characters with same neighbors | function to count the characters with same adjacent characters ; if length is less than 3 then return length as there will be only two characters ; traverse the string ; increment the count if the previous and next character is same ; return count ; ",
        "context": "",
        "code": "def countChar(str):\n    n = len(str)\n    if (n <= 2):\n        return n\n    count = 2\n    for i in range(1, n - 1):\n        if (str[i - 1] == str[i + 1]):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    str = \"egeeksk\"\n    print(countChar(str))\n",
        "output": "4\n",
        "fn_call": "countChar"
    },
    {
        "text": "maximum number of edges in bipartite graph | function to return the maximum number of edges possible in a bipartite graph with n vertices ; ",
        "context": "",
        "code": "def maxEdges(N):\n    edges = 0\n    edges = (N * N) // 4\n    return edges\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    print(maxEdges(N))\n",
        "output": "6\n",
        "fn_call": "maxEdges"
    },
    {
        "text": "length of the longest increasing subsequence such that no two adjacent elements are coprime | python3 program to find the length of the longest increasing sub sequence from the given array such that no two adjacent elements are co prime ; function to find the length of the longest increasing sub sequence from the given array such that no two adjacent elements are co prime ; to store dp and d value ; to store required answer ; for all elements in the array ; initially answer is one ; for all it 's divisors ; update the dp value ; update the divisor value ; check for required answer ; update divisor of a [ i ] ; return required answer ; ",
        "context": "\nN = 100005\n\n",
        "code": "def LIS(a, n):\n    dp = [0 for i in range(N)]\n    d = [0 for i in range(N)]\n    ans = 0\n    for i in range(n):\n        dp[a[i]] = 1\n        for j in range(2, a[i]):\n            if j * j > a[i]:\n                break\n            if (a[i] % j == 0):\n                dp[a[i]] = max(dp[a[i]], dp[d[j]] + 1)\n                dp[a[i]] = max(dp[a[i]], dp[d[a[i] // j]] + 1)\n                d[j] = a[i]\n                d[a[i] // j] = a[i]\n        ans = max(ans, dp[a[i]])\n        d[a[i]] = a[i]\n    return ans\n",
        "test": "\na = [1, 2, 3, 4, 5, 6]\nn = len(a)\nprint(LIS(a, n))\n",
        "output": "3\n",
        "fn_call": "LIS"
    },
    {
        "text": "maximize frequency sum of k chosen characters from given string | function to find the maximum sum of frequencies of the exactly k chosen characters from the string s ; stores the resultant maximum sum ; stores the frequency of array elements ; find the frequency of character ; sort the frequency array in the descending order ; iterate to choose k elements greedily ; if the freq [ i ] cards are chosen ; k cards have been picked ; return the resultant sum ; ",
        "context": "",
        "code": "def maximumSum(S, N, K):\n    sum = 0\n    freq = [0] * 256\n    for i in range(N):\n        freq[ord(S[i])] += 1\n    freq = sorted(freq)[::-1]\n    for i in range(256):\n        if (K > freq[i]):\n            sum += freq[i] * freq[i]\n            K -= freq[i]\n        else:\n            sum += freq[i] * K\n            break\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    S = \"GEEKSFORGEEKS\"\n    K = 10\n    N = len(S)\n    print(maximumSum(S, N, K))\n",
        "output": "28\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "sum of subsets of all the subsets of an array | o ( 2 ^ n ) | store the answer ; function to sum of all subsets of a given array ; function to generate the subsets ; base - case ; finding the sum of all the subsets of the generated subset ; recursively accepting and rejecting the current number ; ",
        "context": "\nc = []\nans = 0\n\n",
        "code": "def subsetSum():\n    global ans\n    L = len(c)\n    mul = pow(2, L - 1)\n    i = 0\n    while (i < len(c)):\n        ans += c[i] * mul\n        i += 1\n\n\ndef subsetGen(arr, i, n):\n    if (i == n):\n        subsetSum()\n        return\n    subsetGen(arr, i + 1, n)\n    c .append(arr[i])\n    subsetGen(arr, i + 1, n)\n    c .pop()\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 1]\n    n = len(arr)\n    subsetGen(arr, 0, n)\n    print(ans)\n",
        "output": "6\n",
        "fn_call": "subsetGen"
    },
    {
        "text": "maximum sum increasing subsequence | dp | maxsumis ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n ; initialize msis values for all indexes ; compute maximum sum values in bottom up manner ; pick maximum of all msis values ; ",
        "context": "",
        "code": "def maxSumIS(arr, n):\n    max = 0\n    msis = [0 for x in range(n)]\n    for i in range(n):\n        msis[i] = arr[i]\n    for i in range(1, n):\n        for j in range(i):\n            if (arr[i] > arr[j] and msis[i] < msis[j] + arr[i]):\n                msis[i] = msis[j] + arr[i]\n    for i in range(n):\n        if max < msis[i]:\n            max = msis[i]\n    return max\n",
        "test": "\narr = [1, 101, 2, 3, 100, 4, 5]\nn = len(arr)\nprint(\"Sum of maximum sum increasing \" +\n      \"subsequence is \" + str(maxSumIS(arr, n)))\n",
        "output": "Sum of maximum sum increasing subsequence is 106\n",
        "fn_call": "maxSumIS"
    },
    {
        "text": "find the string having each substring with exactly k distinct characters | function to find the required output string ; each element at index i is modulus of k ; ",
        "context": "",
        "code": "def findString(N, K):\n    for i in range(N):\n        print(chr(ord('A') + i % K), end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 10\n    K = 3\n    findString(N, K)\n",
        "output": "ABCABCABCA",
        "fn_call": "findString"
    },
    {
        "text": "smallest triangular number larger than p | python 3 code to find the bucket to choose for picking flowers out of it ; ",
        "context": "\nimport math\n\n",
        "code": "def findBucketNo(p):\n    return math .ceil((math .sqrt(8 * p + 1) - 1) / 2)\n",
        "test": "\np = 10\nprint(findBucketNo(p))\n",
        "output": "4\n",
        "fn_call": "findBucketNo"
    },
    {
        "text": "area of circle which is inscribed in equilateral triangle | python3 program to find the area of circle which is inscribed in equilateral triangle ; function return the area of circle inscribed in equilateral triangle ; ",
        "context": "\nfrom math import pi\n\n",
        "code": "def circle_inscribed(a):\n    return pi * (a * a) / 12\n",
        "test": "\na = 4\nprint(circle_inscribed(a))\n",
        "output": "4.1887902047863905\n",
        "fn_call": "circle_inscribed"
    },
    {
        "text": "determine the count of leaf nodes in an n | function to calculate leaf nodes in n - ary tree ; ",
        "context": "",
        "code": "def calcNodes(N, I):\n    result = 0\n    result = I * (N - 1) + 1\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    I = 2\n    print(\"Leaf nodes = \", calcNodes(N, I))\n",
        "output": "Leaf nodes =  9\n",
        "fn_call": "calcNodes"
    },
    {
        "text": "check if the given two matrices are mirror images of one another | function to check whether the two matrices are mirror of each other ; initialising row and column of second matrix ; iterating over the matrices ; check row of first matrix with reversed row of second matrix ; if the element is not equal ; increment column ; reset column to 0 for new row ; increment row ; ",
        "context": "",
        "code": "def mirrorMatrix(mat1, mat2, N):\n    row = 0\n    col = 0\n    isMirrorImage = True\n    for i in range(N):\n        for j in range(N - 1, -1, -1):\n            if (mat2[row][col] != mat1[i][j]):\n                isMirrorImage = False\n            col += 1\n        col = 0\n        row += 1\n    if (isMirrorImage):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    mat1 = [[1, 2, 3, 4], [0, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    mat2 = [[4, 3, 2, 1], [8, 7, 6, 0], [12, 11, 10, 9], [16, 15, 14, 13]]\n    mirrorMatrix(mat1, mat2, N)\n",
        "output": "Yes\n",
        "fn_call": "mirrorMatrix"
    },
    {
        "text": "dynamic programming on trees | set | python3 code to find the maximum path sum ; function for dfs traversal and to store the maximum value in dp [ ] for every node till the leaves ; initially dp [ u ] is always a [ u ] ; stores the maximum value from nodes ; traverse the tree ; if child is parent , then we continue without recursing further ; call dfs for further traversal ; store the maximum of previous visited node and present visited node ; add the maximum value returned to the parent node ; function that returns the maximum value ; ",
        "context": "\ndp = [0] * 100\n\n",
        "code": "def dfs(a, v, u, parent):\n    dp[u] = a[u - 1]\n    maximum = 0\n    for child in v[u]:\n        if child == parent:\n            continue\n        dfs(a, v, child, u)\n        maximum = max(maximum, dp[child])\n    dp[u] += maximum\n\n\ndef maximumValue(a, v):\n    dfs(a, v, 1, 0)\n    return dp[1]\n\n\ndef main():\n    n = 14\n    v = {}\n    for i in range(n + 1):\n        v[i] = []\n    v[1].append(2), v[2].append(1)\n    v[1].append(3), v[3].append(1)\n    v[1].append(4), v[4].append(1)\n    v[2].append(5), v[5].append(2)\n    v[2].append(6), v[6].append(2)\n    v[3].append(7), v[7].append(3)\n    v[4].append(8), v[8].append(4)\n    v[4].append(9), v[9].append(4)\n    v[4].append(10), v[10].append(4)\n    v[5].append(11), v[11].append(5)\n    v[5].append(12), v[12].append(5)\n    v[7].append(13), v[13].append(7)\n    v[7].append(14), v[14].append(7)\n    a = [3, 2, 1, 10, 1, 3, 9, 1, 5, 3, 4, 5, 9, 8]\n    print(maximumValue(a, v))\n",
        "test": "\nmain()\n",
        "output": "22\n",
        "fn_call": "main"
    },
    {
        "text": "calculate cost of visiting all array elements in increasing order | function to calculate total cost of visiting array elements in increasing order ; stores the pair of element and their positions ; traverse the array arr [ ] ; push the pair { arr [ i ] , i } in v ; sort the vector in ascending order . ; stores the total cost ; stores the index of last element visited ; traverse the vector v ; increment ans ; assign ; return ans ; ",
        "context": "",
        "code": "def calculateDistance(arr, N):\n    v = []\n    for i in range(N):\n        v .append([arr[i], i])\n    v .sort()\n    ans = 0\n    last = 0\n    for j in v:\n        ans += abs(j[1] - last)\n        last = j[1]\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 3, 2, 5, 1]\n    N = len(arr)\n    print(calculateDistance(arr, N))\n",
        "output": "11\n",
        "fn_call": "calculateDistance"
    },
    {
        "text": "minimal operations to make a number magical | function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; ",
        "context": "",
        "code": "def calculate(s):\n    ans = 6\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                for l in range(10):\n                    for m in range(10):\n                        for n in range(10):\n                            if (i + j + k == l + m + n):\n                                c = 0\n                                if (i != ord(s[0]) - ord('0')):\n                                    c += 1\n                                if (j != ord(s[1]) - ord('0')):\n                                    c += 1\n                                if (k != ord(s[2]) - ord('0')):\n                                    c += 1\n                                if (l != ord(s[3]) - ord('0')):\n                                    c += 1\n                                if (m != ord(s[4]) - ord('0')):\n                                    c += 1\n                                if (n != ord(s[5]) - ord('0')):\n                                    c += 1\n                                if (c < ans):\n                                    ans = c\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"123456\"\n    print(calculate(s))\n",
        "output": "2\n",
        "fn_call": "calculate"
    },
    {
        "text": "minimum number of square free divisors | python 3 program to find the minimum number of square free divisors ; initializing max with sqrt ( 10 ^ 6 ) ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; print all prime numbers ; this function returns the minimum number of square free divisors ; precomputing prime factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; if number itself is prime , it will be included as answer and thus minimum required answer is 1 ; ",
        "context": "\nfrom math import sqrt\nMAX = 1005\n\n",
        "code": "def SieveOfEratosthenes(primes):\n    prime = [True for i in range(MAX)]\n    for p in range(2, int(sqrt(MAX)) + 1, 1):\n        if (prime[p]):\n            for i in range(p * 2, MAX, p):\n                prime[i] = False\n    for p in range(2, MAX, 1):\n        if (prime[p]):\n            primes .append(p)\n    return primes\n\n\ndef minimumSquareFreeDivisors(N):\n    prime = []\n    primes = []\n    primes = SieveOfEratosthenes(prime)\n    max_count = 0\n    i = 0\n    while (len(primes) and primes[i] * primes[i] <= N):\n        if (N % primes[i] == 0):\n            tmp = 0\n            while (N % primes[i] == 0):\n                tmp += 1\n                N /= primes[i]\n            max_count = max(max_count, tmp)\n        i += 1\n    if (max_count == 0):\n        max_count = 1\n    return max_count\n",
        "test": "\nif __name__ == '__main__':\n    N = 24\n    print(\n        \"Minimum Number of Square Free Divisors is\",\n        minimumSquareFreeDivisors(N))\n    N = 6\n    print(\n        \"Minimum Number of Square Free Divisors is\",\n        minimumSquareFreeDivisors(N))\n",
        "output": "Minimum Number of Square Free Divisors is 3\nMinimum Number of Square Free Divisors is 1\n",
        "fn_call": "minimumSquareFreeDivisors"
    },
    {
        "text": "print the longest leaf to leaf path in a binary tree | tree node structure used in the program ; function to find height of a tree ; update the answer , because diameter of a tree is nothing but maximum value of ( left_height + right_height + 1 ) for each node ; save the root , this will help us finding the left and the right part of the diameter ; save the height of left & right subtree as well . ; prints the root to leaf path ; print left part of the path in reverse order ; this function finds out all the root to leaf paths ; append this node to the path array ; if it 's a leaf, so print the  path that led to here ; print only one path which is equal to the height of the tree . print ( pathlen , \" - - - \" , maxm ) ; otherwise try both subtrees ; computes the diameter of a binary tree with given root . ; lh will store height of left subtree rh will store height of right subtree ; f is a flag whose value helps in printing left & right part of the diameter only once ; print the left part of the diameter ; print the right part of the diameter ; ",
        "context": "\nclass Node:\n    def __init__(self, x):\n        self .data = x\n        self .left = None\n        self .right = None\n\n",
        "code": "def height(root):\n    global ans, k, lh, rh, f\n    if (root is None):\n        return 0\n    left_height = height(root .left)\n    right_height = height(root .right)\n    if (ans < 1 + left_height + right_height):\n        ans = 1 + left_height + right_height\n        k = root\n        lh = left_height\n        rh = right_height\n    return 1 + max(left_height, right_height)\n\n\ndef printArray(ints, lenn, f):\n    if (f == 0):\n        for i in range(lenn - 1, -1, -1):\n            print(ints[i], end=\" \")\n    elif (f == 1):\n        for i in range(lenn):\n            print(ints[i], end=\" \")\n\n\ndef printPathsRecur(node, path, maxm, pathlen):\n    global f\n    if (node is None):\n        return\n    path[pathlen] = node .data\n    pathlen += 1\n    if (node .left is None and node .right is None):\n        if (pathlen == maxm and (f == 0 or f == 1)):\n            printArray(path, pathlen, f)\n            f = 2\n    else:\n        printPathsRecur(node .left, path, maxm, pathlen)\n        printPathsRecur(node .right, path, maxm, pathlen)\n\n\ndef diameter(root):\n    if (root is None):\n        return\n    global ans, lh, rh\n    global f, k, pathLen\n    height_of_tree = height(root)\n    lPath = [0 for i in range(100)]\n    printPathsRecur(k .left, lPath, lh, 0)\n    print(k .data, end=\" \")\n    rPath = [0 for i in range(100)]\n    f = 1\n    printPathsRecur(k .right, rPath, rh, 0)\n",
        "test": "\nif __name__ == '__main__':\n    k, lh, rh, f, ans, pathLen = None, 0, 0, 0, 0 - 10 ** 19, 0\n    root = Node(1)\n    root .left = Node(2)\n    root .right = Node(3)\n    root .left .left = Node(4)\n    root .left .right = Node(5)\n    root .left .right .left = Node(6)\n    root .left .right .right = Node(7)\n    root .left .left .right = Node(8)\n    root .left .left .right .left = Node(9)\n    diameter(root)\n",
        "output": "9 8 4 2 5 6 ",
        "fn_call": "diameter"
    },
    {
        "text": "sum of matrix in which each element is absolute difference of its row and column numbers | return the sum of matrix in which each element is absolute difference of its corresponding row and column number row ; ",
        "context": "",
        "code": "def findSum(n):\n    sum = 0\n    for i in range(n):\n        sum += i * (n - i)\n    return 2 * sum\n",
        "test": "\nn = 3\nprint(findSum(n))\n",
        "output": "8\n",
        "fn_call": "findSum"
    },
    {
        "text": "composite numbers with digit sum 1 | function that returns true if number n is a composite number ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function that returns true if the eventual digit sum of number nm is 1 ; loop till the sum is not single digit number ; intitialize the sum as zero ; find the sum of digits ; if sum is eventually 1 ; function to print the required numbers from the given range ; if i is one of the required numbers ; ",
        "context": "",
        "code": "def isComposite(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return False\n    if (n % 2 == 0 or n % 3 == 0):\n        return True\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return True\n        i = i + 6\n    return False\n\n\ndef isDigitSumOne(nm):\n    while (nm > 9):\n        sum_digit = 0\n        while (nm != 0):\n            digit = nm % 10\n            sum_digit = sum_digit + digit\n            nm = nm // 10\n        nm = sum_digit\n    if (nm == 1):\n        return True\n    else:\n        return False\n\n\ndef printValidNums(m, n):\n    for i in range(m, n + 1):\n        if (isComposite(i) and isDigitSumOne(i)):\n            print(i, end=\" \")\n",
        "test": "\nl = 10\nr = 100\nprintValidNums(l, r)\n",
        "output": "10 28 46 55 64 82 91 100 ",
        "fn_call": "printValidNums"
    },
    {
        "text": "delannoy number | return the nth delannoy number . ; base cases ; ",
        "context": "",
        "code": "def dealnnoy(n, m):\n    dp = [[0 for x in range(n + 1)]for x in range(m + 1)]\n    for i in range(m):\n        dp[0][i] = 1\n    for i in range(1, m + 1):\n        dp[i][0] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i][j - 1]\n    return dp[m][n]\n",
        "test": "\nn = 3\nm = 4\nprint(dealnnoy(n, m))\n",
        "output": "129\n",
        "fn_call": "dealnnoy"
    },
    {
        "text": "check if a string follows a ^ nb ^ n pattern or not | python3 code to check a ^ nb ^ n pattern ; if length of str is odd return no ; check first half is ' a ' and other half is full of 'b ; ",
        "context": "",
        "code": "def isanbn(str):\n    n = len(str)\n    if n & 1:\n        return \"No\"\n\n    for i in range(int(n / 2)):\n        if str[i] != 'a' or str[n - i - 1] != 'b':\n            return \"No\"\n    return \"Yes\"\n",
        "test": "\ninput_str = \"ab\"\nprint(isanbn(input_str))\n",
        "output": "Yes\n",
        "fn_call": "isanbn"
    },
    {
        "text": "find maximum subset | function to calculate maximum sum possible by taking at most k elements that is divisibly by d ; variable to store final answer ; traverse all subsets ; update ans if necessary conditions are satisfied ; ",
        "context": "",
        "code": "def maximumSum(A, N, K, D):\n    ans = 0\n    for i in range((1 << N)):\n        sum = 0\n        c = 0\n        for j in range(N):\n            if (i >> j & 1):\n                sum += A[j]\n                c += 1\n        if (sum % D == 0 and c <= K):\n            ans = max(ans, sum)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    K = 3\n    D = 7\n    A = [1, 11, 5, 5, 18]\n    print(maximumSum(A, N, K, D))\n",
        "output": "28\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "minimum flips to make all 1 s in right and 0 s in left | function to find the minimum count of flips required to make all 1 s on the right and all 0 s on the left of the given string ; stores length of str ; store count of 0 s in the string ; traverse the string ; if current character is 0 ; update zeros ; if count of 0 s in the string is 0 or n ; store minimum count of flips required to make all 0 s on the left and all 1 s on the right ; stores count of 1 s on the left of each index ; stores count of flips required to make all 0 s on the left and all 1 s on the right ; traverse the string ; if current character is 1 ; update currones ; update flips ; update the minimum count of flips ; ",
        "context": "",
        "code": "def minimumCntOfFlipsRequired(str):\n    n = len(str)\n    zeros = 0\n    for i in range(n):\n        if (str[i] == '0'):\n            zeros += 1\n    if (zeros == 0 or zeros == n):\n        return 0\n    minFlips = 10000001\n    currOnes = 0\n    flips = 0\n    for i in range(n):\n        if (str[i] == '1'):\n            currOnes += 1\n        flips = currOnes + (zeros - (i + 1 - currOnes))\n        minFlips = min(minFlips, flips)\n    return minFlips\n",
        "test": "\nif __name__ == '__main__':\n    str = \"100101\"\n    print(minimumCntOfFlipsRequired(str))\n",
        "output": "2\n",
        "fn_call": "minimumCntOfFlipsRequired"
    },
    {
        "text": "program to find nth term of series 0 , 10 , 30 , 60 , 99 , 150 , 210 , 280. ... ... ... . | calculate nth term of series ; ",
        "context": "",
        "code": "def nthTerm(n):\n    return 5 * pow(n, 2) - 5 * n\n",
        "test": "\nN = 4\nprint(nthTerm(N))\n",
        "output": "60\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "xor two binary strings of unequal lengths | function to insert n 0 s in the beginning of the given string ; function to return the xor of the given strings ; lengths of the given strings ; make both the strings of equal lengths by inserting 0 s in the beginning ; updated length ; to store the resultant xor ; ",
        "context": "",
        "code": "def addZeros(strr, n):\n    for i in range(n):\n        strr = \"0\" + strr\n    return strr\n\n\ndef getXOR(a, b):\n    aLen = len(a)\n    bLen = len(b)\n    if (aLen > bLen):\n        b = addZeros(b, aLen - bLen)\n    elif (bLen > aLen):\n        a = addZeros(a, bLen - aLen)\n    lenn = max(aLen, bLen)\n    res = \"\"\n    for i in range(lenn):\n        if (a[i] == b[i]):\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res\n",
        "test": "\na = \"11001\"\nb = \"111111\"\nprint(getXOR(a, b))\n",
        "output": "100110\n",
        "fn_call": "getXOR"
    },
    {
        "text": "longest subsequence having maximum sum | function to find the longest subsequence from the given array with maximum sum ; stores the largest element of the array ; if max is less than 0 ; print the largest element of the array ; traverse the array ; if arr [ i ] is greater than or equal to 0 ; print elements of the subsequence ; ",
        "context": "",
        "code": "def longestSubWithMaxSum(arr, N):\n    Max = max(arr)\n    if (Max < 0):\n        print(Max)\n        return\n    for i in range(N):\n        if (arr[i] >= 0):\n            print(arr[i], end=\" \")\n",
        "test": "\narr = [1, 2, -4, -2, 3, 0]\nN = len(arr)\nlongestSubWithMaxSum(arr, N)\n",
        "output": "1 2 3 0 ",
        "fn_call": "longestSubWithMaxSum"
    },
    {
        "text": "minimize a binary string by repeatedly removing even length substrings of same characters | recursive function to print stack elements from bottom to top without changing their order ; if stack is empty ; pop top element of the stack ; recursively call the function printstack ; print the stack element from the bottom ; push the same element onto the stack to preserve the order ; function to minimize binary string by removing substrings consisting of same character ; declare a stack of characters ; push the first character of the string into the stack ; traverse the string s ; if stack is empty ; push current character into the stack ; check if the current character is same as the top of the stack ; if true , pop the top of the stack ; otherwise , push the current element ; print stack from bottom to top ; ",
        "context": "",
        "code": "def PrintStack(s):\n    if (len(s) == 0):\n        return\n    x = s[-1]\n    s .pop()\n    PrintStack(s)\n    print(x, end=\"\")\n    s .append(x)\n\n\ndef minString(s):\n    Stack = []\n    Stack .append(s[0])\n    for i in range(1, len(s)):\n        if (len(Stack) == 0):\n            Stack .append(s[i])\n        else:\n            if (Stack[-1] == s[i]):\n                Stack .pop()\n            else:\n                Stack .append(s[i])\n    PrintStack(Stack)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"101001\"\n    minString(string)\n",
        "output": "10",
        "fn_call": "minString"
    },
    {
        "text": "find an n | function to find an n - length binary string having maximum sum of elements from all given ranges ; iterate over the range [ 1 , n ] ; if i is odd , then print 0 ; otherwise , print 1 ; ",
        "context": "",
        "code": "def printBinaryString(arr, N):\n    for i in range(1, N + 1):\n        if (i % 2):\n            print(0, end=\"\")\n        else:\n            print(1, end=\"\")\n",
        "test": "\nN = 5\nM = 3\narr = [[1, 3], [2, 4], [2, 5]]\nprintBinaryString(arr, N)\n",
        "output": "01010",
        "fn_call": "printBinaryString"
    },
    {
        "text": "find first non | python3 implementation to find the first non - repeating element of the string using linked list ; function to find the first non - repeating element of the given string using linked list ; ",
        "context": "\nimport collections\n\n",
        "code": "def firstNonRepElement(str):\n    list = collections.deque()\n\n    list.append(str[0])\n\n    for i in range(len(str)):\n        if str[i] in list:\n            list.remove(str[i])\n        else:\n            list.append(str[i])\n\n    print(list[0])\n",
        "test": "\nif __name__ == '__main__':\n\n    str = \"geeksforgeeks\"\n    firstNonRepElement(str)\n",
        "output": "f\n",
        "fn_call": "firstNonRepElement"
    },
    {
        "text": "program to check if n is a icositetragonal number | python3 implementation to check that a number is icositetragonal number or not ; function to check that the number is a icositetragonal number ; condition to check if the number is a icositetragonal number ; ",
        "context": "\nimport math\n\n",
        "code": "def isicositetragonal(N):\n    n = (10 + math .sqrt(44 * N + 100)) / 22\n    return (n - int(n)) == 0\n",
        "test": "\ni = 24\nif (isicositetragonal(i)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isicositetragonal"
    },
    {
        "text": "program to find hcf ( highest common factor ) of 2 numbers | recursive function to return gcd of a and b ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n",
        "test": "\na = 98\nb = 56\nif (gcd(a, b)):\n    print('GCD of', a, 'and', b, 'is', gcd(a, b))\nelse:\n    print('not found')\n",
        "output": "GCD of 98 and 56 is 14\n",
        "fn_call": "gcd"
    },
    {
        "text": "xor of all subarray xors | set 1 | returns xor of all subarray xors ; initialize result by 0 as ( a xor 0 = a ) ; select the starting element ; select the ending element ; do xor of elements in current subarray ; ",
        "context": "",
        "code": "def getTotalXorOfSubarrayXors(arr, N):\n    res = 0\n    for i in range(0, N):\n        for j in range(i, N):\n            for k in range(i, j + 1):\n                res = res ^ arr[k]\n    return res\n",
        "test": "\narr = [3, 5, 2, 4, 6]\nN = len(arr)\nprint(getTotalXorOfSubarrayXors(arr, N))\n",
        "output": "7\n",
        "fn_call": "getTotalXorOfSubarrayXors"
    },
    {
        "text": "determine the position of the third person on regular n sided polygon | function to find out the number of that vertices ; another person can 't stand on  vertex on which 2 children stand. ; calculating minimum jumps from each vertex . ; calculate sum of jumps . ; ",
        "context": "",
        "code": "def vertices(N, A, B):\n    position = 0\n    miniSum = 10 ** 9\n    Sum = 0\n    for i in range(1, N + 1):\n        if (i == A or i == B):\n            continue\n        else:\n            x = abs(i - A)\n            y = abs(i - B)\n            Sum = x + y\n            if (Sum < miniSum):\n                miniSum = Sum\n                position = i\n    return position\n",
        "test": "\nN = 3\nA = 1\nB = 2\nprint(\"Vertex = \", vertices(N, A, B))\n",
        "output": "Vertex =  3\n",
        "fn_call": "vertices"
    },
    {
        "text": "check if n contains all digits as k in base b | python3 program for the above approach ; function to print the number of digits ; calculate log using base change property and then take its floor and then add 1 ; return the output ; function that returns true if n contains all one 's in base b ; calculate the sum ; given number n ; given base b ; ",
        "context": "\nimport math\n\n",
        "code": "def findNumberOfDigits(n, base):\n    dig = (math .floor(math .log(n) / math .log(base)) + 1)\n    return dig\n\n\ndef isAllKs(n, b, k):\n    len = findNumberOfDigits(n, b)\n    sum = k * (1 - pow(b, len)) / (1 - b)\n    return sum == N\n",
        "test": "\nN = 13\nB = 3\nK = 1\nif (isAllKs(N, B, K)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isAllKs"
    },
    {
        "text": "break the number into three parts | function to count number of ways to make the given number n ; ",
        "context": "",
        "code": "def count_of_ways(n):\n    count = 0\n    count = (n + 1) * (n + 2) // 2\n    return count\n",
        "test": "\nn = 3\nprint(count_of_ways(n))\n",
        "output": "10\n",
        "fn_call": "count_of_ways"
    },
    {
        "text": "lexicographically largest possible by merging two strings by adding one character at a time | recursive function for finding the lexicographically largest string ; if either of the string length is 0 , return the other string ; if s1 is lexicographically larger than s2 ; take first character of s1 and call the function ; take first character of s2 and recursively call function for remaining string ; ",
        "context": "",
        "code": "def largestMerge(s1, s2):\n    if len(s1) == 0 or len(s2) == 0:\n        return s1 + s2\n    if (s1 > s2):\n        return s1[0] + largestMerge(s1[1:], s2)\n    return s2[0] + largestMerge(s1, s2[1:])\n",
        "test": "\nif __name__ == '__main__':\n    s1 = \"geeks\"\n    s2 = \"forgeeks\"\n    print(largestMerge(s1, s2))\n",
        "output": "gforgeekseeks\n",
        "fn_call": "largestMerge"
    },
    {
        "text": "program to find lcm of two fibonnaci numbers | python 3 program to find lcm of fib ( a ) and fib ( b ) ; create an array for memoization ; function to return the n 'th fibonacci number using table f[]. ; base cases ; if fib ( n ) is already computed ; applying recursive formula note value n & 1 is 1 if n is odd , else 0. ; function to return gcd of a and b ; function to return the lcm of fib ( a ) and fib ( a ) ; ",
        "context": "\nMAX = 1000\nf = [0] * MAX\n\n",
        "code": "def fib(n):\n    if (n == 0):\n        return 0\n    if (n == 1 or n == 2):\n        f[n] = 1\n        return f[n]\n    if (f[n]):\n        return f[n]\n    k = (n + 1) // 2 if (n & 1)else n // 2\n    if (n & 1):\n        f[n] = (fib(k) * fib(k) + fib(k - 1) * fib(k - 1))\n    else:\n        f[n] = (2 * fib(k - 1) + fib(k)) * fib(k)\n    return f[n]\n\n\ndef gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef findLCMFibonacci(a, b):\n    return (fib(a) * fib(b)) // fib(gcd(a, b))\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 3\n    b = 12\n    print(findLCMFibonacci(a, b))\n",
        "output": "144\n",
        "fn_call": "findLCMFibonacci"
    },
    {
        "text": "count sexy prime pairs in the given array | a utility function that find the prime numbers till n ; resize the prime number ; loop till sqrt ( n ) to find prime numbers and make their multiple false in the bool array prime ; function that returns the count of spp ( sexy prime pair ) pairs ; find the maximum element in the given array arr [ ] ; function to calculate the prime numbers till n ; to store the count of pairs ; to store the frequency of element in the array arr [ ] ; sort before traversing the array ; traverse the array and find the pairs with spp ( sexy prime pair ) s ; if current element is prime , then check for ( current element + 6 ) ; return the count of pairs ; ",
        "context": "",
        "code": "def computePrime(N):\n    Prime = [True] * (N + 1)\n    Prime[0] = False\n    Prime[1] = False\n    i = 2\n    while i * i <= N:\n        if (Prime[i]):\n            for j in range(i * i, N, i):\n                Prime[j] = False\n        i += 1\n    return Prime\n\n\ndef countSexyPairs(arr, n):\n    maxE = max(arr)\n    Prime = computePrime(maxE)\n    count = 0\n    freq = [0] * (maxE + 6)\n    for i in range(n):\n        freq[arr[i]] += 1\n    arr .sort()\n    for i in range(n):\n        if (Prime[arr[i]]):\n            if ((arr[i] + 6) <= (maxE) and freq[arr[i] + 6]\n                    > 0 and Prime[arr[i] + 6]):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 7, 5, 11, 13]\n    n = len(arr)\n    print(countSexyPairs(arr, n))\n",
        "output": "2\n",
        "fn_call": "countSexyPairs"
    },
    {
        "text": "find an anagram of given string having different characters at corresponding indices | function to find anagram of string such that characters at the same indices are different ; copying our original string for comparison ; declaring the two pointers ; checking the given condition ; when string length is odd ; the mid element ; if the characters are the same , then perform the swap operation as illustrated ; check if the corresponding indices has the same character or not ; if string follows required condition ; ",
        "context": "",
        "code": "def findAnagram(s):\n    check = s\n    st = list(s)\n    i = 0\n    j = len(st) - 1\n    while (i = 0):\n        if (st[i] != st[j] and check[i] != st[j] and check[j] != st[i]):\n            st[i], st[j] = st[j], st[i]\n            i += 1\n            j = len(st) - 1\n        else:\n            j -= 1\n    if (len(st) % 2 != 0):\n        mid = len(st) / 2\n        if (check[mid] == st[mid]):\n            for i in range(len(st)):\n                if (check[i] != st[mid] and st[i] != st[mid]):\n                    st[i], st[mid] = st[mid], st[i]\n                    break\n    ok = True\n    for i in range(len(st)):\n        if (check[i] == st[i]):\n            ok = False\n            break\n    if (ok):\n        print(\"\".join(st))\n    else:\n        print(-1)\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"geek\"\n    findAnagram(S)\n",
        "output": "egke\n",
        "fn_call": "findAnagram"
    },
    {
        "text": "program to find the nth term of the series 0 , 14 , 40 , 78 , 124 , ... | calculate sum upto nth term of series ; return the final sum ; ",
        "context": "",
        "code": "def nthTerm(n):\n    return int(6 * pow(n, 2) - 4 * n - 2)\n",
        "test": "\nN = 4\nprint(nthTerm(N))\n",
        "output": "78\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "convert given float value to equivalent fraction | python3 program for the above approach ; function to convert the floating values into fraction ; initialize variables ; traverse the floating string ; check if decimal part exist ; check if recurrence sequence exist ; retrieve decimal part and recurrence resquence ; traverse the string ; convert to integer ; if no recurrence sequence exist ; initialize numerator & denominator ; no reccuring term ; print the result ; if reccuring term exist ; convert reccuring term to integer ; reccu . size ( ) is num of digit in reccur term ; eq 2 - eq 1 ; print the result ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def findFraction(s):\n    be_deci = \"\"\n    af_deci = \"\"\n    reccu = \"\"\n    x = True\n    y = False\n    z = False\n    for i in range(len(s)):\n        if (s[i] == '.'):\n            x = False\n            y = True\n            continue\n        if (s[i] == '('):\n            z = True\n            y = False\n            continue\n        if (x):\n            be_deci += s[i]\n        if (y):\n            af_deci += s[i]\n        if (z):\n            while i < len(s) and s[i] != ')':\n                reccu += s[i]\n                i += 1\n            break\n    num_be_deci = int(be_deci)\n    num_af_deci = 0\n    if len(af_deci) != 0:\n        num_af_deci = int(af_deci)\n    numr = (num_be_deci * pow(10, len(af_deci)) + num_af_deci)\n    deno = pow(10, len(af_deci))\n    if len(reccu) == 0:\n        gd = gcd(numr, deno)\n        print(numr // gd, \"/\", deno // gd)\n    else:\n        reccu_num = int(reccu)\n        numr1 = (numr * pow(10, len(reccu)) + reccu_num)\n        deno1 = deno * pow(10, len(reccu))\n        res_numr = numr1 - numr\n        res_deno = deno1 - deno\n        gd = gcd(res_numr, res_deno)\n        print(res_numr // gd, \" / \", res_deno // gd)\n",
        "test": "\nif __name__ == '__main__':\n    str = \"23.98(231)\"\n    findFraction(str)\n",
        "output": "798611  /  33300\n",
        "fn_call": "findFraction"
    },
    {
        "text": "maximum value of | arr [ i ] | return maximum value of | arr [ i ] - arr [ j ] | + | i - j | ; iterating two for loop , one for i and another for j . ; evaluating | arr [ i ] - arr [ j ] | + | i - j | and compare with previous maximum . ; ",
        "context": "",
        "code": "def findValue(arr, n):\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            ans = ans if ans > (\n                abs(arr[i] - arr[j]) + abs(i - j))else (abs(arr[i] - arr[j]) + abs(i - j))\n    return ans\n",
        "test": "\narr = [1, 2, 3, 1]\nn = len(arr)\nprint(findValue(arr, n))\n",
        "output": "4\n",
        "fn_call": "findValue"
    },
    {
        "text": "quickly find multiple left rotations of an array | set 1 | function to left rotate an array k times ; print array after k rotations ; ",
        "context": "",
        "code": "def leftRotate(arr, n, k):\n    for i in range(k, k + n):\n        print(str(arr[i % n]), end=\" \")\n",
        "test": "\narr = [1, 3, 5, 7, 9]\nn = len(arr)\nk = 2\nleftRotate(arr, n, k)\nprint()\nk = 3\nleftRotate(arr, n, k)\nprint()\nk = 4\nleftRotate(arr, n, k)\nprint()\n",
        "output": "5 7 9 1 3 \n7 9 1 3 5 \n9 1 3 5 7 \n",
        "fn_call": "leftRotate"
    },
    {
        "text": "find if it is possible to make a binary string which contanins given number of \"0\" , \"1\" , \"01\" and \"10\" as sub sequences | function that returns true if it is possible to make a binary string consisting of l 0 ' s , \u2581 m \u2581 1' s , x \"01\" sub - sequences and y \"10\" sub - sequences ; ",
        "context": "",
        "code": "def isPossible(l, m, x, y):\n    if (l * m == x + y):\n        return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    l = 3\n    m = 2\n    x = 4\n    y = 2\n    if (isPossible(l, m, x, y)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "pair with min absolute difference and whose product is n + 1 or n + 2 | python3 program for the above approach ; function to prpair ( a , b ) such that a * b = n + 1 or n + 2 ; loop to iterate over the desired possible values ; check for condition 1 ; check for condition 2 ; ",
        "context": "\nfrom math import sqrt, ceil, floor\n\n",
        "code": "def closestDivisors(n):\n    for i in range(ceil(sqrt(n + 2)), -1, -1):\n        if ((n + 1) % i == 0):\n            print(i, \",\", (n + 1) // i)\n            break\n        if ((n + 2) % i == 0):\n            print(i, \",\", (n + 2) // i)\n            break\n",
        "test": "\nif __name__ == '__main__':\n    N = 123\n    closestDivisors(N)\n",
        "output": "5 , 25\n",
        "fn_call": "closestDivisors"
    },
    {
        "text": "program to get the sum of series : 1 | function to get the series ; computing sum of remaining n - 1 terms . ; ",
        "context": "",
        "code": "def Series(x, n):\n    sum = 1\n    term = 1\n    fct = 1\n    p = 1\n    multi = 1\n    for i in range(1, n):\n        fct = fct * multi * (multi + 1)\n        p = p * x * x\n        term = (-1) * term\n        multi += 2\n        sum = sum + (term * p) / fct\n    return sum\n",
        "test": "\nx = 9\nn = 10\nprint('%.4f' % Series(x, n))\n",
        "output": "-5.1463\n",
        "fn_call": "Series"
    },
    {
        "text": "generate array whose difference of each element with its left yields the given array | function to find the sequence ; initializing 1 st element ; creating sequence in terms of x ; finding min element ; finding value of x ; creating original sequence ; output original sequence ; ",
        "context": "",
        "code": "def find_seq(arr, m, n):\n    b = []\n    x = 0\n    b .append(x)\n    for i in range(n - 1):\n        b .append(x + arr[i] + b[i])\n    mn = n\n    for i in range(n):\n        mn = min(mn, b[i])\n    x = 1 - mn\n    for i in range(n):\n        b[i] += x\n    for i in range(n):\n        print(b[i], end=' ')\n    print()\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    arr = [-2, 1]\n    M = len(arr)\n    find_seq(arr, M, N)\n",
        "output": "3 1 2 \n",
        "fn_call": "find_seq"
    },
    {
        "text": "maximum subarray sum in o ( n ) using prefix sum | python3 program to find out maximum subarray sum in linear time using prefix sum . ; function to compute maximum subarray sum in linear time . ; initialize minimum prefix sum to 0. ; initialize maximum subarray sum so far to - infinity . ; initialize and compute the prefix sum array . ; loop through the array keep track of minimum prefix sum so far and maximum subarray sum . ; test case 1 ; ",
        "context": "\nimport math\n\n",
        "code": "def maximumSumSubarray(arr, n):\n    min_prefix_sum = 0\n    res = -math .inf\n    prefix_sum = []\n    prefix_sum .append(arr[0])\n    for i in range(1, n):\n        prefix_sum .append(prefix_sum[i - 1] + arr[i])\n    for i in range(n):\n        res = max(res, prefix_sum[i] - min_prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum[i])\n    return res\n",
        "test": "\narr1 = [-2, -3, 4, -1, -2, 1, 5, -3]\nn1 = len(arr1)\nprint(maximumSumSubarray(arr1, n1))\narr2 = [4, -8, 9, -4, 1, -8, -1, 6]\nn2 = len(arr2)\nprint(maximumSumSubarray(arr2, n2))\n",
        "output": "7\n9\n",
        "fn_call": "maximumSumSubarray"
    },
    {
        "text": "wildcard pattern matching | function that matches input strr with given wildcard pattern ; empty pattern can only match with empty string ; lookup table for storing results of subproblems ; empty pattern can match with empty string ; only ' * ' can match with empty string ; fill the table in bottom - up fashion ; two cases if we see a ' * ' a ) we ignore a * atm character and move to next character in the pattern , i . e . , a * atm indicates an empty sequence . b ) ' * ' character matches with ith character in input ; current characters are considered as matching in two cases ( a ) current character of pattern is ' ? ' ( b ) characters actually match ; if characters don 't match ; ",
        "context": "",
        "code": "def strrmatch(strr, pattern, n, m):\n    if (m == 0):\n        return (n == 0)\n    lookup = [[False for i in range(m + 1)]for j in range(n + 1)]\n    lookup[0][0] = True\n    for j in range(1, m + 1):\n        if (pattern[j - 1] == '*'):\n            lookup[0][j] = lookup[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (pattern[j - 1] == '*'):\n                lookup[i][j] = lookup[i][j - 1] or lookup[i - 1][j]\n            elif (pattern[j - 1] == '?' or strr[i - 1] == pattern[j - 1]):\n                lookup[i][j] = lookup[i - 1][j - 1]\n            else:\n                lookup[i][j] = False\n    return lookup[n][m]\n",
        "test": "\nstrr = \"baaabab\"\npattern = \"*****ba*****ab\"\nif (strrmatch(strr, pattern, len(strr), len(pattern))):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "strrmatch"
    },
    {
        "text": "making elements of two arrays same with minimum increment / decrement | python 3 program to find minimum increment / decrement operations to make array elements same . ; sorting both arrays in ascending order ; variable to store the final result ; after sorting both arrays . now each array is in non - decreasing order . thus , we will now compare each element of the array and do the increment or decrement operation depending upon the value of array b [ ] . ; ",
        "context": "",
        "code": "def MinOperation(a, b, n):\n    a .sort(reverse=False)\n    b .sort(reverse=False)\n    result = 0\n    for i in range(0, n, 1):\n        if (a[i] > b[i]):\n            result = result + abs(a[i] - b[i])\n        elif (a[i] < b[i]):\n            result = result + abs(a[i] - b[i])\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    a = [3, 1, 1]\n    b = [1, 2, 2]\n    n = len(a)\n    print(MinOperation(a, b, n))\n",
        "output": "2\n",
        "fn_call": "MinOperation"
    },
    {
        "text": "permutation of array such that products of all adjacent elements are even | function to print the required permutation ; push odd elements in ' odd ' and even elements in 'even ; check if it possible to arrange the elements ; else print the permutation ; print remaining odds are even . and even elements ; ",
        "context": "",
        "code": "def printPermutation(arr, n):\n    odd, even = [], []\n    for i in range(n):\n        if (arr[i] % 2 == 0):\n            even .append(arr[i])\n        else:\n            odd .append(arr[i])\n    size_odd = len(odd)\n    size_even = len(even)\n    if (size_odd > size_even + 1):\n        print(-1)\n    else:\n        i, j = 0, 0\n        while (i < size_odd and j < size_even):\n            print(odd[i], end=\" \")\n            i += 1\n            print(even[j], end=\" \")\n            j += 1\n    while (i < size_odd):\n        print(odd[i], end=\" \")\n        i += 1\n    while (j < size_even):\n        print(even[j], end=\" \")\n        j += 1\n",
        "test": "\narr = [6, 7, 9, 8, 10, 11]\nN = len(arr)\nprintPermutation(arr, N)\n",
        "output": "7 6 9 8 11 10 ",
        "fn_call": "printPermutation"
    },
    {
        "text": "count numbers whose sum with x is equal to xor with x | function to find total 0 bit in a number ; function to find count of non - negative numbers less than or equal to x , whose bitwise xor and sum with x are equal . ; count number of zero bit in x ; power of 2 to count ; ",
        "context": "",
        "code": "def CountZeroBit(x):\n    count = 0\n    while (x):\n        if ((x & 1) == 0):\n            count += 1\n        x >>= 1\n    return count\n\n\ndef CountXORandSumEqual(x):\n    count = CountZeroBit(x)\n    return (1 << count)\n",
        "test": "\nif __name__ == '__main__':\n    x = 10\n    print(CountXORandSumEqual(x))\n",
        "output": "4\n",
        "fn_call": "CountXORandSumEqual"
    },
    {
        "text": "print all triplets with given sum | prints all triplets in arr [ ] with given sum ; ",
        "context": "",
        "code": "def findTriplets(arr, n, sum):\n    for i in range(0, n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (arr[i] + arr[j] + arr[k] == sum):\n                    print(arr[i], \" \", arr[j], \" \", arr[k], sep=\"\")\n",
        "test": "\narr = [0, -1, 2, -3, 1]\nn = len(arr)\nfindTriplets(arr, n, -2)\n",
        "output": "0 -3 1\n-1 2 -3\n",
        "fn_call": "findTriplets"
    },
    {
        "text": "elements greater than the previous and next element in an array | function to print elements greater than the previous and next element in an array ; traverse array from index 1 to n - 2 and check for the given condition ; ",
        "context": "",
        "code": "def printElements(arr, n):\n    for i in range(1, n - 1, 1):\n        if (arr[i] > arr[i - 1] and arr[i] > arr[i + 1]):\n            print(arr[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 1, 5, 4, 9, 8, 7, 5]\n    n = len(arr)\n    printElements(arr, n)\n",
        "output": "3 5 9 ",
        "fn_call": "printElements"
    },
    {
        "text": "sine rule with derivation , example and implementation | python3 program for the above approach ; function to calculate remaining two sides ; calculate angle b ; convert angles to their respective radians for using trigonometric functions ; sine rule ; print the answer ; ",
        "context": "\nimport math\n\n",
        "code": "def findSides(A, C, c):\n    B = 180 - (A + C)\n    A = A * (3.14159 / 180)\n    C = C * (3.14159 / 180)\n    B = B * (3.14159 / 180)\n    a = (c / math .sin(C)) * math .sin(A)\n    b = (c / math .sin(C)) * math .sin(B)\n    print(\"{0:.2f}\".format(a))\n    print(\"{0:.2f}\".format(b))\n",
        "test": "\nA = 45.0\nC = 35.0\nc = 23\nfindSides(A, C, c)\n",
        "output": "28.35\n39.49\n",
        "fn_call": "findSides"
    },
    {
        "text": "count even paths in binary tree | a tree node ; utility function to count the even path in a given binary tree ; base condition , when node pointer becomes null or node value is odd ; increment count when encounter leaf node with all node value even ; left recursive call , and save the value of count ; right recursive call , and return value of count ; function to count the even paths in a given binary tree ; function call with count = 0 ; ",
        "context": "\nclass Node:\n    def __init__(self, x):\n        self .key = x\n        self .left = None\n        self .right = None\n\n",
        "code": "def evenPaths(node, count):\n    if (node is None or (node .key % 2 != 0)):\n        return count\n    if (not node .left and not node .right):\n        count += 1\n    count = evenPaths(node .left, count)\n    return evenPaths(node .right, count)\n\n\ndef countEvenPaths(node):\n    return evenPaths(node, 0)\n",
        "test": "\nif __name__ == '__main__':\n    root = Node(12)\n    root .left = Node(13)\n    root .right = Node(12)\n    root .right .left = Node(14)\n    root .right .right = Node(16)\n    root .right .left .left = Node(21)\n    root .right .left .right = Node(22)\n    root .right .right .left = Node(22)\n    root .right .right .right = Node(24)\n    root .right .right .right .left = Node(8)\n    print(countEvenPaths(root))\n",
        "output": "3\n",
        "fn_call": "countEvenPaths"
    },
    {
        "text": "maximum length palindromic substring such that it starts and ends with given char | function that returns true if str [ i ... j ] is a palindrome ; function to return the length of the longest palindromic sub - string such that it starts and ends with the character ch ; if current character is a valid starting index ; instead of finding the ending index from the beginning , find the index from the end this is because if the current sub - string is a palindrome then there is no need to check the sub - strings of smaller length and we can skip to the next iteration of the outer loop ; if current character is a valid ending index ; if str [ i ... j ] is a palindrome then update the length of the maximum palindrome so far ; ",
        "context": "",
        "code": "def isPalindrome(str, i, j):\n    while (i < j):\n        if (str[i] != str[j]):\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef maxLenPalindrome(str, n, ch):\n    maxLen = 0\n    for i in range(n):\n        if (str[i] == ch):\n            for j in range(n - 1, i + 1, -1):\n                if (str[j] == ch):\n                    if (isPalindrome(str, i, j)):\n                        maxLen = max(maxLen, j - i + 1)\n                        break\n    return maxLen\n",
        "test": "\nstr = \"lapqooqpqpl\"\nn = len(str)\nch = 'p'\nprint(maxLenPalindrome(str, n, ch))\n",
        "output": "6\n",
        "fn_call": "maxLenPalindrome"
    },
    {
        "text": "print the balanced bracket expression using given brackets | function to print balanced bracket expression if it is possible ; if the condition is met ; print brackets of type - 1 ; print brackets of type - 3 ; print brackets of type - 4 ; print brackets of type - 2 ; if the condition is not met ; ",
        "context": "",
        "code": "def printBalancedExpression(a, b, c, d):\n    if ((a == d and a) or (a == 0 and c == 0 and d == 0)):\n        for i in range(1, a + 1):\n            print(\"((\", end=\"\")\n        for i in range(1, c + 1):\n            print(\")(\", end=\"\")\n        for i in range(1, d + 1):\n            print(\"))\", end=\"\")\n        for i in range(1, b + 1):\n            print(\"()\", end=\"\")\n    else:\n        print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    a, b, c, d = 3, 1, 4, 3\n    printBalancedExpression(a, b, c, d)\n",
        "output": "(((((()()()()())))))()",
        "fn_call": "printBalancedExpression"
    },
    {
        "text": "sorting array using stacks | this function return the sorted stack ; pop out the first element ; while temporary stack is not empty and top of stack is smaller than temp ; pop from temporary stack and append it to the input stack ; append temp in tempory of stack ; append array elements to stack ; sort the temporary stack ; put stack elements in arrp [ ] ; ",
        "context": "",
        "code": "def sortStack(input):\n    tmpStack = []\n    while (len(input) > 0):\n        tmp = input[-1]\n        input .pop()\n        while (len(tmpStack) > 0 and tmpStack[-1] < tmp):\n            input .append(tmpStack[-1])\n            tmpStack .pop()\n        tmpStack .append(tmp)\n    return tmpStack\n\n\ndef sortArrayUsingStacks(arr, n):\n    input = []\n    i = 0\n    while (i < n):\n        input .append(arr[i])\n        i = i + 1\n    tmpStack = sortStack(input)\n    i = 0\n    while (i < n):\n        arr[i] = tmpStack[-1]\n        tmpStack .pop()\n        i = i + 1\n    return arr\n",
        "test": "\narr = [10, 5, 15, 45]\nn = len(arr)\narr = sortArrayUsingStacks(arr, n)\ni = 0\nwhile (i < n):\n    print(arr[i], end=\" \")\n    i = i + 1\n",
        "output": "5 10 15 45 ",
        "fn_call": "sortArrayUsingStacks"
    },
    {
        "text": "maximum sum of k | function to count the number of distinct elements present in the array ; insert array elements into set ; return the st size ; function to calculate maximum sum of k - length subarray having same unique elements as arr [ ] ; not possible to find an subarray of length k from an n - sized array , if k > n ; traverse the array ; update the mp ; if i >= k , then decrement arr [ i - k ] element 's one  occurence ; if frequency of any element is 0 then remove the element ; if mp size is same as the count of distinct elements of array arr [ ] then update maximum sum ; function that finds the maximum sum of k - length subarray having same number of distinct elements as the original array ; size of array ; stores count of distinct elements ; print maximum subarray sum ; ",
        "context": "",
        "code": "def distinct(arr, N):\n    st = set()\n    for i in range(N):\n        st .add(arr[i])\n    return len(st)\n\n\ndef maxSubarraySumUtil(arr, N, K, totalDistinct):\n    if (K > N):\n        return 0\n    mx = 0\n    sum = 0\n    mp = {}\n    for i in range(N):\n        if (arr[i] in mp):\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n        sum += arr[i]\n        if (i >= K):\n            if (arr[i - K] in mp):\n                mp[arr[i - K]] -= 1\n                sum -= arr[i - K]\n            if (arr[i - K] in mp and mp[arr[i - K]] == 0):\n                mp .remove(arr[i - K])\n        if (len(mp) == totalDistinct):\n            mx = max(mx, sum)\n    return mx\n\n\ndef maxSubarraySum(arr, K):\n    N = len(arr)\n    totalDistinct = distinct(arr, N)\n    print(maxSubarraySumUtil(arr, N, K, totalDistinct))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [7, 7, 2, 4, 2, 7, 4, 6, 6, 6]\n    K = 6\n    maxSubarraySum(arr, K)\n",
        "output": "31\n",
        "fn_call": "maxSubarraySum"
    },
    {
        "text": "triangular matchstick number | python program to find x - th triangular matchstick number ; ",
        "context": "",
        "code": "def numberOfSticks(x):\n    return (3 * x * (x + 1)) / 2\n",
        "test": "\nprint(int(numberOfSticks(7)))\n",
        "output": "84\n",
        "fn_call": "numberOfSticks"
    },
    {
        "text": "split given isosceles triangle of height h into n equal parts | function to divide the isosceles triangle in equal parts by making n - 1 cuts parallel to the base ; iterate over the range [ 1 , n - 1 ] ; ",
        "context": "",
        "code": "def findPoint(n, h):\n    for i in range(1, n):\n        print(\"{0:.2f}\".format(((i / n)**0.5) * h), end=' ')\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    h = 2\n    findPoint(n, h)\n",
        "output": "1.15 1.63 ",
        "fn_call": "findPoint"
    },
    {
        "text": "check if a larger number divisible by 36 | function to check whether a number is divisible by 36 or not ; null number cannot be divisible by 36 ; single digit number other than 0 is not divisible by 36 ; number formed by the last 2 digits ; if number is not divisible by 4 ; number is divisible by 4 calculate sum of digits ; sum of digits is not divisible by 9 ; number is divisible by 4 and 9 hence , number is divisible by 36 ; ",
        "context": "",
        "code": "def divisibleBy36(num):\n    l = len(num)\n    if (l == 0):\n        return (\"No\")\n    if (l == 1 and num[0] != '0'):\n        return (\"No\")\n    two_digit_num = (((int)(num[l - 2])) * 10 + (int)(num[l - 1]))\n    if (two_digit_num % 4 != 0):\n        return \"No\"\n    sm = 0\n    for i in range(0, l):\n        sm = sm + (int)(num[i])\n    if (sm % 9 != 0):\n        return (\"No\")\n    return (\"Yes\")\n",
        "test": "\nnum = \"92567812197966231384\"\nprint(divisibleBy36(num))\n",
        "output": "Yes\n",
        "fn_call": "divisibleBy36"
    },
    {
        "text": "count of all possible ways to reach a target by a knight | python3 program to implement above approach ; function to return x ^ y % mod ; base case ; function to return the inverse of factorial of n ; base case ; function to return factorial of n % mod ; base case ; function to return the value of n ! / ( ( n - k ) ! * k ! ) ; function to return the count of ways to reach ( n , m ) from ( 0 , 0 ) ; if ( n + m ) % 3 != 0 ; no possible way exists ; calculate x and y from the equations x + 2 y = n and 2 x + y == m ; ",
        "context": "\nMod = int(1e9 + 7)\n\n",
        "code": "def power(X, Y, Mod):\n    if Y == 0:\n        return 1\n    p = power(X, Y // 2, Mod) % Mod\n    p = (p * p) % Mod\n    if Y & 1:\n        p = (X * p) % Mod\n    return p\n\n\ndef Inversefactorial(N):\n    if N <= 0:\n        return 1\n    fact = 1\n    for i in range(1, N + 1):\n        fact = (fact * i) % Mod\n    return power(fact, Mod - 2, Mod)\n\n\ndef factorial(N):\n    if N <= 0:\n        return 1\n    fact = 1\n    for i in range(1, N + 1):\n        fact = (fact * i) % Mod\n    return fact\n\n\ndef nck(N, K):\n    factN = factorial(N)\n    inv = Inversefactorial(K)\n    invFact = Inversefactorial(N - K)\n    return (((factN * inv) % Mod) * invFact) % Mod\n\n\ndef TotalWays(N, M):\n    if (N + M) % 3 != 0:\n        return 0\n    X = N - (N + M) // 3\n    Y = M - (N + M) // 3\n    if X < 0 or Y < 0:\n        return 0\n    return nck(X + Y, Y)\n",
        "test": "\nN, M = 3, 3\nprint(TotalWays(N, M))\n",
        "output": "2\n",
        "fn_call": "TotalWays"
    },
    {
        "text": "find the k smallest numbers after deleting given elements | python3 program to find the k maximum number from the array after n deletions ; find k maximum element from arr [ 0. . m - 1 ] after deleting elements from del [ 0. . n - 1 ] ; hash map of the numbers to be deleted ; increment the count of del [ i ] ; search if the element is present ; decrement its frequency ; if the frequency becomes 0 , erase it from the map ; else push it ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def findElementsAfterDel(arr, m, dell, n, k):\n    mp = dict()\n    for i in range(n):\n        if dell[i] in mp .keys():\n            mp[dell[i]] += 1\n        else:\n            mp[dell[i]] = 1\n    heap = list()\n    for i in range(m):\n        if (arr[i] in mp .keys()):\n            mp[arr[i]] -= 1\n            if (mp[arr[i]] == 0):\n                mp .pop(arr[i])\n        else:\n            heap .append(arr[i])\n    heap .sort()\n    return heap[:k]\n",
        "test": "\narray = [5, 12, 33, 4, 56, 12, 20]\nm = len(array)\ndell = [12, 56, 5]\nn = len(dell)\nk = 3\nprint(*findElementsAfterDel(array, m, dell, n, k))\n",
        "output": "4 12 20\n",
        "fn_call": "findElementsAfterDel"
    },
    {
        "text": "possible values of q such that , for any value of r , their product is equal to x times their sum | function to find all possible values of q ; vector initialization to store all numbers satisfying the given condition ; iterate for all the values of x ; check if condition satisfied then push the number ; possible value of q ; print all the numbers ; ",
        "context": "",
        "code": "def values_of_Q(X):\n    val_Q = []\n    for i in range(1, X + 1):\n        if ((((X + i) * X)) % i == 0):\n            val_Q .append(X + i)\n    print(len(val_Q))\n    for i in range(len(val_Q)):\n        print(val_Q[i], end=\" \")\n",
        "test": "\nX = 3\nvalues_of_Q(X)\n",
        "output": "2\n4 6 ",
        "fn_call": "values_of_Q"
    },
    {
        "text": "count number of trailing zeros in ( 1 ^ 1 ) * ( 2 ^ 2 ) * ( 3 ^ 3 ) * ( 4 ^ 4 ) * . . | function to return the number of trailing zeros ; to store the number of 2 s and 5 s ; if we get a factor 2 then we have i number of 2 s because the power of the number is raised to i ; if we get a factor 5 then we have i number of 5 s because the power of the number is raised to i ; take the minimum of them ; ",
        "context": "",
        "code": "def trailing_zeros(N):\n    count_of_two = 0\n    count_of_five = 0\n    for i in range(1, N + 1, 1):\n        val = i\n        while (val % 2 == 0 and val > 0):\n            val /= 2\n            count_of_two += i\n        while (val % 5 == 0 and val > 0):\n            val /= 5\n            count_of_five += i\n    ans = min(count_of_two, count_of_five)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 12\n    print(trailing_zeros(N))\n",
        "output": "15\n",
        "fn_call": "trailing_zeros"
    },
    {
        "text": "shortest path from a source cell to a destination cell of a binary matrix through cells consisting only of 1 s | python3 program for the above approach ; stores the coordinates of the matrix cell ; stores coordinates of a cell and its distance ; check if the given cell is valid or not ; stores the moves of the directions of adjacent cells ; function to find the shortest path from the source to destination in the given matrix ; stores the distance for each cell from the source cell ; distance of source cell is 0 ; initialize a visited array ; mark source cell as visited ; create a queue for bfs ; distance of source cell is 0 ; enqueue source cell ; keeps track of whether destination is reached or not ; iterate until queue is not empty ; deque front of the queue ; if the destination cell is reached , then find the path ; assign the distance of destination to the distance matrix ; stores the smallest path ; iterate until source is reached ; append d ; append u ; append r ; append l ; reverse the backtracked path ; explore all adjacent directions ; if the current cell is valid cell and can be traversed ; mark the adjacent cells as visited ; enque the adjacent cells ; update the distance of the adjacent cells ; if the destination is not reachable ; ",
        "context": "\nfrom collections import deque\n\n\nclass Point:\n    def __init__(self, xx, yy):\n        self .x = xx\n        self .y = yy\n\n\nclass Node:\n    def __init__(self, P, d):\n        self .pt = P\n        self .dist = d\n\n",
        "code": "def isValid(row, col):\n    return (row >= 0) and (col >= 0) and (row < 4) and (col < 4)\n\n\ndRow = [-1, 0, 0, 1]\ndCol = [0, -1, 1, 0]\n\n\ndef pathMoves(mat, src, dest):\n    d = [[-1 for i in range(4)]for i in range(4)]\n    d[src .x][src .y] = 0\n    visited = [[False for i in range(4)]for i in range(4)]\n    visited[src .x][src .y] = True\n    q = deque()\n    s = Node(src, 0)\n    q .append(s)\n    ok = False\n    while (len(q) > 0):\n        curr = q .popleft()\n        pt = curr .pt\n        if (pt .x == dest .x and pt .y == dest .y):\n            xx, yy = pt .x, pt .y\n            dist = curr .dist\n            d[pt .x][pt .y] = dist\n            pathmoves = \"\"\n            while (xx != src .x or yy != src .y):\n                if (xx > 0 and d[xx - 1][yy] == dist - 1):\n                    pathmoves += 'D'\n                    xx -= 1\n                if (xx < 4 - 1 and d[xx + 1][yy] == dist - 1):\n                    pathmoves += 'U'\n                    xx += 1\n                if (yy > 0 and d[xx][yy - 1] == dist - 1):\n                    pathmoves += 'R'\n                    yy -= 1\n                if (yy < 4 - 1 and d[xx][yy + 1] == dist - 1):\n                    pathmoves += 'L'\n                    yy += 1\n                dist -= 1\n            pathmoves = pathmoves[::-1]\n            print(pathmoves, end=\"\")\n            ok = True\n            break\n        for i in range(4):\n            row = pt .x + dRow[i]\n            col = pt .y + dCol[i]\n            if (\n                isValid(\n                    row,\n                    col) and (\n                    mat[row][col] == '1' or mat[row][col] == 's' or mat[row][col] == 'd') and (\n                    not visited[row][col])):\n                visited[row][col] = True\n                adjCell = Node(Point(row, col), curr .dist + 1)\n                q .append(adjCell)\n                d[row][col] = curr .dist + 1\n    if (not ok):\n        print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    mat = [['0', '1', '0', '1'], ['1', '0', '1', '1'],\n           ['0', '1', '1', '1'], ['1', '1', '1', '0']]\n    src = Point(0, 3)\n    dest = Point(3, 0)\n    pathMoves(mat, src, dest)\n",
        "output": "DLDLDL",
        "fn_call": "pathMoves"
    },
    {
        "text": "longest substring of only 4 's from the first n characters of the infinite string | python 3 implementation of the approach ; function to return the length of longest contiguous string containing only 4 atms from the first n characters of the string ; initialize prefix sum array of characters and product variable ; preprocessing of prefix sum array ; finding the string length where n belongs to ; ",
        "context": "\nMAXN = 30\n\n",
        "code": "def countMaxLength(N):\n    pre = [0 for i in range(MAXN)]\n    p = 1\n    pre[0] = 0\n    for i in range(1, MAXN, 1):\n        p *= 2\n        pre[i] = pre[i - 1] + i * p\n    for i in range(1, MAXN, 1):\n        if (pre[i] >= N):\n            ind = i\n            break\n    x = N - pre[ind - 1]\n    y = 2 * ind - 1\n    if (x >= y):\n        res = min(x, y)\n    else:\n        res = max(x, 2 * (ind - 2) + 1)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    N = 25\n    print(countMaxLength(N))\n",
        "output": "5\n",
        "fn_call": "countMaxLength"
    },
    {
        "text": "program to check if n is a myriagon number | python3 implementation to check that a number is a myriagon number or not ; function to check that the number is a myriagon number ; condition to check if the number is a myriagon number ; ",
        "context": "\nimport math\n\n",
        "code": "def isMyriagon(N):\n    n = (9996 + math .sqrt(79984 * N + 99920016)) / 19996\n    return (n - int(n)) == 0\n",
        "test": "\nn = 10000\nif (isMyriagon(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isMyriagon"
    },
    {
        "text": "perfect square string | python3 program to find if string is a perfect square or not . ; calculating the length of the string ; calculating the ascii value of the string ; find floating point value of square root of x . ; if square root is an integer ; ",
        "context": "\nimport math\n\n",
        "code": "def isPerfectSquareString(str):\n    sum = 0\n    l = len(str)\n    for i in range(l):\n        sum = sum + ord(str[i])\n    squareRoot = math .sqrt(sum)\n    return ((squareRoot - math .floor(squareRoot)) == 0)\n",
        "test": "\nstr = \"d\"\nif (isPerfectSquareString(str)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPerfectSquareString"
    },
    {
        "text": "number of array elements derivable from d after performing certain operations | function to return gcd of a and b ; function to return the number of elements of arr [ ] which can be derived from d by performing ( + a , - a , + b , - b ) ; find the gcd of a and b ; counter stores the number of array elements which can be derived from d ; arr [ i ] can be derived from d only if | arr [ i ] - d | is divisible by gcd of a and b ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef findPossibleDerivables(arr, n, D, A, B):\n    gcdAB = gcd(A, B)\n    counter = 0\n    for i in range(n):\n        if ((abs(arr[i] - D) % gcdAB) == 0):\n            counter += 1\n    return counter\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 7, 13]\n    n = len(arr)\n    D, A, B = 5, 4, 2\n    print(findPossibleDerivables(arr, n, D, A, B))\n    a = [1, 2, 3]\n    n = len(a)\n    D, A, B = 6, 3, 2\n    print(findPossibleDerivables(a, n, D, A, B))\n",
        "output": "4\n3\n",
        "fn_call": "findPossibleDerivables"
    },
    {
        "text": "count of elements not divisible by any other elements of array | function to count the number of elements of array which are not divisible by any other element of same array ; length for boolean array ; hash map for storing the element and it 's frequency ; update the maximum element ; boolean array of size of the max element + 1 ; marking the multiples as false ; to store the final count ; traverse boolean array ; check if i is not divisible by any other array elements and appears in the array only once ; return the final count ; ",
        "context": "",
        "code": "def countEle(a, n):\n    len = 0\n    hmap = {}\n    for i in range(n):\n        len = max(len, a[i])\n        hmap[a[i]] = hmap .get(a[i], 0) + 1\n    v = [True for i in range(len + 1)]\n    for i in range(n):\n        if (v[a[i]] == False):\n            continue\n        for j in range(2 * a[i], len + 1, a[i]):\n            v[j] = False\n    count = 0\n    for i in range(1, len + 1):\n        if (v[i] and (i in hmap) and hmap[i] == 1):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [86, 45, 18, 4, 8, 28, 19, 33, 2]\n    n = len(arr)\n    print(countEle(arr, n))\n",
        "output": "4\n",
        "fn_call": "countEle"
    },
    {
        "text": "count of matchsticks required to represent the given number | stick [ i ] stores the count of sticks required to represent the digit i ; function to return the count of matchsticks required to represent the given number ; for every digit of the given number ; add the count of sticks required to represent the current digit ; ",
        "context": "\nsticks = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n\n",
        "code": "def countSticks(string, n):\n    cnt = 0\n    for i in range(n):\n        cnt += (sticks[ord(string[i]) - ord('0')])\n    return cnt\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"56\"\n    n = len(string)\n    print(countSticks(string, n))\n",
        "output": "11\n",
        "fn_call": "countSticks"
    },
    {
        "text": "subsequences of given string consisting of non | function to find all the subsequences of the str1ing with non - repeating ch1aracters ; base case ; insert current subsequence ; if str1 [ i ] is not present in the current subsequence ; insert str1 [ i ] into the set ; insert str1 [ i ] into the current subsequence ; remove str1 [ i ] from current subsequence ; remove str1 [ i ] from the set ; not including str1 [ i ] from the current subsequence ; utility function to print all subsequences of str1ing with non - repeating ch1aracters ; stores all possible subsequences with non - repeating ch1aracters ; stores subsequence with non - repeating ch1aracters ; traverse all possible subsequences containing non - repeating ch1aracters ; print subsequence ; ",
        "context": "",
        "code": "def FindSub(sub, ch1, str1, res, i):\n    if (i == len(str1)):\n        sub .add(res)\n        return\n    if (str1[i]not in ch1):\n        ch1 .add(str1[i])\n        FindSub(sub, ch1, str1, res + str1[i], i + 1)\n        res += str1[i]\n        res = res[0:len(res) - 1]\n        ch1 .remove(str1[i])\n    FindSub(sub, ch1, str1, res, i + 1)\n\n\ndef printSubwithUniquech1ar(str1, N):\n    sub = set()\n    ch1 = set()\n    FindSub(sub, ch1, str1, \"\", 0)\n    temp = []\n    for substr1ing in sub:\n        temp .append(substr1ing)\n    temp .sort(reverse=False)\n    for x in temp:\n        print(x, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    str2 = \"abac\"\n    N = len(str2)\n    printSubwithUniquech1ar(str2, N)\n",
        "output": " a ab abc ac b ba bac bc c ",
        "fn_call": "printSubwithUniquech1ar"
    },
    {
        "text": "alternatively merge two strings in java | function for alternatively merging two strings ; to store the final string ; for every index in the strings ; first choose the ith character of the first string if it exists ; then choose the ith character of the second string if it exists ; ",
        "context": "",
        "code": "def merge(s1, s2):\n    result = \"\"\n    i = 0\n    while (i < len(s1)) or (i < len(s2)):\n        if (i < len(s1)):\n            result += s1[i]\n        if (i < len(s2)):\n            result += s2[i]\n        i += 1\n    return result\n",
        "test": "\ns1 = \"geeks\"\ns2 = \"forgeeks\"\nprint(merge(s1, s2))\n",
        "output": "gfeoerkgseeks\n",
        "fn_call": "merge"
    },
    {
        "text": "count palindromic characteristics of a string | python program which counts different palindromic characteristics of a string . ; function which checks whether a substr [ i . . j ] of a given is a palindrome or not . ; p [ i , j ] = true if substr [ i . . j ] is palindrome , else false ; palindrome of single length ; palindrome of length 2 ; palindromes of length more then 2. this loop is similar to matrix chain multiplication . we start with a gap of length 2 and fill p table in a way that gap between starting and ending indexes increases one by one by outer loop . ; pick starting point for current gap ; set ending point ; if current string is palindrome ; function which recursively counts if a str [ i . . j ] is a k - palindromic or not . ; terminating condition for a which is a k - palindrome . ; terminating condition for a which is not a k - palindrome . ; increases the counter for the if it is a k - palindrome . ; mid is middle pointer of the str [ i ... j ] . ; if length of which is ( j - i + 1 ) is odd than we have to subtract one from mid else if even then no change . ; if the is k - palindrome then we check if it is a ( k + 1 ) - palindrome or not by just sending any of one half of the to the count_k_palindrome def . ; finding all palindromic substrings of given string ; counting k - palindromes for each and every sub of given string . . ; output the number of k - palindromic substrings of a given string . ; ",
        "context": "\nMAX_STR_LEN = 1000\nP = [[0 for x in range(MAX_STR_LEN)]for y in range(MAX_STR_LEN)]\nfor i in range(0, MAX_STR_LEN):\n    for j in range(0, MAX_STR_LEN):\n        P[i][j] = False\nKpal = [0] * MAX_STR_LEN\n\n",
        "code": "def checkSubStrPal(str, n):\n    global P, Kpal, MAX_STR_LEN\n    for i in range(0, MAX_STR_LEN):\n        for j in range(0, MAX_STR_LEN):\n            P[i][j] = False\n        Kpal[i] = 0\n    for i in range(0, n):\n        P[i][i] = True\n    for i in range(0, n - 1):\n        if (str[i] == str[i + 1]):\n            P[i][i + 1] = True\n    for gap in range(2, n):\n        for i in range(0, n - gap):\n            j = gap + i\n            if (str[i] == str[j] and P[i + 1][j - 1]):\n                P[i][j] = True\n\n\ndef countKPalindromes(i, j, k):\n    global Kpal, P\n    if (i == j):\n        Kpal[k] = Kpal[k] + 1\n        return\n    if (P[i][j] == False):\n        return\n    Kpal[k] = Kpal[k] + 1\n    mid = int((i + j) / 2)\n    if ((j - i + 1) % 2 == 1):\n        mid = mid - 1\n    countKPalindromes(i, mid, k + 1)\n\n\ndef printKPalindromes(s):\n    global P, Kpal, MAX_STR_LEN\n    n = len(s)\n    checkSubStrPal(s, n)\n    for i in range(0, n):\n        for j in range(0, n - i):\n            countKPalindromes(j, j + i, 1)\n    for i in range(1, n + 1):\n        print(Kpal[i], end=\" \")\n    print()\n",
        "test": "\ns = \"abacaba\"\nprintKPalindromes(s)\n",
        "output": "12 4 1 0 0 0 0 \n",
        "fn_call": "printKPalindromes"
    },
    {
        "text": "Count N | to keep the string in lexicographically sorted order use start index to add the vowels starting the from that index ; base case : if string length is 0 add to the count ; if last character in string is ' e ' add vowels starting from ' e ' i . e ' e ' , ' i ' , ' o ' , 'u ; decrease the length of string ; char arr [ 5 ] = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' } ; starting from index 0 add the vowels to strings",
        "context": "",
        "code": "def countstrings(n, start):\n    if n == 0:\n        return 1\n    cnt = 0\n    for i in range(start, 5):\n        cnt += countstrings(n - 1, i)\n    return cnt\n\n\ndef countVowelStrings(n):\n    return countstrings(n, 0)\n",
        "test": "\nn = 2\nprint(countVowelStrings(n))\n",
        "output": "15\n",
        "fn_call": "countVowelStrings"
    },
    {
        "text": "postfix to infix | python3 program to find infix for a given postfix . ; get infix for a given postfix expression ; push operands ; we assume that input is a valid postfix and expect an operator . ; there must be a single element in stack now which is the required infix . ; ",
        "context": "",
        "code": "def isOperand(x):\n    return ((x >= 'a' and x = 'A' and x <= 'Z'))\n\n\ndef getInfix(exp):\n    s = []\n    for i in exp:\n        if (isOperand(i)):\n            s .insert(0, i)\n        else:\n            op1 = s[0]\n            s .pop(0)\n            op2 = s[0]\n            s .pop(0)\n            s .insert(0, \"(\" + op2 + i + op1 + \")\")\n    return s[0]\n",
        "test": "\nif __name__ == '__main__':\n    exp = \"ab*c+\"\n    print(getInfix(exp .strip()))\n",
        "output": "((a*b)+c)\n",
        "fn_call": "getInfix"
    },
    {
        "text": "check if n can be represented as sum of distinct powers of 3 | function to check whether the given n can be represented as the sum of the distinct powers of 3 ; iterate until n is non - zero ; termination condition ; right shift ternary bits by 1 for the next digit ; if n can be expressed as the sum of perfect powers of 3 ; ",
        "context": "",
        "code": "def DistinctPowersOf3(N):\n    while (N > 0):\n        if (N % 3 == 2):\n            cout << \"No\"\n            return\n        N //= 3\n    print(\"Yes\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 91\n    DistinctPowersOf3(N)\n",
        "output": "Yes\n",
        "fn_call": "DistinctPowersOf3"
    },
    {
        "text": "count of subarrays with maximum value as k | function to count the subarrays with maximum not greater than k ; if arr [ i ] > k then arr [ i ] cannot be a part of any subarray . ; count the number of elements where arr [ i ] is not greater than k . ; summation of all possible subarrays in the variable ans . ; function to count the subarrays with maximum value is equal to k ; stores count of subarrays with max = k + 1. ; stores count of subarrays with max = k . ; ",
        "context": "",
        "code": "def totalSubarrays(arr, n, k):\n    ans = 0\n    i = 0\n    while (i < n):\n        if (arr[i] > k):\n            i += 1\n            continue\n        count = 0\n        while (i < n and arr[i] <= k):\n            i += 1\n            count += 1\n        ans += ((count * (count + 1)) // 2)\n    return ans\n\n\ndef countSubarrays(arr, n, k):\n    count1 = totalSubarrays(arr, n, k - 1)\n    count2 = totalSubarrays(arr, n, k)\n    ans = count2 - count1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    k = 3\n    arr = [2, 1, 3, 4]\n    print(countSubarrays(arr, n, k))\n",
        "output": "3\n",
        "fn_call": "countSubarrays"
    },
    {
        "text": "find lexicographically smallest string in at most one swaps | function to return the lexicographically smallest string that can be formed by swapping at most one character . the characters might not necessarily be adjacent . ; set - 1 as default for every character . ; character index to fill in the last occurrence array ; if this is true then this character is being visited for the first time from the last thus last occurrence of this character is stored in this index ; character to replace ; find the last occurrence of this character . ; swap this with the last occurrence swap ( s [ i ] , s [ last_occ ] ) ; ; ",
        "context": "",
        "code": "def findSmallest(s):\n    length = len(s)\n    loccur = [-1] * 26\n    for i in range(length - 1, -1, -1):\n        chI = ord(s[i]) - ord('a')\n        if (loccur[chI] == -1):\n            loccur[chI] = i\n    sorted_s = s\n    sorted_s .sort()\n    for i in range(length):\n        if (s[i] != sorted_s[i]):\n            chI = ord(sorted_s[i]) - ord('a')\n            last_occ = loccur[chI]\n            s[i], s[last_occ] = s[last_occ], s[i]\n            break\n    return \"\".join(s)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"geeks\"\n    print(findSmallest(list(s)))\n",
        "output": "eegks\n",
        "fn_call": "findSmallest"
    },
    {
        "text": "",
        "context": "",
        "code": "def find(arr):\n    n = len(arr)\n    i = 0\n    j = n - 1\n    res = -1\n    while i = 0:\n        if arr[i][j] == 0:\n            while j >= 0 and (arr[i][j] == 0 or i == j):\n                j -= 1\n            if j == -1:\n                res = i\n                break\n            else:\n                i += 1\n        else:\n            while i < n and (arr[i][j] == 1 or i == j):\n                i += 1\n            if i == n:\n                res = j\n                break\n            else:\n                j -= 1\n    if res == -1:\n        return res\n    for i in range(0, n):\n        if res != i and arr[i][res] != 1:\n            return -1\n    for j in range(0, j):\n        if res != j and arr[res][j] != 0:\n            return -1\n    return res\n",
        "test": "\narr = [[0, 0, 1, 1, 0], [0, 0, 0, 1, 0], [\n    1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]]\nprint(find(arr))\n",
        "output": "3\n",
        "fn_call": "find"
    },
    {
        "text": "print matrix in antispiral form | python 3 program to print matrix in anti - spiral form ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; print the first row from the remaining rows ; print the last column from the remaining columns ; print the last row from the remaining rows ; print the first column from the remaining columns ; ",
        "context": "\nR = 4\nC = 5\n\n",
        "code": "def antiSpiralTraversal(m, n, a):\n    k = 0\n    l = 0\n    stk = []\n    while (k <= m and l <= n):\n        for i in range(l, n + 1):\n            stk .append(a[k][i])\n        k += 1\n        for i in range(k, m + 1):\n            stk .append(a[i][n])\n        n -= 1\n        if (k <= m):\n            for i in range(n, l - 1, -1):\n                stk .append(a[m][i])\n            m -= 1\n        if (l <= n):\n            for i in range(m, k - 1, -1):\n                stk .append(a[i][l])\n            l += 1\n    while len(stk) != 0:\n        print(str(stk[-1]), end=\" \")\n        stk .pop()\n",
        "test": "\nmat = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [\n    11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]\nantiSpiralTraversal(R - 1, C - 1, mat)\n",
        "output": "12 13 14 9 8 7 6 11 16 17 18 19 20 15 10 5 4 3 2 1 ",
        "fn_call": "antiSpiralTraversal"
    },
    {
        "text": "convert the given rgb color code to hex color code | function to convert decimal to hexadecimal ; char array to store hexadecimal number ; counter for hexadecimal number array ; temporary variable to store remainder ; storing remainder in temp variable . ; check if temp < 10 ; return the equivalent hexadecimal color code ; function to convert the rgb code to hex color code ; the hex color code doesn 't exist ; ",
        "context": "",
        "code": "def decToHexa(n):\n    hexaDeciNum = ['0'] * 100\n    i = 0\n    while (n != 0):\n        temp = 0\n        temp = n % 16\n        if (temp < 10):\n            hexaDeciNum[i] = chr(temp + 48)\n            i = i + 1\n        else:\n            hexaDeciNum[i] = chr(temp + 55)\n            i = i + 1\n        n = int(n / 16)\n    hexCode = \"\"\n    if (i == 2):\n        hexCode = hexCode + hexaDeciNum[0]\n        hexCode = hexCode + hexaDeciNum[1]\n    elif (i == 1):\n        hexCode = \"0\"\n        hexCode = hexCode + hexaDeciNum[0]\n    elif (i == 0):\n        hexCode = \"00\"\n    return hexCode\n\n\ndef convertRGBtoHex(R, G, B):\n    if ((R >= 0 and R = 0 and G = 0 and B <= 255)):\n        hexCode = \"#\"\n        hexCode = hexCode + decToHexa(R)\n        hexCode = hexCode + decToHexa(G)\n        hexCode = hexCode + decToHexa(B)\n        return hexCode\n    else:\n        return \"-1\"\n",
        "test": "\nR = 0\nG = 0\nB = 0\nprint(convertRGBtoHex(R, G, B))\nR = 255\nG = 255\nB = 255\nprint(convertRGBtoHex(R, G, B))\nR = 25\nG = 56\nB = 123\nprint(convertRGBtoHex(R, G, B))\nR = 2\nG = 3\nB = 4\nprint(convertRGBtoHex(R, G, B))\nR = 255\nG = 255\nB = 256\nprint(convertRGBtoHex(R, G, B))\n",
        "output": "#000000\n#FFFFFF\n#9183B7\n#020304\n-1\n",
        "fn_call": "convertRGBtoHex"
    },
    {
        "text": "maximize the given number by replacing a segment of digits with the alternate digits given | function to return the maximized number ; iterate till the end of the string ; check if it is greater or not ; replace with the alternate till smaller ; return original s in case no change took place ; ",
        "context": "",
        "code": "def get_maximum(s, a):\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        if (ord(s[i]) - ord('0') < a[ord(s[i]) - ord('0')]):\n            j = i\n            while (j < n and (ord(s[j]) - ord('0')\n                   <= a[ord(s[j]) - ord('0')])):\n                s[j] = chr(ord('0') + a[ord(s[j]) - ord('0')])\n                j += 1\n            return \"\".join(s)\n    return s\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"1337\"\n    a = [0, 1, 2, 5, 4, 6, 6, 3, 1, 9]\n    print(get_maximum(s, a))\n",
        "output": "1557\n",
        "fn_call": "get_maximum"
    },
    {
        "text": "find two numbers with sum and product both same as n | python 3 program to find a and b such that a * b = n and a + b = n ; function to return the smallest string ; not possible ; find a and b ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def findAandB(N):\n    val = N * N - 4.0 * N\n    if (val < 0):\n        print(\"NO\")\n        return\n    a = (N + sqrt(val)) / 2.0\n    b = (N - sqrt(val)) / 2.0\n    print(\"a =\", '{0:.6}'.format(a))\n    print(\"b =\", '{0:.6}'.format(b))\n",
        "test": "\nif __name__ == '__main__':\n    N = 69.0\n    findAandB(N)\n",
        "output": "a = 67.9851\nb = 1.01493\n",
        "fn_call": "findAandB"
    },
    {
        "text": "count of subarrays having exactly k perfect square numbers | python3 program to count of subarrays having exactly k perfect square numbers . ; a utility function to check if the number n is perfect square or not ; find floating point value of square root of x . ; if square root is an integer ; function to find number of subarrays with sum exactly equal to k ; stl map to store number of subarrays starting from index zero having particular value of sum . ; to store the sum of element traverse so far ; add current element to currsum ; if currsum = k , then a new subarray is found ; if currsum > k then find the no . of subarrays with sum currsum - k and exclude those subarrays ; add currsum to count of different values of sum ; return the final result ; function to count the subarray with k perfect square numbers ; update the array element ; if current element is perfect square then update the arr [ i ] to 1 ; else change arr [ i ] to 0 ; function call ; ",
        "context": "\nfrom collections import defaultdict\nimport math\n\n",
        "code": "def isPerfectSquare(x):\n    sr = math .sqrt(x)\n    return ((sr - math .floor(sr)) == 0)\n\n\ndef findSubarraySum(arr, n, K):\n    prevSum = defaultdict(int)\n    res = 0\n    currsum = 0\n    for i in range(n):\n        currsum += arr[i]\n        if (currsum == K):\n            res += 1\n        if ((currsum - K) in prevSum):\n            res += (prevSum[currsum - K])\n        prevSum[currsum] += 1\n    return res\n\n\ndef countSubarray(arr, n, K):\n    for i in range(n):\n        if (isPerfectSquare(arr[i])):\n            arr[i] = 1\n        else:\n            arr[i] = 0\n    print(findSubarraySum(arr, n, K))\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 4, 9, 2]\n    K = 2\n    N = len(arr)\n    countSubarray(arr, N, K)\n",
        "output": "4\n",
        "fn_call": "countSubarray"
    },
    {
        "text": "check if euler totient function is same for a given number and twice of that number | function to find the euler 's totient function ; initialize result as n ; consider all prime factors of n and subtract their multiples from result ; return the count ; function to check if phi ( n ) is equals phi ( 2 * n ) ; ",
        "context": "",
        "code": "def phi(n):\n    result = 1\n    for p in range(2, n):\n        if (__gcd(p, n) == 1):\n            result += 1\n    return result\n\n\ndef __gcd(a, b):\n    return a if b == 0 else __gcd(b, a % b)\n\n\ndef sameEulerTotient(n):\n    return phi(n) == phi(2 * n)\n",
        "test": "\nif __name__ == '__main__':\n    N = 13\n    if (sameEulerTotient(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "sameEulerTotient"
    },
    {
        "text": "subset with sum closest to zero | python3 code for above implementation ; variable to store states of dp ; function to return the number closer to integer s ; to find the sum closest to zero since sum can be negative , we will add max to it to make it positive ; base cases ; checks if a state is already solved ; recurrence relation ; returning the value ; function to calculate the closest sum value ; calculate the closest value for every subarray arr [ i - 1 : n ] ; ",
        "context": "\nimport numpy as np\narrSize = 51\nmaxSum = 201\nMAX = 100\ninf = 999999\ndp = np .zeros((arrSize, maxSum))\nvisit = np .zeros((arrSize, maxSum))\n\n",
        "code": "def RetClose(a, b, s):\n    if (abs(a - s) < abs(b - s)):\n        return a\n    else:\n        return b\n\n\ndef MinDiff(i, sum, arr, n):\n    if (i == n):\n        return 0\n    if (visit[i][sum + MAX]):\n        return dp[i][sum + MAX]\n    visit[i][sum + MAX] = 1\n    dp[i][sum +\n          MAX] = RetClose(arr[i] +\n                          MinDiff(i +\n                                  1, sum +\n                                  arr[i], arr, n), MinDiff(i +\n                                                           1, sum, arr, n), -\n                          1 *\n                          sum)\n    return dp[i][sum + MAX]\n\n\ndef FindClose(arr, n):\n    ans = inf\n    for i in range(1, n + 1):\n        ans = RetClose(arr[i - 1] + MinDiff(i, arr[i - 1], arr, n), ans, 0)\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [25, -9, -10, -4, -7, -33]\n    n = len(arr)\n    FindClose(arr, n)\n",
        "output": "-1.0\n",
        "fn_call": "FindClose"
    },
    {
        "text": "find numbers which are multiples of first array and factors of second array | python3 implementation of the approach ; function to return the lcm of two numbers ; function to print the required numbers ; to store the lcm of array a [ ] elements and the gcd of array b [ ] elements ; finding lcm of first array ; finding gcd of second array ; no such element exists ; all the multiples of lcma which are less than or equal to gcdb and evenly divide gcdb will satisfy the conditions ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def lcm(x, y):\n    temp = (x * y) // gcd(x, y)\n    return temp\n\n\ndef findNumbers(a, n, b, m):\n    lcmA = 1\n    __gcdB = 0\n    for i in range(n):\n        lcmA = lcm(lcmA, a[i])\n    for i in range(m):\n        __gcdB = gcd(__gcdB, b[i])\n    if (__gcdB % lcmA != 0):\n        print(\"-1\")\n        return\n    num = lcmA\n    while (num <= __gcdB):\n        if (__gcdB % num == 0):\n            print(num, end=\" \")\n        num += lcmA\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 2, 4]\n    b = [16, 32, 64]\n    n = len(a)\n    m = len(b)\n    findNumbers(a, n, b, m)\n",
        "output": "4 8 16 ",
        "fn_call": "findNumbers"
    },
    {
        "text": "create a new string by alternately combining the characters of two halves of the string in reverse | function performing calculations ; calculating the two halves of string s as first and second . the final string p ; it joins the characters to final string in reverse order ; it joins the characters to final string in reverse order ; ",
        "context": "",
        "code": "def solve(s):\n    l = len(s)\n    x = l // 2\n    y = l\n    p = \"\"\n    while (x > 0 and y > l / 2):\n        p = p + s[x - 1]\n        x = x - 1\n        p = p + s[y - 1]\n        y = y - 1\n    if (y > l // 2):\n        p = p + s[y - 1]\n        y = y - 1\n    print(p)\n",
        "test": "\ns = \"sunshine\"\nsolve(s)\n",
        "output": "sennuish\n",
        "fn_call": "solve"
    },
    {
        "text": "find sum of all unique sub | function for finding grandsum ; go through all subarrays , compute sums and count occurrences of sums . ; print all those sums that appear once . ; ",
        "context": "",
        "code": "def findSubarraySum(arr, n):\n    res = 0\n    m = dict()\n    for i in range(n):\n        Sum = 0\n        for j in range(i, n):\n            Sum += arr[j]\n            m[Sum] = m .get(Sum, 0) + 1\n    for x in m:\n        if m[x] == 1:\n            res += x\n    return res\n",
        "test": "\narr = [3, 2, 3, 1, 4]\nn = len(arr)\nprint(findSubarraySum(arr, n))\n",
        "output": "41\n",
        "fn_call": "findSubarraySum"
    },
    {
        "text": "find a point such that sum of the manhattan distances is minimized | function to print the required points which minimizes the sum of manhattan distances ; sorting points in all dimension ; output the required k points ; ",
        "context": "",
        "code": "def minDistance(n, k, point):\n    for i in range(k):\n        point[i].sort()\n    for i in range(k):\n        print(point[i][((n + 1) // 2) - 1], end=\" \")\n",
        "test": "\nn = 4\nk = 4\npoint = [[1, 5, 2, 4], [6, 2, 0, 6], [9, 5, 1, 3], [6, 7, 5, 9]]\nminDistance(n, k, point)\n",
        "output": "2 2 3 6 ",
        "fn_call": "minDistance"
    },
    {
        "text": "count of perfect squares of given length | python3 program to count perfect squares of given length ; function to return the count of n digit perfect squares ; ",
        "context": "\nimport math\n\n",
        "code": "def countSquares(n):\n    r = math .ceil(math .sqrt(math .pow(10, n)))\n    l = math .ceil(math .sqrt(math .pow(10, n - 1)))\n    return r - l\n",
        "test": "\nn = 3\nprint(countSquares(n))\n",
        "output": "22\n",
        "fn_call": "countSquares"
    },
    {
        "text": "find the xor of first half and second half elements of an array | function to find the xor of the first half elements and second half elements of an array ; xor of elements in firsthalfxor ; xor of elements in secondhalfxor ; ",
        "context": "",
        "code": "def XOROfElements(arr, n):\n    FirstHalfXOR = 0\n    SecondHalfXOR = 0\n    for i in range(n):\n        if (i < n // 2):\n            FirstHalfXOR ^= arr[i]\n        else:\n            SecondHalfXOR ^= arr[i]\n    print(FirstHalfXOR, \",\", SecondHalfXOR)\n",
        "test": "\narr = [20, 30, 50, 10, 55, 15, 42]\nN = len(arr)\nXOROfElements(arr, N)\n",
        "output": "56 , 24\n",
        "fn_call": "XOROfElements"
    },
    {
        "text": "find the winner of the game | function to find the winner of the game ; to store the strings for both the players ; if the index is even ; append the current character to player a 's string ; if the index is odd ; append the current character to player b 's string ; sort both the strings to get the lexicographically smallest string possible ; copmpare both the strings to find the winner of the game ; ",
        "context": "",
        "code": "def find_winner(string, n):\n    string1 = \"\"\n    string2 = \"\"\n    for i in range(n):\n        if (i % 2 == 0):\n            string1 += string[i]\n        else:\n            string2 += string[i]\n    string1 = \"\".join(sorted(string1))\n    string2 = \"\".join(sorted(string2))\n    if (string1 < string2):\n        print(\"A\", end=\"\")\n    elif (string2 < string1):\n        print(\"B\", end=\"\")\n    else:\n        print(\"Tie\", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    n = len(string)\n    find_winner(string, n)\n",
        "output": "B",
        "fn_call": "find_winner"
    },
    {
        "text": "number of subsets with sum divisible by m | use dynamic programming to find sum of subsequences . ; find sum pf array elements ; dp [ i ] [ j ] would be > 0 if arr [ 0. . i - 1 ] has a subsequence with sum equal to j . ; there is always sum equals zero ; fill up the dp table ; initialize the counter ; check if the sum exists ; check sum is divisible by m ; ",
        "context": "",
        "code": "def sumSubSequence(arr, length, m):\n    summ = 0\n    for i in arr:\n        summ += i\n    dp = [[0 for i in range(summ + 1)]for j in range(length + 1)]\n    for i in range(length + 1):\n        dp[i][0] += 1\n    for i in range(1, length + 1):\n        dp[i][arr[i - 1]] += 1\n        for j in range(1, summ + 1):\n            if dp[i - 1][j] > 0:\n                dp[i][j] += 1\n                dp[i][j + arr[i - 1]] += 1\n    count = 0\n    for i in range(1, summ + 1):\n        if dp[length][i] > 0:\n            if i % m == 0:\n                count += dp[length][i]\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3]\n    m = 3\n    length = len(arr)\n    print(sumSubSequence(arr, length, m))\n",
        "output": "3\n",
        "fn_call": "sumSubSequence"
    },
    {
        "text": "count ways to reach the nth stair using multiple 1 or 2 steps and a single step 3 | python3 implementation to find the number the number of ways to reach nth stair by taking 1 or 2 steps at a time and 3 rd step exactly once ; function to find the number of ways ; base case ; count of 2 - steps ; count of 1 - steps ; initial length of sequence ; expected count of 2 - steps ; loop to find the ways for every possible sequence ; ",
        "context": "\nimport math\n\n",
        "code": "def ways(n):\n    if n < 3:\n        return 0\n    c2 = 0\n    c1 = n - 3\n    l = c1 + 1\n    s = 0\n    exp_c2 = c1 / 2\n    while exp_c2 >= c2:\n        f1 = math .factorial(l)\n        f2 = math .factorial(c1)\n        f3 = math .factorial(c2)\n        s += f1 // (f2 * f3)\n        c2 += 1\n        c1 -= 2\n        l -= 1\n    return s\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 7\n    print(ways(N))\n",
        "output": "20\n",
        "fn_call": "ways"
    },
    {
        "text": "count the number of ordered sets not containing consecutive numbers | dp table ; function to calculate the count of ordered set for a given size ; base cases ; if subproblem has been soved before ; store and return answer to this subproblem ; function returns the count of all ordered sets ; prestore the factorial value ; iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than n as all elements are distinct and non consecutive . ; multiply ny size ! for all the arrangements because sets are ordered . ; add to total answer ; ",
        "context": "\ndp = [[-1 for j in range(500)]for i in range(500)]\n\n",
        "code": "def CountSets(x, pos):\n    if (x <= 0):\n        if (pos == 0):\n            return 1\n        else:\n            return 0\n    if (pos == 0):\n        return 1\n    if (dp[x][pos] != -1):\n        return dp[x][pos]\n    answer = (CountSets(x - 1, pos) + CountSets(x - 2, pos - 1))\n    dp[x][pos] = answer\n    return answer\n\n\ndef CountOrderedSets(n):\n    factorial = [0 for i in range(10000)]\n    factorial[0] = 1\n    for i in range(1, 10000):\n        factorial[i] = factorial[i - 1] * i\n    answer = 0\n    for i in range(1, n + 1):\n        sets = CountSets(n, i) * factorial[i]\n        answer = answer + sets\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    print(CountOrderedSets(N))\n",
        "output": "5\n",
        "fn_call": "CountOrderedSets"
    },
    {
        "text": "find number of times a string occurs as a subsequence in given string | recursive function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; if both first and second string is empty , or if second string is empty , return 1 ; if only first string is empty and second string is not empty , return 0 ; if last characters are same recur for remaining strings by 1. considering last characters of both strings 2. ignoring last character of first string ; if last characters are different , ignore last char of first string and recur for remaining string ; ",
        "context": "",
        "code": "def count(a, b, m, n):\n    if ((m == 0 and n == 0) or n == 0):\n        return 1\n    if (m == 0):\n        return 0\n    if (a[m - 1] == b[n - 1]):\n        return (count(a, b, m - 1, n - 1) + count(a, b, m - 1, n))\n    else:\n        return count(a, b, m - 1, n)\n",
        "test": "\na = \"GeeksforGeeks\"\nb = \"Gks\"\nprint(count(a, b, len(a), len(b)))\n",
        "output": "4\n",
        "fn_call": "count"
    },
    {
        "text": "numbers with exactly 3 divisors | generates all primes upto n and prints their squares ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; print squares of primes upto n . ; ",
        "context": "",
        "code": "def numbersWith3Divisors(n):\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False\n    p = 2\n    while (p * p <= n):\n        if (prime[p]):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    print(\"Numbers with 3 divisors :\")\n    i = 0\n    while (i * i <= n):\n        if (prime[i]):\n            print(i * i, end=\" \")\n        i += 1\n",
        "test": "\nn = 96\nnumbersWith3Divisors(n)\n",
        "output": "Numbers with 3 divisors :\n4 9 25 49 ",
        "fn_call": "numbersWith3Divisors"
    },
    {
        "text": "longest suffix such that occurrence of each character is less than n after deleting atmost k characters | function to find the maximum length suffix in the string ; length of the string ; map to store the number of occurrence of character ; loop to iterate string from the last character ; condition to check if the occurrence of each character is less than given number ; condition when character cannot be deleted ; longest suffix ; ",
        "context": "",
        "code": "def maximumSuffix(s, n, k):\n    i = len(s) - 1\n    arr = [0 for i in range(26)]\n    suffix = \"\"\n    while (i > -1):\n        index = ord(s[i]) - ord('a')\n        if (arr[index] < n):\n            arr[index] += 1\n            suffix += s[i]\n            i -= 1\n            continue\n        if (k == 0):\n            break\n        k -= 1\n        i -= 1\n    suffix = suffix[::-1]\n    print(suffix)\n",
        "test": "\nif __name__ == '__main__':\n    str = \"iahagafedcba\"\n    n = 1\n    k = 2\n    maximumSuffix(str, n, k)\n",
        "output": "hgfedcba\n",
        "fn_call": "maximumSuffix"
    },
    {
        "text": "longest repeated subsequence | this function mainly returns lcs ( str , str ) with a condition that same characters at same index are not considered . ; this part of code is same as below post it fills dp [ ] [ ] https : www . geeksforgeeks . org / longest - repeating - subsequence / or the code mentioned above ; this part of code finds the result string using dp [ ] [ ] initialize result ; traverse dp [ ] [ ] from bottom right ; if this cell is same as diagonally adjacent cell just above it , then same characters are present at str [ i - 1 ] and str [ j - 1 ] . append any of them to result . ; otherwise we move to the side that gave us maximum result . ; since we traverse dp [ ] [ ] from bottom , we get result in reverse order . ; ",
        "context": "",
        "code": "def longestRepeatedSubSeq(str):\n    n = len(str)\n    dp = [[0 for i in range(n + 1)]for j in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (str[i - 1] == str[j - 1] and i != j):\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    res = ''\n    i = n\n    j = n\n    while (i > 0 and j > 0):\n        if (dp[i][j] == dp[i - 1][j - 1] + 1):\n            res += str[i - 1]\n            i -= 1\n            j -= 1\n        elif (dp[i][j] == dp[i - 1][j]):\n            i -= 1\n        else:\n            j -= 1\n    res = ''.join(reversed(res))\n    return res\n",
        "test": "\nstr = 'AABEBCDD'\nprint(longestRepeatedSubSeq(str))\n",
        "output": "ABD\n",
        "fn_call": "longestRepeatedSubSeq"
    },
    {
        "text": "find an n | function to print the required permutation ; ",
        "context": "",
        "code": "def findPermutation(N):\n    for i in range(1, N + 1, 1):\n        print(i, end=\" \")\n    print(\"\",  end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    findPermutation(N)\n",
        "output": "1 2 3 4 5 ",
        "fn_call": "findPermutation"
    },
    {
        "text": "subarray whose absolute sum is closest to k | python code to find sub - array whose sum shows the minimum deviation ; starting index , ending index , deviation ; iterate i and j to get all subarrays ; found sub - array with less sum ; exactly same sum ; ",
        "context": "",
        "code": "def getSubArray(arr, n, K):\n    i = -1\n    j = -1\n    currSum = 0\n    result = [i, j, abs(K - abs(currSum))]\n    for i in range(0, n):\n        currSum = 0\n        for j in range(i, n):\n            currSum += arr[j]\n            currDev = abs(K - abs(currSum))\n            if (currDev < result[2]):\n                result = [i, j, currDev]\n            if (currDev == 0):\n                return result\n    return result\n\n\ndef main():\n    arr = [15, -3, 5, 2, 7, 6, 34, -6]\n    n = len(arr)\n    K = 50\n    [i, j, minDev] = getSubArray(arr, n, K)\n    if (i == -1):\n        print(\"The empty array shows minimum Deviation\")\n        return 0\n    for i in range(i, j + 1):\n        print(arr[i],)\n",
        "test": "\nmain()\n",
        "output": "-3\n5\n2\n7\n6\n34\n",
        "fn_call": "main"
    },
    {
        "text": "check whether a number is emirpimes or not | checking whether a number is semi - prime or not ; increment count of prime numbers ; if number is still greater than 1 , after exiting the add it to the count variable as it indicates the number is a prime number ; return '1' if count is equal to '2' else return '0 ; checking whether a number is emirpimes or not ; number itself is not semiprime . ; finding reverse of n . ; the definition of emirpimes excludes palindromes , hence we do not check further , if the number entered is a palindrome ; checking whether the reverse of the semi prime number entered is also a semi prime number or not ; ",
        "context": "",
        "code": "def checkSemiprime(num):\n    cnt = 0\n    i = 2\n    while (cnt < 2 and (i * i) <= num):\n        while (num % i == 0):\n            num /= i\n            cnt += 1\n        i += 1\n    if (num > 1):\n        cnt += 1\n    return cnt == 2\n\n\ndef isEmirpimes(n):\n    if (checkSemiprime(n) == False):\n        return False\n    r = 0\n    t = n\n    while (t != 0):\n        r = r * 10 + t % 10\n        t = t / n\n    if (r == n):\n        return false\n    return (checkSemiprime(r))\n",
        "test": "\nn = 15\nif (isEmirpimes(n)):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n",
        "output": "Yes\n",
        "fn_call": "isEmirpimes"
    },
    {
        "text": "alternate fibonacci numbers | alternate fibonacci series using dynamic programming ; 0 th and 1 st number of the series are 0 and 1 ; ",
        "context": "",
        "code": "def alternateFib(n):\n    if (n < 0):\n        return -1\n    f1 = 0\n    f2 = 1\n    print(f1, end=\" \")\n    for i in range(2, n + 1):\n        f3 = f2 + f1\n        if (i % 2 == 0):\n            print(f3, end=\" \")\n        f1 = f2\n        f2 = f3\n",
        "test": "\nN = 15\nalternateFib(N)\n",
        "output": "0 1 3 8 21 55 144 377 ",
        "fn_call": "alternateFib"
    },
    {
        "text": "min and max length subarray having adjacent element difference atmost k | function to find the maximum and minimum length subarray ; initialise minimum and maximum size of subarray in worst case ; left will scan the size of possible subarray in left of selected element ; right will scan the size of possible subarray in right of selected element ; temp will store size of group associateed with every element ; loop to find size of subarray for every element of array ; left will move in left direction and compare difference between itself and element left to it ; right will move in right direction and compare difference between itself and element right to it ; if subarray of much lesser or much greater is found than yet known then update ; print minimum and maximum possible size of subarray ; ",
        "context": "",
        "code": "def findMaxMinSubArray(arr, K, n):\n    min = n\n    max = 0\n    left = 0\n    right = n\n    tmp = 0\n    for i in range(0, n):\n        tmp = 1\n        left = i\n        while (left - 1 >= 0 and abs(arr[left] - arr[left - 1]) <= K):\n            left = left - 1\n            tmp = tmp + 1\n        right = i\n        while (right + 1 <= n - 1 and abs(arr[right] - arr[right + 1]) <= K):\n            right = right + 1\n            tmp = tmp + 1\n        if (min > tmp):\n            min = tmp\n        if (max < tmp):\n            max = tmp\n    print(min, end=', ')\n    print(max, end='')\n",
        "test": "\narr = [1, 2, 5, 6, 7]\nK = 2\nn = len(arr)\nfindMaxMinSubArray(arr, K, n)\n",
        "output": "2, 3",
        "fn_call": "findMaxMinSubArray"
    },
    {
        "text": "find the winner of a game of removing at most 3 stones from a pile in each turn | function to find the maximum score of player 1 ; base case ; if the result is already computed , then return the result ; variable to store maximum score ; pick one stone ; pick 2 stones ; pick 3 stones ; return the score of the player ; function to find the winner of the game ; create a 1d table , dp of size n ; store the result ; player 1 wins ; player 2 wins ; tie ; ",
        "context": "",
        "code": "def maximumStonesUtil(arr, n, i, dp):\n    if (i >= n):\n        return 0\n    ans = dp[i]\n    if (ans != -1):\n        return ans\n    ans = -2 ** 31\n    ans = max(ans, arr[i] - maximumStonesUtil(arr, n, i + 1, dp))\n    if (i + 1 < n):\n        ans = max(ans, arr[i] + arr[i + 1] -\n                  maximumStonesUtil(arr, n, i + 2, dp))\n    if (i + 2 < n):\n        ans = max(ans, arr[i] + arr[i + 1] + arr[i + 2] -\n                  maximumStonesUtil(arr, n, i + 3, dp))\n    return ans\n\n\ndef maximumStones(arr, n):\n    dp = [-1] * n\n    res = maximumStonesUtil(arr, n, 0, dp)\n    if (res > 0):\n        return \"Player1\"\n    elif (res < 0):\n        return \"Player2\"\n    else:\n        return \"Tie\"\n",
        "test": "\narr = [1, 2, 3, 7]\nn = len(arr)\nprint(maximumStones(arr, n))\n",
        "output": "Player2\n",
        "fn_call": "maximumStones"
    },
    {
        "text": "count of all subsequences having adjacent elements with different parity | function to find required subsequences ; initialise the dp [ ] [ ] with 0. ; if odd element is encountered ; considering i - th element will be present in the subsequence ; appending i - th element to all non - empty subsequences ending with even element till ( i - 1 ) th indexes ; considering ith element will not be present in the subsequence ; considering i - th element will be present in the subsequence ; appending i - th element to all non - empty subsequences ending with odd element till ( i - 1 ) th indexes ; considering ith element will not be present in the subsequence ; count of all valid subsequences ; ",
        "context": "",
        "code": "def validsubsequences(arr, n):\n    dp = [[0 for i in range(2)]for j in range(n + 1)]\n    for i in range(1, n + 1):\n        if (arr[i - 1] % 2):\n            dp[i][1] += 1\n            dp[i][1] += dp[i - 1][0]\n            dp[i][1] += dp[i - 1][1]\n            dp[i][0] += dp[i - 1][0]\n        else:\n            dp[i][0] += 1\n            dp[i][0] += dp[i - 1][1]\n            dp[i][0] += dp[i - 1][0]\n            dp[i][1] += dp[i - 1][1]\n    return dp[n][0] + dp[n][1]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 6, 9, 7]\n    n = len(arr)\n    print(validsubsequences(arr, n))\n",
        "output": "9\n",
        "fn_call": "validsubsequences"
    },
    {
        "text": "difference between sums of odd level and even level nodes of a binary tree | a binary tree node ; the main function that returns difference between odd and even level nodes ; base case ; difference for root is root 's data - difference for  left subtree - difference for right subtree ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def getLevelDiff(root):\n    if root is None:\n        return 0\n    return (root .data - getLevelDiff(root .left) - getLevelDiff(root .right))\n",
        "test": "\nroot = Node(5)\nroot .left = Node(2)\nroot .right = Node(6)\nroot .left .left = Node(1)\nroot .left .right = Node(4)\nroot .left .right .left = Node(3)\nroot .right .right = Node(8)\nroot .right .right .right = Node(9)\nroot .right .right .left = Node(7)\nprint(\"%d is the required difference\" % (getLevelDiff(root)))\n",
        "output": "-9 is the required difference\n",
        "fn_call": "getLevelDiff"
    },
    {
        "text": "count of elements which is the sum of a subarray of the given array | function to count element such that their exist a subarray whose sum is equal to this element ; loop to compute frequency of the given elements ; loop to iterate over every possible subarray of array ; ",
        "context": "",
        "code": "def countElement(arr, n):\n    freq = {}\n    ans = 0\n    for i in range(n):\n        freq[arr[i]] = freq .get(arr[i], 0) + 1\n    for i in range(n - 1):\n        tmpsum = arr[i]\n        for j in range(i + 1, n):\n            tmpsum += arr[j]\n            if tmpsum in freq:\n                ans += freq[tmpsum]\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    n = len(arr)\n    print(countElement(arr, n))\n",
        "output": "4\n",
        "fn_call": "countElement"
    },
    {
        "text": "minimum element left from the array after performing given operations | function to return the minimum possible value of the last element left after performing the given operations ; ",
        "context": "",
        "code": "def getMin(arr, n):\n    minVal = min(arr)\n    return minVal\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 3, 1, 6, 9]\n    n = len(arr)\n    print(getMin(arr, n))\n",
        "output": "1\n",
        "fn_call": "getMin"
    },
    {
        "text": "josephus problem using bit magic | function to find the position of the most significant bit ; keeps shifting bits to the right until we are left with 0 ; function to return at which place josephus should sit to avoid being killed ; getting the position of the most significant bit ( msb ) . the leftmost '1' . if the number is '41' then its binary is '101001' . so msbpos ( 41 ) = 6 ; ' j ' stores the number with which to xor the number ' n ' . since we need '100000' we will do 1 << 6 - 1 to get '100000 ; toggling the most significant bit . changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; toggling the '0' at the end to '1' which is essentially the same as putting the msb at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; ",
        "context": "",
        "code": "def msbPos(n):\n    pos = 0\n    while n != 0:\n        pos += 1\n        n = n >> 1\n    return pos\n\n\ndef josephify(n):\n    position = msbPos(n)\n    j = 1 << (position - 1)\n    n = n ^ j\n    n = n << 1\n    n = n | 1\n    return n\n",
        "test": "\nn = 41\nprint(josephify(n))\n",
        "output": "19\n",
        "fn_call": "josephify"
    },
    {
        "text": "largest and smallest n | function to return the largest n - digit number in hexa - decimal number system ; append ' f ' n times ; function to return the smallest n - digit number in hexa - decimal number system ; append '0' ( n - 1 ) times to 1 ; function to print the largest and smallest n - digit hexa - decimal number ; ",
        "context": "",
        "code": "def findLargest(N):\n    largest = 'F' * N\n    return largest\n\n\ndef findSmallest(N):\n    smallest = '1' + '0' * (N - 1)\n    return smallest\n\n\ndef printAns(largest):\n    print(\"Largest: \", findLargest(largest))\n    print(\"Smallest: \", findSmallest(largest))\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    printAns(N)\n",
        "output": "Largest:  FFFF\nSmallest:  1000\n",
        "fn_call": "printAns"
    },
    {
        "text": "length of the smallest number which is divisible by k and formed by using 1 's only | function to return length of the resultant number ; if k is a multiple of 2 or 5 ; instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , k 1 's  take remainder with k ; if number is divisible by k then remainder will be 0 ; ",
        "context": "",
        "code": "def numLen(K):\n    if (K % 2 == 0 or K % 5 == 0):\n        return -1\n    number = 0\n    len = 1\n    for len in range(1, K + 1):\n        number = (number * 10 + 1) % K\n        if number == 0:\n            return len\n    return -1\n",
        "test": "\nK = 7\nprint(numLen(K))\n",
        "output": "6\n",
        "fn_call": "numLen"
    },
    {
        "text": "number of digits in the product of two numbers | python 3 implementation to count number of digits in the product of two numbers ; function to count number of digits in the product of two numbers ; if either of the number is 0 , then product will be 0 ; required count of digits ; ",
        "context": "\nimport math\n\n",
        "code": "def countDigits(a, b):\n    if (a == 0 or b == 0):\n        return 1\n    return math .floor(math .log10(abs(a)) + math .log10(abs(b))) + 1\n",
        "test": "\na = 33\nb = -24\nprint(countDigits(a, b))\n",
        "output": "3\n",
        "fn_call": "countDigits"
    },
    {
        "text": "k | program to find kth element from two sorted arrays ; ",
        "context": "",
        "code": "def kth(arr1, arr2, m, n, k):\n    sorted1 = [0] * (m + n)\n    i = 0\n    j = 0\n    d = 0\n    while (i < m and j < n):\n        if (arr1[i] < arr2[j]):\n            sorted1[d] = arr1[i]\n            i += 1\n        else:\n            sorted1[d] = arr2[j]\n            j += 1\n        d += 1\n    while (i < m):\n        sorted1[d] = arr1[i]\n        d += 1\n        i += 1\n    while (j < n):\n        sorted1[d] = arr2[j]\n        d += 1\n        j += 1\n    return sorted1[k - 1]\n",
        "test": "\narr1 = [2, 3, 6, 7, 9]\narr2 = [1, 4, 8, 10]\nk = 5\nprint(kth(arr1, arr2, 5, 4, k))\n",
        "output": "6\n",
        "fn_call": "kth"
    },
    {
        "text": "minimum sum of two integers whose product is strictly greater than n | function to find the minimum sum of two integers such that their product is strictly greater than n ; initialise low as 0 and high as 1e9 ; iterate to find the first number ; find the middle value ; if mid ^ 2 is greater than equal to a , then update high to mid ; otherwise update low ; store the first number ; again , set low as 0 and high as 1e9 ; iterate to find the second number ; find the middle value ; if first number * mid is greater than n then update high to mid ; else , update low to mid ; store the second number ; print the result ; ",
        "context": "",
        "code": "def minSum(N):\n    low = 0\n    high = 1000000000\n    while (low + 1 < high):\n        mid = low + (high - low) / 2\n        if (mid * mid >= N):\n            high = mid\n        else:\n            low = mid\n    first = high\n    low = 0\n    high = 1000000000\n    while (low + 1 < high):\n        mid = low + (high - low) / 2\n        if (first * mid > N):\n            high = mid\n        else:\n            low = mid\n    second = high\n    print(round(first + second))\n",
        "test": "\nN = 10\nminSum(N)\n",
        "output": "7\n",
        "fn_call": "minSum"
    },
    {
        "text": "decimal equivalent of gray code and its inverse | function to convert given decimal number of gray code into its inverse in decimal form ; taking xor until n becomes zero ; ",
        "context": "",
        "code": "def inversegrayCode(n):\n    inv = 0\n    while (n):\n        inv = inv ^ n\n        n = n >> 1\n    return inv\n",
        "test": "\nn = 15\nprint(inversegrayCode(n))\n",
        "output": "10\n",
        "fn_call": "inversegrayCode"
    },
    {
        "text": "count number of islands where every island is row | this function takes a matrix of ' x ' and ' o ' and returns the number of rectangular islands of ' x ' where no two islands are row - wise or column - wise adjacent , the islands may be diagonaly adjacent ; initialize result ; traverse the input matrix ; if current cell is ' x ' , then check whether this is top - leftmost of a rectangle . if yes , then increment count ; ",
        "context": "",
        "code": "def countIslands(mat):\n    count = 0\n    for i in range(0, M):\n        for j in range(0, N):\n            if (mat[i][j] == 'X'):\n                if ((i == 0 or mat[i - 1][j] == 'O')\n                        and (j == 0 or mat[i][j - 1] == 'O')):\n                    count = count + 1\n    return count\n",
        "test": "\nM = 6\nN = 3\nmat = [['O', 'O', 'O'], ['X', 'X', 'O'], ['X', 'X', 'O'],\n       ['O', 'O', 'X'], ['O', 'O', 'X'], ['X', 'X', 'O']]\nprint(\"Number of rectangular islands is\", countIslands(mat))\n",
        "output": "Number of rectangular islands is 3\n",
        "fn_call": "countIslands"
    },
    {
        "text": "minimum number of deletions to make a string palindrome | function definition ; base cases ; checking the ndesired condition ; if yes increment the cunt ; if no ; return the value form the table ; else store the max tranforamtion from the subsequence ; return the dp [ - 1 ] [ - 1 ] ;  ; ",
        "context": "",
        "code": "def transformation(s1, s2, i, j, dp):\n    if i >= len(s1) or j >= len(s2):\n        return 0\n    if s1[i] == s2[j]:\n        dp[i][j] = 1 + transformation(s1, s2, i + 1, j + 1, dp)\n    if dp[i][j] != -1:\n        return dp[i][j]\n    else:\n        dp[i][j] = max(\n            transformation(\n                s1,\n                s2,\n                i,\n                j + i,\n                dp),\n            transformation(\n                s1,\n                s2,\n                i + 1,\n                j,\n                dp))\n    return dp[-1][-1]\n",
        "test": "\ns1 = \"geeksforgeeks\"\ns2 = \"geeks\"\ni = 0\nj = 0\ndp = [[-1 for _ in range(len(s1) + 1)]for _ in range(len(s2) + 1)]\nprint(\"MINIMUM NUMBER OF DELETIONS: \", len(s1) -\n      transformation(s1, s2, 0, 0, dp), end=\" \")\nprint(\"MINIMUM NUMBER OF INSERTIONS: \", len(s2) -\n      transformation(s1, s2, 0, 0, dp), end=\" \")\nprint(\"LCS LENGTH: \", transformation(s1, s2, 0, 0, dp))\n",
        "output": "MINIMUM NUMBER OF DELETIONS:  8 MINIMUM NUMBER OF INSERTIONS:  0 LCS LENGTH:  5\n",
        "fn_call": "transformation"
    },
    {
        "text": "count of largest sized groups while grouping according to product of digits | function to find out product of digit ; calculate product ; return the product of digits ; function to find the count ; hash map for counting frequency ; counting freq of each element ; find the maximum ; count the number of groups having size of equal to largest group . ; ",
        "context": "",
        "code": "def digit_prod(x):\n    prod = 1\n    while (x):\n        prod = prod * (x % 10)\n        x = x // 10\n    return prod\n\n\ndef find_count(n):\n    mpp = {}\n    for i in range(1, n + 1):\n        x = digit_prod(i)\n        if x in mpp:\n            mpp[x] += 1\n        else:\n            mpp[x] = 1\n    ans = 1\n    maxm = 0\n    for value in mpp .values():\n        if (value > maxm):\n            maxm = value\n            ans = 1\n        elif (value == maxm):\n            ans = ans + 1\n    return ans\n",
        "test": "\nN = 13\nprint(find_count(N))\n",
        "output": "3\n",
        "fn_call": "find_count"
    },
    {
        "text": "reduce hamming distance by swapping two characters | python 3 code to decrease hamming distance using swap . ; function to return the swapped indexes to get minimum hamming distance . ; find the initial hamming distance ; case - i : to decrease distance by two ; ascii values of present character . ; if two same letters appear in different positions print their indexes ; store the index of letters which is in wrong position ; case : ii ; if misplaced letter is found , print its original index and its new index ; store the index of letters in wrong position ; case - iii ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def Swap(s, t, n):\n    dp = [[-1 for x in range(MAX)]for y in range(MAX)]\n    tot = 0\n    for i in range(n):\n        if (s[i] != t[i]):\n            tot += 1\n    for i in range(n):\n        a = ord(s[i]) - ord('a')\n        b = ord(t[i]) - ord('a')\n        if (a == b):\n            continue\n        if (dp[a][b] != -1):\n            print(i + 1, \" \", dp[a][b] + 1)\n            return\n        dp[b][a] = i\n    A = [-1] * MAX\n    B = [-1] * MAX\n    for i in range(n):\n        a = ord(s[i]) - ord('a')\n        b = ord(t[i]) - ord('a')\n        if (a == b):\n            continue\n        if (A[b] != -1):\n            print(i + 1, A[b] + 1)\n            return\n        if (B[a] != -1):\n            print(i + 1, B[a] + 1)\n            return\n        A[a] = i\n        B[b] = i\n    print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"permanent\"\n    T = \"pergament\"\n    n = len(S)\n    if (S == \"\" or T == \"\"):\n        print(\"Required string is empty.\")\n    else:\n        Swap(S, T, n)\n",
        "output": "6 4\n",
        "fn_call": "Swap"
    },
    {
        "text": "perfect binary tree specific level order traversal | set 2 | linked list node ; given a perfect binary tree , print its nodes in specific level order ; for level order traversal ; stack to print reverse ; vector to store the level ; considering size of the level ; push data of the node of a particular level to vector ; push vector containing a level in stack ; print the stack ; finally pop all nodes from stack and prints them . ; finally print root ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def specific_level_order_traversal(root):\n    q = []\n    s = []\n    q .append(root)\n    sz = 0\n    while (len(q) > 0):\n        v = []\n        sz = len(q)\n        i = 0\n        while (i < sz):\n            temp = q[0]\n            q .pop(0)\n            v .append(temp .data)\n            if (temp .left is not None):\n                q .append(temp .left)\n            if (temp .right is not None):\n                q .append(temp .right)\n            i = i + 1\n        s .append(v)\n    while (len(s) > 0):\n        v = s[-1]\n        s .pop()\n        i = 0\n        j = len(v) - 1\n        while (i < j):\n            print(v[i], \" \", v[j], end=\" \")\n            j = j - 1\n            i = i + 1\n    print(root .data)\n",
        "test": "\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nprint(\"Specific Level Order traversal of binary tree is\")\nspecific_level_order_traversal(root)\n",
        "output": "Specific Level Order traversal of binary tree is\n2   3 1\n",
        "fn_call": "specific_level_order_traversal"
    },
    {
        "text": "count indices where the maximum in the prefix array is less than that in the suffix array | function to print the count of indices in which the maximum in prefix arrays is less than that in the suffix array ; if size of array is 1 ; pre [ ] : prefix array suf [ ] : suffix array ; stores the required count ; find the maximum in prefix array ; find the maximum in suffix array ; traverse the array ; if maximum in prefix array is less than maximum in the suffix array ; print the answer ; ",
        "context": "",
        "code": "def count(a, n):\n    if (n == 1):\n        print(0)\n        return\n    pre = [0] * (n - 1)\n    suf = [0] * (n - 1)\n    max = a[0]\n    ans = 0\n    pre[0] = a[0]\n    for i in range(n - 1):\n        if (a[i] > max):\n            max = a[i]\n        pre[i] = max\n    max = a[n - 1]\n    suf[n - 2] = a[n - 1]\n    for i in range(n - 2, 0, -1):\n        if (a[i] > max):\n            max = a[i]\n        suf[i - 1] = max\n    for i in range(n - 1):\n        if (pre[i] < suf[i]):\n            ans += 1\n    print(ans)\n",
        "test": "\narr = [2, 3, 4, 8, 1, 4]\nN = len(arr)\ncount(arr, N)\n",
        "output": "3\n",
        "fn_call": "count"
    },
    {
        "text": "count ways to generate pairs having bitwise xor and bitwise and equal to x and y respectively | function to return the count of possible pairs of a and b whose bitwise xor is x and y respectively ; stores the count of pairs ; iterate till any bit are set ; extract i - th bit of x and y ; divide x and y by 2 ; if xi = 1 and yi = 2 , multiply counter by 2 ; increase required count ; if xi = 1 and yi = 1 ; no answer exists ; return the final count ; ",
        "context": "",
        "code": "def countOfPairs(x, y):\n    counter = 1\n    while (x or y):\n        bit1 = x % 2\n        bit2 = y % 2\n        x >>= 1\n        y >>= 1\n        if (bit1 == 1 and bit2 == 0):\n            counter *= 2\n            continue\n        if (bit1 & bit2):\n            counter = 0\n            break\n    return counter\n",
        "test": "\nX = 2\nY = 5\nprint(countOfPairs(X, Y))\n",
        "output": "2\n",
        "fn_call": "countOfPairs"
    },
    {
        "text": "largest even and odd n | function to print the largest n - digit even and odd numbers in hexadecimal number system ; append ' f ' ( n - 1 ) times ; append ' e ' for an even number ; append ' f ' for an odd number ; ",
        "context": "",
        "code": "def findNumbers(n):\n    ans = 'F' * (n - 1)\n    even = ans + 'E'\n    odd = ans + 'F'\n    print(\"Even: \", even)\n    print(\"Odd: \", odd)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 2\n    findNumbers(n)\n",
        "output": "Even:  FE\nOdd:  FF\n",
        "fn_call": "findNumbers"
    },
    {
        "text": "remove an occurrence of most frequent array element exactly k times | function to print the most frequent array element exactly k times ; stores frequency array element ; count frequency of array element ; maximum array element ; traverse the map ; find the element with maximum frequency ; if the frequency is maximum , store that number in element ; print element as it contains the element having highest frequency ; decrease the frequency of the maximum array element ; reduce the number of operations ; given array ; size of the array ; ",
        "context": "",
        "code": "def maxFreqElements(arr, N, K):\n    mp = {}\n    for i in range(N):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n    while (K > 0):\n        Max = 0\n        for i in mp:\n            if (mp[i] > Max):\n                Max = mp[i]\n                element = i\n        print(element, end=\" \")\n        if element in mp:\n            mp[element] -= 1\n        else:\n            mp[element] = -1\n        K -= 1\n",
        "test": "\narr = [1, 3, 2, 1, 4, 1]\nN = len(arr)\nK = 2\nmaxFreqElements(arr, N, K)\n",
        "output": "1 1 ",
        "fn_call": "maxFreqElements"
    },
    {
        "text": "find ways an integer can be expressed as sum of n | python 3 program to find number of ways to express a number as sum of n - th powers of numbers . ; wrapper over checkrecursive ( ) ; ",
        "context": "",
        "code": "def checkRecursive(num, rem_num, next_int, n, ans=0):\n    if (rem_num == 0):\n        ans += 1\n    r = int(num ** (1 / n))\n    for i in range(next_int + 1, r + 1):\n        a = rem_num - int(i ** n)\n        if a >= 0:\n            ans += checkRecursive(num, rem_num - int(i ** n), i, n, 0)\n    return ans\n\n\ndef check(x, n):\n    return checkRecursive(x, x, 0, n)\n",
        "test": "\nif __name__ == '__main__':\n    print(check(10, 2))\n",
        "output": "1\n",
        "fn_call": "check"
    },
    {
        "text": "minimum possible sum of array elements after performing the given operation | function to find the maximum sum of the sub array ; max_so_far represents the maximum sum found till now and max_ending_here represents the maximum sum ending at a specific index ; iterating through the array to find the maximum sum of the subarray ; if the maximum sum ending at a specific index becomes less than 0 , then making it equal to 0. ; function to find the minimum possible sum of the array elements after performing the given operation ; finding the sum of the array ; computing the minimum sum of the array ; ",
        "context": "",
        "code": "def maxSubArraySum(a, size):\n    max_so_far = -10 ** 9\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        if (max_ending_here < 0):\n            max_ending_here = 0\n    return max_so_far\n\n\ndef minPossibleSum(a, n, x):\n    mxSum = maxSubArraySum(a, n)\n    sum = 0\n    for i in range(n):\n        sum += a[i]\n    sum = sum - mxSum + mxSum / x\n    print(round(sum, 2))\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    X = 2\n    A = [1, -2, 3]\n    minPossibleSum(A, N, X)\n",
        "output": "0.5\n",
        "fn_call": "minPossibleSum"
    },
    {
        "text": "Area of square Circumscribed by Circle | Function to find area of square ; Radius of a circle ; Call Function to find an area of square",
        "context": "",
        "code": "def find_Area(r):\n    return (2 * r * r)\n",
        "test": "\nr = 3\nprint(\" Area of square = \", find_Area(r))\n",
        "output": " Area of square =  18\n",
        "fn_call": "find_Area"
    },
    {
        "text": "check if two numbers have same number of digits | function that return true if a and b have same number of digits ; both must be 0 now if they had same lengths ; ",
        "context": "",
        "code": "def sameLength(A, B):\n    while (A > 0 and B > 0):\n        A = A / 10\n        B = B / 10\n    if (A == 0 and B == 0):\n        return True\n    return False\n",
        "test": "\nA = 21\nB = 1\nif (sameLength(A, B)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "sameLength"
    },
    {
        "text": "check whether two strings are anagram of each other | python program to check if two strings are anagrams of each other ; function to check whether two strings are anagram of each other ; create two count arrays and initialize all values as 0 ; for each character in input strings , increment count in the corresponding count array ; if both strings are of different length . removing this condition will make the program fail for strings like \" aaca \" and \" aca \" ; compare count arrays ; ",
        "context": "\nNO_OF_CHARS = 256\n\n",
        "code": "def areAnagram(str1, str2):\n    count1 = [0] * NO_OF_CHARS\n    count2 = [0] * NO_OF_CHARS\n    for i in str1:\n        count1[ord(i)] += 1\n    for i in str2:\n        count2[ord(i)] += 1\n    if len(str1) != len(str2):\n        return 0\n    for i in range(NO_OF_CHARS):\n        if count1[i] != count2[i]:\n            return 0\n    return 1\n",
        "test": "\nstr1 = \"geeksforgeeks\"\nstr2 = \"forgeeksgeeks\"\nif areAnagram(str1, str2):\n    print(\"The two strings are anagram of each other\")\nelse:\n    print(\"The two strings are not anagram of each other\")\n",
        "output": "The two strings are anagram of each other\n",
        "fn_call": "areAnagram"
    },
    {
        "text": "rearrange string such that no pair of adjacent characters are of the same type | function to rearrange given alphanumeric such that no two adjacent characters are of the same type ; stores alphabets and digits ; store the alphabets and digits separately in the strings ; stores the count of alphabets and digits ; if respective counts differ by 1 ; desired arrangement not possible ; stores the indexes ; check if first character should be alphabet or digit ; place alphabets and digits alternatively ; if current character needs to be alphabet ; if current character needs to be a digit ; flip flag for alternate arrangement ; return resultant string ; ",
        "context": "",
        "code": "def rearrange(s):\n    s1 = []\n    s2 = []\n    for x in s:\n        if x .isalpha():\n            s1 .append(x)\n        else:\n            s2 .append(x)\n    n = len(s1)\n    m = len(s2)\n    if (abs(n - m) > 1):\n        return \"-1\"\n    i = 0\n    j = 0\n    k = 0\n    flag = 0\n    if (n >= m):\n        flag = 1\n    else:\n        flag = 0\n    while (i < n and j < m):\n        if (flag):\n            s[k] = s1[i]\n            k += 1\n            i += 1\n        else:\n            s[k] = s2[j]\n            k += 1\n            j += 1\n        flag = not flag\n    return \"\".join(s)\n",
        "test": "\nif __name__ == '__main__':\n    str = \"geeks2020\"\n    str1 = [i for i in str]\n    print(rearrange(str1))\n",
        "output": "g2e0e2k00\n",
        "fn_call": "rearrange"
    },
    {
        "text": "largest number less than or equal to z that leaves a remainder x when divided by y | function to get the number ; remainder can ' t \u2581 be \u2581 larger \u2581 \u2581 than \u2581 the \u2581 largest \u2581 number , \u2581 \u2581 if \u2581 so \u2581 then \u2581 answer \u2581 doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; ",
        "context": "",
        "code": "def get(x, y, z):\n    if (x > z):\n        return -1\n    val = z - x\n    div = (z - x) // y\n    ans = div * y + x\n    return ans\n",
        "test": "\nx = 1\ny = 5\nz = 8\nprint(get(x, y, z))\n",
        "output": "6\n",
        "fn_call": "get"
    },
    {
        "text": "make all elements of an array equal with the given operation | function that returns true if all the elements of the array can be made equal with the given operation ; to store the sum of the array elements and the maximum element from the array ; ",
        "context": "",
        "code": "def isPossible(n, k, arr):\n    sum = arr[0]\n    maxVal = arr[0]\n    for i in range(1, n):\n        sum += arr[i]\n        maxVal = max(maxVal, arr[i])\n    if (int(maxVal) > int((sum + k) / n)):\n        return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    k = 8\n    arr = [1, 2, 3, 4]\n    n = len(arr)\n    if (isPossible(n, k, arr)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "find n from the value of n ! | map to precompute and store the factorials of the numbers ; function to precompute factorial ; calculating the factorial for each i and storing in a map ; ",
        "context": "\nm = {}\n\n",
        "code": "def precompute():\n    fact = 1\n    for i in range(1, 19):\n        fact = fact * i\n        m[fact] = i\n",
        "test": "\nif __name__ == \"__main__\":\n    precompute()\n    K = 120\n    print(m[K])\n    K = 6\n    print(m[K])\n",
        "output": "5\n3\n",
        "fn_call": "precompute"
    },
    {
        "text": "program for mean absolute deviation | function to find mean of the array elements . ; calculate sum of all elements . ; function to find mean absolute deviation of given elements . ; calculate the sum of absolute deviation about mean . ; return mean absolute deviation about mean . ; ",
        "context": "",
        "code": "def Mean(arr, n):\n    sm = 0\n    for i in range(0, n):\n        sm = sm + arr[i]\n    return sm // n\n\n\ndef meanAbsoluteDeviation(arr, n):\n    absSum = 0\n    for i in range(0, n):\n        absSum = absSum + abs(arr[i] - Mean(arr, n))\n    return absSum / n\n",
        "test": "\narr = [10, 15, 15, 17, 18, 21]\nn = len(arr)\nprint(meanAbsoluteDeviation(arr, n))\n",
        "output": "2.6666666666666665\n",
        "fn_call": "meanAbsoluteDeviation"
    },
    {
        "text": "print the two possible permutations from a given sequence | function to check if the sequence is concatenation of two permutations or not ; computing the sum of all the elements in the array ; computing the prefix sum for all the elements in the array ; iterating through the i from lengths 1 to n - 1 ; sum of first i + 1 elements ; sum of remaining n - i - 1 elements ; lengths of the 2 permutations ; checking if the sums satisfy the formula or not ; function to print the two permutations ; print the first permutation ; print the second permutation ; function to find the two permutations from the given sequence ; if the sequence is not a concatenation of two permutations ; find the largest element in the array and set the lengths of the permutations accordingly ; ",
        "context": "",
        "code": "def checkPermutation(arr, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    prefix = [0 for i in range(n + 1)]\n    prefix[0] = arr[0]\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] + arr[i]\n    for i in range(n - 1):\n        lsum = prefix[i]\n        rsum = sum - prefix[i]\n        l_len = i + 1\n        r_len = n - i - 1\n        if (((2 * lsum) == (l_len * (l_len + 1)))\n                and ((2 * rsum) == (r_len * (r_len + 1)))):\n            return True\n    return False\n\n\ndef printPermutations(arr, n, l1, l2):\n    for i in range(l1):\n        print(arr[i], end=\" \")\n    print(\"\", end=\"\")\n    for i in range(l1, n, 1):\n        print(arr[i], end=\" \")\n\n\ndef findPermutations(arr, n):\n    if (checkPermutation(arr, n) == False):\n        print(\"Not Possible\")\n        return\n    l1 = 0\n    l2 = 0\n    l1 = max(arr)\n    l2 = n - l1\n    s1 = set()\n    s2 = set()\n    for i in range(l1):\n        s1 .add(arr[i])\n    for i in range(l1, n):\n        s2 .add(arr[i])\n    if (len(s1) == l1 and len(s2) == l2):\n        printPermutations(arr, n, l1, l2)\n    else:\n        temp = l1\n        l1 = l2\n        l2 = temp\n        printPermutations(arr, n, l1, l2)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 1, 3, 4, 5, 6, 7, 8, 9, 1, 10, 2]\n    n = len(arr)\n    findPermutations(arr, n)\n",
        "output": "2 1 3 4 5 6 7 8 9 1 10 2 ",
        "fn_call": "findPermutations"
    },
    {
        "text": "square root of a number without using sqrt ( ) function | python3 implementation of the approach ; recursive function that returns square root of a number with precision upto 5 decimal places ; if mid itself is the square root , return mid ; if mul is less than n , recur second half ; else recur first half ; function to find the square root of n ; while the square root is not found ; if n is a perfect square ; square root will lie in the interval i - 1 and i ; ",
        "context": "\nimport math\n\n",
        "code": "def Square(n, i, j):\n    mid = (i + j) / 2\n    mul = mid * mid\n    if ((mul == n) or (abs(mul - n) < 0.00001)):\n        return mid\n    elif (mul < n):\n        return Square(n, mid, j)\n    else:\n        return Square(n, i, mid)\n\n\ndef findSqrt(n):\n    i = 1\n    found = False\n    while (found == False):\n        if (i * i == n):\n            print(i)\n            found = True\n        elif (i * i > n):\n            res = Square(n, i - 1, i)\n            print(\"{0:.5f}\".format(res))\n            found = True\n        i += 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    findSqrt(n)\n",
        "output": "1.73205\n",
        "fn_call": "findSqrt"
    },
    {
        "text": "maximum squares possible parallel to both axes from n distinct points | function that returns the count of squares parallel to both x and y - axis from a given set of points ; initialize result ; initialize a set to store points ; initialize a map to store the points in the same vertical line ; store the points in a set ; store the points in the same vertical line i . e . with same x co - ordinates ; check for every two points in the same vertical line ; check if other two point are present or not ; ",
        "context": "",
        "code": "def countSquares(X, Y, N):\n    count = 0\n    points = []\n    vertical = dict .fromkeys(X, None)\n    for i in range(N):\n        points .append((X[i], Y[i]))\n    for i in range(N):\n        if vertical[X[i]] is None:\n            vertical[X[i]] = [Y[i]]\n        else:\n            vertical[X[i]].append(Y[i])\n    for line in vertical:\n        X1 = line\n        yList = vertical[line]\n        for i in range(len(yList)):\n            Y1 = yList[i]\n            for j in range(i + 1, len(yList)):\n                Y2 = yList[j]\n                side = abs(Y1 - Y2)\n                X2 = X1 + side\n                if (X2, Y1) in points and (X2, Y2) in points:\n                    count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    X = [0, 2, 0, 2]\n    Y = [0, 2, 2, 0]\n    N = len(X)\n    print(countSquares(X, Y, N))\n",
        "output": "1\n",
        "fn_call": "countSquares"
    },
    {
        "text": "check whether given floating point number is even or odd | function to check even or odd . ; loop to traverse number from lsb ; we ignore trailing 0 s after dot ; if it is ' . ' we will check next digit and it means decimal part is traversed . ; if digit is divisible by 2 means even number . ; ",
        "context": "",
        "code": "def isEven(s):\n    l = len(s)\n    dotSeen = False\n    for i in range(l - 1, -1, -1):\n        if (s[i] == '0' and dotSeen == False):\n            continue\n        if (s[i] == '.'):\n            dotSeen = True\n            continue\n        if ((int)(s[i]) % 2 == 0):\n            return True\n        return False\n",
        "test": "\ns = \"100.70\"\nif (isEven(s)):\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n",
        "output": "Odd\n",
        "fn_call": "isEven"
    },
    {
        "text": "modify n by adding its smallest positive divisor exactly k times | python 3 program to implement the above approach ; function to find the smallest divisor of n greater than 1 ; if i is a divisor of n ; if n is a prime number ; function to find the value of n by performing the operations k times ; iterate over the range [ 1 , k ] ; update n ; ",
        "context": "\nimport math\n\n",
        "code": "def smallestDivisorGr1(N):\n    for i in range(2, int(math .sqrt(N)) + 1):\n        if (N % i == 0):\n            return i\n    return N\n\n\ndef findValOfNWithOperat(N, K):\n    for i in range(1, K + 1):\n        N += smallestDivisorGr1(N)\n    return N\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    K = 4\n    print(findValOfNWithOperat(N, K))\n",
        "output": "14\n",
        "fn_call": "findValOfNWithOperat"
    },
    {
        "text": "smallest n digit number whose sum of square of digits is a perfect square | python3 implementation to find smallest n digit number whose sum of square of digits is a perfect square ; function to check if number is a perfect square ; function to calculate the smallest n digit number ; place digits greater than equal to prev ; check if placing this digit leads to a solution then return it ; else backtrack ; create a representing the n digit number ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isSquare(n):\n    k = int(sqrt(n))\n    return (k * k == n)\n\n\ndef calculate(pos, prev, sum, v):\n    if (pos == len(v)):\n        return isSquare(sum)\n    for i in range(prev, 9 + 1):\n        v[pos] = i\n        sum += i * i\n        if (calculate(pos + 1, i, sum, v)):\n            return 1\n        sum -= i * i\n    return 0\n\n\ndef minValue(n):\n    v = [0] * (n)\n    if (calculate(0, 1, 0, v)):\n        answer = \"\"\n        for i in range(len(v)):\n            answer += chr(v[i] + ord('0'))\n        return answer\n    else:\n        return \"-1\"\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    print(minValue(N))\n",
        "output": "34\n",
        "fn_call": "minValue"
    },
    {
        "text": "number of n digit stepping numbers | function that calculates the answer ; dp [ i ] [ j ] stores count of i digit stepping numbers ending with digit j . ; if n is 1 then answer will be 10. ; initialize values for count of digits equal to 1. ; compute values for count of digits more than 1. ; if ending digit is 0 ; if ending digit is 9 ; for other digits . ; stores the final answer ; ",
        "context": "",
        "code": "def answer(n):\n    dp = [[0 for x in range(10)]for y in range(n + 1)]\n    if (n == 1):\n        return 10\n    for j in range(10):\n        dp[1][j] = 1\n    for i in range(2, n + 1):\n        for j in range(10):\n            if (j == 0):\n                dp[i][j] = dp[i - 1][j + 1]\n            elif (j == 9):\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1])\n    sum = 0\n    for j in range(1, 10):\n        sum = sum + dp[n][j]\n    return sum\n",
        "test": "\nn = 2\nprint(answer(n))\n",
        "output": "17\n",
        "fn_call": "answer"
    },
    {
        "text": "program for decimal to binary conversion | function to convert decimal to binary ; array to store binary number ; counter for binary array ; storing remainder in binary array ; printing binary array in reverse order ; ",
        "context": "",
        "code": "def decToBinary(n):\n    binaryNum = [0] * n\n    i = 0\n    while (n > 0):\n        binaryNum[i] = n % 2\n        n = int(n / 2)\n        i += 1\n    for j in range(i - 1, -1, -1):\n        print(binaryNum[j], end=\"\")\n",
        "test": "\nn = 17\ndecToBinary(n)\n",
        "output": "10001",
        "fn_call": "decToBinary"
    },
    {
        "text": "check whether n is a factorion or not | python3 implementation of the approach ; function that returns true if n is a factorion ; fact [ i ] will store i ! ; a copy of the given integer ; to store the sum of factorials of the digits of n ; get the last digit ; add the factorial of the current digit to the sum ; remove the last digit ; ",
        "context": "\nMAX = 10\n\n",
        "code": "def isFactorion(n):\n    fact = [0] * MAX\n    fact[0] = 1\n    for i in range(1, MAX):\n        fact[i] = i * fact[i - 1]\n    org = n\n    sum = 0\n    while (n > 0):\n        d = n % 10\n        sum += fact[d]\n        n = n // 10\n    if (sum == org):\n        return True\n    return False\n",
        "test": "\nn = 40585\nif (isFactorion(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isFactorion"
    },
    {
        "text": "check if it is possible to get given sum by taking one element from each row | function that prints whether is it possible to make sum equal to k ; base case ; condition if we can make sum equal to current column by using above rows ; iterate through current column and check whether we can make sum less than or equal to k ; printing whether is it possible or not ; ",
        "context": "",
        "code": "def PossibleSum(n, m, v, k):\n    dp = [[0] * (k + 1)for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if dp[i][j] == 1:\n                for d in range(m):\n                    if (j + v[i][d]) <= k:\n                        dp[i + 1][j + v[i][d]] = 1\n    if dp[n][k] == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nN = 2\nM = 10\nK = 5\narr = [[4, 0, 15, 3, 2, 20, 10, 1, 5, 4], [4, 0, 10, 3, 2, 25, 4, 1, 5, 4]]\nPossibleSum(N, M, arr, K)\n",
        "output": "YES\n",
        "fn_call": "PossibleSum"
    },
    {
        "text": "generate all unique partitions of an integer | set 2 | array to store the numbers used to form the required sum ; function to print the array which contains the unique partitions which are used to form the required sum ; function to find all the unique partitions remsum = remaining sum to form maxval is the maximum number that can be used to make the partition ; if remsum == 0 that means the sum is achieved so print the array ; i will begin from maxval which is the maximum value which can be used to form the sum ; store the number used in forming sum gradually in the array ; since i used the rest of partition cant have any number greater than i hence second parameter is i ; ",
        "context": "\ndp = [0 for i in range(200)]\ncount = 0\n\n",
        "code": "def print1(idx):\n    for i in range(1, idx, 1):\n        print(dp[i], end=\" \")\n    print(\"\", end=\"\")\n\n\ndef solve(remSum, maxVal, idx, count):\n    if (remSum == 0):\n        print1(idx)\n        count += 1\n        return\n    i = maxVal\n    while (i >= 1):\n        if (i > remSum):\n            i -= 1\n            continue\n        elif (i <= remSum):\n            dp[idx] = i\n            solve(remSum - i, i, idx + 1, count)\n            i -= 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    count = 0\n    solve(n, n, 1, count)\n",
        "output": "4 3 1 2 2 2 1 1 1 1 1 1 ",
        "fn_call": "solve"
    },
    {
        "text": "even perfect number | python3 program for the above approach ; function to check for perfect number ; find a number close to 2 ^ q - 1 ; calculate q - 1 ; condition of perfect number ; check whether q is prime or not ; check whether 2 ^ q - 1 is a prime number or not ; function to check for prime number ; check whether it is equal to 2 or 3 ; check if it can be divided by 2 and 3 then it is not prime number ; check whether the given number be divide by other prime numbers ; ",
        "context": "\nimport math\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return bool(False)\n    elif (n == 2 or n == 3):\n        return bool(True)\n    else:\n        if (n % 2 == 0 or n % 3 == 0):\n            return bool(False)\n        for i in range(5, sqrt(n + 1) + 1, 6):\n            if (n % i == 0 or n % (i + 2) == 0):\n                return bool(False)\n        return bool(True)\n\n\ndef check(num):\n    root = (int)(math .sqrt(num))\n    poww = (int)(math .log(root) / math .log(2))\n    if (num == (int)(pow(2, poww) * (pow(2, poww + 1) - 1))):\n        if (isPrime(poww + 1)):\n            if (isPrime((int)(pow(2, poww + 1)) - 1)):\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n",
        "test": "\nnum = 6\ncheck(num)\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "pentanacci numbers | function to print nth pentanacci number ; initialize first five numbers to base cases ; declare a current variable ; loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth to second , third , fourth and curr to fifth respectively ; ",
        "context": "",
        "code": "def printpenta(n):\n    if (n < 0):\n        return\n    first = 0\n    second = 0\n    third = 0\n    fourth = 0\n    fifth = 1\n    curr = 0\n    if (n == 0 or n == 1 or n == 2 or n == 3):\n        print(first)\n    elif (n == 5):\n        print(fifth)\n    else:\n        for i in range(5, n):\n            curr = first + second + third + fourth + fifth\n            first = second\n            second = third\n            third = fourth\n            fourth = fifth\n            fifth = curr\n    print(curr)\n",
        "test": "\nn = 10\nprintpenta(n)\n",
        "output": "16\n",
        "fn_call": "printpenta"
    },
    {
        "text": "find unique pair in an array with pairs of numbers | python 3 program to find a unique pair in an array of pairs . ; xor each element and get xor of two unique elements ( ans ) ; get a set bit of xor ( we get the rightmost set bit ) ; now divide elements in two sets by comparing rightmost set bit of xor with bit at same position in each element . ; xor of first set in arr [ ] ; xor of second set in arr [ ] ; ",
        "context": "",
        "code": "def findUniquePair(arr, n):\n    XOR = arr[0]\n    for i in range(1, n):\n        XOR = XOR ^ arr[i]\n    set_bit_no = XOR & ~(XOR - 1)\n    x = 0\n    y = 0\n    for i in range(0, n):\n        if (arr[i] & set_bit_no):\n            x = x ^ arr[i]\n        else:\n            y = y ^ arr[i]\n    print(\"The unique pair is (\", x, \", \", y, \")\", sep=\"\")\n",
        "test": "\na = [6, 1, 3, 5, 1, 3, 7, 6]\nn = len(a)\nfindUniquePair(a, n)\n",
        "output": "The unique pair is (7, 5)\n",
        "fn_call": "findUniquePair"
    },
    {
        "text": "generate all binary strings from given pattern | recursive function to generate all binary strings formed by replacing each wildcard character by 0 or 1 ; replace ' ? ' by '0' and recurse ; replace ' ? ' by '1' and recurse ; note : need to backtrack as string is passed by reference to the function ; ",
        "context": "",
        "code": "def _print(string, index):\n    if index == len(string):\n        print(''.join(string))\n        return\n    if string[index] == \"?\":\n        string[index] = '0'\n        _print(string, index + 1)\n        string[index] = '1'\n        _print(string, index + 1)\n        string[index] = '?'\n    else:\n        _print(string, index + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"1??0?101\"\n    string = list(string)\n    _print(string, 0)\n",
        "output": "10000101\n10001101\n10100101\n10101101\n11000101\n11001101\n11100101\n11101101\n",
        "fn_call": "_print"
    },
    {
        "text": "check if a given number can be represented in given a no . of digits in any base | returns true if ' num ' can be represented using ' dig ' digits in 'base ; base case ; if there are more than 1 digits left and number is more than base , then remove last digit by doing num / base , reduce the number of digits and recur ; return true of num can be represented in ' dig ' digits in any base from 2 to 32 ; check for all bases one by one ; ",
        "context": "",
        "code": "def checkUtil(num, dig, base):\n    if (dig == 1 and num < base):\n        return True\n    if (dig > 1 and num >= base):\n        return checkUtil(num / base, --dig, base)\n    return False\n\n\ndef check(num, dig):\n    for base in range(2, 33):\n        if (checkUtil(num, dig, base)):\n            return True\n    return False\n",
        "test": "\nnum = 8\ndig = 3\nif (check(num, dig)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "check"
    },
    {
        "text": "check if the binary representation of a number has equal number of 0 s and 1 s in blocks | function to convert decimal to binary ; count same bits in last block ; if n is 0 or it has all 1 s , then it is not considered to have equal number of 0 s and 1 s in blocks . ; count same bits in all remaining blocks . ; ",
        "context": "",
        "code": "def isEqualBlock(n):\n    first_bit = n % 2\n    first_count = 1\n    n = n // 2\n    while n % 2 == first_bit and n > 0:\n        n = n // 2\n        first_count += 1\n    if n == 0:\n        return False\n    while n > 0:\n        first_bit = n % 2\n        curr_count = 1\n        n = n // 2\n        while n % 2 == first_bit:\n            n = n // 2\n            curr_count += 1\n        if curr_count != first_count:\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 51\n    if isEqualBlock(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isEqualBlock"
    },
    {
        "text": "count of pairs in an array with same number of set bits | function to return the count of pairs ; get the maximum element ; array to store count of bits of all elements upto maxm ; store the set bits for powers of 2 ; compute the set bits for the remaining elements ; store the frequency of respective counts of set bits ; ",
        "context": "",
        "code": "def countPairs(arr, N):\n    maxm = max(arr)\n    i = 0\n    k = 0\n    bitscount = [0 for i in range(maxm + 1)]\n    i = 1\n    while i <= maxm:\n        bitscount[i] = 1\n        i *= 2\n    for i in range(1, maxm + 1):\n        if (bitscount[i] == 1):\n            k = i\n        if (bitscount[i] == 0):\n            bitscount[i] = (bitscount[k] + bitscount[i - k])\n    setbits = dict()\n    for i in range(N):\n        if bitscount[arr[i]] in setbits:\n            setbits[bitscount[arr[i]]] += 1\n        else:\n            setbits[bitscount[arr[i]]] = 1\n    ans = 0\n    for it in setbits .values():\n        ans += it * (it - 1) // 2\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 12\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(countPairs(arr, N))\n",
        "output": "22\n",
        "fn_call": "countPairs"
    },
    {
        "text": "remove all zero | function to remove the rows or columns from the matrix which contains all 0 s elements ; stores count of rows ; col [ i ] : stores count of 0 s in current column ; row [ i ] : stores count of 0 s in current row ; traverse the matrix ; stores count of 0 s in current row ; update col [ j ] ; update count ; update row [ i ] ; traverse the matrix ; if all elements of current row is 0 ; if all elements of current column is 0 ; ",
        "context": "",
        "code": "def removeZeroRowCol(arr):\n    n = len(arr)\n    col = [0] * (n + 1)\n    row = [0] * (n + 1)\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            col[j] += (arr[i][j] == 1)\n            count += (arr[i][j] == 1)\n        row[i] = count\n    for i in range(n):\n        if (row[i] == 0):\n            continue\n        for j in range(n):\n            if (col[j] != 0):\n                print(arr[i][j], end=\"\")\n        print()\n",
        "test": "\narr = [[1, 1, 0, 1], [0, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 1]]\nremoveZeroRowCol(arr)\n",
        "output": "111\n111\n011\n",
        "fn_call": "removeZeroRowCol"
    },
    {
        "text": "median of bitwise xor of all submatrices starting from the top left corner | function to find the median of bitwise xor of all the submatrix whose topmost leftmost corner is ( 0 , 0 ) ; dp [ i ] [ j ] : stores the bitwise xor of submatrix having top left corner at ( 0 , 0 ) and bottom right corner at ( i , j ) ; stores count of submatrix ; base case ; base case ; fill dp using tabulation ; fill dp [ i ] [ j ] ; ",
        "context": "",
        "code": "def findMedXOR(mat, N, M):\n    dp = [[0 for i in range(M)]for j in range(N)]\n    med = [0] * (N * M)\n    dp[0][0] = mat[0][0]\n    med[0] = dp[0][0]\n    len = 1\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] ^ mat[i][0]\n        med[len] = dp[i][0]\n        len += 1\n    for i in range(1, M):\n        dp[0][i] = dp[0][i - 1] ^ mat[0][i]\n        med[len] = dp[0][i]\n        len += 1\n    for i in range(1, N):\n        for j in range(1, M):\n            dp[i][j] = dp[i - 1][j] ^ dp[i][j - 1] ^ dp[i - 1][j - 1] ^ mat[i][j]\n            med[len] = dp[i][j]\n            len += 1\n    med .sort()\n    if (len % 2 == 0):\n        return (med[(len // 2)] + med[(len // 2) - 1]) / 2.0\n    return med[len // 2]\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[1, 2], [2, 3]]\n    N = len(mat[0])\n    M = 2\n    print(findMedXOR(mat, N, M))\n",
        "output": "2.5\n",
        "fn_call": "findMedXOR"
    },
    {
        "text": "path in a rectangle with circles | python3 program to find out path in a rectangle containing circles . ; function to find out if there is any possible path or not . ; take an array of m * n size and initialize each element to 0. ; now using pythagorean theorem find if a cell touches or within any circle or not . ; if the starting cell comes within any circle return false . ; now use bfs to find if there is any possible path or not . initialize the queue which holds the discovered cells whose neighbors are not discovered yet . ; discover cells until queue is not empty ; discover the eight adjacent nodes . check top - left cell ; check top cell ; check top - right cell ; check left cell ; check right cell ; check bottom - left cell ; check bottom cell ; check bottom - right cell ; now if the end cell ( i . e . bottom right cell ) is 1 ( reachable ) then we will send true . ; ",
        "context": "\nimport math\nimport queue\n\n",
        "code": "def isPossible(m, n, k, r, X, Y):\n    rect = [[0] * n for i in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for p in range(k):\n                if (math .sqrt(\n                        (pow((X[p] - 1 - i), 2) + pow((Y[p] - 1 - j), 2))) <= r):\n                    rect[i][j] = -1\n    if (rect[0][0] == -1):\n        return False\n    qu = queue .Queue()\n    rect[0][0] = 1\n    qu .put([0, 0])\n    while (not qu .empty()):\n        arr = qu .get()\n        elex = arr[0]\n        eley = arr[1]\n        if ((elex > 0) and (eley > 0) and (rect[elex - 1][eley - 1] == 0)):\n            rect[elex - 1][eley - 1] = 1\n            v = [elex - 1, eley - 1]\n            qu .put(v)\n        if ((elex > 0) and (rect[elex - 1][eley] == 0)):\n            rect[elex - 1][eley] = 1\n            v = [elex - 1, eley]\n            qu .put(v)\n        if ((elex > 0) and (eley < n - 1) and (rect[elex - 1][eley + 1] == 0)):\n            rect[elex - 1][eley + 1] = 1\n            v = [elex - 1, eley + 1]\n            qu .put(v)\n        if ((eley > 0) and (rect[elex][eley - 1] == 0)):\n            rect[elex][eley - 1] = 1\n            v = [elex, eley - 1]\n            qu .put(v)\n        if ((eley < n - 1) and (rect[elex][eley + 1] == 0)):\n            rect[elex][eley + 1] = 1\n            v = [elex, eley + 1]\n            qu .put(v)\n        if ((elex  0) and (rect[elex + 1][eley - 1] == 0)):\n            rect[elex + 1][eley - 1] = 1\n            v = [elex + 1, eley - 1]\n            qu .put(v)\n        if ((elex < m - 1) and (rect[elex + 1][eley] == 0)):\n            rect[elex + 1][eley] = 1\n            v = [elex + 1, eley]\n            qu .put(v)\n        if ((elex < m - 1) and (eley < n - 1)\n                and (rect[elex + 1][eley + 1] == 0)):\n            rect[elex + 1][eley + 1] = 1\n            v = [elex + 1, eley + 1]\n            qu .put(v)\n    return (rect[m - 1][n - 1] == 1)\n",
        "test": "\nif __name__ == '__main__':\n    m1 = 5\n    n1 = 5\n    k1 = 2\n    r1 = 1\n    X1 = [1, 3]\n    Y1 = [3, 3]\n    if (isPossible(m1, n1, k1, r1, X1, Y1)):\n        print(\"Possible\")\n    else:\n        print(\"Not Possible\")\n    m2 = 5\n    n2 = 5\n    k2 = 2\n    r2 = 1\n    X2 = [1, 1]\n    Y2 = [2, 3]\n    if (isPossible(m2, n2, k2, r2, X2, Y2)):\n        print(\"Possible\")\n    else:\n        print(\"Not Possible\")\n",
        "output": "Possible\nNot Possible\n",
        "fn_call": "isPossible"
    },
    {
        "text": "increment a number without using ++ or + | function that increment the value . ; invert bits and apply negative sign ; ",
        "context": "",
        "code": "def increment(i):\n    i = -(~ord(i))\n    return chr(i)\n",
        "test": "\nn = 'a'\nprint(increment(n))\n",
        "output": "b\n",
        "fn_call": "increment"
    },
    {
        "text": "minimum distance a person has to move in order to take a picture of every racer | python3 program for the above approach ; function to return the minimum distance the person has to move order to get the pictures ; to store the minimum ending point ; to store the maximum starting point ; find the values of minseg and maxseg ; impossible ; the person doesn 't need to move ; get closer to the left point ; get closer to the right point ; ",
        "context": "\nimport sys\n\n",
        "code": "def minDistance(start, end, n, d):\n    left = -sys .maxsize\n    right = sys .maxsize\n    for i in range(n):\n        left = max(left, start[i])\n        right = min(right, end[i])\n    if (left > right):\n        return -1\n    if (d >= left and d <= right):\n        return 0\n    if (d < left):\n        return (left - d)\n    if (d > right):\n        return (d - right)\n",
        "test": "\nstart = [0, 2, 4]\nend = [7, 14, 6]\nn = len(start)\nd = 3\nprint(minDistance(start, end, n, d))\n",
        "output": "1\n",
        "fn_call": "minDistance"
    },
    {
        "text": "sum of all submatrices of a given matrix | python3 program to find the sum of all possible submatrices of a given matrix ; function to find the sum of all possible submatrices of a given matrix ; variable to store the required sum ; nested loop to find the number of submatrices , each number belongs to ; number of ways to choose from top - left elements ; number of ways to choose from bottom - right elements ; ",
        "context": "\nn = 3\n\n",
        "code": "def matrixSum(arr):\n    sum = 0\n    for i in range(n):\n        for j in range(n):\n            top_left = (i + 1) * (j + 1)\n            bottom_right = (n - i) * (n - j)\n            sum += (top_left * bottom_right * arr[i][j])\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    print(matrixSum(arr))\n",
        "output": "100\n",
        "fn_call": "matrixSum"
    },
    {
        "text": "prime points ( points that split a number into two primes ) | function to count number of digits ; function to check whether a number is prime or not . returns 0 if prime else - 1 ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to print prime points ; counting digits ; as single and double digit numbers do not have left and right number pairs ; finding all left and right pairs . printing the prime points accordingly . discarding first and last index point ; calculating left number ; calculating right number ; prime point condition ; no prime point found ; ",
        "context": "",
        "code": "def countDigits(n):\n    count = 0\n    while (n > 0):\n        count += 1\n        n = n // 10\n    return count\n\n\ndef checkPrime(n):\n    if (n <= 1):\n        return -1\n    if (n <= 3):\n        return 0\n    if (n % 2 == 0 or n % 3 == 0):\n        return -1\n    i = 5\n    while i * i <= n:\n        if (n % i == 0 or n % (i + 2) == 0):\n            return -1\n        i += 6\n    return 0\n\n\ndef printPrimePoints(n):\n    count = countDigits(n)\n    if (count == 1 or count == 2):\n        print(\"-1\")\n        return\n    found = False\n    for i in range(1, (count - 1)):\n        left = n // (pow(10, count - i))\n        right = n % (pow(10, count - i - 1))\n        if (checkPrime(left) == 0 and checkPrime(right) == 0):\n            print(i, end=\" \")\n            found = True\n    if (found == False):\n        print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 2317\n    printPrimePoints(n)\n",
        "output": "1 2 ",
        "fn_call": "printPrimePoints"
    },
    {
        "text": "heptacontagon number | finding the nth heptacontagon number ; ",
        "context": "",
        "code": "def heptacontagonNum(n):\n    return (68 * n * n - 66 * n) // 2\n",
        "test": "\nN = 3\nprint(\"3rd heptacontagon Number is =\", heptacontagonNum(N))\n",
        "output": "3rd heptacontagon Number is = 207\n",
        "fn_call": "heptacontagonNum"
    },
    {
        "text": "minimum sum of medians of all possible k length subsequences of a sorted array | function to find the minimum sum of all the medians of the k sized sorted arrays formed from the given array ; stores the distance between the medians ; stores the number of subsequences required ; stores the resultant sum ; iterate from start and add all the medians ; add the value of arr [ i ] to the variable minsum ; increment i by select the median to get the next median index ; decrement the value of totalarrays by 1 ; print the resultant minimum sum ; ",
        "context": "",
        "code": "def sumOfMedians(arr, N, K):\n    selectMedian = (K + 1) // 2\n    totalArrays = N // K\n    minSum = 0\n    i = selectMedian - 1\n    while (i < N and totalArrays != 0):\n        minSum = minSum + arr[i]\n        i = i + selectMedian\n        totalArrays -= 1\n    print(minSum)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    N = len(arr)\n    K = 2\n    sumOfMedians(arr, N, K)\n",
        "output": "6\n",
        "fn_call": "sumOfMedians"
    },
    {
        "text": "count of occurrences of each prefix in a string using modified kmp algorithm | function to print the count of all prefix in the given string ; iterate over string s ; print the prefix and their frequency ; function to implement the lps array to store the longest prefix which is also a suffix for every substring of the string s ; array to store lps values value of lps [ 0 ] is 0 by definition ; find the values of lps [ i ] for the rest of the string using two pointers and dp ; initially set the value of j as the longest prefix that is also a suffix for i as lps [ i - 1 ] ; check if the suffix of length j + 1 is also a prefix ; if s [ i ] = s [ j ] then , assign lps [ i ] as j + 1 ; if we reached j = 0 , assign lps [ i ] as 0 as there was no prefix equal to suffix ; return the calculated lps array ; function to count the occurrence of all the prefix in the string s ; call the prefix_function to get lps ; to store the occurrence of all the prefix ; count all the suffixes that are also prefix ; add the occurences of i to smaller prefixes ; adding 1 to all occ [ i ] for all the orignal prefix ; function call to print the occurence of all the prefix ; ",
        "context": "",
        "code": "def Print(occ, s):\n    for i in range(1, len(s) + 1):\n        print(s[0:i], \"occur\", occ[i], \"times.\")\n\n\ndef prefix_function(s):\n    LPS = [0 for i in range(len(s))]\n    for i in range(1, len(s)):\n        j = LPS[i - 1]\n        while (j > 0 and s[i] != s[j]):\n            j = LPS[j - 1]\n        if (s[i] == s[j]):\n            LPS[i] = j + 1\n        else:\n            LPS[i] = 0\n    return LPS\n\n\ndef count_occurence(s):\n    n = len(s)\n    LPS = prefix_function(s)\n    occ = [0 for i in range(n + 1)]\n    for i in range(n):\n        occ[LPS[i]] += 1\n    for i in range(n - 1, 0, -1):\n        occ[LPS[i - 1]] += occ[i]\n    for i in range(n + 1):\n        occ[i] += 1\n    Print(occ, s)\n",
        "test": "\nA = \"ABACABA\"\ncount_occurence(A)\n",
        "output": "A occur 4 times.\nAB occur 2 times.\nABA occur 2 times.\nABAC occur 1 times.\nABACA occur 1 times.\nABACAB occur 1 times.\nABACABA occur 1 times.\n",
        "fn_call": "count_occurence"
    },
    {
        "text": "find maximum path sum in a 2d matrix when exactly two left moves are allowed | python3 program to find maximum path sum in a 2d matrix when exactly two left moves are allowed ; function to return the maximum path sum ; copy last column i . e . starting and ending columns in another array ; calculate suffix sum in each row ; select the path we are going to follow ; ",
        "context": "\nimport numpy as np\nN = 3\nM = 3\n\n",
        "code": "def findMaxSum(arr):\n    sum = 0\n    b = np .zeros((N, M))\n    for i in range(N):\n        b[i][M - 1] = arr[i][M - 1]\n    for i in range(N):\n        for j in range(M - 2, -1, -1):\n            b[i][j] = arr[i][j] + b[i][j + 1]\n    for i in range(1, N):\n        for j in range(M):\n            sum = max(sum, b[i][j] + b[i - 1][j])\n            b[i][j] = max(b[i][j], b[i - 1][j] + arr[i][j])\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [[3, 7, 4], [1, 9, 6], [1, 7, 7]]\n    print(findMaxSum(arr))\n",
        "output": "34.0\n",
        "fn_call": "findMaxSum"
    },
    {
        "text": "eulerian number | return euleriannumber a ( n , m ) ; for each row from 1 to n ; for each column from 0 to m ; if i is greater than j ; if j is 0 , then make that state as 1. ; basic recurrence relation . ; ",
        "context": "",
        "code": "def eulerian(n, m):\n    dp = [[0 for x in range(m + 1)]for y in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            if (i > j):\n                if (j == 0):\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = (((i - j) * dp[i - 1][j - 1]) +\n                                ((j + 1) * dp[i - 1][j]))\n    return dp[n][m]\n",
        "test": "\nn = 3\nm = 1\nprint(eulerian(n, m))\n",
        "output": "4\n",
        "fn_call": "eulerian"
    },
    {
        "text": "longest alternating sub | function to calculate alternating sub - array for each index of array elements ; initialize the base state of len [ ] ; calculating value for each element ; if both elements are different then add 1 to next len [ i + 1 ] ; else initialize to 1 ; print lengths of binary subarrays . ; ",
        "context": "",
        "code": "def alternateSubarray(arr, n):\n    len = []\n    for i in range(n + 1):\n        len .append(0)\n    len[n - 1] = 1\n    for i in range(n - 2, -1, -1):\n        if (arr[i] ^ arr[i + 1]):\n            len[i] = len[i + 1] + 1\n        else:\n            len[i] = 1\n    for i in range(n):\n        print(len[i], \" \", end=\"\")\n",
        "test": "\narr = [True, False, True, False, False, True]\nn = len(arr)\nalternateSubarray(arr, n)\n",
        "output": "4  3  2  1  2  1  ",
        "fn_call": "alternateSubarray"
    },
    {
        "text": "number of visible boxes after putting one inside another | python3 program to count number of visible boxes . ; return the minimum number of visible boxes ; new queue of integers . ; sorting the array ; traversing the array ; checking if current element is greater than or equal to twice of front element ; pushing each element of array ; ",
        "context": "\nimport collections\n\n",
        "code": "def minimumBox(arr, n):\n    q = collections .deque([])\n    arr .sort()\n    q .append(arr[0])\n    for i in range(1, n):\n        now = q[0]\n        if (arr[i] >= 2 * now):\n            q .popleft()\n        q .append(arr[i])\n    return len(q)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 1, 2, 8]\n    n = len(arr)\n    print(minimumBox(arr, n))\n",
        "output": "1\n",
        "fn_call": "minimumBox"
    },
    {
        "text": "move spaces to front of string in single traversal | function to find spaces and move to beginning ; keep copying non - space characters ; move spaces to be beginning ; ",
        "context": "",
        "code": "def moveSpaceInFront(s):\n    i = len(s) - 1\n    for j in range(i, -1, -1):\n        if (s[j] != ' '):\n            s = s[:i] + s[j] + s[i + 1:]\n            i -= 1\n    while (i >= 0):\n        s = s[:i] + ' ' + s[i + 1:]\n        i -= 1\n    return s\n",
        "test": "\ns = \"Hey there, it's GeeksforGeeks\"\ns = moveSpaceInFront(s)\nprint(s)\n",
        "output": "   Heythere,it'sGeeksforGeeks\n",
        "fn_call": "moveSpaceInFront"
    },
    {
        "text": "remove duplicates from a string in o ( 1 ) extra space | method to remove duplicates ; table to keep track of visited characters ; to keep track of end index of resultant string ; ",
        "context": "\n",
        "code": "def removeDuplicatesFromString(string):\n    table = [0 for i in range(256)]\n    endIndex = 0\n    string = list(string)\n    for i in range(len(string)):\n        if (table[ord(string[i])] == 0):\n            table[ord(string[i])] = -1\n            string[endIndex] = string[i]\n            endIndex += 1\n    ans = \"\"\n    for i in range(endIndex):\n        ans += string[i]\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    temp = \"geeksforgeeks\"\n    print(removeDuplicatesFromString(temp))\n",
        "output": "geksfor\n",
        "fn_call": "removeDuplicatesFromString"
    },
    {
        "text": "longest bitonic subsequence | dp | lbs ( ) returns the length of the longest bitonic subsequence in arr [ ] of size n . the function mainly creates two temporary arrays lis [ ] and lds [ ] and returns the maximum lis [ i ] + lds [ i ] - 1. lis [ i ] == > longest increasing subsequence ending with arr [ i ] lds [ i ] == > longest decreasing subsequence starting with arr [ i ] ; allocate memory for lis [ ] and initialize lis values as 1 for all indexes ; compute lis values from left to right ; allocate memory for lds and initialize lds values for all indexes ; compute lds values from right to left for i in reversed ( range ( n - 1 ) ) : loop from n - 2 downto 0 for j in reversed ( range ( i - 1 , n ) ) : loop from n - 1 downto i - 1 ; return the maximum value of ( lis [ i ] + lds [ i ] - 1 ) ; ",
        "context": "",
        "code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if ((arr[i] > arr[j]) and (lis[i] < lis[j] + 1)):\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    if (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n        lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max((lis[i] + lds[i] - 1), maximum)\n    return maximum\n",
        "test": "\narr = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\nprint(\"Length of LBS is\", lbs(arr))\n",
        "output": "Length of LBS is 7\n",
        "fn_call": "lbs"
    },
    {
        "text": "check if a number exists having exactly n factors and k prime factors | function to compute the number of factors of the given number ; vector to store the prime factors ; while there are no two multiples in the number , divide it by 2 ; if the size is already greater than k , then return true ; computing the remaining divisors of the number ; if n is divisible by i , then it is a divisor ; if the size is already greater than k , then return true ; if the size is already greater than k , then return true ; if none of the above conditions satisfies , then return false ; function to check if it is possible to make a number having total n factors and k prime factors ; if total divisors are less than the number of prime divisors , then print no ; find the number of factors of n ; ",
        "context": "",
        "code": "def factors(n, k):\n    v = []\n    while (n % 2 == 0):\n        v .append(2)\n        n //= 2\n    if (len(v) >= k):\n        return True\n    for i in range(3, int(n ** (1 / 2)), 2):\n        while (n % i == 0):\n            n = n // i\n            v .append(i)\n        if (len(v) >= k):\n            return True\n    if (n > 2):\n        v .append(n)\n    if (len(v) >= k):\n        return True\n    return False\n\n\ndef operation(n, k):\n    answered = False\n    if (n < k):\n        answered = True\n        print(\"No\")\n    ok = factors(n, k)\n    if (not ok and not answered):\n        answered = True\n        print(\"No\")\n    if (ok and not answered):\n        print(\"Yes\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    k = 2\n    operation(n, k)\n",
        "output": "Yes\n",
        "fn_call": "operation"
    },
    {
        "text": "modify string by replacing all occurrences of given characters by specified replacing characters | function to modify given string by replacing characters ; store the size of string and the number of pairs ; initialize 2 character arrays ; traverse the string s update arrays arr [ ] and brr [ ] ; traverse the array of pairs p ; a -> character to be replaced b -> replacing character ; iterate over the range [ 0 , 25 ] ; if it is equal to current character , then replace it in the array b ; print the array brr [ ] ; ",
        "context": "",
        "code": "def replaceCharacters(s, p):\n    n, k = len(s), len(p)\n    arr = [0] * 26\n    brr = [0] * 26\n    for i in range(n):\n        arr[ord(s[i]) - ord('a')] = s[i]\n        brr[ord(s[i]) - ord('a')] = s[i]\n    for j in range(k):\n        a, b = p[j][0], p[j][1]\n        for i in range(26):\n            if (arr[i] == a):\n                brr[i] = b\n    for i in range(n):\n        print(brr[ord(s[i]) - ord('a')], end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"aabbgg\"\n    P = [['a', 'b'], ['b', 'g'], ['g', 'a']]\n    replaceCharacters(S, P)\n",
        "output": "bbggaa",
        "fn_call": "replaceCharacters"
    },
    {
        "text": "queries to find minimum sum of array elements from either end of an array | function to calculate the minimum sum from either end of the arrays for the given queries ; traverse the query [ ] array ; stores sum from start and end of the array ; calculate distance from start ; calculate distance from end ; ",
        "context": "",
        "code": "def calculateQuery(arr, N, query, M):\n    for i in range(M):\n        X = query[i]\n        sum_start = 0\n        sum_end = 0\n        for j in range(N):\n            sum_start += arr[j]\n            if (arr[j] == X):\n                break\n        for j in range(N - 1, -1, -1):\n            sum_end += arr[j]\n            if (arr[j] == X):\n                break\n        print(min(sum_end, sum_start), end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 3, 6, 7, 4, 5, 30]\n    queries = [6, 5]\n    N = len(arr)\n    M = len(queries)\n    calculateQuery(arr, N, queries, M)\n",
        "output": "11 27 ",
        "fn_call": "calculateQuery"
    },
    {
        "text": "check whether frequency of characters in a string makes fibonacci sequence | python3 program to check whether the frequency of characters in a string make fibonacci sequence ; function to check if the frequencies are in fibonacci series ; map to store the frequencies of character ; vector to store first n fibonacci numbers ; get the size of the map ; a and b are first and second terms of fibonacci series ; vector v contains elements of fibonacci series ; compare vector elements with values in map ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def isFibonacci(s):\n    m = defaultdict(lambda: 0)\n    for i in range(0, len(s)):\n        m[s[i]] += 1\n    v = []\n    n = len(m)\n    a = b = 1\n    v .append(a)\n    v .append(b)\n    for i in range(0, n - 2):\n        v .append(a + b)\n        c = a + b\n        a, b = b, c\n    flag, i = 1, 0\n    for itr in sorted(m):\n        if m[itr] != v[i]:\n            flag = 0\n            break\n        i += 1\n    if flag == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abeeedd\"\n    print(isFibonacci(s))\n",
        "output": "YES\n",
        "fn_call": "isFibonacci"
    },
    {
        "text": "find the remainder when n is divided by 4 using bitwise and operator | function to find the remainder ; bitwise and with 3 ; return x ; ",
        "context": "",
        "code": "def findRemainder(n):\n    x = n & 3\n    return x\n",
        "test": "\nif __name__ == '__main__':\n    N = 43\n    ans = findRemainder(N)\n    print(ans)\n",
        "output": "3\n",
        "fn_call": "findRemainder"
    },
    {
        "text": "make the array non | function to make array non - decreasing ; take the first element ; perform the operation ; traverse the array ; next element ; if next element is greater than the current element then decrease it to increase the possibilities ; it is not possible to make the array non - decreasing with the given operation ; next element is now the current ; the array can be made non - decreasing with the given operation ; ",
        "context": "",
        "code": "def isPossible(a, n):\n    cur = a[0]\n    cur -= 1\n    for i in range(1, n):\n        nxt = a[i]\n        if (nxt > cur):\n            nxt -= 1\n        elif (nxt < cur):\n            return False\n        cur = nxt\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 1, 2, 3]\n    n = len(a)\n    if (isPossible(a, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "memoization ( 1d , 2d and 3d ) | fibonacci series using recursion ; base case ; recursive calls ; ",
        "context": "",
        "code": "def fib(n):\n    if (n <= 1):\n        return n\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "\nif __name__ == '__main__':\n    n = 6\n    print(fib(n))\n",
        "output": "8\n",
        "fn_call": "fib"
    },
    {
        "text": "check whether triangle is valid or not if three points are given | function to check if three points make a triangle ; calculation the area of triangle . we have skipped multiplication with 0.5 to avoid floating point computations ; condition to check if area is not equal to 0 ; ",
        "context": "",
        "code": "def checkTriangle(x1, y1, x2, y2, x3, y3):\n    a = (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if a == 0:\n        print('No')\n    else:\n        print('Yes')\n",
        "test": "\nif __name__ == '__main__':\n    (x1, x2, x3) = (1, 2, 3)\n    (y1, y2, y3) = (1, 2, 3)\n    checkTriangle(x1, y1, x2, y2, x3, y3)\n",
        "output": "No\n",
        "fn_call": "checkTriangle"
    },
    {
        "text": "highest power of a number that divides other number | python program to implement the above approach ; function to get the prime factors and its count of times it divides ; count the number of 2 s that divide n ; n must be odd at this point . so we can skip one element ( note i = i + 2 ) ; while i divides n , count i and divide n ; this condition is to handle the case when n is a prime number greater than 2 ; function to return the highest power ; initialize two arrays ; get the prime factors of n and m ; iterate and find the maximum power ; if i not a prime factor of n and m ; if i is a prime factor of n and m if count of i dividing m is more than i dividing n , then power will be 0 ; if i is a prime factor of m ; get the maximum power ; ",
        "context": "\nimport math\n\n",
        "code": "def primeFactors(n, freq):\n    cnt = 0\n    while n % 2 == 0:\n        cnt = cnt + 1\n        n = int(n // 2)\n    freq[2] = cnt\n    i = 3\n    while i <= math .sqrt(n):\n        cnt = 0\n        while (n % i == 0):\n            cnt = cnt + 1\n            n = int(n // i)\n        freq[int(i)] = cnt\n        i = i + 2\n    if (n > 2):\n        freq[int(n)] = 1\n\n\ndef getMaximumPower(n, m):\n    freq1 = [0] * (n + 1)\n    freq2 = [0] * (m + 1)\n    primeFactors(n, freq1)\n    primeFactors(m, freq2)\n    maxi = 0\n    i = 2\n    while i <= m:\n        if (freq1[i] == 0 and freq2[i] == 0):\n            i = i + 1\n            continue\n        if (freq2[i] > freq1[i]):\n            return 0\n        if (freq2[i]):\n            maxi = max(maxi, int(freq1[i] // freq2[i]))\n        i = i + 1\n    return maxi\n",
        "test": "\nn = 48\nm = 4\nprint(getMaximumPower(n, m))\n",
        "output": "2\n",
        "fn_call": "getMaximumPower"
    },
    {
        "text": "finding sum of digits of a number until sum becomes single digit | python program to find sum of digits of a number until sum becomes single digit . ; method to find sum of digits of a number until sum becomes single digit ; ",
        "context": "\nimport math\n\n",
        "code": "def digSum(n):\n    sum = 0\n    while (n > 0 or sum > 9):\n        if (n == 0):\n            n = sum\n            sum = 0\n        sum += n % 10\n        n /= 10\n    return sum\n",
        "test": "\nn = 1234\nprint(digSum(n))\n",
        "output": "2.3456790123456845\n",
        "fn_call": "digSum"
    },
    {
        "text": "previous greater element | python 3 program previous greater element a naive solution to print previous greater element for every element in an array . ; previous greater for first element never exists , so we print - 1. ; let us process remaining elements . ; find first element on left side that is greater than arr [ i ] . ; if all elements on left are smaller . ; ",
        "context": "",
        "code": "def prevGreater(arr, n):\n    print(\"-1\", end=\", \")\n    for i in range(1, n):\n        flag = 0\n        for j in range(i - 1, -1, -1):\n            if arr[i] < arr[j]:\n                print(arr[j], end=\", \")\n                flag = 1\n                break\n        if j == 0 and flag == 0:\n            print(\"-1\", end=\", \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 4, 2, 20, 40, 12, 30]\n    n = len(arr)\n    prevGreater(arr, n)\n",
        "output": "-1, 10, 4, -1, -1, 40, 40, ",
        "fn_call": "prevGreater"
    },
    {
        "text": "minimum move to end operations to make all strings equal | python 3 program to make all strings same using move to end operations . ; returns minimum number of moves to end operations to make all strings same . ; consider s [ i ] as target string and count rotations required to make all other strings same as str [ i ] . ; find function returns the index where we found arr [ i ] which is actually count of move - to - front operations . ; if any two strings are not rotations of each other , we can 't make them same. ; ",
        "context": "\nimport sys\n\n",
        "code": "def minimunMoves(arr, n):\n    ans = sys .maxsize\n    for i in range(n):\n        curr_count = 0\n        for j in range(n):\n            tmp = arr[j] + arr[j]\n            index = tmp .find(arr[i])\n            if (index == len(arr[i])):\n                return -1\n            curr_count += index\n        ans = min(curr_count, ans)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"xzzwo\", \"zwoxz\", \"zzwox\", \"xzzwo\"]\n    n = len(arr)\n    print(minimunMoves(arr, n))\n",
        "output": "5\n",
        "fn_call": "minimunMoves"
    },
    {
        "text": "minimum changes required to make first string substring of second string | python3 program to find the minimum number of characters to be replaced in string s2 , such that s1 is a substring of s2 ; function to find the minimum number of characters to be replaced in string s2 , such that s1 is a substring of s2 ; get the sizes of both strings ; traverse the string s2 ; from every index in s2 , check the number of mis - matching characters in substring of length of s1 ; take minimum of prev and current mis - match ; return answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def minimumChar(S1, S2):\n    n, m = len(S1), len(S2)\n    ans = sys .maxsize\n    for i in range(m - n + 1):\n        minRemovedChar = 0\n        for j in range(n):\n            if (S1[j] != S2[i + j]):\n                minRemovedChar += 1\n        ans = min(minRemovedChar, ans)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    S1 = \"abc\"\n    S2 = \"paxzk\"\n    print(minimumChar(S1, S2))\n",
        "output": "2\n",
        "fn_call": "minimumChar"
    },
    {
        "text": "Summing the sum series | Python3 program to calculate the terms of summing of sum series ; Function to calculate twice of sum of first N natural numbers ; Function to calculate the terms of summing of sum series ;",
        "context": "\nMOD = 1000000007\n\n",
        "code": "def Sum(N):\n    val = N * (N + 1)\n    val = val % MOD\n    return val\n\n\ndef sumX(N, M, K):\n    for i in range(M):\n        N = int(Sum(K + N))\n    N = N % MOD\n    return N\n",
        "test": "\nif __name__ == \"__main__\":\n    MOD = 1000000007\n    N, M, K = 1, 2, 3\n    print(sumX(N, M, K))\n",
        "output": "552\n",
        "fn_call": "sumX"
    },
    {
        "text": "padovan sequence | function to calculate padovan number p ( n ) ; 0 th , 1 st and 2 nd number of the series are 1 ; ",
        "context": "",
        "code": "def pad(n):\n    pPrevPrev, pPrev, pCurr, pNext = 1, 1, 1, 1\n    for i in range(3, n + 1):\n        pNext = pPrevPrev + pPrev\n        pPrevPrev = pPrev\n        pPrev = pCurr\n        pCurr = pNext\n    return pNext\n",
        "test": "\nprint(pad(12))\n",
        "output": "21\n",
        "fn_call": "pad"
    },
    {
        "text": "count ways to divide c in two parts and add to a and b to make a strictly greater than b | function to count the number of ways to divide c into two parts and add to a and b such that a is strictly greater than b ; minimum value added to a to satisfy the given relation ; number of different values of a , i . e . , number of ways to divide c ; ",
        "context": "",
        "code": "def countWays(A, B, C):\n    minAddA = max(0, (C + B - A + 2) // 2)\n    count_ways = max(C - minAddA + 1, 0)\n    return count_ways\n",
        "test": "\nA = 3\nB = 5\nC = 5\nprint(countWays(A, B, C))\n",
        "output": "2\n",
        "fn_call": "countWays"
    },
    {
        "text": "largest ratio contiguous subarray | python3 program for the above approach ; function to return maximum of two double values ; check if a is greater than b then return a ; function that returns the ratio of max ratio subarray ; variable to store the maximum ratio ; compute the product while traversing for subarrays ; calculate the ratio ; update max ratio ; print the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def maximum(a, b):\n    if (a > b):\n        return a\n    return b\n\n\ndef maxSubarrayRatio(arr, n):\n    maxRatio = -sys .maxsize - 1\n    for i in range(n):\n        for j in range(i, n):\n            ratio = arr[i]\n            for k in range(i + 1, j + 1):\n                ratio = ratio // arr[k]\n            maxRatio = maximum(maxRatio, ratio)\n    return int(maxRatio)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 2, 4, -0.2, -1]\n    n = len(arr)\n    print(maxSubarrayRatio(arr, n))\n",
        "output": "20\n",
        "fn_call": "maxSubarrayRatio"
    },
    {
        "text": "tetradic primes | function to check if the number n having all digits lies in the set ( 0 , 1 , 8 ) ; function to check if the number n is palindrome ; function to check if a number n is tetradic ; function to generate all primes and checking whether number is tetradic or not ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; print all tetradic prime numbers ; checking whether the given number is prime tetradic or not ; ",
        "context": "",
        "code": "def isContaindigit(n):\n    temp = str(n)\n    for i in temp:\n        if i not in ['0', '1', '8']:\n            return False\n    return True\n\n\ndef ispalindrome(n):\n    temp = str(n)\n    if temp == temp[::-1]:\n        return True\n    return False\n\n\ndef isTetradic(n):\n    if ispalindrome(n):\n        if isContaindigit(n):\n            return True\n    return False\n\n\ndef printTetradicPrimesLessThanN(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (prime[p]):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if (prime[p] and isTetradic(p)):\n            print(p, end=\" \")\n",
        "test": "\nn = 1000\nprintTetradicPrimesLessThanN(n)\n",
        "output": "11 101 181 ",
        "fn_call": "printTetradicPrimesLessThanN"
    },
    {
        "text": "lexicographically next greater string using same character set | function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; ",
        "context": "",
        "code": "def lexoString(s, k):\n    n = len(s)\n    v = []\n    mp = {s[i]: 0 for i in range(len(s))}\n    for i in range(len(s)):\n        if (mp[s[i]] == 0):\n            mp[s[i]] = 1\n            v .append(s[i])\n    v .sort(reverse=False)\n    if (k > n):\n        print(s, end=\"\")\n        for i in range(n, k, 1):\n            print(v[0], end=\"\")\n        return\n    i = k - 1\n    while (i >= 0):\n        if (s[i] != v[len(v) - 1]):\n            for j in range(0, i, 1):\n                print(s[j], end=\" \")\n            for j in range(0, len(v), 1):\n                if (v[j] > s[i]):\n                    print(v[j], end=\" \")\n                    break\n            for j in range(i + 1, k, 1):\n                print(v[0], end=\" \")\n            re1turn\n        i -= 1\n    print(\n        \"No lexicographically greater\",\n        \"string of length\",\n        k,\n        \"possible here.\")\n",
        "test": "\nif __name__ == '__main__':\n    s = \"gi\"\n    k = 3\n    lexoString(s, k)\n",
        "output": "gig",
        "fn_call": "lexoString"
    },
    {
        "text": "collect maximum coins before hitting a dead end | a naive recursive python 3 program to find maximum number of coins that can be collected before hitting a dead end ; to check whether current cell is out of the grid or not ; dir = 0 for left , dir = 1 for facing right . this function returns number of maximum coins that can be collected starting from ( i , j ) . ; if this is a invalid cell or if cell is a blocking cell ; check if this cell contains the coin ' c ' or if its empty ' e ' . ; get the maximum of two cases when you are facing right in this cell ; direction is right ; direction is left get the maximum of two cases when you are facing left in this cell ; ",
        "context": "\nR = 5\nC = 5\n\n",
        "code": "def isValid(i, j):\n\n    return (i >= 0 and i = 0 and j < C)\n\n\ndef maxCoinsRec(arr, i, j, dir):\n    if (isValid(i, j) == False or arr[i][j] == '#'):\n        return 0\n    if (arr[i][j] == 'C'):\n        result = 1\n    else:\n        result = 0\n\n    if (dir == 1):\n\n        return (result + max(maxCoinsRec(arr, i+1, j, 0),\n                             maxCoinsRec(arr, i, j+1, 1)))\n\n    return (result + max(maxCoinsRec(arr, i+1, j, 1),\n                         maxCoinsRec(arr, i, j-1, 0)))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [['E', 'C', 'C', 'C', 'C'],\n           ['C', '#', 'C', '#', 'E'],\n           ['#', 'C', 'C', '#', 'C'],\n           ['C', 'E', 'E', 'C', 'E'],\n           ['C', 'E', '#', 'C', 'E']]\n\n    print(\"Maximum number of collected coins is \", maxCoinsRec(arr, 0, 0, 1))\n",
        "output": "Maximum number of collected coins is  8\n",
        "fn_call": "maxCoinsRec"
    },
    {
        "text": "length of smallest subarray in range 1 to n with sum greater than a given value | function to do a binary search on a given range . ; total sum is the sum of n numbers . ; sum until mid ; if remaining sum is < the required value , then the required number is in the right half ; ",
        "context": "",
        "code": "def usingBinarySearch(start, end, N, S):\n    if (start >= end):\n        return start\n    mid = start + (end - start) // 2\n    totalSum = (N * (N + 1)) // 2\n    midSum = (mid * (mid + 1)) // 2\n    if ((totalSum - midSum) <= S):\n        return usingBinarySearch(start, mid, N, S)\n    return usingBinarySearch(mid + 1, end, N, S)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    S = 11\n    print(N - usingBinarySearch(1, N, N, S) + 1)\n",
        "output": "3\n",
        "fn_call": "usingBinarySearch"
    },
    {
        "text": "median of two sorted arrays of same size | while loop to swap all smaller numbers to arr1 ; ",
        "context": "",
        "code": "def getMedian(ar1, ar2, n):\n    i, j = n - 1, 0\n    while (ar1[i] > ar2[j] and i > -1 and j < n):\n        ar1[i], ar2[j] = ar2[j], ar1[i]\n        i -= 1\n        j += 1\n    ar1 .sort()\n    ar2 .sort()\n    return (ar1[-1] + ar2[0]) >> 1\n",
        "test": "\nif __name__ == '__main__':\n    ar1 = [1, 12, 15, 26, 38]\n    ar2 = [2, 13, 17, 30, 45]\n    n1, n2 = len(ar1), len(ar2)\n    if (n1 == n2):\n        print('Median is', getMedian(ar1, ar2, n1))\n    else:\n        print(\"Doesn't work for arrays of unequal size\")\n",
        "output": "Median is 16\n",
        "fn_call": "getMedian"
    },
    {
        "text": "find n positive integers that satisfy the given equations | function to find n positive integers that satisfy the given conditions ; to store n positive integers ; place n - 1 one 's ; if can not place ( y - ( n - 1 ) ) as the nth integer ; place nth integer ; to store the sum of squares of n integers ; if it is less than x ; print the required integers ; ",
        "context": "",
        "code": "def findIntegers(n, x, y):\n    ans = []\n    for i in range(n - 1):\n        ans .append(1)\n    if (y - (n - 1) <= 0):\n        print(\"-1\", end=\"\")\n        return\n    ans .append(y - (n - 1))\n    store = 0\n    for i in range(n):\n        store += ans[i] * ans[i]\n    if (store < x):\n        print(\"-1\", end=\"\")\n        return\n    for i in range(n):\n        print(ans[i], end=\" \")\n",
        "test": "\nn, x, y = 3, 254, 18\nfindIntegers(n, x, y)\n",
        "output": "1 1 16 ",
        "fn_call": "findIntegers"
    },
    {
        "text": "find if a number is divisible by every number in a list | python program which check is a number divided with every element in list or not ; checking if a number is divided by every element or not ; ",
        "context": "",
        "code": "def findNoIsDivisibleOrNot(n, l=[]):\n    for i in range(0, len(l)):\n        if l[i] % n != 0:\n            return 0\n    return 1\n",
        "test": "\nl = [14, 12, 4, 18]\nn = 2\nif findNoIsDivisibleOrNot(n, l) == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "findNoIsDivisibleOrNot"
    },
    {
        "text": "count of nodes having odd divisors in the given subtree for q queries | python3 implementation to count the number of nodes having odd number of divisors for each query ; adjacency list for tree . ; array for values and answer at ith node . ; function to check whether n has odd divisors or not ; dfs function to pre - compute the answers ; initialize the count ; repeat for every child ; increase the count if current node has odd number of divisors ; ",
        "context": "\nimport math\nN = 100001\nadj = [[]for i in range(N)]\na = [0 for i in range(N)]\nans = [0 for i in range(N)]\n\n",
        "code": "def hasOddNumberOfDivisors(n):\n    if (math .sqrt(n) == int(math .sqrt(n))):\n        return True\n    return False\n\n\ndef dfs(node, parent):\n    count = 0\n    for i in adj[node]:\n        if (i != parent):\n            count += dfs(i, node)\n    if (hasOddNumberOfDivisors(a[node])):\n        count += 1\n    ans[node] = count\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    i = 0\n    q = [4, 1, 5, 3]\n    adj[1].append(2)\n    adj[2].append(1)\n    adj[2].append(3)\n    adj[3].append(2)\n    adj[3].append(4)\n    adj[4].append(3)\n    adj[1].append(5)\n    adj[5].append(1)\n    a[1] = 4\n    a[2] = 9\n    a[3] = 14\n    a[4] = 100\n    a[5] = 5\n    dfs(1, -1)\n    for i in range(len(q)):\n        print(ans[q[i]], end=' ')\n",
        "output": "1 3 0 1 ",
        "fn_call": "dfs"
    },
    {
        "text": "find product of all elements at indexes which are factors of m for all possible sorted subsequences of length m | python3 program to find the product of all the combinations of m elements from an array whose index in the sorted order divides m completely ; iterative function to calculate ( x ^ y ) % p in o ( log y ) ; if y is odd , multiply x with result ; y must be even now ; iterative function to calculate ( ncr ) % p and save in f [ n ] [ r ] c ( n , r ) % p = [ c ( n - 1 , r - 1 ) % p + c ( n - 1 , r ) % p ] % p and c ( n , 0 ) = c ( n , n ) = 1 ; if j > i then c ( i , j ) = 0 ; if i is equal to j then c ( i , j ) = 1 ; c ( i , j ) = ( c ( i - 1 , j ) + c ( i - 1 , j - 1 ) ) % p ; initialize the answer ; for every element arr [ i ] , x is count of occurrence of arr [ i ] in different set such that index of arr [ i ] in those sets divides m completely . ; finding the count of arr [ i ] by placing it at the index which divides m completely ; using fermat 's little theorem ; multiplying with the count ; ",
        "context": "\nm = 4\n\n",
        "code": "def power(x, y, p):\n    res = 1\n    x = x % p\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef nCr(n, p, f):\n    for i in range(n):\n        for j in range(m + 1):\n            if (j > i):\n                f[i][j] = 0\n            elif (j == 0 or j == i):\n                f[i][j] = 1\n            else:\n                f[i][j] = ((f[i - 1][j] + f[i - 1][j - 1]) % p)\n\n\ndef operations(arr, n, f):\n    p = 1000000007\n    nCr(n, p - 1, f)\n    arr .sort()\n    ans = 1\n    for i in range(n):\n        x = 0\n        for j in range(1, m + 1):\n            if (m % j == 0):\n                x = ((x + (f[n - i - 1][m - j] * f[i][j - 1]) %\n                     (p - 1)) % (p - 1))\n        ans = ((ans * power(arr[i], x, p)) % p)\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 5, 7, 9, 3]\n    n = len(arr)\n    f = [[0 for x in range(m + 1)]for y in range(n + 1)]\n    operations(arr, n, f)\n",
        "output": "808556639\n",
        "fn_call": "operations"
    },
    {
        "text": "count all prefixes of the given binary array which are divisible by x | function to return the count of total binary prefix which are divisible by x ; initialize with zero ; instead of converting all prefixes to decimal , take reminder with x ; if number is divisible by x then reminder = 0 ; ",
        "context": "",
        "code": "def CntDivbyX(arr, n, x):\n    number = 0\n    count = 0\n    for i in range(0, n):\n        number = (number * 2 + arr[i]) % x\n        if number == 0:\n            count += 1\n    return count\n",
        "test": "\narr = [1, 0, 1, 0, 1, 1, 0]\nn = 7\nx = 2\nprint(CntDivbyX(arr, n, x))\n",
        "output": "3\n",
        "fn_call": "CntDivbyX"
    },
    {
        "text": "number of index pairs such that s [ i ] and s [ j ] are anagrams | function to find number of pairs of integers i , j such that s [ i ] is an anagram of s [ j ] . ; to store the count of sorted strings ; traverse all strings and store in the map ; sort the string ; if string exists in map , increment count else create key value pair with count = 1 ; to store the number of pairs ; traverse through the map ; count the pairs for each string ; return the required answer ; ",
        "context": "",
        "code": "def anagram_pairs(s, n):\n    mp = dict()\n    for i in range(n):\n        temp_str = \"\".join(sorted(s[i]))\n        if temp_str in mp:\n            mp[temp_str] += 1\n        else:\n            mp[temp_str] = 1\n    ans = 0\n    for k in mp .values():\n        ans += (k * (k - 1)) // 2\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = [\"aaab\", \"aaba\", \"baaa\", \"cde\", \"dec\"]\n    n = len(s)\n    print(anagram_pairs(s, n))\n",
        "output": "4\n",
        "fn_call": "anagram_pairs"
    },
    {
        "text": "check three or more consecutive identical characters or numbers | python3 program to check three or more consecutiveidentical characters or numbers using regular expression ; function to check three or more consecutiveidentical characters or numbers using regular expression ; regex to check three or more consecutive identical characters or numbers ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidGUID(str):\n    regex = \"\\\\b([a-zA-Z0-9])\\\\1\\\\1+\\\\b\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"aaa\"\nprint(isValidGUID(str1))\nstr2 = \"11111\"\nprint(isValidGUID(str2))\nstr3 = \"aaab\"\nprint(isValidGUID(str3))\nstr4 = \"abc\"\nprint(isValidGUID(str4))\nstr5 = \"aa\"\nprint(isValidGUID(str5))\n",
        "output": "True\nTrue\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidGUID"
    },
    {
        "text": "find the area of quadrilateral when diagonal and the perpendiculars to it from opposite vertices are given | function to find the area of quadrilateral ; ",
        "context": "",
        "code": "def Area(d, h1, h2):\n    area = 0.5 * d * (h1 + h2)\n    return area\n",
        "test": "\nif __name__ == '__main__':\n    d = 6\n    h1 = 4\n    h2 = 3\n    print(\"Area of Quadrilateral = \", (Area(d, h1, h2)))\n",
        "output": "Area of Quadrilateral =  21.0\n",
        "fn_call": "Area"
    },
    {
        "text": "sum of the count of number of adjacent squares in an m x n grid | function to calculate the sum of all cells adjacent value ; ",
        "context": "",
        "code": "def summ(m, n):\n    return 8 * m * n - 6 * m - 6 * n + 4\n",
        "test": "\nm = 3\nn = 2\nprint(summ(m, n))\n",
        "output": "22\n",
        "fn_call": "summ"
    },
    {
        "text": "n 'th palindrome of k digits | a naive approach of python3 program of finding nth palindrome of k digit ; utility function to reverse the number n ; boolean function to check for palindromic number ; function for finding nth palindrome of k digits ; get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found  break the loop ; increment number for checking next palindrome ; ",
        "context": "\nimport math\n\n",
        "code": "def reverseNum(n):\n    rev = 0\n    while (n):\n        rem = n % 10\n        rev = (rev * 10) + rem\n        n = int(n / 10)\n    return rev\n\n\ndef isPalindrom(num):\n    return num == reverseNum(num)\n\n\ndef nthPalindrome(n, k):\n    num = math .pow(10, k - 1)\n    while (True):\n        if (isPalindrom(num)):\n            n -= 1\n        if (not n):\n            break\n        num += 1\n    return int(num)\n",
        "test": "\nn = 6\nk = 5\nprint(n, \"th palindrome of\", k, \"digit =\", nthPalindrome(n, k))\nn = 10\nk = 6\nprint(n, \"th palindrome of\", k, \"digit =\", nthPalindrome(n, k))\n",
        "output": "6 th palindrome of 5 digit = 10501\n10 th palindrome of 6 digit = 109901\n",
        "fn_call": "nthPalindrome"
    },
    {
        "text": "longest alternating subsequence with maximum sum | set 2 | function to check the sign of the element ; function to calculate and return the maximum sum of longest alternating subsequence ; iterate through the array ; stores the first element of a sequence of same sign ; traverse until an element with opposite sign is encountered ; update the maximum ; update the maximum sum ; update i ; return the maximum sum ; ",
        "context": "",
        "code": "def sign(x):\n    if (x > 0):\n        return 1\n    else:\n        return -1\n\n\ndef findMaxSum(arr, size):\n    max_sum = 0\n    i = 0\n    while i < size:\n        pres = arr[i]\n        j = i\n        while (j < size and (sign(arr[i]) == sign(arr[j]))):\n            pres = max(pres, arr[j])\n            j += 1\n        max_sum = max_sum + pres\n        i = j - 1\n        i += 1\n    return max_sum\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [-2, 8, 3, 8, -4, -15, 5, -2, -3, 1]\n    size = len(arr)\n    print(findMaxSum(arr, size))\n",
        "output": "6\n",
        "fn_call": "findMaxSum"
    },
    {
        "text": "largest number not exceeding n that does not contain any of the digits of s | function to obtain the largest number not exceeding num which does not contain any digits present in s ; stores digits of s ; traverse the string s ; set occurrence as true ; traverse the string n ; all digits of num are not present in string s ; largest digit not present in the string s ; set all digits from positions in + 1 to n - 1 as largestdig ; counting leading zeroes ; removing leading zeroes ; if the string becomes null ; return the largest number ; ",
        "context": "",
        "code": "def greatestReducedNumber(num, s):\n    vis_s = [False] * 10\n    for i in range(len(s)):\n        vis_s[(ord)(s[i]) - 48] = True\n    n = len(num)\n    In = -1\n    for i in range(n):\n        if (vis_s[ord(num[i]) - ord('0')]):\n            In = i\n            break\n    if (In == -1):\n        return num\n    for dig in range(ord(num[In]), ord('0') - 1, -1):\n        if (vis_s[dig - ord('0')] == False):\n            num = num[0: In] + chr(dig) + num[In + 1: n - In - 1]\n            break\n    LargestDig = '0'\n    for dig in range(ord('9'), ord('0') - 1, -1):\n        if (vis_s[dig - ord('0')] == False):\n            LargestDig = dig\n            break\n    for i in range(In + 1, n):\n        num = num[0: i] + chr(LargestDig)\n    Count = 0\n    for i in range(n):\n        if (num[i] == '0'):\n            Count += 1\n        else:\n            break\n    num = num[Count: n]\n    if (int(len(num)) == 0):\n        return \"0\"\n    return num\n",
        "test": "\nN = \"12345\"\nS = \"23\"\nprint(greatestReducedNumber(N, S))\n",
        "output": "11999\n",
        "fn_call": "greatestReducedNumber"
    },
    {
        "text": "find next sparse number | python3 program to find next sparse number ; find binary representation of x and store it in bin [ ] . bin [ 0 ] contains least significant bit ( lsb ) , next bit is in bin [ 1 ] , and so on . ; there my be extra bit in result , so add one extra bit ; the position till which all bits are finalized ; start from second bit ( next to lsb ) ; if current bit and its previous bit are 1 , but next bit is not 1. ; make the next bit 1 ; make all bits before current bit as 0 to make sure that we get the smallest next number ; store position of the bit set so that this bit and bits before it are not changed next time . ; find decimal equivalent of modified bin [ ] ; ",
        "context": "",
        "code": "def nextSparse(x):\n    bin = []\n    while (x != 0):\n        bin .append(x & 1)\n        x >>= 1\n    bin .append(0)\n    n = len(bin)\n    last_final = 0\n    for i in range(1, n - 1):\n        if ((bin[i] == 1 and bin[i - 1] == 1 and bin[i + 1] != 1)):\n            bin[i + 1] = 1\n            for j in range(i, last_final - 1, -1):\n                bin[j] = 0\n            last_final = i + 1\n    ans = 0\n    for i in range(n):\n        ans += bin[i] * (1 << i)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    x = 38\n    print(\"Next Sparse Number is\", nextSparse(x))\n",
        "output": "Next Sparse Number is 40\n",
        "fn_call": "nextSparse"
    },
    {
        "text": "sort an array containing two types of elements | method for segregation 0 and 1 given input array ; ",
        "context": "",
        "code": "def segregate0and1(arr, n):\n    type0 = 0\n    type1 = n - 1\n    while (type0 < type1):\n        if (arr[type0] == 1):\n            arr[type0], arr[type1] = arr[type1], arr[type0]\n            type1 -= 1\n        else:\n            type0 += 1\n",
        "test": "\narr = [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1]\nn = len(arr)\nsegregate0and1(arr, n)\nfor i in range(0, n):\n    print(arr[i], end=\" \")\n",
        "output": "0 0 0 1 1 1 1 1 1 1 1 ",
        "fn_call": "segregate0and1"
    },
    {
        "text": "modify array of strings by replacing characters repeating in the same or remaining strings | function to remove duplicate characters across the strings ; stores distinct characters ; size of the array ; stores the list of modified strings ; traverse the array ; stores the modified string ; iterate over the characters of the modified string ; if character is already present ; insert character into the set ; print the list of modified strings ; print each string ; ",
        "context": "",
        "code": "def removeDuplicateCharacters(arr):\n    cset = set([])\n    n = len(arr)\n    out = []\n    for st in arr:\n        out_curr = \"\"\n        for ch in st:\n            if (ch in cset):\n                continue\n            out_curr += ch\n            cset .add(ch)\n        if (len(out_curr)):\n            out .append(out_curr)\n    for i in range(len(out)):\n        print(out[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"Geeks\", \"For\", \"Geeks\", \"Post\"]\n    removeDuplicateCharacters(arr)\n",
        "output": "Geks For Pt ",
        "fn_call": "removeDuplicateCharacters"
    },
    {
        "text": "check if the given string of words can be formed from words present in the dictionary | function to check if the word is in the dictionary or not ; map to store all words in dictionary with their count ; adding all words in map ; search in map for all words in the sentence ; all words of sentence are present ; ",
        "context": "",
        "code": "def match_words(dictionary, sentence, n, m):\n    mp = dict()\n    for i in range(n):\n        mp[dictionary[i]] = mp .get(dictionary[i], 0) + 1\n    for i in range(m):\n        if (mp[sentence[i]]):\n            mp[sentence[i]] -= 1\n        else:\n            return False\n    return True\n",
        "test": "\ndictionary = [\n    \"find\",\n    \"a\",\n    \"geeks\",\n    \"all\",\n    \"for\",\n    \"on\",\n    \"geeks\",\n    \"answers\",\n    \"inter\"]\nn = len(dictionary)\nsentence = [\"find\", \"all\", \"answers\", \"on\", \"geeks\", \"for\", \"geeks\"]\nm = len(sentence)\nif (match_words(dictionary, sentence, n, m)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "match_words"
    },
    {
        "text": "number of ways to reach ( m , n ) in a matrix starting from the origin without visiting ( x , y ) | function for computing ncr ; function to find factorial of a number ; function for counting the number of ways to reach ( m , n ) without visiting ( x , y ) ; ",
        "context": "",
        "code": "def nCr(n, r):\n    return (fact(n) // (fact(r) * fact(n - r)))\n\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef countWays(m, n, x, y):\n    return (nCr(m + n, m) - nCr(x + y, x) * nCr(m + n - x - y, m - x))\n",
        "test": "\nm = 5\nn = 4\nx = 3\ny = 2\nprint(countWays(m, n, x, y))\n",
        "output": "66\n",
        "fn_call": "countWays"
    },
    {
        "text": "count number less than n which are product of perfect squares | python 3 program to count number less than n which are product of any two perfect squares ; function to count number less than n which are product of any two perfect squares ; ",
        "context": "\nimport math\n\n",
        "code": "def countNumbers(N):\n    return int(math .sqrt(N)) - 1\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 36\n    print(countNumbers(N))\n",
        "output": "5\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "kth smallest positive integer y such that its sum with x is same as its bitwise or with x | function to calculate k - th smallest solution ( y ) of equation x + y = x | y ; initialize the variable to store the answer ; the i - th bit of x is off ; the i - bit of k is on ; divide k by 2 ; if k becomes 0 then break ; ",
        "context": "",
        "code": "def KthSolution(X, K):\n    ans = 0\n    for i in range(64):\n        if not (X & (1 << i)):\n            if (K & 1):\n                ans |= (1 << i)\n            K >>= 1\n            if not K:\n                break\n    return ans\n",
        "test": "\nX = 10\nK = 5\nprint(KthSolution(X, K))\n",
        "output": "17\n",
        "fn_call": "KthSolution"
    },
    {
        "text": "find all missing numbers from a given sorted array | function to find the missing elements ; initialize diff ; check if diff and arr [ i ] - i both are equal or not ; loop for consecutive missing elements ; ",
        "context": "",
        "code": "def printMissingElements(arr, N):\n    diff = arr[0]\n    for i in range(N):\n        if (arr[i] - i != diff):\n            while (diff < arr[i] - i):\n                print(i + diff, end=\" \")\n                diff += 1\n",
        "test": "\narr = [6, 7, 10, 11, 13]\nN = len(arr)\nprintMissingElements(arr, N)\n",
        "output": "8 9 12 ",
        "fn_call": "printMissingElements"
    },
    {
        "text": "sum of all divisors from 1 to n | python3 code to find sum of all divisor of number up to 'n ; utility function to find sum of all divisor of number up to 'n ; find all divisors of i and add them ; ",
        "context": "\n'NEW_LINE'\n\n",
        "code": "def divisorSum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if i % j == 0:\n                if i / j == j:\n                    sum += j\n                else:\n                    sum += j + i / j\n            j = j + 1\n    return int(sum)\n",
        "test": "\nn = 4\nprint(divisorSum(n))\nn = 5\nprint(divisorSum(n))\n",
        "output": "15\n21\n",
        "fn_call": "divisorSum"
    },
    {
        "text": "minimum players required to win the game | python 3 program to find minimum players required to win the game anyhow ; function to calculate ( a ^ b ) % ( 10 ^ 9 + 7 ) . ; function to find the minimum required player ; computing the nenomenator ; computing modulo inverse of denominator ; final result ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def power(a, b):\n    res = 1\n    while (b):\n        if (b & 1):\n            res *= a\n            res %= mod\n        b //= 2\n        a *= a\n        a %= mod\n    return res\n\n\ndef minPlayer(n, k):\n    num = ((power(k, n) - 1) + mod) % mod\n    den = (power(k - 1, mod - 2) + mod) % mod\n    ans = (((num * den) % mod) * k) % mod\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n, k = 3, 3\n    print(minPlayer(n, k))\n",
        "output": "39\n",
        "fn_call": "minPlayer"
    },
    {
        "text": "find the player who wins the game of placing alternate + and | function to check which player wins the game ; stores the difference between + ve and - ve array elements ; traverse the array ; update diff ; checks if diff is even ; ",
        "context": "",
        "code": "def checkWinner(arr, N):\n    diff = 0\n    for i in range(N):\n        diff -= arr[i]\n    if (diff % 2 == 0):\n        print(\"A\")\n    else:\n        print(\"B\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2]\n    N = len(arr)\n    checkWinner(arr, N)\n",
        "output": "B\n",
        "fn_call": "checkWinner"
    },
    {
        "text": "minimum cost required to move all elements to the same position | function to find the minimum cost required to place all elements in the same position ; stores the count of even and odd elements ; traverse the array arr [ ] ; count even elements ; count odd elements ; print the minimum count ; ",
        "context": "",
        "code": "def minCost(arr):\n    odd = 0\n    even = 0\n    for i in range(len(arr)):\n        if (arr[i] % 2 == 0):\n            even += 1\n        else:\n            odd += 1\n    print(min(even, odd))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3]\n    minCost(arr)\n",
        "output": "1\n",
        "fn_call": "minCost"
    },
    {
        "text": "maximize 0 s in given array after replacing each element a [ i ] with ( a [ i ] * d + b [ i ] ) | python program for the above approach ; function to find the maximum number of 0 s in the array a [ ] after changing the array element to a [ i ] * d + b [ i ] ; stores the frequency of fractions needed to make each element 0 ; stores the maximum number of 0 ; traverse the array ; find the numerator and the denominator ; check if den is not equal to 0 ; divide num and den by their gcd ; check if num is not greater than 0 ; check if both num and den are equal to 0 ; increment the value of { num , den } in the map ; update the value of ans ; prthe value of ans + cnt ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def maxZeroes(A, B):\n    mp = {}\n    N = len(A)\n    ans = 0\n    cnt = 0\n    for i in range(N):\n        num = -B[i]\n        den = A[i]\n        gc = gcd(num, den)\n        if (den != 0):\n            num //= gc\n            den //= gc\n        if (num <= 0):\n            num *= -1\n            den *= -1\n        if (den == 0 and num == 0):\n            cnt += 1\n        if (den != 0):\n            mp[(num, den)] = mp .get((num, den), 0) + 1\n            ans = max(mp[(num, den)], ans)\n    print(ans + cnt)\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, -1]\n    B = [-6, -12, 6]\n    maxZeroes(A, B)\n",
        "output": "3\n",
        "fn_call": "maxZeroes"
    },
    {
        "text": "boolean parenthesization problem | dp | returns count of all possible parenthesizations that lead to result true for a boolean expression with symbols like true and false and operators like & , | and ^ filled between symbols ; fill diaginal entries first all diagonal entries in t [ i ] [ i ] are 1 if symbol [ i ] is t ( true ) . similarly , all f [ i ] [ i ] entries are 1 if symbol [ i ] is f ( false ) ; now fill t [ i ] [ i + 1 ] , t [ i ] [ i + 2 ] , t [ i ] [ i + 3 ] ... in order and f [ i ] [ i + 1 ] , f [ i ] [ i + 2 ] , f [ i ] [ i + 3 ] ... in order ; find place of parenthesization using current value of gap ; store total [ i ] [ k ] and total [ k + 1 ] [ j ] ; follow the recursive formulas according to the current operator ; ",
        "context": "",
        "code": "def countParenth(symb, oper, n):\n    F = [[0 for i in range(n + 1)]for i in range(n + 1)]\n    T = [[0 for i in range(n + 1)]for i in range(n + 1)]\n    for i in range(n):\n        if symb[i] == 'F':\n            F[i][i] = 1\n        else:\n            F[i][i] = 0\n        if symb[i] == 'T':\n            T[i][i] = 1\n        else:\n            T[i][i] = 0\n    for gap in range(1, n):\n        i = 0\n        for j in range(gap, n):\n            T[i][j] = F[i][j] = 0\n            for g in range(gap):\n                k = i + g\n                tik = T[i][k] + F[i][k]\n                tkj = T[k + 1][j] + F[k + 1][j]\n                if oper[k] == '&':\n                    T[i][j] += T[i][k] * T[k + 1][j]\n                    F[i][j] += (tik * tkj - T[i][k] * T[k + 1][j])\n                if oper[k] == '|':\n                    F[i][j] += F[i][k] * F[k + 1][j]\n                    T[i][j] += (tik * tkj - F[i][k] * F[k + 1][j])\n                if oper[k] == '^':\n                    T[i][j] += (F[i][k] * T[k + 1][j] + T[i][k] * F[k + 1][j])\n                    F[i][j] += (T[i][k] * T[k + 1][j] + F[i][k] * F[k + 1][j])\n            i += 1\n    return T[0][n - 1]\n",
        "test": "\nsymbols = \"TTFT\"\noperators = \"|&^\"\nn = len(symbols)\nprint(countParenth(symbols, operators, n))\n",
        "output": "4\n",
        "fn_call": "countParenth"
    },
    {
        "text": "replace specified matrix elements such that no two adjacent elements are equal | function to display the valid matrix ; traverse the matrix ; if the current cell is a free space and is even - indexed ; if the current cell is a free space and is odd - indexed ; print the matrix ; given n and m ; ",
        "context": "",
        "code": "def Print(arr, n, m):\n    for i in range(n):\n        for j in range(m):\n            a = arr[i][j]\n            if ((i + j) % 2 == 0 and a == 'F'):\n                arr[i][j] = '1'\n            elif (a == 'F'):\n                arr[i][j] = '2'\n    for i in range(n):\n        for j in range(m):\n            print(arr[i][j], end=\"\")\n        print()\n",
        "test": "\nn, m = 4, 4\narr = [['F', 'F', 'F', 'F'], ['F', 'O', 'F', 'F'],\n       ['F', 'F', 'O', 'F'], ['F', 'F', 'F', 'F']]\nPrint(arr, n, m)\n",
        "output": "1212\n2O21\n12O2\n2121\n",
        "fn_call": "Print"
    },
    {
        "text": "find the center of the circle using endpoints of diameter | function to find the center of the circle ; ",
        "context": "",
        "code": "def center(x1, x2, y1, y2):\n    print(int((x1 + x2) / 2), end=\"\")\n    print(\",\", int((y1 + y2) / 2))\n",
        "test": "\nx1 = -9\ny1 = 3\nx2 = 5\ny2 = -7\ncenter(x1, x2, y1, y2)\n",
        "output": "-2, -2\n",
        "fn_call": "center"
    },
    {
        "text": "find substrings that contain all vowels | returns true if x is vowel . ; function to check whether a character is vowel or not ; outer loop picks starting character and inner loop picks ending character . ; if current character is not vowel , then no more result substr1ings possible starting from str1 [ i ] . ; if vowel , then we insert it in hash ; if all vowels are present in current substr1ing ; ",
        "context": "",
        "code": "def isVowel(x):\n    if (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u'):\n        return True\n    return False\n\n\ndef FindSubstr1ing(str1):\n    n = len(str1)\n    for i in range(n):\n        hash = dict()\n        for j in range(i, n):\n            if (isVowel(str1[j]) == False):\n                break\n            hash[str1[j]] = 1\n            if (len(hash) == 5):\n                print(str1[i:j + 1], end=\" \")\n",
        "test": "\nstr1 = \"aeoibsddaeiouudb\"\nFindSubstr1ing(str1)\n",
        "output": "aeiou aeiouu ",
        "fn_call": "FindSubstr1ing"
    },
    {
        "text": "check if array sum can be made k by three operations on it | python program to find if array can have sum of k by applying three types of possible operations on it ; check if it is possible to achieve a sum with three operation allowed ; if sum id negative . ; if going out of bound . ; if sum is achieved . ; if the current state is not evaluated yet . ; replacing element with negative value of the element . ; substracting index number from the element . ; adding index number to the element . ; wrapper function ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def check(i, add, n, k, a, dp):\n    if add <= 0:\n        return False\n    if i >= n:\n        if add == k:\n            return True\n        return False\n    if dp[i][add] != -1:\n        return dp[i][add]\n    dp[i][add] = (\n        check(\n            i + 1,\n            add - 2 * a[i],\n            n,\n            k,\n            a,\n            dp) or check(\n            i + 1,\n            add,\n            n,\n            k,\n            a,\n            dp))\n    dp[i][add] = (check(i + 1, add - (i + 1), n, k, a, dp) or dp[i][add])\n    dp[i][add] = (check(i + 1, add + i + 1, n, k, a, dp) or dp[i][add])\n    return dp[i][add]\n\n\ndef wrapper(n, k, a):\n    add = 0\n    for i in range(n):\n        add += a[i]\n    dp = [-1] * MAX\n    for i in range(MAX):\n        dp[i] = [-1] * MAX\n    return check(0, add, n, k, a, dp)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4]\n    n = 4\n    k = 5\n    print(\"Yes\")if wrapper(n, k, a)else print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "wrapper"
    },
    {
        "text": "count greater elements on the left side of every array element | function to print the count of greater elements on left of each array element ; function to get the count of greater elements on left of each array element ; store distinct array elements in sorted order ; stores the count of greater elements on the left side ; traverse the array ; insert array elements into the set ; find previous greater element ; find the distance between the previous greater element of arr [ i ] and last element of the set ; ",
        "context": "",
        "code": "def display(countLeftGreater, N):\n    for i in range(N):\n        print(countLeftGreater[i], end=\" \")\n\n\ndef countGreater(arr, N):\n    St = set()\n    countLeftGreater = [0] * (N)\n    for i in range(N):\n        St .add(arr[i])\n        it = 0\n        for st in St:\n            if (arr[i] < st):\n                break\n            it += 1\n        countLeftGreater[i] = abs(it - len(St))\n    display(countLeftGreater, N)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [12, 1, 2, 3, 0, 11, 4]\n    N = len(arr)\n    countGreater(arr, N)\n",
        "output": "0 1 1 1 4 1 2 ",
        "fn_call": "countGreater"
    },
    {
        "text": "minimum number of jumps required to sort numbers placed on a number line | function to find the minimum number of jumps required to sort the array ; base case ; store the required result ; stores the current position of elements and their respective maximum jump ; used to check if a position is already taken by another element ; stores the sorted array a [ ] ; traverse the array w [ ] & update positions jumps array a [ ] ; sort the array a [ ] ; traverse the array a [ ] over the range [ 1 , n - 1 ] ; store the index of current element and its just smaller element in array w [ ] ; iterate until current element position is at most its just smaller element position ; update the position of the current element ; print the result ; ",
        "context": "",
        "code": "def minJumps(w, l, n):\n    if (n == 1):\n        print(0)\n        return\n    ans = 0\n    pos = {}\n    jump = {}\n    filled = {}\n    a = [0 for i in range(n)]\n    for i in range(n):\n        pos[w[i]] = i\n        filled[i] = True\n        jump[w[i]] = l[i]\n        a[i] = w[i]\n    a .sort()\n    for curr in range(1, n, 1):\n        currElementPos = pos[a[curr]]\n        prevElementPos = pos[a[curr - 1]]\n        if (currElementPos > prevElementPos):\n            continue\n        while (currElementPos <= prevElementPos or (\n                currElementPos in filled and filled[currElementPos])):\n            currElementPos += jump[a[curr]]\n            ans += 1\n        pos[a[curr]] = currElementPos\n        filled[currElementPos] = True\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    W = [2, 1, 4, 3]\n    L = [4, 1, 2, 4]\n    N = len(W)\n    minJumps(W, L, N)\n",
        "output": "5\n",
        "fn_call": "minJumps"
    },
    {
        "text": "divide n into k unique parts such that gcd of those parts is maximum | python3 implementation of the approach ; function to calculate maximum gcd ; minimum possible sum for k unique positive integers ; it is not possible to divide n into k unique parts ; all the factors greater than sqrt ( n ) are complementary of the factors less than sqrt ( n ) ; if i is a factor of n ; ",
        "context": "\nfrom math import sqrt, ceil, floor\n\n",
        "code": "def maxGCD(N, K):\n    minSum = (K * (K + 1)) / 2\n    if (N < minSum):\n        return -1\n    i = ceil(sqrt(N))\n    res = 1\n    while (i >= 1):\n        if (N % i == 0):\n            if (i >= minSum):\n                res = max(res, N / i)\n            if (N / i >= minSum):\n                res = max(res, i)\n        i -= 1\n    return res\n",
        "test": "\nN = 18\nK = 3\nprint(maxGCD(N, K))\n",
        "output": "3\n",
        "fn_call": "maxGCD"
    },
    {
        "text": "maximum of sum and product of digits until number is reduced to a single digit | function to sum the digits until it becomes a single digit ; function to product the digits until it becomes a single digit ; loop to do sum while sum is not less than or equal to 9 ; function to find the maximum among repeated sum and repeated product ; ",
        "context": "",
        "code": "def repeatedSum(n):\n    if (n == 0):\n        return 0\n    return 9 if (n % 9 == 0)else (n % 9)\n\n\ndef repeatedProduct(n):\n    prod = 1\n    while (n > 0 or prod > 9):\n        if (n == 0):\n            n = prod\n            prod = 1\n        prod *= n % 10\n        n //= 10\n    return prod\n\n\ndef maxSumProduct(N):\n    if (N < 10):\n        return N\n    return max(repeatedSum(N), repeatedProduct(N))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 631\n    print(maxSumProduct(n))\n",
        "output": "8\n",
        "fn_call": "maxSumProduct"
    },
    {
        "text": "steps to reduce n to zero by subtracting its most significant digit at every step | function to count the number of digits in a number m ; function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; ",
        "context": "",
        "code": "def countdig(m):\n    if (m == 0):\n        return 0\n    else:\n        return 1 + countdig(m // 10)\n\n\ndef countSteps(x):\n    c = 0\n    last = x\n    while (last):\n        digits = countdig(last)\n        digits -= 1\n        divisor = pow(10, digits)\n        first = last // divisor\n        lastnumber = first * divisor\n        skipped = (last - lastnumber) // first\n        skipped += 1\n        c += skipped\n        last = last - (first * skipped)\n    return c\n",
        "test": "\nn = 14\nprint(countSteps(n))\n",
        "output": "6\n",
        "fn_call": "countSteps"
    },
    {
        "text": "maximum in array which is at | function to find the index of max element that satisfies the condition ; finding index of max of the array ; returns - 1 if the max element is not twice of the i - th element . ; ",
        "context": "",
        "code": "def findIndex(arr):\n    maxIndex = 0\n    for i in range(0, len(arr)):\n        if (arr[i] > arr[maxIndex]):\n            maxIndex = i\n    for i in range(0, len(arr)):\n        if (maxIndex != i and arr[maxIndex] < (2 * arr[i])):\n            return -1\n    return maxIndex\n",
        "test": "\narr = [3, 6, 1, 0]\nprint(findIndex(arr))\n",
        "output": "1\n",
        "fn_call": "findIndex"
    },
    {
        "text": "program to add two fractions | function to return gcd of a and b ; function to convert the obtained fraction into it 's simplest form ; finding gcd of both terms ; converting both terms into simpler terms by dividing them by common factor ; function to add two fractions ; finding gcd of den1 and den2 ; denominator of final fraction obtained finding lcm of den1 and den2 lcm * gcd = a * b ; changing the fractions to have same denominator numerator of the final fraction obtained ; calling function to convert final fraction into it 's  simplest form ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef lowest(den3, num3):\n    common_factor = gcd(num3, den3)\n    den3 = int(den3 / common_factor)\n    num3 = int(num3 / common_factor)\n    print(num3, \"/\", den3)\n\n\ndef addFraction(num1, den1, num2, den2):\n    den3 = gcd(den1, den2)\n    den3 = (den1 * den2) / den3\n    num3 = ((num1) * (den3 / den1) + (num2) * (den3 / den2))\n    lowest(den3, num3)\n",
        "test": "\nnum1 = 1\nden1 = 500\nnum2 = 2\nden2 = 1500\nprint(num1, \"/\", den1, \" + \", num2, \"/\", den2, \" is equal to \", end=\"\")\naddFraction(num1, den1, num2, den2)\n",
        "output": "1 / 500  +  2 / 1500  is equal to 1 / 300\n",
        "fn_call": "addFraction"
    },
    {
        "text": "number of intersections between two ranges | python3 implementation of above approach ; function to return total number of intersections ; maximum possible number of intersections ; store all starting points of type1 ranges ; store all endpoints of type1 ranges ; starting point of type2 ranges ; ending point of type2 ranges ; subtract those ranges which are starting after r ; subtract those ranges which are ending before l ; ",
        "context": "\nfrom bisect import bisect as upper_bound\n\n",
        "code": "def FindIntersection(type1, n, type2, m):\n    ans = n * m\n    start = []\n    end = []\n    for i in range(n):\n        start .append(type1[i][0])\n        end .append(type1[i][1])\n    start = sorted(start)\n    start = sorted(end)\n    for i in range(m):\n        L = type2[i][0]\n        R = type2[i][1]\n        ans -= (len(start) - upper_bound(start, R))\n        ans -= (upper_bound(end, L - 1))\n    return ans\n",
        "test": "\ntype1 = [[1, 2], [2, 3], [4, 5], [6, 7]]\ntype2 = [[1, 5], [2, 3], [4, 7], [5, 7]]\nn = len(type1)\nm = len(type2)\nprint(FindIntersection(type1, n, type2, m))\n",
        "output": "9\n",
        "fn_call": "FindIntersection"
    },
    {
        "text": "sum of binomial coefficients | python program to find the sum of binomial coefficient . ; returns value of binomial coefficient sum ; ",
        "context": "\nimport math\n\n",
        "code": "def binomialCoeffSum(n):\n    return (1 << n)\n",
        "test": "\nn = 4\nprint(binomialCoeffSum(n))\n",
        "output": "16\n",
        "fn_call": "binomialCoeffSum"
    },
    {
        "text": "find xor of all elements in an array | function to find the xor of all elements in the array ; resultant variable ; iterating through every element in the array ; find xor with the result ; return the xor ; ",
        "context": "",
        "code": "def xorOfArray(arr, n):\n    xor_arr = 0\n    for i in range(n):\n        xor_arr = xor_arr ^ arr[i]\n    return xor_arr\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 9, 12, 13, 15]\n    n = len(arr)\n    print(xorOfArray(arr, n))\n",
        "output": "4\n",
        "fn_call": "xorOfArray"
    },
    {
        "text": "number of factors of very large number n modulo m where m is any prime number | python 3 implementation to find the number of factors of very large number n modulo m ; function for modular multiplication ; function to find the number of factors of large number n ; count the number of times 2 divides the number n ; condition to check if 2 divides it ; check for all the possible numbers that can divide it ; loop to check the number of times prime number i divides it ; condition to check if prime number i divides it ; condition to check if n at the end is a prime number . ; ",
        "context": "\nfrom math import sqrt\nmod = 1000000007\n\n",
        "code": "def mult(a, b):\n    return ((a % mod) * (b % mod)) % mod\n\n\ndef calculate_factors(n):\n    cnt = 0\n    ans = 1\n    while (n % 2 == 0):\n        cnt += 1\n        n = n // 2\n    if (cnt):\n        ans = mult(ans, (cnt + 1))\n    for i in range(3, int(sqrt(n)), 2):\n        cnt = 0\n        while (n % i == 0):\n            cnt += 1\n            n = n // i\n        if (cnt):\n            ans = mult(ans, (cnt + 1))\n    if (n > 2):\n        ans = mult(ans, 2)\n    return ans % mod\n",
        "test": "\nif __name__ == '__main__':\n    n = 19374857\n    mod = 17\n    print(calculate_factors(n))\n",
        "output": "8\n",
        "fn_call": "calculate_factors"
    },
    {
        "text": "divide given numeric string into at most two increasing subsequences which form an increasing string upon concatenation | function to check for valid subsequences ; stores which element belongs to which subsequence ; check for each pos if a possible subsequence exist or not ; last member of 1 subsequence ; last member of 2 nd subsequence ; check if current element can go to 2 nd subsequence ; check if the current elements belongs to first subsequence ; if the current element does not belong to any subsequence ; check if last digit of first subsequence is greater than pos ; if a subsequence is found , find the subsequences ; stores the resulting subsequences ; print the subsequence ; if no subsequence found , print - 1 ; ",
        "context": "",
        "code": "def findSubsequence(str):\n    n = len(str)\n    res = ['0'for i in range(n)]\n    for pos in range(10):\n        lst1 = '0'\n        flag = 1\n        lst2 = chr(pos + 48)\n        for i in range(n):\n            if (lst2 <= str[i]):\n                res[i] = '2'\n                lst2 = str[i]\n            elif (lst1 <= str[i]):\n                res[i] = '1'\n                lst1 = str[i]\n            else:\n                flag = 0\n        if (lst1 > chr(pos + 48)):\n            flag = 0\n        if (flag):\n            S1 = \"\"\n            S2 = \"\"\n            for i in range(n):\n                if (res[i] == '1'):\n                    S1 += str[i]\n                else:\n                    S2 += str[i]\n            print(S1, S2)\n            return\n    print(\"-1\")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"040425524644\"\n    findSubsequence(S)\n    S = \"123456789\"\n    findSubsequence(S)\n",
        "output": "0022444 44556\n 123456789\n",
        "fn_call": "findSubsequence"
    },
    {
        "text": "check if any valid sequence is divisible by m | python3 program to check if any valid sequence is divisible by m ; calculate modulo for this call ; base case ; check if sum is divisible by m ; check if the current state is already computed ; 1. try placing '+ ; 2. try placing '- ; calculate value of res for recursive case ; store the value for res for current states and return for parent call ; ",
        "context": "",
        "code": "def isPossible(n, index, modulo, M, arr, dp):\n    modulo = ((modulo % M) + M) % M\n    if (index == n):\n        if (modulo == 0):\n            return 1\n        return 0\n    if (dp[index][modulo] != -1):\n        return dp[index][modulo]\n\n    placeAdd = isPossible(n, index+1, modulo+arr[index], M, arr, dp)\n    placeMinus = isPossible(n, index + 1, modulo - arr[index], M, arr, dp)\n    res = bool(placeAdd or placeMinus)\n    dp[index][modulo] = res\n    return res\n",
        "test": "\nMAX = 100\narr = [1, 2, 3, 4, 6]\nn = len(arr)\nM = 4\ndp = [[-1] * (n + 1)] * MAX\nres = isPossible(n, 1, arr[0], M, arr, dp)\nif (res):\n    print(\"True\")\nelse:\n    print(\"False\")\n",
        "output": "True\n",
        "fn_call": "isPossible"
    },
    {
        "text": "check if an element is present in an array using at most floor ( n / 2 ) + 2 comparisons | function to check whether x is present in the array a [ ] ; initialise a pointer ; store the number of comparisons ; variable to store product ; check is n is odd ; update i and t ; traverse the array ; check if i < n ; update t ; check if t is equal to 0 ; ",
        "context": "",
        "code": "def findElement(A, N, X):\n    i = 0\n    Comparisons = 0\n    T = 1\n    Found = \"No\"\n    Comparisons += 1\n    if (N % 2 == 1):\n        i = 1\n        T *= (A[0] - X)\n    while (i < N):\n        Comparisons += 1\n        T *= (A[i] - X)\n        T *= (A[i + 1] - X)\n        i += 2\n    Comparisons += 1\n    if (T == 0):\n        print(\"Yes\", Comparisons)\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    A = [-3, 5, 11, 3, 100, 2, 88, 22, 7, 900, 23, 4, 1]\n    N = len(A)\n    X = 1\n    findElement(A, N, X)\n",
        "output": "Yes 8\n",
        "fn_call": "findElement"
    },
    {
        "text": "find initial integral solution of linear diophantine equation if finite solution exists | python3 program for the above approach ; function to implement the extended euclid algorithm ; base case ; recursively find the gcd ; function to prlet the solutions of the given equations ax + by = c ; condition for infinite solutions ; condition for no solutions exist ; condition for no solutions exist ; print the solution ; ",
        "context": "\nimport math\nx, y = 0, 0\n\n",
        "code": "def gcd_extend(a, b):\n    global x, y\n    if (b == 0):\n        x = 1\n        y = 0\n        return a\n    else:\n        g = gcd_extend(b, a % b)\n        x1, y1 = x, y\n        x = y1\n        y = x1 - math .floor(a / b) * y1\n        return g\n\n\ndef print_solution(a, b, c):\n    if (a == 0 and b == 0):\n        if (c == 0):\n            print(\"Infinite Solutions Exist\")\n        else:\n            print(\"No Solution exists\")\n    gcd = gcd_extend(a, b)\n    if (c % gcd != 0):\n        print(\"No Solution exists\")\n    else:\n        print(\"x = \", int(x * (c / gcd)), \", y = \", int(y * (c / gcd)), sep=\"\")\n",
        "test": "\na = 4\nb = 18\nc = 10\nprint_solution(a, b, c)\n",
        "output": "x = -20, y = 5\n",
        "fn_call": "print_solution"
    },
    {
        "text": "count subarrays for every array element in which they are the minimum | function to required count subarrays ; for storing count of subarrays ; for finding next smaller element left to a element if there is no next smaller element left to it than taking - 1. ; for finding next smaller element right to a element if there is no next smaller element right to it than taking n . ; taking exact boundaries in which arr [ i ] is minimum ; similarly for right side ; ",
        "context": "",
        "code": "def countingSubarray(arr, n):\n    a = [0 for i in range(n)]\n    nsml = [-1 for i in range(n)]\n    nsmr = [n for i in range(n)]\n    st = []\n    for i in range(n - 1, -1, -1):\n        while (len(st) > 0 and arr[st[-1]] >= arr[i]):\n            del st[-1]\n        if (len(st) > 0):\n            nsmr[i] = st[-1]\n        else:\n            nsmr[i] = n\n        st .append(i)\n    while (len(st) > 0):\n        del st[-1]\n    for i in range(n):\n        while (len(st) > 0 and arr[st[-1]] >= arr[i]):\n            del st[-1]\n        if (len(st) > 0):\n            nsml[i] = st[-1]\n        else:\n            nsml[i] = -1\n        st .append(i)\n    for i in range(n):\n        nsml[i] += 1\n        nsmr[i] -= 1\n        r = nsmr[i] - i + 1\n        l = i - nsml[i] + 1\n        a[i] = r * l\n    return a\n",
        "test": "\nN = 5\narr = [3, 2, 4, 1, 5]\na = countingSubarray(arr, N)\nprint(a)\n",
        "output": "[1, 4, 1, 8, 1]\n",
        "fn_call": "countingSubarray"
    },
    {
        "text": "count numbers ( smaller than or equal to n ) with given digit sum | n can be max 10 ^ 18 and hence digitsum will be 162 maximum . ; if sum_so_far equals to given sum then return 1 else 0 ; our constructed number should not become greater than n . ; if tight is true then it will also be true for ( i + 1 ) digit . ; ",
        "context": "",
        "code": "def solve(i, tight, sum_so_far, Sum, number, length):\n    if i == length:\n        if sum_so_far == Sum:\n            return 1\n        else:\n            return 0\n    ans = dp[i][tight][sum_so_far]\n    if ans != -1:\n        return ans\n    ans = 0\n    for currdigit in range(0, 10):\n        currdigitstr = str(currdigit)\n        if not tight and currdigitstr > number[i]:\n            break\n        ntight = tight or currdigitstr < number[i]\n        nsum_so_far = sum_so_far + currdigit\n        ans += solve(i + 1, ntight, nsum_so_far, Sum, number, length)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    count, Sum = 0, 4\n    number = \"100\"\n    dp = [[[-1 for i in range(162)]for j in range(2)]for k in range(18)]\n    print(solve(0, 0, 0, Sum, number, len(number)))\n",
        "output": "5\n",
        "fn_call": "solve"
    },
    {
        "text": "tidy number ( digits in non | returns true if num is tidy ; to store previous digit ( assigning initial value which is more than any digit ) ; traverse all digits from right to left and check if any digit is smaller than previous . ; ",
        "context": "",
        "code": "def isTidy(num):\n    prev = 10\n    while (num):\n        rem = num % 10\n        num /= 10\n        if rem > prev:\n            return False\n        prev = rem\n    return True\n",
        "test": "\nnum = 1556\nif isTidy(num):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isTidy"
    },
    {
        "text": "find minimum sum such that one of every three consecutive elements is taken | a utility function to find minimum of 3 elements ; returns minimum possible sum of elements such that an element out of every three consecutive elements is picked . ; create a dp table to store results of subproblems . sum [ i ] is going to store minimum possible sum when arr [ i ] is part of the solution . ; when there are less than or equal to 3 elements ; iterate through all other elements ; ",
        "context": "",
        "code": "def minimum(a, b, c):\n    return min(min(a, b), c)\n\n\ndef findMinSum(arr, n):\n    sum = []\n    sum .append(arr[0])\n    sum .append(arr[1])\n    sum .append(arr[2])\n    for i in range(3, n):\n        sum .append(arr[i] + minimum(sum[i - 3], sum[i - 2], sum[i - 1]))\n    return minimum(sum[n - 1], sum[n - 2], sum[n - 3])\n",
        "test": "\narr = [1, 2, 3, 20, 2, 10, 1]\nn = len(arr)\nprint(\"Min Sum is \", findMinSum(arr, n))\n",
        "output": "Min Sum is  4\n",
        "fn_call": "findMinSum"
    },
    {
        "text": "maximum value possible by rotating digits of a given number | function to find the maximum value possible by rotations of digits of n ; store the required result ; store the number of digits ; iterate over the range [ 1 , len - 1 ] ; store the unit 's digit ; store the remaining number ; find the next rotation ; if the current rotation is greater than the overall answer , then update answer ; print the result ; ",
        "context": "",
        "code": "def findLargestRotation(num):\n    ans = num\n    length = len(str(num))\n    x = 10 ** (length - 1)\n    for i in range(1, length):\n        lastDigit = num % 10\n        num = num // 10\n        num += (lastDigit * x)\n        if (num > ans):\n            ans = num\n    print(ans)\n",
        "test": "\nN = 657\nfindLargestRotation(N)\n",
        "output": "765\n",
        "fn_call": "findLargestRotation"
    },
    {
        "text": "find the number of ways to divide number into four parts such that a = c and b = d | function to find the number of ways to divide n into four parts such that a = c and b = d ; ",
        "context": "",
        "code": "def possibleways(n):\n    if (n % 2 == 1):\n        return 0\n    elif (n % 4 == 0):\n        return n // 4 - 1\n    else:\n        return n // 4\n",
        "test": "\nn = 20\nprint(possibleways(n))\n",
        "output": "4\n",
        "fn_call": "possibleways"
    },
    {
        "text": "modify an array by sorting after reversal of bits of each array element | function to convert binary number to equivalent decimal ; set base value to 1 , i . e 2 ^ 0 ; function to convert a decimal to equivalent binary representation ; stores the binary representation ; since ascii value of '0' , '1' are 48 and 49 ; as the string is already reversed , no further reversal is required ; function to convert the reversed binary representation to equivalent integer ; stores reversed binary representation of given decimal ; stores equivalent decimal value of the binary representation ; return the resultant integer ; utility function to print the sorted array ; sort the array ; traverse the array ; print the array elements ; utility function to reverse the binary representations of all array elements and sort the modified array ; traverse the array ; passing array elements to reversedbinarydecimal function ; pass the array to the sorted array ; ",
        "context": "",
        "code": "def binaryToDecimal(n):\n    num = n\n    dec_value = 0\n    base = 1\n    length = len(num)\n    for i in range(length - 1, -1, -1):\n        if (num[i] == '1'):\n            dec_value += base\n        base = base * 2\n    return dec_value\n\n\ndef decimalToBinary(n):\n    binstr = \"\"\n    while (n > 0):\n        binstr += chr(n % 2 + 48)\n        n = n // 2\n    return binstr\n\n\ndef reversedBinaryDecimal(N):\n    decimal_to_binar = decimalToBinary(N)\n    binary_to_decimal = binaryToDecimal(decimal_to_binar)\n    return binary_to_decimal\n\n\ndef printSortedArray(arr, size):\n    arr .sort()\n    for i in range(size):\n        print(arr[i], end=\" \")\n    print()\n\n\ndef modifyArray(arr, size):\n    for i in range(size):\n        arr[i] = reversedBinaryDecimal(arr[i])\n    printSortedArray(arr, size)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [98, 43, 66, 83]\n    n = len(arr)\n    modifyArray(arr, n)\n",
        "output": "33 35 53 101 \n",
        "fn_call": "modifyArray"
    },
    {
        "text": "xor of xors of all sub | function to find to required xor value ; nested loop to find the number of sub - matrix each index belongs to ; number of ways to choose from top - left elements ; number of ways to choose from bottom - right elements ; ",
        "context": "",
        "code": "def submatrixXor(arr, n):\n    ans = 0\n    for i in range(0, n):\n        for j in range(0, n):\n            top_left = (i + 1) * (j + 1)\n            bottom_right = (n - i) * (n - j)\n            if (top_left % 2 == 1 and bottom_right % 2 == 1):\n                ans = (ans ^ arr[i][j])\n    return ans\n",
        "test": "\nn = 3\narr = [[6, 7, 13], [8, 3, 4], [9, 7, 6]]\nprint(submatrixXor(arr, n))\n",
        "output": "4\n",
        "fn_call": "submatrixXor"
    },
    {
        "text": "find all factorial numbers less than or equal to n | python3 program to find all factorial numbers smaller than or equal to n . ; compute next factorial using previous ; ",
        "context": "",
        "code": "def printFactorialNums(n):\n    fact = 1\n    x = 2\n    while fact <= n:\n        print(fact, end=\" \")\n        fact = fact * x\n        x += 1\n",
        "test": "\nn = 100\nprintFactorialNums(n)\n",
        "output": "1 2 6 24 ",
        "fn_call": "printFactorialNums"
    },
    {
        "text": "find the substring with maximum product | function to return the value of a character ; function to find the maximum product sub ; to store subs ; check if current product is maximum possible or not ; if product is 0 ; return the sub with maximum product ; ",
        "context": "",
        "code": "def value(x):\n    return (ord(x) - ord('a'))\n\n\ndef maximumProduct(strr, n):\n    answer = \"\"\n    curr = \"\"\n    maxProduct = 0\n    product = 1\n    for i in range(n):\n        product *= value(strr[i])\n        curr += strr[i]\n        if (product >= maxProduct):\n            maxProduct = product\n            answer = curr\n        if (product == 0):\n            product = 1\n            curr = \"\"\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"sdtfakdhdahdzz\"\n    n = len(strr)\n    print(maximumProduct(strr, n))\n",
        "output": "hdzz\n",
        "fn_call": "maximumProduct"
    },
    {
        "text": "sort 1 to n by swapping adjacent elements | return true if array can be sorted otherwise false ; check if array is sorted or not ; ",
        "context": "",
        "code": "def sortedAfterSwap(A, B, n):\n    for i in range(0, n - 1):\n        if B[i]:\n            if A[i] != i + 1:\n                A[i], A[i + 1] = A[i + 1], A[i]\n    for i in range(n):\n        if A[i] != i + 1:\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 5, 3, 4, 6]\n    B = [0, 1, 1, 1, 0]\n    n = len(A)\n    if (sortedAfterSwap(A, B, n)):\n        print(\"A can be sorted\")\n    else:\n        print(\"A can not be sorted\")\n",
        "output": "A can be sorted\n",
        "fn_call": "sortedAfterSwap"
    },
    {
        "text": "construct a string that has exactly k subsequences from given string | python3 program for the above approach ; function that computes the string s ; length of the given string str ; list that stores all the prime factors of given k ; find the prime factors ; initialize the count of each character position as 1 ; loop until the list becomes empty ; increase the character count by multiplying it with the prime factor ; if we reach end then again start from beginning ; store output ; print the string ; ",
        "context": "\nimport math\n\n",
        "code": "def printSubsequenceString(st, k):\n    n = len(st)\n    factors = []\n    sqt = (int(math .sqrt(k)))\n    for i in range(2, sqt + 1):\n        while (k % i == 0):\n            factors .append(i)\n            k //= i\n    if (k > 1):\n        factors .append(k)\n    count = [1] * n\n    index = 0\n    while (len(factors) > 0):\n        count[index] *= factors[-1]\n        factors .pop()\n        index += 1\n        if (index == n):\n            index = 0\n    s = \"\"\n    for i in range(n):\n        while (count[i] > 0):\n            s += st[i]\n            count[i] -= 1\n    print(s)\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"code\"\n    k = 20\n    printSubsequenceString(st, k)\n",
        "output": "cccccoodde\n",
        "fn_call": "printSubsequenceString"
    },
    {
        "text": "count inversions in a permutation of first n natural numbers | python3 program for the above approach ; function to count number of inversions in a permutation of first n natural numbers ; store array elements in sorted order ; store the count of inversions ; traverse the array ; store the index of first occurrence of arr [ i ] in vector v ; add count of smaller elements than current element ; erase current element from vector and go to next index ; print the result ; ",
        "context": "\nfrom bisect import bisect_left\n\n",
        "code": "def countInversions(arr, n):\n    v = []\n    for i in range(1, n + 1, 1):\n        v .append(i)\n    ans = 0\n    for i in range(n):\n        itr = bisect_left(v, arr[i])\n        ans += itr\n        v = v[:itr] + v[itr + 1:]\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 1, 5, 4]\n    n = len(arr)\n    countInversions(arr, n)\n",
        "output": "3\n",
        "fn_call": "countInversions"
    },
    {
        "text": "sort the given string using character search | python 3 implementation to sort the given string without using any sorting technique ; a character array to store the no . of occurrences of each character between ' a ' to 'z ; to store the final sorted string ; to store each occurrence of character by relative indexing ; to traverse the character array and append it to new_str ; ",
        "context": "",
        "code": "def sortString(st, n):\n\n    arr = [0] * 26\n    new_str = \"\"\n    for i in range(n):\n        arr[ord(st[i]) - ord('a')] += 1\n    for i in range(26):\n        while (arr[i] > 0):\n            new_str += chr(i + ord('a'))\n            arr[i] -= 1\n    return new_str\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"geeksforgeeks\"\n    n = len(st)\n    print(sortString(st, n))\n",
        "output": "eeeefggkkorss\n",
        "fn_call": "sortString"
    },
    {
        "text": "maximum score possible by removing substrings made up of single distinct character | function to check if the string s consists of a single distinct character or not ; function to calculate the maximum score possible by removing substrings ; if string is empty ; if length of string is 1 ; store the maximum result ; try to remove all substrings that satisfy the condition and check for resultant string after removal ; store the substring { s [ i ] , . . , s [ j ] } ; check if the substring contains only a single distinct character ; return the maximum score ; ",
        "context": "",
        "code": "def isUnique(s):\n    return True if len(set(s)) == 1 else False\n\n\ndef maxScore(s, a):\n    n = len(s)\n    if n == 0:\n        return 0\n    if n == 1:\n        return a[0]\n    mx = -1\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j + 1]\n            if isUnique(sub):\n                mx = max(mx, a[len(sub) - 1] + maxScore(s[:i] + s[j + 1:], a))\n    return mx\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"011\"\n    a = [1, 3, 1]\n    print(maxScore(s, a))\n",
        "output": "4\n",
        "fn_call": "maxScore"
    },
    {
        "text": "smallest pair of indices with product of subarray co | function to calculate gcd of two integers ; recursively calculate gcd ; function to find the lexicographically smallest pair of indices whose product is co - prime with the product of the subarrays on its left and right ; stores the suffix product of array elements ; set 0 / 1 if pair satisfies the given condition or not ; initialize array right_prod ; update the suffix product ; stores product of all elements ; stores the product of subarray in between the pair of indices ; iterate through every pair of indices ( i , j ) ; store product of a [ i , j ] ; check if product is co - prime to product of either the left or right subarrays ; if no such pair is found , then pr - 1 ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef findPair(A, N):\n    right_prod = [0] * N\n    flag = 0\n    right_prod[N - 1] = A[N - 1]\n    for i in range(N - 2, 0, -1):\n        right_prod[i] = right_prod[i + 1] * A[i]\n    total_prod = right_prod[0]\n    product = 1\n    for i in range(1, N - 1):\n        product = 1\n        for j in range(i, N - 1):\n            product *= A[j]\n            if (gcd(product,\n                    right_prod[j + 1]) == 1 or gcd(product,\n                                                   total_prod / right_prod[i]) == 1):\n                flag = 1\n                print(\"(\", (i - 1), \", \", (j + 1), \")\")\n                break\n        if (flag == 1):\n            break\n    if (flag == 0):\n        print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 4, 1, 3, 7]\n    N = len(arr)\n    findPair(arr, N)\n",
        "output": "( 0 ,  2 )\n",
        "fn_call": "findPair"
    },
    {
        "text": "lower case to upper case | converts a string to uppercase ; ",
        "context": "",
        "code": "def to_upper(s):\n    for i in range(len(s)):\n        if ('a' <= s[i] <= 'z'):\n            s = s[0:i] + chr(ord(s[i]) & (~(1 << 5))) + s[i + 1:]\n    return s\n",
        "test": "\nif __name__ == '__main__':\n    string = \"geeksforgeeks\"\n    print(to_upper(string))\n",
        "output": "GEEKSFORGEEKS\n",
        "fn_call": "to_upper"
    },
    {
        "text": "number of ordered pairs such that ( ai & aj ) = 0 | naive function to count the number of ordered pairs such that their bitwise and is 0 ; check for all possible pairs ; add 2 as ( i , j ) and ( j , i ) are considered different ; ",
        "context": "",
        "code": "def countPairs(a, n):\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (a[i] & a[j]) == 0:\n                count += 2\n    return count\n",
        "test": "\na = [3, 4, 2]\nn = len(a)\nprint(countPairs(a, n))\n",
        "output": "4\n",
        "fn_call": "countPairs"
    },
    {
        "text": "minimum number of appends needed to make a string palindrome | checking if the string is palindrome or not ; single character is always palindrome ; pointing to first character ; pointing to last character ; recursive function to count number of appends ; removing first character of string by incrementing base address pointer . ; ",
        "context": "",
        "code": "def isPalindrome(Str):\n    Len = len(Str)\n    if (Len == 1):\n        return True\n    ptr1 = 0\n    ptr2 = Len - 1\n    while (ptr2 > ptr1):\n        if (Str[ptr1] != Str[ptr2]):\n            return False\n        ptr1 += 1\n        ptr2 -= 1\n    return True\n\n\ndef noOfAppends(s):\n    if (isPalindrome(s)):\n        return 0\n    del s[0]\n    return 1 + noOfAppends(s)\n",
        "test": "\nse = \"abede\"\ns = [i for i in se]\nprint(noOfAppends(s))\n",
        "output": "2\n",
        "fn_call": "noOfAppends"
    },
    {
        "text": "number of ways of writing n as a sum of 4 squares | number of ways of writing n as a sum of 4 squares ; sum of odd and even factor ; iterate from 1 to the number ; if i is the factor of n ; if factor is even ; if factor is odd ; n / i is also a factor ; if factor is even ; if factor is odd ; if n is odd ; if n is even ; ",
        "context": "",
        "code": "def sum_of_4_squares(n):\n    i, odd, even = 0, 0, 0\n    for i in range(1, int(n ** (.5)) + 1):\n        if (n % i == 0):\n            if (i % 2 == 0):\n                even += i\n            else:\n                odd += i\n            if ((n // i) != i):\n                if ((n // i) % 2 == 0):\n                    even += (n // i)\n                else:\n                    odd += (n // i)\n    if (n % 2 == 1):\n        return 8 * (odd + even)\n    else:\n        return 24 * (odd)\n",
        "test": "\nn = 4\nprint(sum_of_4_squares(n))\n",
        "output": "24\n",
        "fn_call": "sum_of_4_squares"
    },
    {
        "text": "find the word with most anagrams in a given sentence | function to find the word with maximum number of anagrams ; primes assigned to 26 alphabets ; stores the product and word mappings ; stores the frequencies of products ; calculate the product of primes assigned ; if product already exists ; otherwise ; fetch the most frequent product ; return a string with that product ; ",
        "context": "",
        "code": "def largestAnagramGrp(arr):\n    prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\n             43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\n    max = -1\n    maxpdt = -1\n    W = {}\n    P = {}\n    for temp in arr:\n        c = [i for i in temp]\n        pdt = 1\n        for t in c:\n            pdt *= prime[ord(t) - ord('a')]\n        if (pdt in P):\n            P[pdt] = P .get(pdt, 0) + 1\n        else:\n            W[pdt] = temp\n            P[pdt] = 1\n    for e in P:\n        if (max < P[e]):\n            max = P[e]\n            maxpdt = e\n    return W[maxpdt]\n",
        "test": "\nif __name__ == '__main__':\n    S = \"please be silent and listen to what the professor says\"\n    arr = S .split(\" \")\n    print(largestAnagramGrp(arr))\n",
        "output": "silent\n",
        "fn_call": "largestAnagramGrp"
    },
    {
        "text": "maximum number of uncrossed lines between two given arrays | function to count maximum number of uncrossed lines between the two given arrays ; stores the length of lcs obtained upto every index ; iterate over first array ; iterate over second array ; update value in dp table ; if both characters are equal ; update the length of lcs ; if both characters are not equal ; update the table ; return the answer ; ",
        "context": "",
        "code": "def uncrossedLines(a, b, n, m):\n    dp = [[0 for x in range(m + 1)]for y in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if (i == 0 or j == 0):\n                dp[i][j] = 0\n            elif (a[i - 1] == b[j - 1]):\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [3, 9, 2]\n    B = [3, 2, 9]\n    N = len(A)\n    M = len(B)\n    print(uncrossedLines(A, B, N, M))\n",
        "output": "2\n",
        "fn_call": "uncrossedLines"
    },
    {
        "text": "count of substrings consisting of even number of vowels | utility function to check if a character is a vowel ; function to calculate and return the count of substrings with even number of vowels ; stores the count of substrings ; if the current character is a vowel ; increase count ; if substring contains even number of vowels ; increase the answer ; prthe final answer ; ",
        "context": "",
        "code": "def isVowel(c):\n    if (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u'):\n        return True\n    return False\n\n\ndef countSubstrings(s, n):\n    result = 0\n    for i in range(n):\n        count = 0\n        for j in range(i, n):\n            if (isVowel(s[j])):\n                count += 1\n            if (count % 2 == 0):\n                result += 1\n    print(result)\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    s = \"abcde\"\n    countSubstrings(s, n)\n",
        "output": "7\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "minimum count of full binary trees such that the count of leaves is n | function to return the minimum count of trees required ; to store the count of set bits in n ; ",
        "context": "",
        "code": "def minTrees(n):\n    count = 0\n    while (n):\n        n &= (n - 1)\n        count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 7\n    print(minTrees(n))\n",
        "output": "3\n",
        "fn_call": "minTrees"
    },
    {
        "text": "Find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted | Python3 program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted ; step 1 ( a ) of above algo ; step 1 ( b ) of above algo ; step 2 ( a ) of above algo ; step 2 ( b ) of above algo ; step 2 ( c ) of above algo ; step 3 of above algo",
        "context": "",
        "code": "def printUnsorted(arr, n):\n    e = n - 1\n    for s in range(0, n - 1):\n        if arr[s] > arr[s + 1]:\n            break\n    if s == n - 1:\n        print(\"The complete array is sorted\")\n        exit()\n    e = n - 1\n    while e > 0:\n        if arr[e] < arr[e - 1]:\n            break\n        e -= 1\n    max = arr[s]\n    min = arr[s]\n    for i in range(s + 1, e + 1):\n        if arr[i] > max:\n            max = arr[i]\n        if arr[i] < min:\n            min = arr[i]\n    for i in range(s):\n        if arr[i] > min:\n            s = i\n            break\n    i = n - 1\n    while i >= e + 1:\n        if arr[i] < max:\n            e = i\n            break\n        i -= 1\n    print(\"The unsorted subarray which makes the given array\")\n    print(\"sorted lies between the indexes %d and %d\" % (s, e))\n",
        "test": "\narr = [10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60]\narr_size = len(arr)\nprintUnsorted(arr, arr_size)\n",
        "output": "The unsorted subarray which makes the given array\nsorted lies between the indexes 3 and 8\n",
        "fn_call": "printUnsorted"
    },
    {
        "text": "find elements larger than half of the elements in an array | set 2 | function to find the element that are larger than half of elements of the array ; find the value of mid ; stores the maximum element ; stores the frequency of each array element ; traverse the array in the reverse order ; decrement the value of count [ i ] and mid ; prthe current element ; check if the value of mid is equal to 0 ; ",
        "context": "",
        "code": "def findLarger(arr, n):\n    mid = (n + 1) // 2\n    mx = max(arr)\n    count = [0] * (mx + 1)\n    for i in range(n):\n        count[arr[i]] += 1\n    for i in range(mx, -1, -1):\n        while (count[i] > 0):\n            count[i] -= 1\n            mid -= 1\n            print(i, end=\" \")\n            if (mid == 0):\n                break\n        if (mid == 0):\n            break\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 4, 2, 8, 9]\n    N = len(arr)\n    findLarger(arr, N)\n",
        "output": "10 9 8 ",
        "fn_call": "findLarger"
    },
    {
        "text": "check if two arrays can be made equal by reversing subarrays multiple times | function to check if array b can be made equal to array a ; sort both the arrays ; check if both the arrays are equal or not ; ",
        "context": "",
        "code": "def canMadeEqual(A, B, n):\n    A .sort()\n    B .sort()\n    for i in range(n):\n        if (A[i] != B[i]):\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 2, 3]\n    B = [1, 3, 2]\n    n = len(A)\n    if (canMadeEqual(A, B, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canMadeEqual"
    },
    {
        "text": "count of triples ( a , b , c ) where a * c is greater than b * b | counts the number of triplets for a given value of b ; count all triples in which a = i ; smallest value j such that i * j > b2 ; count all ( i , b2 , x ) such that x >= j ; count all ( x , b2 , y ) such that x >= j this counts all such triples in which a >= j ; as all triples with a >= j have been counted reduce a to j - 1. ; counts the number of triples that satisfy the given constraints ; getcount of triples in which b = i ; ",
        "context": "",
        "code": "def getCount(A, B2, C):\n    count = 0\n    i = 1\n    while (i < A):\n        j = (B2 // i) + 1\n        if (C >= j):\n            count = count + C - j + 1\n        if (A >= j and C >= i):\n            count = count + (C - i + 1) * (A - j + 1)\n        if (A >= j):\n            A = j - 1\n        i += 1\n    return count\n\n\ndef countTriplets(A, B, C):\n    ans = 0\n    for i in range(1, B + 1):\n        ans = (ans + getCount(A, i * i, C))\n    return ans\n",
        "test": "\nA = 3\nB = 2\nC = 2\nprint(countTriplets(A, B, C))\n",
        "output": "6\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "find time taken for signal to reach all positions in a string | python3 program to find time taken for signal to reach all positions in a string ; returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; we use ceiling function to handle odd number ' o ' s ; ",
        "context": "\nimport sys\nimport math\n\n",
        "code": "def maxLength(s, n):\n    right = 0\n    left = 0\n    coun = 0\n    max_length = -(sys .maxsize - 1)\n    s = s + '1'\n    for i in range(0, n + 1):\n        if s[i] == 'o':\n            coun += 1\n        else:\n            if coun > max_length:\n                right = 0\n                left = 0\n                if s[i] == 'x':\n                    right = 1\n                if i - coun > 0 and s[i - coun - 1] == 'x':\n                    left = 1\n                coun = math .ceil(float(coun / (right + left)))\n                max_length = max(max_length, coun)\n            coun = 0\n    return max_length\n",
        "test": "\nif __name__ == '__main__':\n    s = \"oooxoooooooooxooo\"\n    n = len(s)\n    print(maxLength(s, n))\n",
        "output": "5\n",
        "fn_call": "maxLength"
    },
    {
        "text": "check if an array of 1 s and 2 s can be divided into 2 parts with equal sum | function to check if it is possible to split the array in two halfs with equal sum ; calculate sum of elements and count of 1 's ; if total sum is odd , return false ; if sum of each half is even , return true ; if sum of each half is even but there is atleast one 1 ; ",
        "context": "",
        "code": "def isSpiltPossible(n, a):\n    Sum = 0\n    c1 = 0\n    for i in range(n):\n        Sum += a[i]\n        if (a[i] == 1):\n            c1 += 1\n    if (Sum % 2):\n        return False\n    if ((Sum // 2) % 2 == 0):\n        return True\n    if (c1 > 0):\n        return True\n    else:\n        return False\n",
        "test": "\nn = 3\na = [1, 1, 2]\nif (isSpiltPossible(n, a)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isSpiltPossible"
    },
    {
        "text": "optimal binary search tree | dp | a utility function to get sum of array elements freq [ i ] to freq [ j ] ; a recursive function to calculate cost of optimal binary search tree ; base cases no elements in this subarray ; one element in this subarray ; get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ] ; initialize minimum value ; one by one consider all elements as root and recursively find cost of the bst , compare the cost with min and update min if needed ; return minimum value ; the main function that calculates minimum cost of a binary search tree . it mainly uses optcost ( ) to find the optimal cost . ; here array keys [ ] is assumed to be sorted in increasing order . if keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly . ; ",
        "context": "",
        "code": "def Sum(freq, i, j):\n    s = 0\n    for k in range(i, j + 1):\n        s += freq[k]\n    return s\n\n\ndef optCost(freq, i, j):\n    if j < i:\n        return 0\n    if j == i:\n        return freq[i]\n    fsum = Sum(freq, i, j)\n    Min = 999999999999\n    for r in range(i, j + 1):\n        cost = (optCost(freq, i, r - 1) + optCost(freq, r + 1, j))\n        if cost < Min:\n            Min = cost\n    return Min + fsum\n\n\ndef optimalSearchTree(keys, freq, n):\n    return optCost(freq, 0, n - 1)\n",
        "test": "\nif __name__ == '__main__':\n    keys = [10, 12, 20]\n    freq = [34, 8, 50]\n    n = len(keys)\n    print(\"Cost of Optimal BST is\", optimalSearchTree(keys, freq, n))\n",
        "output": "Cost of Optimal BST is 142\n",
        "fn_call": "optimalSearchTree"
    },
    {
        "text": "longest subsequence with different adjacent characters | function to find the longest subsequence with different adjacent character ; length of the string s ; previously picked character ; if the current character is different from the previous then include this character and update previous character ; ",
        "context": "",
        "code": "def longestSubsequence(s):\n    n = len(s)\n    answer = 0\n    prev = '-'\n    for i in range(0, n):\n        if (prev != s[i]):\n            prev = s[i]\n            answer += 1\n    return answer\n",
        "test": "\nstr = \"ababa\"\nprint(longestSubsequence(str))\n",
        "output": "5\n",
        "fn_call": "longestSubsequence"
    },
    {
        "text": "number of subarrays having sum of the form k ^ m , m >= 0 | python3 implementation of the above approach ; function to count number of sub - arrays whose sum is k ^ p where p >= 0 ; if m [ a + b ] = c , then add c to the current sum . ; increase count of prefix sum . ; if m [ a + b ] = c , then add c to the current sum . ; increase count of prefix sum . ; b = k ^ p , p >= 0 ; k ^ m can be maximum equal to 10 ^ 14. ; if m [ a + b ] = c , then add c to the current sum . ; increase count of prefix sum . ; ",
        "context": "\nfrom collections import defaultdict\nMAX = 100005\n\n",
        "code": "def partial_sum(prefix_sum, arr, n):\n    for i in range(1, n + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + arr[i - 1])\n    return prefix_sum\n\n\ndef countSubarrays(arr, n, k):\n    prefix_sum = [0] * MAX\n    prefix_sum[0] = 0\n    prefix_sum = partial_sum(prefix_sum, arr, n)\n    if (k == 1):\n        sum = 0\n        m = defaultdict(int)\n        for i in range(n, -1, -1):\n            if ((prefix_sum[i] + 1) in m):\n                sum += m[prefix_sum[i] + 1]\n            m[prefix_sum[i]] += 1\n        return sum\n    if (k == -1):\n        sum = 0\n        m = defaultdict(int)\n        for i in range(n, -1, -1):\n            if ((prefix_sum[i] + 1) in m):\n                sum += m[prefix_sum[i] + 1]\n            if ((prefix_sum[i] - 1) in m):\n                sum += m[prefix_sum[i] - 1]\n            m[prefix_sum[i]] += 1\n        return sum\n    sum = 0\n    m = defaultdict(int)\n    for i in range(n, -1, -1):\n        b = 1\n        while (True):\n            if (b > 100000000000000):\n                break\n            if ((prefix_sum[i] + b) in m):\n                sum += m[prefix_sum[i] + b]\n            b *= k\n        m[prefix_sum[i]] += 1\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 2, 2, 2]\n    n = len(arr)\n    k = 2\n    print(countSubarrays(arr, n, k))\n",
        "output": "8\n",
        "fn_call": "countSubarrays"
    },
    {
        "text": "find the first , second and third minimum elements in an array | a python program to find the first , second and third minimum element in an array ; check if current element is less than firstmin , then update first , second and third ; check if current element is less than secmin then update second and third ; check if current element is less than , then upadte third ; ",
        "context": "\nMAX = 100000\n\n",
        "code": "def Print3Smallest(arr, n):\n    firstmin = MAX\n    secmin = MAX\n    thirdmin = MAX\n    for i in range(0, n):\n        if arr[i] < firstmin:\n            thirdmin = secmin\n            secmin = firstmin\n            firstmin = arr[i]\n        elif arr[i] < secmin:\n            thirdmin = secmin\n            secmin = arr[i]\n        elif arr[i] < thirdmin:\n            thirdmin = arr[i]\n    print(\"First min = \", firstmin)\n    print(\"Second min = \", secmin)\n    print(\"Third min = \", thirdmin)\n",
        "test": "\narr = [4, 9, 1, 32, 12]\nn = len(arr)\nPrint3Smallest(arr, n)\n",
        "output": "First min =  1\nSecond min =  4\nThird min =  9\n",
        "fn_call": "Print3Smallest"
    },
    {
        "text": "check if a large number is divisible by 11 or not | function to find that number divisible by 11 or not ; compute sum of even and odd digit sums ; when i is even , position of digit is odd ; check its difference is divisible by 11 or not ; ",
        "context": "",
        "code": "def check(st):\n    n = len(st)\n    oddDigSum = 0\n    evenDigSum = 0\n    for i in range(0, n):\n        if (i % 2 == 0):\n            oddDigSum = oddDigSum + ((int)(st[i]))\n        else:\n            evenDigSum = evenDigSum + ((int)(st[i]))\n    return ((oddDigSum - evenDigSum) % 11 == 0)\n",
        "test": "\nst = \"76945\"\nif (check(st)):\n    print(\"Yes\")\nelse:\n    print(\"No \")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "program to calculate root mean square | python3 program to calculate root mean square ; function that calculate root mean square ; calculate square ; calculate mean ; calculate root ; ",
        "context": "\nimport math\n\n",
        "code": "def rmsValue(arr, n):\n    square = 0\n    mean = 0.0\n    root = 0.0\n    for i in range(0, n):\n        square += (arr[i]**2)\n    mean = (square / (float)(n))\n    root = math .sqrt(mean)\n    return root\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 4, 6, 8]\n    n = len(arr)\n    print(rmsValue(arr, n))\n",
        "output": "7.3484692283495345\n",
        "fn_call": "rmsValue"
    },
    {
        "text": "check if given number is a power of d where d is a power of 2 | python3 program to find if a number is power of d where d is power of 2. ; function to count the number of ways to paint n * 3 grid based on given conditions ; check if there is only one bit set in n ; count 0 bits before set bit ; if count is a multiple of log2 ( d ) then return true else false ; if there are more than 1 bit set then n is not a power of 4 ; ",
        "context": "",
        "code": "def Log2n(n):\n    return (1 + Log2n(n / 2))if (n > 1)else 0\n\n\ndef isPowerOfd(n, d):\n    count = 0\n    if (n and (n & (n - 1)) == 0):\n        while (n > 1):\n            n >>= 1\n            count += 1\n        return (count % (Log2n(d)) == 0)\n    return False\n",
        "test": "\nn = 64\nd = 8\nif (isPowerOfd(n, d)):\n    print(n, \"is a power of\", d)\nelse:\n    print(n, \"is not a power of\", d)\n",
        "output": "64 is a power of 8\n",
        "fn_call": "isPowerOfd"
    },
    {
        "text": "check if sum and xor of all elements of array is equal | function to check if sum and xor of all elements of array is equal ; sum and xor of all elements ; checking sum and xor to be equal ; ",
        "context": "",
        "code": "def equal_xor_sum(arr, n):\n    Sum = 0\n    Xor = 0\n    for i in range(n):\n        Sum = Sum + arr[i]\n        Xor = Xor ^ arr[i]\n    if (Sum == Xor):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 3, 7, 10]\n    n = len(arr)\n    equal_xor_sum(arr, n)\n",
        "output": "NO\n",
        "fn_call": "equal_xor_sum"
    },
    {
        "text": "longest subarray having strictly positive xor | function to return the length of the longest sub - array having positive xor ; to store the xor of all the elements ; to check if all the elements of the array are 0 s ; take xor of all the elements ; if any positive value is found the make the checkallzero false ; if complete array is the answer ; if all elements are equal to zero ; initialize l and r ; first positive value of the array ; last positive value of the array ; maximum length among these two subarrays ; ",
        "context": "",
        "code": "def StrictlyPositiveXor(A, N):\n    allxor = 0\n    checkallzero = True\n    for i in range(N):\n        allxor ^= A[i]\n        if (A[i] > 0):\n            checkallzero = False\n    if (allxor != 0):\n        return N\n    if (checkallzero):\n        return -1\n    l = N\n    r = -1\n    for i in range(N):\n        if (A[i] > 0):\n            l = i + 1\n            break\n    for i in range(N - 1, -1, -1):\n        if (A[i] > 0):\n            r = i + 1\n            break\n    return max(N - l, r - 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 0, 0, 1]\n    N = len(A)\n    print(StrictlyPositiveXor(A, N))\n",
        "output": "3\n",
        "fn_call": "StrictlyPositiveXor"
    },
    {
        "text": "check whether a number can be represented by sum of two squares | function to check if there exist two numbers sum of whose squares is n . ; store square value in hashmap ; ",
        "context": "",
        "code": "def sumSquare(n):\n    s = dict()\n    for i in range(n):\n        if i * i > n:\n            break\n        s[i * i] = 1\n        if (n - i * i) in s .keys():\n            print((n - i * i)**(1 / 2), \"^2 +\", i, \"^2\")\n            return True\n    return False\n",
        "test": "\nn = 1\nif n == 1:\n    print('0^2 + 1^2')\nelif (sumSquare(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "0^2 + 1^2\n",
        "fn_call": "sumSquare"
    },
    {
        "text": "longest sub | function to return the required length ; to store the filtered numbers ; filtering the numbers ; if there are no elements to check ; find the or of all the filtered elements ; check if the or is equal to m ; ",
        "context": "",
        "code": "def findLen(arr, n, m):\n    filter = []\n    for i in range(n):\n        if ((arr[i] | m) == m):\n            filter .append(arr[i])\n    if (len(filter) == 0):\n        return 0\n    c_or = filter[0]\n    for i in range(1, len(filter)):\n        c_or |= filter[i]\n    if (c_or == m):\n        return len(filter)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [7, 3, 3, 1, 3]\n    n = len(arr)\n    m = 3\n    print(findLen(arr, n, m))\n",
        "output": "4\n",
        "fn_call": "findLen"
    },
    {
        "text": "minimum sum of two integers whose product is strictly greater than n | python3 program for the above approach ; function to find the minimum sum of two integers such that their product is strictly greater than n ; store the answer using the ap - gp inequality ; print the result ; ",
        "context": "\nimport math\n\n",
        "code": "def minSum(N):\n    ans = math .ceil(2 * math .sqrt(N + 1))\n    print(math .trunc(ans))\n",
        "test": "\nN = 10\nminSum(N)\n",
        "output": "7\n",
        "fn_call": "minSum"
    },
    {
        "text": "sum of digits of a given number to a given power | function to calculate sum ; ",
        "context": "",
        "code": "def calculate(n, power):\n    return sum([int(i)for i in str(pow(n, power))])\n",
        "test": "\nn = 5\npower = 4\nprint(calculate(n, power))\n",
        "output": "13\n",
        "fn_call": "calculate"
    },
    {
        "text": "find the smallest positive number missing from an unsorted array | set 2 | function to find smallest positive missing number . ; to store next array element in current traversal ; if value is negative or greater than array size , then it cannot be marked in array . so move to next element . ; traverse the array until we reach at an element which is already marked or which could not be marked . ; find first array index which is not marked which is also the smallest positive missing number . ; if all indices are marked , then smallest missing positive number is array_size + 1. ; ",
        "context": "",
        "code": "def findMissingNo(arr, n):\n    for i in range(n):\n        if (arr[i]  n):\n            continue\n        val = arr[i]\n        while (arr[val - 1] != val):\n            nextval = arr[val - 1]\n            arr[val - 1] = val\n            val = nextval\n            if (val  n):\n                break\n    for i in range(n):\n        if (arr[i] != i + 1):\n            return i + 1\n    return n + 1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 3, 7, 6, 8, -1, -10, 15]\n    arr_size = len(arr)\n    missing = findMissingNo(arr, arr_size)\n    print(\"The smallest positive\", \"missing number is \", missing)\n",
        "output": "The smallest positive missing number is  1\n",
        "fn_call": "findMissingNo"
    },
    {
        "text": "count of numbers in range where first digit is equal to last digit of the number | python3 program to implement the above approach ; base case ; calculating the last digit ; calculating the first digit ; ",
        "context": "",
        "code": "def solve(x):\n    ans, temp = 0, x\n    if (x < 10):\n        return x\n    last = x % 10\n    while (x):\n        first = x % 10\n        x = x // 10\n    if (first <= last):\n        ans = 9 + temp // 10\n    else:\n        ans = 8 + temp // 10\n    return ans\n",
        "test": "\nL, R = 2, 60\nprint(solve(R) - solve(L - 1))\nL, R = 1, 1000\nprint(solve(R) - solve(L - 1))\n",
        "output": "13\n108\n",
        "fn_call": "solve"
    },
    {
        "text": "longest dividing subsequence | lds ( ) returns the length of the longest dividing subsequence in arr [ ] of size n ; compute optimized lds values in bottom up manner ; return maximum value in lds [ ] ; ",
        "context": "",
        "code": "def lds(arr, n):\n    lds = [0 for i in range(n)]\n    lds[0] = 1\n    for i in range(n):\n        lds[i] = 1\n        for j in range(i):\n            if (lds[j] != 0 and arr[i] % arr[j] == 0):\n                lds[i] = max(lds[i], lds[j] + 1)\n    return max(lds)\n",
        "test": "\narr = [2, 11, 16, 12, 36, 60, 71, 17, 29, 144, 288, 129, 432, 993]\nprint(\"Length of lds is\", lds(arr, len(arr)))\n",
        "output": "Length of lds is 5\n",
        "fn_call": "lds"
    },
    {
        "text": "count of total subarrays whose sum is a fibonacci numbers | python3 program for the above approach ; function to check whether a number is perfect square or not ; function to check whether a number is fibonacci number or not ; if 5 * n * n + 4 or 5 * n * n - 5 is a perfect square , then the number is fibonacci ; function to count the subarray with sum fibonacci number ; traverse the array arr [ ] to find the sum of each subarray ; to store the sum ; check whether sum of subarray between [ i , j ] is fibonacci or not ; ",
        "context": "\nimport math\n\n",
        "code": "def isPerfectSquare(x):\n    s = int(math .sqrt(x))\n    if s * s == x:\n        return True\n    return False\n\n\ndef isFibonacci(n):\n    return (isPerfectSquare(5 * n * n + 4) or isPerfectSquare(5 * n * n - 4))\n\n\ndef fibonacciSubarrays(arr, n):\n    count = 0\n    for i in range(n):\n        sum = 0\n        for j in range(i, n):\n            sum += arr[j]\n            if (isFibonacci(sum)):\n                count += 1\n    print(count)\n",
        "test": "\narr = [6, 7, 8, 9]\nn = len(arr)\nfibonacciSubarrays(arr, n)\n",
        "output": "3\n",
        "fn_call": "fibonacciSubarrays"
    },
    {
        "text": "print k 'th element in spiral form of matrix |  ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; check the first row from the remaining rows ; check the last column from the remaining columns ; check the last row from the remaining rows ; check the first column from the remaining columns ; ",
        "context": "\nR = 3\nC = 6\n\n",
        "code": "def spiralPrint(m, n, a, c):\n    k = 0\n    l = 0\n    count = 0\n    while (k < m and l < n):\n        for i in range(l, n):\n            count += 1\n            if (count == c):\n                print(a[k][i], end=\" \")\n        k += 1\n        for i in range(k, m):\n            count += 1\n            if (count == c):\n                print(a[i][n - 1], end=\" \")\n        n -= 1\n        if (k < m):\n            for i in range(n - 1, l - 1, -1):\n                count += 1\n                if (count == c):\n                    print(a[m - 1][i], end=\" \")\n            m -= 1\n        if (l < n):\n            for i in range(m - 1, k - 1, -1):\n                count += 1\n                if (count == c):\n                    print(a[i][l], end=\" \")\n            l += 1\n",
        "test": "\na = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18]]\nk = 17\nspiralPrint(R, C, a, k)\n",
        "output": "10 ",
        "fn_call": "spiralPrint"
    },
    {
        "text": "smallest number whose sum of digits is square of n | function to return smallest number whose sum of digits is n ^ 2 ; ",
        "context": "",
        "code": "def smallestNum(n):\n    return ((n * n % 9 + 1) * pow(10, int(n * n / 9)) - 1)\n",
        "test": "\nN = 4\nprint(smallestNum(N))\n",
        "output": "79\n",
        "fn_call": "smallestNum"
    },
    {
        "text": "average of first n even natural numbers | function to find average of sum of first n even numbers ; sum of first n even numbers ; calculating average ; ",
        "context": "",
        "code": "def avg_of_even_num(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum = sum + 2 * i\n    return sum / n\n",
        "test": "\nn = 9\nprint(avg_of_even_num(n))\n",
        "output": "10.0\n",
        "fn_call": "avg_of_even_num"
    },
    {
        "text": "minimum steps to convert an array into permutation of numbers from 1 to n | function to find minimum number of steps to convert a given sequence into a permutation ; sort the given array ; to store the required minimum number of operations ; find the operations on each step ; return the answer ; ",
        "context": "",
        "code": "def get_permutation(arr, n):\n    arr = sorted(arr)\n    result = 0\n    for i in range(n):\n        result += abs(arr[i] - (i + 1))\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 2, 3, 4, 1, 6, 8, 9]\n    n = len(arr)\n    print(get_permutation(arr, n))\n",
        "output": "7\n",
        "fn_call": "get_permutation"
    },
    {
        "text": "maximum and minimum in a square matrix . | python3 program for finding maximum and minimum in a matrix . ; finds maximum and minimum in arr [ 0. . n - 1 ] [ 0. . n - 1 ] using pair wise comparisons ; traverses rows one by one ; compare elements from beginning and end of current row ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def MAXMIN(arr, n):\n    MIN = 10 ** 9\n    MAX = -10 ** 9\n    for i in range(n):\n        for j in range(n // 2 + 1):\n            if (arr[i][j] > arr[i][n - j - 1]):\n                if (MIN > arr[i][n - j - 1]):\n                    MIN = arr[i][n - j - 1]\n                if (MAX < arr[i][j]):\n                    MAX = arr[i][j]\n            else:\n                if (MIN > arr[i][j]):\n                    MIN = arr[i][j]\n                if (MAX < arr[i][n - j - 1]):\n                    MAX = arr[i][n - j - 1]\n    print(\"MAXimum =\", MAX, \", MINimum =\", MIN)\n",
        "test": "\narr = [[5, 9, 11], [25, 0, 14], [21, 6, 4]]\nMAXMIN(arr, 3)\n",
        "output": "MAXimum = 25 , MINimum = 0\n",
        "fn_call": "MAXMIN"
    },
    {
        "text": "minimum sum path in a triangle | util function to find minimum sum for a path ; for storing the result in a 1 - d array , and simultaneously updating the result . ; for the bottom row ; calculation of the remaining rows , in bottom up manner . ; return the top element ; ",
        "context": "",
        "code": "def minSumPath(A):\n    memo = [None] * len(A)\n    n = len(A) - 1\n    for i in range(len(A[n])):\n        memo[i] = A[n][i]\n    for i in range(len(A) - 2, -1, -1):\n        for j in range(len(A[i])):\n            memo[j] = A[i][j] + min(memo[j], memo[j + 1])\n    return memo[0]\n",
        "test": "\nA = [[2], [3, 9], [1, 6, 7]]\nprint(minSumPath(A))\n",
        "output": "6\n",
        "fn_call": "minSumPath"
    },
    {
        "text": "flip all 0 s in given binary strings k times with different neighbours | function to modify the given string k number of times by flipping 0 s having different adjacent characters ; size of the string ; stores modified string after each iteration ; iterate over the range [ 0 k ] ; traverse the string s ; if '0' is present at 0 th index then replace it with 1 st index ; if '0' is present at the last index then replace it with last index - 1 character ; otherwise , convert 0 s to 1 if the adjacent characters are different ; if during this iteration there is no change in the string then break this loop ; update the string s ; print the updated string ; ",
        "context": "",
        "code": "def convertString(S, k):\n    n = len(S)\n    temp = S\n    temp = list(temp)\n    for i in range(k):\n        for j in range(n - 1):\n            if (j == 0 and S[j] == '0'):\n                temp[j] = S[j + 1]\n            elif (j == n - 1 and S[j] == '0'):\n                temp[j] = S[j - 1]\n            elif (S[j - 1] != S[j + 1] and S[j] == '0'):\n                temp[j] = '1'\n        if (S == temp):\n            break\n        temp = ''.join(temp)\n        S = temp\n    print(S)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"10010001\"\n    K = 1\n    convertString(S, K)\n",
        "output": "11111011\n",
        "fn_call": "convertString"
    },
    {
        "text": "repeat substrings of the given string required number of times | function that returns true if the passed character is a digit ; function to return the next index of a non - digit character in the string starting at the index i ( returns - 1 ifno such index is found ) ; if the character at index i is a digit then skip to the next character ; if no such index was found ; function to append str the given number of times to the stringbuilder ; function to return the string after performing the given operations ; to build the resultant string ; index of the first non - digit character in the string ; while there are substrings that do not consist of digits ; find the ending of the substring ; starting index of the number ; if no digit appears after the current substring ; find the index at which the current number ends ; parse the number from the substring ; repeat the current substring required number of times ; find the next non - digit character index ; return the resultant string ; ",
        "context": "",
        "code": "def isDigit(ch):\n    if ch >= '0' and ch <= '9':\n        return True\n    return False\n\n\ndef nextNonDigit(string, i):\n    while i < len(string) and isDigit(string[i]):\n        i += 1\n    if i >= len(string):\n        return -1\n    return i\n\n\ndef appendRepeated(sb, string, times):\n    for i in range(times):\n        sb .append(string)\n\n\ndef findString(string, n):\n    sb = list()\n    startStr = nextNonDigit(string, 0)\n    while startStr != -1:\n        endStr = startStr\n        while (endStr + 1 < n and not isDigit(string[endStr + 1])):\n            endStr += 1\n        startNum = endStr + 1\n        if startNum == -1:\n            break\n        endNum = startNum\n        while (endNum + 1 < n and isDigit(string[endNum + 1])):\n            endNum += 1\n        num = int(string[startNum:endNum + 1])\n        appendRepeated(sb, string[startStr:endStr + 1], num)\n        startStr = nextNonDigit(string, endStr + 1)\n    sb = ''.join(sb)\n    return sb\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"g1ee1ks1for1g1e2ks1\"\n    n = len(string)\n    print(findString(string, n))\n",
        "output": "geeksforgeeks\n",
        "fn_call": "findString"
    },
    {
        "text": "count pairs in an array whose product is composite number | python3 program to implement the above approach ; function to get all the prime numbers in the range [ 1 , x ] ; stores the boolean value to check if a number is prime or not ; mark all non prime numbers as false ; if i is prime number ; mark j as a composite number ; function to get the count of pairs whose product is a composite number ; stores the boolean value to check if a number is prime or not ; stores the count of 1 s ; stores the count of prime numbers ; traverse the given array . ; stores count of pairs whose product is not a composite number ; stores the count of pairs whose product is composite number ; ",
        "context": "\nX = 1000000\n\n",
        "code": "def getPrimeNum():\n    isPrime = [True] * (X)\n    isPrime[0] = False\n    isPrime[1] = False\n    i = 2\n    while i * i <= X:\n        if (isPrime[i]):\n            for j in range(i * i, X, i):\n                isPrime[j] = False\n        i += 1\n    return isPrime\n\n\ndef cntPairs(arr, N):\n    isPrime = getPrimeNum()\n    cntOne = 0\n    cntPrime = 0\n    for i in range(N):\n        if (arr[i] == 1):\n            cntOne += 1\n        elif (isPrime[i]):\n            cntPrime += 1\n    cntNonComp = 0\n    cntNonComp = (cntPrime * cntOne + cntOne * (cntOne - 1) // 2)\n    res = 0\n    res = (N * (N - 1) // 2 - cntNonComp)\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 1, 2, 2, 8]\n    N = len(arr)\n    print(cntPairs(arr, N))\n",
        "output": "5\n",
        "fn_call": "cntPairs"
    },
    {
        "text": "highest power of 2 that divides a number represented in binary | function to return the highest power of 2 which divides the given binary number ; to store the highest required power of 2 ; counting number of consecutive zeros from the end in the given binary string ; ",
        "context": "",
        "code": "def highestPower(str, length):\n    ans = 0\n    for i in range(length - 1, -1, -1):\n        if (str[i] == '0'):\n            ans += 1\n        else:\n            break\n    return ans\n\n\ndef main():\n    str = \"100100\"\n    length = len(str)\n    print(highestPower(str, length))\n",
        "test": "\nif __name__ == '__main__':\n    main()\n",
        "output": "2\n",
        "fn_call": "main"
    },
    {
        "text": "converting a real number ( between 0 and 1 ) to binary string | function to convert binary real number to string ; check if the number is between 0 to 1 or not ; setting a limit on length : 32 characters . ; compare the number to .5 ; now it become 0.25 ; ",
        "context": "",
        "code": "def toBinary(n):\n    if (n >= 1 or n <= 0):\n        return \"ERROR\"\n    frac = 0.5\n    answer = \".\"\n    while (n > 0):\n        if (len(answer) >= 32):\n            return \"ERROR\"\n        if (n >= frac):\n            answer += \"1\"\n            n = n - frac\n        else:\n            answer += \"0\"\n        frac = (frac / 2)\n    return answer\n",
        "test": "\nn = 0.625\nresult = toBinary(n)\nprint(\"( 0\", result, \") in base 2\")\nm = 0.72\nresult = toBinary(m)\nprint(\"(\", result, \")\")\n",
        "output": "( 0 .101 ) in base 2\n( ERROR )\n",
        "fn_call": "toBinary"
    },
    {
        "text": "minimize swaps of pairs of characters required such that no two adjacent characters in the string are same | python3 program for the above approach ; function to check if s contains any pair of adjacent characters that are same ; traverse the string s ; if current pair of adjacent characters are the same ; return true ; utility function to find the minimum number of swaps of pair of characters required to make all pairs of adjacent characters different ; check if the required string is formed already ; traverse the string s ; swap the characters at i and j position ; swap for backtracking step ; function to find the minimum number of swaps of pair of characters required to make all pairs of adjacent characters different ; stores the resultant minimum number of swaps required ; function call to find the minimum swaps required ; prvar the result ; ",
        "context": "\nimport sys\nansSwaps = 0\n\n",
        "code": "def check(S):\n    for i in range(1, len(S)):\n        if (S[i - 1] == S[i]):\n            return False\n    return True\n\n\ndef minimumSwaps(S, swaps, idx):\n    global ansSwaps\n    if (check(S)):\n        ansSwaps = 1 + min(ansSwaps, swaps)\n    for i in range(idx, len(S)):\n        for j in range(i + 1, len(S)):\n            swap(S, i, j)\n            minimumSwaps(S, swaps + 1, i + 1)\n            S = swap(S, i, j)\n\n\ndef swap(arr, i, j):\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n    return arr\n\n\ndef findMinimumSwaps(S):\n    global ansSwaps\n    ansSwaps = sys .maxsize\n    minimumSwaps(S, 0, 0)\n    if (ansSwaps == sys .maxsize):\n        print(\"-1\")\n    else:\n        print(ansSwaps)\n",
        "test": "\nS = \"ABAACD\"\nfindMinimumSwaps(S .split())\n",
        "output": "1\n",
        "fn_call": "findMinimumSwaps"
    },
    {
        "text": "n digit numbers divisible by 5 formed from the m digits | function to find the count of all possible n digit numbers which are divisible by 5 formed from m digits ; if it is not possible to form n digit number from the given m digits without repetition ; if both zero and five exists ; remaining n - 1 iterations ; remaining n - 1 iterations ; ",
        "context": "",
        "code": "def numbers(n, arr, m):\n    isZero = 0\n    isFive = 0\n    result = 0\n    if (m < n):\n        return -1\n    for i in range(m):\n        if (arr[i] == 0):\n            isZero = 1\n        if (arr[i] == 5):\n            isFive = 1\n    if (isZero and isFive):\n        result = 2\n        for i in range(n - 1):\n            m -= 1\n            result = result * (m)\n    elif (isZero or isFive):\n        result = 1\n        for i in range(n - 1):\n            m -= 1\n            result = result * (m)\n    else:\n        result = -1\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    m = 6\n    arr = [2, 3, 5, 6, 7, 9]\n    print(numbers(n, arr, m))\n",
        "output": "20\n",
        "fn_call": "numbers"
    },
    {
        "text": "maximize length of the string by concatenating characters from an array of strings | function to check if all the string characters are unique ; check for repetition in characters ; function to generate all possible strings from the given array ; base case ; consider every string as a starting substring and store the generated string ; add current string to result of other strings and check if characters are unique or not ; function to find the maximum possible length of a string ; return max length possible ; return the answer ; ",
        "context": "",
        "code": "def check(s):\n    a = set()\n    for i in s:\n        if i in a:\n            return False\n        a .add(i)\n    return True\n\n\ndef helper(arr, ind):\n    if (ind == len(arr)):\n        return [\"\"]\n    tmp = helper(arr, ind + 1)\n    ret = tmp\n    for i in tmp:\n        test = i + arr[ind]\n        if (check(test)):\n            ret .append(test)\n    return ret\n\n\ndef maxLength(arr):\n    tmp = helper(arr, 0)\n    l = 0\n    for i in tmp:\n        l = l if l > len(i)else len(i)\n    return l\n",
        "test": "\nif __name__ == '__main__':\n    s = []\n    s .append(\"abcdefgh\")\n    print(maxLength(s))\n",
        "output": "8\n",
        "fn_call": "maxLength"
    },
    {
        "text": "largest palindromic string possible from given strings by rearranging the characters | python3 program for the above approach ; function to find largest palindrome possible from s and p after rearranging characters to make palindromic string t ; using unordered_map to store frequency of elements mapt will have freq of elements of t ; size of both the strings ; take all character in mapt which occur even number of times in respective strings & simultaneously update number of characters left in map ; check if a unique character is present in both string s and p ; making string t in two halves half1 - first half half2 - second half ; reverse the half2 to attach with half1 to make palindrome ; if same unique element is present in both s and p , then taking that only which is already taken through mapt ; if same unique element is not present in s and p , then take characters that make string t lexicographically smallest ; if no unique element is present in both string s and p ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def mergePalindromes(S, P):\n    mapS = defaultdict(lambda: 0)\n    mapP = defaultdict(lambda: 0)\n    mapT = defaultdict(lambda: 0)\n    n = len(S)\n    m = len(P)\n    for i in range(n):\n        mapS[ord(S[i])] += 1\n    for i in range(m):\n        mapP[ord(P[i])] += 1\n    for i in range(ord('a'), ord('z') + 1):\n        if (mapS[i] % 2 == 0):\n            mapT[i] += mapS[i]\n            mapS[i] = 0\n        else:\n            mapT[i] += mapS[i] - 1\n            mapS[i] = 1\n        if (mapP[i] % 2 == 0):\n            mapT[i] += mapP[i]\n            mapP[i] = 0\n        else:\n            mapT[i] += mapP[i] - 1\n            mapP[i] = 1\n    check = 0\n    for i in range(ord('a'), ord('z') + 1):\n        if (mapS[i] > 0 and mapP[i] > 0):\n            mapT[i] += 2\n            check = 1\n            break\n    half1, half2 = \"\", \"\"\n    for i in range(ord('a'), ord('z') + 1):\n        j = 0\n        while ((2 * j) < mapT[i]):\n            half1 += chr(i)\n            half2 += chr(i)\n            j += 1\n    half2 = half2[::-1]\n    if (check):\n        return half1 + half2\n    for i in range(ord('a'), ord('z') + 1):\n        if (mapS[i] > 0 or mapP[i] > 0):\n            half1 += chr(i)\n            return half1 + half2\n    return half1 + half2\n",
        "test": "\nS = \"aeabb\"\nP = \"dfedf\"\nprint(mergePalindromes(S, P))\n",
        "output": "abdeffedba\n",
        "fn_call": "mergePalindromes"
    },
    {
        "text": "time when minute hand and hour hand coincide | function to find the minute ; finding the angle between minute hand and the first hour hand ; ",
        "context": "",
        "code": "def find_time(h1):\n    theta = 30 * h1\n    print(\"(\", end=\"\")\n    print((theta * 2), \"/ 11) minutes\")\n",
        "test": "\nh1 = 3\nfind_time(h1)\n",
        "output": "(180 / 11) minutes\n",
        "fn_call": "find_time"
    },
    {
        "text": "kaprekar constant | this function checks validity of kaprekar ' s \u2581 constant . \u2581 it \u2581 returns \u2581 kaprekar ' s constant for any four digit number \" n \" such that all digits of n are not same . ; store current n as previous number ; get four digits of ",
        "context": "",
        "code": "def kaprekarRec(n, prev):\n    if (n == 0):\n        return 0\n    prev = n\n    digits = [0] * 4\n    for i in range(4):\n        digits[i] = n % 10\n        n = int(n / 10)\n    digits .sort()\n    asc = 0\n    for i in range(4):\n        asc = asc * 10 + digits[i]\n    digits .sort()\n    desc = 0\n    for i in range(3, -1, -1):\n        desc = desc * 10 + digits[i]\n    diff = abs(asc - desc)\n    if (diff == prev):\n        return diff\n    return kaprekarRec(diff, prev)\n\n\ndef kaprekar(n):\n    rev = 0\n    return kaprekarRec(n, rev)\n",
        "test": "\nprint(kaprekar(1000))\nprint(kaprekar(1112))\nprint(kaprekar(9812))\n",
        "output": "6174\n6174\n6174\n",
        "fn_call": "kaprekar"
    },
    {
        "text": "longest subsequence having maximum sum | function to find the longest subsequence from the given array with maximum sum ; stores the largest element of the array ; if max is less than 0 ; print the largest element of the array ; traverse the array ; if arr [ i ] is greater than or equal to 0 ; print elements of the subsequence ; ",
        "context": "",
        "code": "def longestSubWithMaxSum(arr, N):\n    Max = max(arr)\n    if (Max < 0):\n        print(Max)\n        return\n    for i in range(N):\n        if (arr[i] >= 0):\n            print(arr[i], end=\" \")\n",
        "test": "\narr = [1, 2, -4, -2, 3, 0]\nN = len(arr)\nlongestSubWithMaxSum(arr, N)\n",
        "output": "1 2 3 0 ",
        "fn_call": "longestSubWithMaxSum"
    },
    {
        "text": "find if two people ever meet after same number of jumps | function to find if any one of them can overtake the other ; since starting points are always different , they will meet if following conditions are met . ( 1 ) speeds are not same ( 2 ) difference between speeds divide the total distance between initial points . ; ",
        "context": "",
        "code": "def sackRace(p1, s1, p2, s2):\n    return ((s1 > s2 and (p2 - p1) %\n             (s1 - s2) == 0) or (s2 > s1 and (p1 - p2) %\n                                 (s2 - s1) == 0))\n",
        "test": "\np1 = 4\ns1 = 4\np2 = 8\ns2 = 2\nif (sackRace(p1, s1, p2, s2)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "sackRace"
    },
    {
        "text": "sort the queue using recursion | defining a class queue ; function to push element in last by popping from front until size becomes 0 ; base condition ; pop front element and push this last in a queue ; recursive call for pushing element ; function to push an element in the queue while maintaining the sorted order ; base condition ; if current element is less than the element at the front ; call stack with front of queue ; recursive call for inserting a front element of the queue to the last ; push front element into last in a queue ; recursive call for pushing element in a queue ; function to sort the given queue using recursion ; return if queue is empty ; get the front element which will be stored in this variable throughout the recursion stack ; recursive call ; push the current element into the queue according to the sorting order ; ",
        "context": "\nclass Queue:\n    def __init__(self):\n        self .queue = []\n\n    def put(self, item):\n        self .queue .append(item)\n\n    def get(self):\n        if len(self .queue) < 1:\n            return None\n        return self .queue .pop(0)\n\n    def front(self):\n        return self .queue[0]\n\n    def size(self):\n        return len(self .queue)\n\n    def empty(self):\n        return not (len(self .queue))\n\n",
        "code": "def FrontToLast(q, qsize):\n    if qsize <= 0:\n        return\n    q .put(q .get())\n    FrontToLast(q, qsize - 1)\n\n\ndef pushInQueue(q, temp, qsize):\n    if q .empty() or qsize == 0:\n        q .put(temp)\n        return\n    elif temp <= q .front():\n        q .put(temp)\n        FrontToLast(q, qsize)\n    else:\n        q .put(q .get())\n        pushInQueue(q, temp, qsize - 1)\n\n\ndef sortQueue(q):\n    if q .empty():\n        return\n    temp = q .get()\n    sortQueue(q)\n    pushInQueue(q, temp, q .size())\n",
        "test": "\nqu = Queue()\nqu .put(10)\nqu .put(7)\nqu .put(16)\nqu .put(9)\nqu .put(20)\nqu .put(5)\nsortQueue(qu)\nwhile not qu .empty():\n    print(qu .get(), end=' ')\n",
        "output": "5 7 9 10 16 20 ",
        "fn_call": "sortQueue"
    },
    {
        "text": "queries to return the absolute difference between l | function to return the result for a particular query ; get the difference between the indices of l - th and the r - th smallest element ; return the answer ; function that performs all the queries ; store the array numbers and their indices ; sort the array elements ; answer all the queries ; ",
        "context": "",
        "code": "def answerQuery(arr, l, r):\n    answer = abs(arr[l - 1][1] - arr[r - 1][1])\n    return answer\n\n\ndef solveQueries(a, n, q, m):\n    arr = [[0 for i in range(n)]for j in range(n)]\n    for i in range(n):\n        arr[i][0] = a[i]\n        arr[i][1] = i\n    arr .sort(reverse=False)\n    for i in range(m):\n        print(answerQuery(arr, q[i][0], q[i][1]))\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 5, 4, 2, 8, 6, 7]\n    n = len(a)\n    q = [[2, 5], [1, 3], [1, 5], [3, 6]]\n    m = len(q)\n    solveQueries(a, n, q, m)\n",
        "output": "2\n2\n5\n4\n",
        "fn_call": "solveQueries"
    },
    {
        "text": "maximize the sum of the given array using given operations | comparator to sort the array in ascending order ; function to maximise the sum of the given array ; stores { a [ i ] , b [ i ] } pairs ; sort in descending order of the values in the array a [ ] ; stores the maximum sum ; if b [ i ] is equal to 0 ; simply add a [ i ] to the sum ; add the highest k numbers ; subtract from the sum ; return the sum ; ",
        "context": "",
        "code": "def compare(p1, p2):\n    return p1[0] > p2[0]\n\n\ndef maximiseScore(A, B, K, N):\n    pairs = []\n    for i in range(N):\n        pairs .append([A[i], B[i]])\n    pairs .sort(key=lambda x: x[0], reverse=True)\n    Sum = 0\n    for i in range(N):\n        if (pairs[i][1] == 0):\n            Sum += pairs[i][0]\n        elif (pairs[i][1] == 1):\n            if (K > 0):\n                Sum += pairs[i][0]\n                K -= 1\n            else:\n                Sum -= pairs[i][0]\n    return Sum\n",
        "test": "\nA = [5, 4, 6, 2, 8]\nB = [1, 0, 1, 1, 0]\nK = 2\nN = len(A)\nprint(maximiseScore(A, B, K, N))\n",
        "output": "21\n",
        "fn_call": "maximiseScore"
    },
    {
        "text": "m coloring problem | backtracking | python3 program for the above approach ; a node class which stores the color and the edges connected to the node ; create a visited array of n nodes , initialized to zero ; maxcolors used till now are 1 as all nodes are painted color 1 ; do a full bfs traversal from all unvisited starting points ; if the starting point is unvisited , mark it visited and push it in queue ; bfs travel starts here ; checking all adjacent nodes to \" top \" edge in our queue ; important : if the color of the adjacent node is same , increase it by 1 ; if number of colors used shoots m , return 0 ; if the adjacent node is not visited , mark it visited and push it in queue ; ",
        "context": "\nfrom queue import Queue\n\n\nclass node:\n    color = 1\n    edges = set()\n\n",
        "code": "def canPaint(nodes, n, m):\n    visited = [0 for _ in range(n + 1)]\n    maxColors = 1\n    for _ in range(1, n + 1):\n        if visited[_]:\n            continue\n        visited[_] = 1\n        q = Queue()\n        q .put(_)\n        while not q .empty():\n            top = q .get()\n            for _ in nodes[top].edges:\n                if nodes[top].color == nodes[_].color:\n                    nodes[_].color += 1\n                maxColors = max(\n                    maxColors, max(\n                        nodes[top].color, nodes[_].color))\n                if maxColors > m:\n                    print(maxColors)\n                    return 0\n                if not visited[_]:\n                    visited[_] = 1\n                    q .put(_)\n    return 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    graph = [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]\n    m = 3\n    nodes = []\n    for _ in range(n + 1):\n        nodes .append(node())\n    for _ in range(n):\n        for __ in range(n):\n            if graph[_][__]:\n                nodes[_].edges .add(_)\n                nodes[__].edges .add(__)\n    print(canPaint(nodes, n, m))\n",
        "output": "1\n",
        "fn_call": "canPaint"
    },
    {
        "text": "number of symmetric relations on a set | function find the square of n ; base case ; return 2 ^ ( n ( n + 1 ) / 2 ) ; ",
        "context": "",
        "code": "def countSymmetric(n):\n    if (n == 0):\n        return 1\n    return (1 << ((n * (n + 1)) // 2))\n",
        "test": "\nn = 3\nprint(countSymmetric(n))\n",
        "output": "64\n",
        "fn_call": "countSymmetric"
    },
    {
        "text": "sum of alternating sign squares of first n natural numbers | function to calculate the alternating sign sum ; variable to store the sum ; loop to iterate each number from 1 to n ; the alternating sign is put by checking if the number is even or odd ; add the square with the sign ; add the square with the sign ; ",
        "context": "",
        "code": "def summation(n):\n    sum = 0\n    for i in range(1, n + 1):\n        if (i % 2 == 1):\n            sum += (i * i)\n        else:\n            sum -= (i * i)\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 2\n    print(summation(N))\n",
        "output": "-3\n",
        "fn_call": "summation"
    },
    {
        "text": "program to check diagonal matrix and scalar matrix | program to check matrix is scalar matrix or not . ; function to check matrix is scalar matrix or not . ; check all elements except main diagonal are zero or not . ; check all diagonal elements are same or not . ; ",
        "context": "\nN = 4\n\n",
        "code": "def isScalarMatrix(mat):\n    for i in range(0, N):\n        for j in range(0, N):\n            if ((i != j) and (mat[i][j] != 0)):\n                return False\n    for i in range(0, N - 1):\n        if (mat[i][i] != mat[i + 1][i + 1]):\n            return False\n    return True\n",
        "test": "\nmat = [[2, 0, 0, 0], [0, 2, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]]\nif (isScalarMatrix(mat)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isScalarMatrix"
    },
    {
        "text": "sum of all differences between maximum and minimum of increasing subarrays | function to calculate and return the sum of differences of maximum and minimum of strictly increasing subarrays ; stores the sum ; traverse the array ; if last element of the increasing sub - array is found ; update sum ; if the last element of the array is reached ; update sum ; return the sum ; ",
        "context": "",
        "code": "def sum_of_differences(arr, N):\n    sum = 0\n    i = 0\n    while (i < N - 1):\n        if arr[i] < arr[i + 1]:\n            flag = 0\n            for j in range(i + 1, N - 1):\n                if arr[j] >= arr[j + 1]:\n                    sum += (arr[j] - arr[i])\n                    i = j\n                    flag = 1\n                    break\n            if flag == 0 and arr[i] < arr[N - 1]:\n                sum += (arr[N - 1] - arr[i])\n                break\n        i += 1\n    return sum\n",
        "test": "\narr = [6, 1, 2, 5, 3, 4]\nN = len(arr)\nprint(sum_of_differences(arr, N))\n",
        "output": "5\n",
        "fn_call": "sum_of_differences"
    },
    {
        "text": "count the elements having frequency equals to its value | function to find the count ; hash map for counting frequency ; counting freq of each element ; check if value equals to frequency and increment the count ; ",
        "context": "",
        "code": "def find_maxm(arr, n):\n    mpp = {}\n    for i in range(0, n):\n        if arr[i] in mpp:\n            mpp[arr[i]] = mpp[arr[i]] + 1\n        else:\n            mpp[arr[i]] = 1\n    ans = 0\n    for key in mpp:\n        value = key\n        freq = mpp[key]\n        if value == freq:\n            ans = ans + 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 2, 2, 3, 4, 3]\n    n = len(arr)\n    print(find_maxm(arr, n))\n",
        "output": "2\n",
        "fn_call": "find_maxm"
    },
    {
        "text": "find sum of the series 1 + 22 + 333 + 4444 + ... ... upto n terms | function to calculate sum ; return sum ; ",
        "context": "",
        "code": "def solve_sum(n):\n    return (pow(10, n + 1) * (9 * n - 1) + 10) / pow(9, 3) - n * (n + 1) / 18\n",
        "test": "\nn = 3\nprint(int(solve_sum(n)))\n",
        "output": "356\n",
        "fn_call": "solve_sum"
    },
    {
        "text": "length of longest strictly increasing subset with each pair of adjacent elements satisfying the condition 2 * a [ i ] \u00e2 \u2030\u00a5 a [ i + 1 ] | function to find the length of the longest subset satisfying given conditions ; sort the array in ascending order ; stores the starting index and maximum length of the required subset ; pointer to traverse the array ; iterate while i < n ; stores end point of current subset ; store the length of the current subset ; continue adding elements to the current subset till the condition satisfies ; increment length of the current subset ; increment the pointer j ; if length of the current subset exceeds overall maximum length ; update maxlen ; update index ; increment j ; update i ; store the starting index of the required subset in i ; print the required subset ; print the array element ; decrement maxlen ; increment i ; ",
        "context": "",
        "code": "def maxLenSubset(a, n):\n    a .sort(reverse=False)\n    index = 0\n    maxlen = -1\n    i = 0\n    while (i < n):\n        j = i\n        len1 = 1\n        while (j < n - 1):\n            if (2 * a[j] >= a[j + 1]):\n                len1 += 1\n            else:\n                break\n            j += 1\n        if (maxlen < len1):\n            maxlen = len1\n            index = i\n        j += 1\n        i = j\n    i = index\n    while (maxlen > 0):\n        print(a[i], end=\" \")\n        maxlen -= 1\n        i += 1\n",
        "test": "\nif __name__ == '__main__':\n    a = [3, 1, 5, 11]\n    n = len(a)\n    maxLenSubset(a, n)\n",
        "output": "3 5 ",
        "fn_call": "maxLenSubset"
    },
    {
        "text": "minimum length subarray containing all unique elements after q operations | function to find minimum size subarray of all array elements ; updating the array after processing each query ; making it to 0 - indexing ; prefix sum array concept is used to obtain the count array ; iterating over the array to get the final array ; variable to get count of all unique elements ; hash to maintain perviously occurred elements ; loop to find the all unique elements ; array to maintain counter of encountered elements ; variable to store answer ; using two pointers approach ; increment counter if occurred once ; when all unique elements are found ; update answer with minimum size ; decrement count of elements from left ; decrement counter ; ",
        "context": "",
        "code": "def subarrayLength(A, R, N, M):\n    for i in range(M):\n        l = R[i][0]\n        r = R[i][1] + 1\n        l -= 1\n        r -= 1\n        A[l] += 1\n        if (r < N):\n            A[r] -= 1\n    for i in range(1, N):\n        A[i] += A[i - 1]\n    count = 0\n    s = []\n    for i in range(N):\n        if (A[i]not in s):\n            count += 1\n        s .append(A[i])\n    repeat = [0] * (count + 1)\n    ans = N\n    counter, left, right = 0, 0, 0\n    while (right < N):\n        cur_element = A[right]\n        repeat[cur_element] += 1\n        if (repeat[cur_element] == 1):\n            counter += 1\n        while (counter == count):\n            ans = min(ans, right - left + 1)\n            cur_element = A[left]\n            repeat[cur_element] -= 1\n            left += 1\n            if (repeat[cur_element] == 0):\n                counter -= 1\n        right += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    N, queries = 8, 6\n    Q = [[1, 4], [3, 4], [4, 5], [5, 5], [7, 8], [8, 8]]\n    A = [0] * N\n    print(subarrayLength(A, Q, N, queries))\n",
        "output": "4\n",
        "fn_call": "subarrayLength"
    },
    {
        "text": "program to remove vowels from a string | python program to remove vowels from a string function to remove vowels ; ",
        "context": "",
        "code": "def rem_vowel(string):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = [letter for letter in string if letter .lower()not in vowels]\n    result = ''.join(result)\n    print(result)\n",
        "test": "\nstring = \"GeeksforGeeks - A Computer Science Portal for Geeks\"\nrem_vowel(string)\nstring = \"Loving Python LOL\"\nrem_vowel(string)\n",
        "output": "GksfrGks -  Cmptr Scnc Prtl fr Gks\nLvng Pythn LL\n",
        "fn_call": "rem_vowel"
    },
    {
        "text": "length of the chord the circle if length of the another chord which is equally inclined through the diameter is given | python3 program to find the length of the chord of the circle if length of the other chord which is equally inclined through the diameter is given ; ",
        "context": "",
        "code": "def lengchord(z):\n    print(\"The length is \", end=\"\")\n    print(z)\n",
        "test": "\nz = 48\nlengchord(z)\n",
        "output": "The length is 48\n",
        "fn_call": "lengchord"
    },
    {
        "text": "non | efficient python program to print all non - repeating elements . ; insert all array elements in hash table ; traverse through map only and ; ",
        "context": "",
        "code": "def firstNonRepeating(arr, n):\n    mp = {}\n    for i in range(n):\n        if arr[i]not in mp:\n            mp[arr[i]] = 0\n        mp[arr[i]] += 1\n    for x in mp:\n        if (mp[x] == 1):\n            print(x, end=\" \")\n",
        "test": "\narr = [9, 4, 9, 6, 7, 4]\nn = len(arr)\nfirstNonRepeating(arr, n)\n",
        "output": "6 7 ",
        "fn_call": "firstNonRepeating"
    },
    {
        "text": "maximize the number of indices such that element is greater than element to its left | function to find the maximum pairs such that arr [ i + 1 ] > arr [ i ] ; to store the frequency of the element in arr [ ] ; store the frequency in map m ; to find the maximum frequency store in map m ; print the maximum number of possible pairs ; ",
        "context": "",
        "code": "def countPairs(arr, N):\n    M = dict .fromkeys(arr, 0)\n    for i in range(N):\n        M[arr[i]] += 1\n    maxFreq = 0\n    for it in M .values():\n        maxFreq = max(maxFreq, it)\n    print(N - maxFreq)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 8, 5, 9, 8, 8, 7, 7, 5, 7, 7]\n    N = len(arr)\n    countPairs(arr, N)\n",
        "output": "7\n",
        "fn_call": "countPairs"
    },
    {
        "text": "count numbers from a given range that contains a given number as the suffix | python3 program of the above approach ; function to count the number ends with given number in range ; find number of digits in a ; find the power of 10 ; incrementing the a ; ",
        "context": "\nfrom math import log10\n\n",
        "code": "def countNumEnds(A, L, R):\n    count = 0\n    digits = int(log10(A) + 1)\n    temp = int(pow(10, digits))\n    cycle = temp\n    while (temp <= R):\n        if (temp >= L):\n            count += 1\n        temp += cycle\n    print(count)\n",
        "test": "\nA = 2\nL = 2\nR = 20\ncountNumEnds(A, L, R)\n",
        "output": "2\n",
        "fn_call": "countNumEnds"
    },
    {
        "text": "how to validate html tag using regular expression | python3 program to validate html tag using regex . using regular expression ; function to validate html tag using regex . ; regex to check valid html tag using regex . ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidHTMLTag(str):\n    regex = \"])*>\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"'>\"\nprint(isValidHTMLTag(str1))\nstr2 = \"\"\nprint(isValidHTMLTag(str2))\nstr3 = \"br/>\"\nprint(isValidHTMLTag(str3))\nstr4 = \"\"\nprint(isValidHTMLTag(str4))\n",
        "output": "False\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidHTMLTag"
    },
    {
        "text": "queries to find minimum sum of array elements from either end of an array | function to find the minimum sum for the given queries ; stores prefix and suffix sums ; stores pairs of prefix and suffix sums ; traverse the array ; add element to prefix ; store prefix for each element ; traverse the array in reverse ; add element to suffix ; storing suffix for each element ; traverse the array queries [ ] ; minimum of suffix and prefix sums ; ",
        "context": "",
        "code": "def calculateQuery(arr, N, query, M):\n    prefix = 0\n    suffix = 0\n    mp = {}\n    for i in range(N):\n        prefix += arr[i]\n        mp[arr[i]] = [prefix, 0]\n    for i in range(N - 1, -1, -1):\n        suffix += arr[i]\n        mp[arr[i]] = [mp[arr[i]][0], suffix]\n    for i in range(M):\n        X = query[i]\n        print(min(mp[X][0], mp[X][1]), end=\" \")\n",
        "test": "\narr = [2, 3, 6, 7, 4, 5, 30]\nqueries = [6, 5]\nN = len(arr)\nM = len(queries)\ncalculateQuery(arr, N, queries, M)\n",
        "output": "11 27 ",
        "fn_call": "calculateQuery"
    },
    {
        "text": "check if a string is concatenation of another given string | function to check if a is concatenation of another string ; stores the length of str2 ; stores the length of str1 ; if m is not multiple of n ; traverse both the strings ; if str1 is not concatenation of str2 ; ",
        "context": "",
        "code": "def checkConcat(str1, str2):\n    N = len(str1)\n    M = len(str2)\n    if (N % M != 0):\n        return False\n    for i in range(N):\n        if (str1[i] != str2[i % M]):\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"abcabcabc\"\n    str2 = \"abc\"\n    if (checkConcat(str1, str2)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkConcat"
    },
    {
        "text": "Find pair with maximum GCD in an array | function to find GCD of pair with max GCD in the array ; Calculating MAX in array ; Maintaining count array ; Variable to store the multiples of a number ; Iterating from MAX to 1 GCD is always between MAX and 1 The first GCD found will be the highest as we are decrementing the potential GCD ; Iterating from current potential GCD till it is less than MAX ; A multiple found ; Incrementing potential GCD by itself To check i , 2 i , 3 i ... . ; 2 multiples found , max GCD found ; Array in which pair with max GCD is to be found ; Size of array",
        "context": "",
        "code": "def findMaxGCD(arr, n):\n    high = 0\n    for i in range(0, n):\n        high = max(high, arr[i])\n    count = [0] * (high + 1)\n    for i in range(0, n):\n        count[arr[i]] += 1\n    counter = 0\n    for i in range(high, 0, -1):\n        j = i\n        while (j <= high):\n            if (count[j] > 0):\n                counter += count[j]\n            j += i\n            if (counter == 2):\n                return i\n        counter = 0\n",
        "test": "\narr = [1, 2, 4, 8, 8, 12]\nn = len(arr)\nprint(findMaxGCD(arr, n))\n",
        "output": "8\n",
        "fn_call": "findMaxGCD"
    },
    {
        "text": "centered hexadecagonal number | centered hexadecagonal function ; formula to calculate nth centered hexadecagonal number ; ",
        "context": "",
        "code": "def center_hexadecagonal_num(n):\n    return 8 * n * n - 8 * n + 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    print(n, \"nd centered hexadecagonal \" +\n          \"number : \", center_hexadecagonal_num(n))\n    n = 12\n    print(n, \"th centered hexadecagonal \" +\n          \"number : \", center_hexadecagonal_num(n))\n",
        "output": "2 nd centered hexadecagonal number :  17\n12 th centered hexadecagonal number :  1057\n",
        "fn_call": "center_hexadecagonal_num"
    },
    {
        "text": "area of circle inscribed within rhombus | function to find the area of the inscribed circle ; the diagonals cannot be negative ; area of the circle ; ",
        "context": "",
        "code": "def circlearea(a, b):\n    if (a < 0 or b < 0):\n        return -1\n    A = ((3.14 * pow(a, 2) * pow(b, 2)) / (4 * (pow(a, 2) + pow(b, 2))))\n    return A\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 8\n    b = 10\n    print(circlearea(a, b))\n",
        "output": "30.634146341463413\n",
        "fn_call": "circlearea"
    },
    {
        "text": "merge two sorted arrays | merge arr1 [ 0. . n1 - 1 ] and arr2 [ 0. . n2 - 1 ] into arr3 [ 0. . n1 + n2 - 1 ] ; traverse both array ; check if current element of first array is smaller than current element of second array . if yes , store first array element and increment first array index . otherwise do same with second array ; store remaining elements of first array ; store remaining elements of second array ; ",
        "context": "",
        "code": "def mergeArrays(arr1, arr2, n1, n2):\n    arr3 = [None] * (n1 + n2)\n    i = 0\n    j = 0\n    k = 0\n    while i < n1 and j < n2:\n        if arr1[i] < arr2[j]:\n            arr3[k] = arr1[i]\n            k = k + 1\n            i = i + 1\n        else:\n            arr3[k] = arr2[j]\n            k = k + 1\n            j = j + 1\n    while i < n1:\n        arr3[k] = arr1[i]\n        k = k + 1\n        i = i + 1\n    while j < n2:\n        arr3[k] = arr2[j]\n        k = k + 1\n        j = j + 1\n    print(\"Array after merging\")\n    for i in range(n1 + n2):\n        print(str(arr3[i]), end=\" \")\n",
        "test": "\narr1 = [1, 3, 5, 7]\nn1 = len(arr1)\narr2 = [2, 4, 6, 8]\nn2 = len(arr2)\nmergeArrays(arr1, arr2, n1, n2)\n",
        "output": "Array after merging\n1 2 3 4 5 6 7 8 ",
        "fn_call": "mergeArrays"
    },
    {
        "text": "count of total bits toggled / flipped in binary representation of 0 to n | function to count and pr the required number of toggles ; store the count of toggles ; add the contribution of the current lsb ; update n ; print the result ; ",
        "context": "",
        "code": "def solve(N):\n    ans = 0\n    while (N != 0):\n        ans += N\n        N //= 2\n    print(ans)\n",
        "test": "\nN = 5\nsolve(N)\n",
        "output": "8\n",
        "fn_call": "solve"
    },
    {
        "text": "deficient number | python program to implement an optimized solution to check deficient number ; function to calculate sum of divisors ; note that this loop runs till square root of n ; if divisors are equal , take only one of them ; else : otherwise take both ; function to check deficient number ; check if sum ( n ) < 2 * n ; ",
        "context": "\nimport math\n\n",
        "code": "def divisorsSum(n):\n    sum = 0\n    i = 1\n    while i <= math .sqrt(n):\n        if (n % i == 0):\n            if (n / i == i):\n                sum = sum + i\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    return sum\n\n\ndef isDeficient(n):\n    return (divisorsSum(n) < (2 * n))\n",
        "test": "\nif (isDeficient(12)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\nif (isDeficient(15)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\nYES\n",
        "fn_call": "isDeficient"
    },
    {
        "text": "number of ways to cut a stick of length n into in even length at most k units long pieces | recursive function to count the total number of ways ; base case if no - solution exist ; condition if a solution exist ; check if already calculated ; initialize counter ; recursive call ; store the answer ; return the answer ; ",
        "context": "",
        "code": "def solve(n, k, mod, dp):\n    if (n < 0):\n        return 0\n    if (n == 0):\n        return 1\n    if (dp[n] != -1):\n        return dp[n]\n    cnt = 0\n    for i in range(2, k + 1, 2):\n        cnt = ((cnt % mod + solve(n - i, k, mod, dp) % mod) % mod)\n    dp[n] = cnt\n    return int(cnt)\n",
        "test": "\nif __name__ == '__main__':\n    mod = 1e9 + 7\n    n = 4\n    k = 2\n    dp = [-1] * (n + 1)\n    ans = solve(n, k, mod, dp)\n    print(ans)\n",
        "output": "1\n",
        "fn_call": "solve"
    },
    {
        "text": "print all integers that are sum of powers of two given numbers | function to print powerful integers ; set is used to store distinct numbers in sorted order ; store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; if num is within limits insert it into the set ; break out of the inner loop ; adding any number to it will be out of bounds ; increment i ; print the contents of the set ; ",
        "context": "",
        "code": "def powerfulIntegers(x, y, bound):\n    s = set()\n    powersOfY = []\n    powersOfY .append(1)\n    i = y\n    while i < bound and y != 1:\n        powersOfY .append(i)\n        i *= y\n    i = 0\n    while (True):\n        xPowI = pow(x, i)\n        for j in powersOfY:\n            num = xPowI + j\n            if (num <= bound):\n                s .add(num)\n            else:\n                break\n        if (xPowI >= bound or x == 1):\n            break\n        i += 1\n    for itr in s:\n        print(itr, end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 2\n    y = 3\n    bound = 10\n    powerfulIntegers(x, y, bound)\n",
        "output": "2 3 4 5 7 9 10 ",
        "fn_call": "powerfulIntegers"
    },
    {
        "text": "all unique triplets that sum up to a given value | function to all find unique triplets without using extra space ; sort the input array ; for handling the cases when no such triplets exits . ; iterate over the array from start to n - 2. ; index of the first element in remaining range . ; index of the last element ; setting our new target ; checking if current element is same as previous ; checking if current element is same as previous ; if we found the triplets then print it and set the flag ; if target is greater then increment the start index ; if target is smaller than decrement the end index ; if no such triplets found ; ",
        "context": "",
        "code": "def findTriplets(a, n, sum):\n    a .sort()\n    flag = False\n    for i in range(n - 2):\n        if (i == 0 or a[i] > a[i - 1]):\n            start = i + 1\n            end = n - 1\n            target = sum - a[i]\n            while (start < end):\n                if (start > i + 1 and a[start] == a[start - 1]):\n                    start += 1\n                    continue\n                if (end < n - 1 and a[end] == a[end + 1]):\n                    end -= 1\n                    continue\n                if (target == a[start] + a[end]):\n                    print(\"[\", a[i], \",\", a[start], \",\", a[end], \"]\", end=\" \")\n                    flag = True\n                    start += 1\n                    end -= 1\n                elif (target > (a[start] + a[end])):\n                    start += 1\n                else:\n                    end -= 1\n    if (flag == False):\n        print(\"No Such Triplets Exist\")\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [12, 3, 6, 1, 6, 9]\n    n = len(a)\n    sum = 24\n    findTriplets(a, n, sum)\n",
        "output": "[ 3 , 9 , 12 ] [ 6 , 6 , 12 ] ",
        "fn_call": "findTriplets"
    },
    {
        "text": "number of points lying inside a rectangle as well as a triangle | function to calculate area of a triangle ; return the resultant area ; function to check if a point lies inside a triangle or not ; calculate area of triangle abc ; calculate area of triangle formed by connecting b , c , point ; calculate area of triangle formed by connecting a , c , point ; calculate area of triangle formed by connecting a , b , point ; check if the sum of the areas of above three triangles the same as abc ; function to count the number of points lying inside a triangle & rectangle ; stores the coordinates of the vertices of the triangles ; stores the number of points lying inside the triangle and rectangle ; traverse the array of points ; stores whether the current point lies inside triangle1 or not ; stores whether the current point lies inside triangle2 or not ; stores whether the current point lies inside triangle3 or not ; stores whether the current point lies inside triangle4 or not ; stores whether the current point lies inside given triangle or not ; if current point lies inside given triangle as well as inside any of the four obtained triangles ; print the count of points ; ",
        "context": "",
        "code": "def getArea(x1, y1, x2, y2, x3, y3):\n    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n\ndef isInside(triangle, point):\n    A, B, C = triangle\n    x, y = point\n    ABC = getArea(A[0], A[1], B[0], B[1], C[0], C[1])\n    BPC = getArea(x, y, B[0], B[1], C[0], C[1])\n    APC = getArea(A[0], A[1], x, y, C[0], C[1])\n    APB = getArea(A[0], A[1], B[0], B[1], x, y)\n    return ABC == (APC + APB + BPC)\n\n\ndef countPoints(rectangle, triangle, points):\n    triangle1 = rectangle[1:]\n    triangle2 = rectangle[:3]\n    triangle3 = rectangle[:2]\n    triangle3 .append(rectangle[3])\n    triangle4 = rectangle[-2:]\n    triangle4 .append(rectangle[0])\n    ans = 0\n    for point in points:\n        condOne = isInside(triangle1, point)\n        condTwo = isInside(triangle2, point)\n        condThree = isInside(triangle3, point)\n        condFour = isInside(triangle4, point)\n        condFive = isInside(triangle, point)\n        if (condOne or condTwo or condThree or condFour) and condFive:\n            ans += 1\n    print(ans)\n",
        "test": "\nrectangle = [[6, 5], [2, 2], [2, 1], [5, 5]]\npoints = [[1, 1], [6, 1], [6, 6], [1, 6]]\ntriangle = [[4, 4], [0, 4], [0, -2]]\ncountPoints(points, triangle, rectangle)\n",
        "output": "2\n",
        "fn_call": "countPoints"
    },
    {
        "text": "minimum cost to reduce the integer n to 1 as per given conditions | function to find the minimum cost to reduce the integer n to 1 by the given operations ; check if x is 1 ; print the answer ; prestore the answer ; iterate till n exists ; divide n by x ; reduce n by x ; add the cost ; update the answer ; return the answer ; ",
        "context": "",
        "code": "def min_cost(n, x, p, q):\n    if (x == 1):\n        print((n - 1) * p)\n        return 0\n    ans = (n - 1) * p\n    pre = 0\n    while (n > 1):\n        tmp = n // x\n        if (tmp < 0):\n            break\n        pre += (n - tmp * x) * p\n        n //= x\n        pre += q\n        ans = min(ans, pre + (n - 1) * p)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    x = 2\n    p = 2\n    q = 3\n    print(min_cost(n, x, p, q))\n",
        "output": "7\n",
        "fn_call": "min_cost"
    },
    {
        "text": "minimum cost to complete given tasks if cost of 1 , 7 and 30 days are given | function to find the minimum cost to hire the workers for the given days in the array days [ ] ; initialize the array dp ; minimum cost for nth day ; poleter of the array arr [ ] ; traverse from right to left ; if worker is hired for 1 day ; if worker is hired for 7 days ; if worker is hired for 30 days ; update the value of dp [ i ] as minimum of 3 options ; if the day is not at the array arr [ ] ; return the answer ; ",
        "context": "",
        "code": "def MinCost(days, cost, N):\n    size = days[N - 1] + 1\n    dp = [0 for i in range(size)]\n    dp[size - 1] = min(cost[0], min(cost[1], cost[2]))\n    ptr = N - 2\n    for i in range(size - 2, 0, -1):\n        if (ptr >= 0 and days[ptr] == i):\n            val1 = dp[i + 1] + cost[0]\n            val2 = cost[1] + (0 if (i + 7 >= size)else dp[i + 7])\n            val3 = cost[2] + (0 if (i + 30 >= size)else dp[i + 30])\n            dp[i] = min(val1, min(val2, val3))\n            ptr -= 1\n        else:\n            dp[i] = dp[i + 1]\n    return dp[1]\n",
        "test": "\narr = [2, 4, 6, 7, 8, 10, 17]\ncost = [3, 8, 20]\nN = len(arr)\nprint(MinCost(arr, cost, N))\n",
        "output": "14\n",
        "fn_call": "MinCost"
    },
    {
        "text": "smallest possible integer to be added to n | function to find the smallest positive integer x such that x is added to every element of a except one element to give array b ; stores the unique elements of array a ; insert a [ i ] into the set s ; sort array a [ ] ; sort array b [ ] ; assume x value as b [ 0 ] - a [ 1 ] ; check if x value assumed is negative or 0 ; update the x value to b [ 0 ] - a [ 0 ] ; if assumed value is wrong ; update x value ; ",
        "context": "",
        "code": "def findVal(A, B, N):\n    s = set()\n    for i in range(N):\n        s .add(A[i])\n    A .sort()\n    B .sort()\n    X = B[0] - A[1]\n    if (X <= 0):\n        X = B[0] - A[0]\n    else:\n        for i in range(N - 1):\n            if (B[i] - X not in s):\n                X = B[0] - A[0]\n                break\n    print(X)\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 4, 3, 8]\n    B = [15, 8, 11]\n    N = len(A)\n    findVal(A, B, N)\n",
        "output": "7\n",
        "fn_call": "findVal"
    },
    {
        "text": "find the numbers from 1 to n that contains exactly k non | function to find number less than n having k non - zero digits ; store the memorised values ; initialise ; base ; calculate all states for every state , from numbers 1 to n , the count of numbers which contain exactly j non zero digits is being computed and updated in the dp array . ; return the required answer ; ",
        "context": "",
        "code": "def k_nonzero_numbers(s, n, k):\n    dp = [[[0 for i in range(k + 2)]for i in range(2)]for i in range(n + 2)]\n    for i in range(n + 1):\n        for j in range(2):\n            for x in range(k + 1):\n                dp[i][j][x] = 0\n    dp[0][0][0] = 1\n    for i in range(n):\n        sm = 0\n        while (sm < 2):\n            for j in range(k + 1):\n                x = 0\n                y = 0\n                if sm:\n                    y = 9\n                else:\n                    y = ord(s[i]) - ord('0')\n                while (x <= y):\n                    dp[i + 1][(sm or x < (ord(s[i]) - ord('0')))\n                              ][j + (x > 0)] += dp[i][sm][j]\n                    x += 1\n            sm += 1\n    return dp[n][0][k] + dp[n][1][k]\n",
        "test": "\nif __name__ == '__main__':\n    s = \"25\"\n    k = 2\n    n = len(s)\n    print(k_nonzero_numbers(s, n, k))\n",
        "output": "14\n",
        "fn_call": "k_nonzero_numbers"
    },
    {
        "text": "longest substring with no pair of adjacent characters are adjacent english alphabets | function to find the longest substring satisfying the given condition ; stores all temporary substrings ; stores the longest substring ; stores the length of the subt ; stores the first character of s ; traverse the string ; if the absolute difference is 1 ; update the length of subt ; update the longest substring ; otherwise , stores the current character ; again checking for longest substring and update accordingly ; print the longest substring ; ",
        "context": "",
        "code": "def findSubstring(S):\n    T = \"\"\n    ans = \"\"\n    l = 0\n    T += S[0]\n    for i in range(1, len(S)):\n        if (abs(ord(S[i]) - ord(S[i - 1])) == 1):\n            l = len(T)\n            if (l > len(ans)):\n                ans = T\n            T = \"\"\n            T += S[i]\n        else:\n            T += S[i]\n    l = len(T)\n    if (l > len(ans)):\n        ans = T\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"aabdml\"\n    findSubstring(S)\n",
        "output": "bdm\n",
        "fn_call": "findSubstring"
    },
    {
        "text": "find nth term ( a matrix exponentiation example ) | python3 program to find n - th term of a recursive function using matrix exponentiation . ; this power function returns first row of { transformation matrix } ^ n - 1 * initial vector ; this is an identity matrix . ; this is transformation matrix . ; matrix exponentiation to calculate power of { tmat } ^ n - 1 store res in \" res \" matrix . ; res store { transformation matrix } ^ n - 1 hence will be first row of res * initial vector . ; ",
        "context": "\nMOD = 1000000009\n\n",
        "code": "def power(n):\n    if (n <= 1):\n        return 1\n    n -= 1\n    res = [[1, 0], [0, 1]]\n    tMat = [[2, 3], [1, 0]]\n    while (n):\n        if (n & 1):\n            tmp = [[0 for x in range(2)]for y in range(2)]\n            tmp[0][0] = (res[0][0] * tMat[0][0] + res[0][1] * tMat[1][0]) % MOD\n            tmp[0][1] = (res[0][0] * tMat[0][1] + res[0][1] * tMat[1][1]) % MOD\n            tmp[1][0] = (res[1][0] * tMat[0][0] + res[1][1] * tMat[1][0]) % MOD\n            tmp[1][1] = (res[1][0] * tMat[0][1] + res[1][1] * tMat[1][1]) % MOD\n            res[0][0] = tmp[0][0]\n            res[0][1] = tmp[0][1]\n            res[1][0] = tmp[1][0]\n            res[1][1] = tmp[1][1]\n        n = n // 2\n        tmp = [[0 for x in range(2)]for y in range(2)]\n        tmp[0][0] = (tMat[0][0] * tMat[0][0] + tMat[0][1] * tMat[1][0]) % MOD\n        tmp[0][1] = (tMat[0][0] * tMat[0][1] + tMat[0][1] * tMat[1][1]) % MOD\n        tmp[1][0] = (tMat[1][0] * tMat[0][0] + tMat[1][1] * tMat[1][0]) % MOD\n        tmp[1][1] = (tMat[1][0] * tMat[0][1] + tMat[1][1] * tMat[1][1]) % MOD\n        tMat[0][0] = tmp[0][0]\n        tMat[0][1] = tmp[0][1]\n        tMat[1][0] = tmp[1][0]\n        tMat[1][1] = tmp[1][1]\n    return (res[0][0] * 1 + res[0][1] * 1) % MOD\n",
        "test": "\nn = 3\nprint(power(n))\n",
        "output": "13\n",
        "fn_call": "power"
    },
    {
        "text": "reduce the string to minimum length with the given operation | function to return the minimum possible length str can be reduced to with the given operation ; stack to store the characters of the given string ; for every character of the string ; if the stack is empty then push the current character in the stack ; get the top character ; if the top element is not equal to the current element and it only differs in the case ; pop the top element from stack ; else push the current element ; ",
        "context": "",
        "code": "def minLength(string, l):\n    s = []\n    for i in range(l):\n        if (len(s) == 0):\n            s .append(string[i])\n        else:\n            c = s[-1]\n            if (c != string[i] and c .upper() == string[i].upper()):\n                s .pop()\n            else:\n                s .append(string[i])\n    return len(s)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"ASbBsd\"\n    l = len(string)\n    print(minLength(string, l))\n",
        "output": "2\n",
        "fn_call": "minLength"
    },
    {
        "text": "check if the array has an element which is equal to xor of remaining elements | function that returns true if the array contains an element which is equal to the xor of the remaining elements ; to store the xor of all the array elements ; for every element of the array ; take the xor after excluding the current element ; if the xor of the remaining elements is equal to the current element ; if no such element is found ; ",
        "context": "",
        "code": "def containsElement(arr, n):\n    xorArr = 0\n    for i in range(n):\n        xorArr ^= arr[i]\n    for i in range(n):\n        x = xorArr ^ arr[i]\n        if (arr[i] == x):\n            return True\n    return False\n",
        "test": "\narr = [8, 2, 4, 15, 1]\nn = len(arr)\nif (containsElement(arr, n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "containsElement"
    },
    {
        "text": "construct an array from its pair | fills element in arr [ ] from its pair sum array pair [ ] . n is size of arr [ ] ; ",
        "context": "",
        "code": "def constructArr(arr, pair, n):\n    arr[0] = (pair[0] + pair[1] - pair[n - 1]) // 2\n    for i in range(1, n):\n        arr[i] = pair[i - 1] - arr[0]\n",
        "test": "\nif __name__ == '__main__':\n    pair = [15, 13, 11, 10, 12, 10, 9, 8, 7, 5]\n    n = 5\n    arr = [0] * n\n    constructArr(arr, pair, n)\n    for i in range(n):\n        print(arr[i], end=\" \")\n",
        "output": "8 7 5 3 2 ",
        "fn_call": "constructArr"
    },
    {
        "text": "sum of product of consecutive binomial coefficients | python3 program to find sum of product of consecutive binomial coefficient . ; find the binomial coefficient up to nth term ; c [ 0 ] = 1 ; nc0 is 1 ; compute next row of pascal triangle using the previous row ; return the sum of the product of consecutive binomial coefficient . ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def binomialCoeff(n, k):\n    C = [0] * (k + 1)\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n\n\ndef sumOfproduct(n):\n    return binomialCoeff(2 * n, n - 1)\n",
        "test": "\nn = 3\nprint(sumOfproduct(n))\n",
        "output": "0\n",
        "fn_call": "sumOfproduct"
    },
    {
        "text": "check if a string contains a palindromic sub | function to check if two consecutive same characters are present ; ",
        "context": "",
        "code": "def check(s):\n    for i in range(0, len(s)):\n        if (s[i] == s[i + 1]):\n            return True\n    return False\n",
        "test": "\ns = \"xzyyz\"\nif (check(s)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "check"
    },
    {
        "text": "maximum number of multiplication by 3 or division by 2 operations possible on an array | function to count maximum number of multiplication by 3 or division by 2 operations that can be performed ; stores the maximum number of operations possible ; traverse the array arr [ ] ; iterate until arr [ i ] is even ; increment count by 1 ; update arr [ i ] ; return the value of count as the answer ; ",
        "context": "",
        "code": "def maximumTurns(arr, N):\n    Count = 0\n    for i in range(0, N):\n        while (arr[i] % 2 == 0):\n            Count += 1\n            arr[i] = arr[i] // 2\n    return Count\n",
        "test": "\narr = [5, 2, 4]\nM = 3\nK = 2\nN = len(arr)\nprint(maximumTurns(arr, N))\n",
        "output": "3\n",
        "fn_call": "maximumTurns"
    },
    {
        "text": "count nodes within k | python3 program to count nodes inside k distance range from marked nodes ; utility bfs method to fill distance vector and returns most distant marked node from node u ; push node u in queue and initialize its distance as 0 ; loop untill all nodes are processed ; if node is marked , update lastmarked variable ; loop over all neighbors of u and update their distance before pushing in queue ; if not given value already ; return last updated marked value ; method returns count of nodes which are in k - distance range from marked nodes ; vertices in a tree are one more than number of edges ; fill vector for graph ; fill boolean array mark from marked array ; vectors to store distances ; first bfs ( from any random node ) to get one distant marked node ; second bfs to get other distant marked node and also dl is filled with distances from first chosen marked node ; third bfs to fill dr by distances from second chosen marked node ; loop over all nodes ; increase res by 1 , if current node has distance less than k from both extreme nodes ; ",
        "context": "\nimport queue\n\n",
        "code": "def bfsWithDistance(g, mark, u, dis):\n    lastMarked = 0\n    q = queue .Queue()\n    q .put(u)\n    dis[u] = 0\n    while (not q .empty()):\n        u = q .get()\n        if (mark[u]):\n            lastMarked = u\n        for i in range(len(g[u])):\n            v = g[u][i]\n            if (dis[v] == -1):\n                dis[v] = dis[u] + 1\n                q .put(v)\n    return lastMarked\n\n\ndef nodesKDistanceFromMarked(edges, V, marked, N, K):\n    V = V + 1\n    g = [[]for i in range(V)]\n    u, v = 0, 0\n    for i in range(V - 1):\n        u = edges[i][0]\n        v = edges[i][1]\n        g[u].append(v)\n        g[v].append(u)\n    mark = [False] * V\n    for i in range(N):\n        mark[marked[i]] = True\n    tmp = [-1] * V\n    dl = [-1] * V\n    dr = [-1] * V\n    u = bfsWithDistance(g, mark, 0, tmp)\n    u = bfsWithDistance(g, mark, u, dl)\n    bfsWithDistance(g, mark, u, dr)\n    res = 0\n    for i in range(V):\n        if (dl[i] <= K and dr[i] <= K):\n            res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    edges = [\n        [\n            1, 0], [\n            0, 3], [\n                0, 8], [\n                    2, 3], [\n                        3, 5], [\n                            3, 6], [\n                                3, 7], [\n                                    4, 5], [\n                                        5, 9]]\n    V = len(edges)\n    marked = [1, 2, 4]\n    N = len(marked)\n    K = 3\n    print(nodesKDistanceFromMarked(edges, V, marked, N, K))\n",
        "output": "6\n",
        "fn_call": "nodesKDistanceFromMarked"
    },
    {
        "text": "program to print tetrahedral numbers upto nth term | function to generate nth triangular number ; function to print tetrahedral number series up to n ; initialize prev as 0. it stores the sum of all previously generated triangular number ; loop to print series ; find ith triangular number ; add ith triangular number to sum of all previously generated triangular number to get ith tetrahedral number ; update sum of all previously generated triangular number ; ",
        "context": "",
        "code": "def findTriangularNumber(n):\n    return (n * (n + 1)) / 2\n\n\ndef printSeries(n):\n    prev = 0\n    for i in range(1, n + 1):\n        curr = findTriangularNumber(i)\n        curr = int(curr + prev)\n        print(curr, end=' ')\n        prev = curr\n",
        "test": "\nn = 10\nprintSeries(n)\n",
        "output": "1 4 10 20 35 56 84 120 165 220 ",
        "fn_call": "printSeries"
    },
    {
        "text": "duplicates in an array in o ( n ) time and by using o ( 1 ) extra space | set | function to find repeating elements ; flag variable used to represent whether repeating element is found or not . ; check if current element is repeating or not . if it is repeating then value will be greater than or equal to n . ; check if it is first repetition or not . if it is first repetition then value at index arr [ i ] is less than 2 * n . print arr [ i ] if it is first repetition . ; add n to index arr [ i ] to mark presence of arr [ i ] or to mark repetition of arr [ i ] . ; if flag variable is not set then no repeating element is found . so print - 1. ; ",
        "context": "",
        "code": "def printDuplicates(arr, n):\n    fl = 0\n    for i in range(0, n):\n        if (arr[arr[i] % n] >= n):\n            if (arr[arr[i] % n] < 2 * n):\n                print(arr[i] % n, end=\" \")\n                fl = 1\n        arr[arr[i] % n] += n\n    if (fl == 0):\n        print(\"-1\")\n",
        "test": "\narr = [1, 6, 3, 1, 3, 6, 6]\narr_size = len(arr)\nprintDuplicates(arr, arr_size)\n",
        "output": "1 3 6 ",
        "fn_call": "printDuplicates"
    },
    {
        "text": "print n | function to generate n digit numbers ; if number generated ; append 1 at the current number and reduce the remaining places by one ; if more ones than zeros , append 0 to the current number and reduce the remaining places by one ; ",
        "context": "",
        "code": "def printRec(number, extraOnes, remainingPlaces):\n    if (0 == remainingPlaces):\n        print(number, end=\" \")\n        return\n    printRec(number + \"1\", extraOnes + 1, remainingPlaces - 1)\n    if (0 < extraOnes):\n        printRec(number + \"0\", extraOnes - 1, remainingPlaces - 1)\n\n\ndef printNums(n):\n    str = \"\"\n    printRec(str, 0, n)\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    printNums(n)\n",
        "output": "1111 1110 1101 1100 1011 1010 ",
        "fn_call": "printNums"
    },
    {
        "text": "find index i such that prefix of s1 and suffix of s2 till i form a palindrome when concatenated | function that returns true if the sub - string starting from index i and ending at index j is a palindrome ; function to get the required index ; start comparing the two strings from both ends . ; break from the loop at first mismatch ; if it is possible to concatenate the strings to form palindrome , return index ; if remaining part for s2 is palindrome ; if remaining part for s1 is palindrome ; if not possible , return - 1 ; ",
        "context": "",
        "code": "def isPalindrome(s, i, j):\n    while (i < j):\n        if (s[i] != s[j]):\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\ndef getIndex(s1, s2, length):\n    i = 0\n    j = length - 1\n    while (i < j):\n        if (s1[i] != s2[j]):\n            break\n        i += 1\n        j -= 1\n    if (i == j):\n        return i - 1\n    elif (isPalindrome(s2, i, j)):\n        return i - 1\n    elif (isPalindrome(s1, i, j)):\n        return j\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"abcdf\"\n    s2 = \"sfgba\"\n    length = len(s1)\n    print(getIndex(s1, s2, length))\n",
        "output": "1\n",
        "fn_call": "getIndex"
    },
    {
        "text": "a product array puzzle | function to print product array for a given array arr [ ] of size n ; base case ; allocate memory for the product array ; in this loop , temp variable contains product of elements on left side excluding arr [ i ] ; initialize temp to 1 for product on right side ; in this loop , temp variable contains product of elements on right side excluding arr [ i ] ; print the constructed prod array ; ",
        "context": "",
        "code": "def productArray(arr, n):\n    if n == 1:\n        print(0)\n        return\n    i, temp = 1, 1\n    prod = [1 for i in range(n)]\n    for i in range(n):\n        prod[i] = temp\n        temp *= arr[i]\n    temp = 1\n    for i in range(n - 1, -1, -1):\n        prod[i] *= temp\n        temp *= arr[i]\n    for i in range(n):\n        print(prod[i], end=\" \")\n    return\n",
        "test": "\narr = [10, 3, 5, 6, 2]\nn = len(arr)\nprint(\"The product array is: n\")\nproductArray(arr, n)\n",
        "output": "The product array is: n\n180 600 360 300 900 ",
        "fn_call": "productArray"
    },
    {
        "text": "minimize steps defined by a string required to reach the destination from a given source | function to find the minimum length of string required to reach from source to destination ; size of the string ; stores the index of the four directions e , w , n , s ; if destination reached ; iterate over the string ; move east ; change x1 according to direction e ; move west ; change x1 according to direction w ; move north ; change y1 according to direction n ; move south ; change y1 according to direction s ; store the max of all positions ; print the minimum length of string required ; otherwise , it is impossible ; given string ; ",
        "context": "",
        "code": "def minimum_length(x1, y1, x2, y2, str):\n    n = len(str)\n    pos1 = -1\n    pos2 = -1\n    pos3 = -1\n    pos4 = -1\n    if (x1 == x2 and y1 == y2):\n        print(\"0\")\n    else:\n        for i in range(n):\n            if (x2 > x1):\n                if (str[i] == 'E'):\n                    x1 = x1 + 1\n                    if (x1 == x2):\n                        pos1 = i\n            if (x2 < x1):\n                if (str[i] == 'W'):\n                    x1 = x1 - 1\n                    if (x1 == x2):\n                        pos2 = i\n            if (y2 > y1):\n                if (str[i] == 'N'):\n                    y1 = y1 + 1\n                    if (y1 == y2):\n                        pos3 = i\n            if (y2 < y1):\n                if (str[i] == 'S'):\n                    y1 = y1 - 1\n                    if (y1 == y2):\n                        pos4 = i\n        z = 0\n        z = max(pos1, max(max(pos2, pos3), pos4))\n        if (x1 == x2 and y1 == y2):\n            print(z + 1)\n        else:\n            print(\"-1\")\n",
        "test": "\nstr = \"SESNW\"\nx1 = 0\nx2 = 1\ny1 = 0\ny2 = 1\nminimum_length(x1, y1, x2, y2, str)\n",
        "output": "4\n",
        "fn_call": "minimum_length"
    },
    {
        "text": "find the longest sub | function to find longest prefix suffix ; to store longest prefix suffix ; length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; loop calculates lps [ i ] for i = 1 to n - 1 ; ( pat [ i ] != pat [ len ] ) ; if len = 0 ; function to find the longest substring which is prefix as well as a sub - of s [ 1. . . n - 2 ] ; find longest prefix suffix ; if lps of n - 1 is zero ; at any position lps [ i ] equals to lps [ n - 1 ] ; if answer is not possible ; ",
        "context": "",
        "code": "def compute_lps(s):\n    n = len(s)\n    lps = [0 for i in range(n)]\n    Len = 0\n    lps[0] = 0\n    i = 1\n    while (i < n):\n        if (s[i] == s[Len]):\n            Len += 1\n            lps[i] = Len\n            i += 1\n        else:\n            if (Len != 0):\n                Len = lps[Len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\n\ndef Longestsubstring(s):\n    lps = compute_lps(s)\n    n = len(s)\n    if (lps[n - 1] == 0):\n        print(-1)\n        exit()\n    for i in range(0, n - 1):\n        if (lps[i] == lps[n - 1]):\n            print(s[0:lps[i]])\n            exit()\n    if (lps[lps[n - 1] - 1] == 0):\n        print(-1)\n    else:\n        print(s[0:lps[lps[n - 1] - 1]])\n",
        "test": "\ns = \"fixprefixsuffix\"\nLongestsubstring(s)\n",
        "output": "fix\n",
        "fn_call": "Longestsubstring"
    },
    {
        "text": "count n | function to find the number of arrays following the given condition ; initialize answer ; calculate npm ; print ans ; ",
        "context": "",
        "code": "def noOfArraysPossible(N, M):\n    ans = 1\n    for i in range(N):\n        ans = ans * (M - i)\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 2\n    M = 3\n    noOfArraysPossible(N, M)\n",
        "output": "6\n",
        "fn_call": "noOfArraysPossible"
    },
    {
        "text": "count occurrences of an element in a matrix of size n * n generated such that each element is equal to product of its indices | python3 program for the above approach ; function to count the occurrences of x in the generated square matrix ; stores the required result ; iterate upto square root of x ; check if i divides x ; store the quotient obtained on dividing x by i ; if both the numbers fall in the range , update count ; return the result ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def countOccurrences(N, X):\n    count = 0\n    for i in range(1, int(sqrt(X)) + 1):\n        if X % i == 0:\n            a = i\n            b = X // i\n            if a <= N and b <= N:\n                if a == b:\n                    count += 1\n                else:\n                    count += 2\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    N = 7\n    X = 12\n    print(countOccurrences(N, X))\n",
        "output": "4\n",
        "fn_call": "countOccurrences"
    },
    {
        "text": "smallest n digit number divisible by n | function to find the smallest n - digit number divisible by n ; find largest n digit number ; find smallest n digit number ; if i is divisible by n , then print i and return ; ; ",
        "context": "",
        "code": "def smallestNumber(N):\n    L = pow(10, N) - 1\n    S = pow(10, N - 1)\n    for i in range(S, L):\n        if (i % N == 0):\n            print(i)\n            return\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 2\n    smallestNumber(N)\n",
        "output": "10\n",
        "fn_call": "smallestNumber"
    },
    {
        "text": "bitwise or ( | ) of all even number from 1 to n | python3 implementation of the above approach ; function to return the bitwise or of all even numbers upto n ; for value less than 2 ; count total number of bits in bitwise or all bits will be set except last bit ; compute 2 to the power bitcount and subtract 2 ; ",
        "context": "\nfrom math import log2\n\n",
        "code": "def bitwiseOrTillN(n):\n    if (n < 2):\n        return 0\n    bitCount = int(log2(n)) + 1\n    return pow(2, bitCount) - 2\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10\n    print(bitwiseOrTillN(n))\n",
        "output": "14\n",
        "fn_call": "bitwiseOrTillN"
    },
    {
        "text": "queries to find maximum sum contiguous subarrays of given length in a rotating array | function to calculate the maximum sum of length k ; calculating the max sum for the first k elements ; find subarray with maximum sum ; update the sum ; return maximum sum ; function to calculate gcd of the two numbers n1 and n2 ; base case ; recursively find the gcd ; function to rotate the array by y ; for handling k >= n ; dividing the array into number of sets ; rotate the array by y ; update arr [ j ] ; return the rotated array ; function that performs the queries on the given array ; traverse each query ; if query of type x = 1 ; print the array ; if query of type x = 2 ; ",
        "context": "",
        "code": "def MaxSum(arr, n, k):\n    i, max_sum = 0, 0\n    sum = 0\n    while i < k:\n        sum += arr[i]\n        i += 1\n    max_sum = sum\n    while (i < n):\n        sum = sum - arr[i - k] + arr[i]\n        if (max_sum < sum):\n            max_sum = sum\n        i += 1\n    return max_sum\n\n\ndef gcd(n1, n2):\n    if (n2 == 0):\n        return n1\n    else:\n        return gcd(n2, n1 % n2)\n\n\ndef RotateArr(arr, n, d):\n    i = 0\n    j = 0\n    d = d % n\n    no_of_sets = gcd(d, n)\n    for i in range(no_of_sets):\n        temp = arr[i]\n        j = i\n        while (True):\n            k = j + d\n            if (k >= n):\n                k = k - n\n            if (k == i):\n                break\n            arr[j] = arr[k]\n            j = k\n        arr[j] = temp\n    return arr\n\n\ndef performQuery(arr, Q, q):\n    N = len(arr)\n    for i in range(q):\n        if (Q[i][0] == 1):\n            arr = RotateArr(arr, N, Q[i][1])\n            for t in arr:\n                print(t, end=\" \")\n            print()\n        else:\n            print(MaxSum(arr, N, Q[i][1]))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5]\n    q = 5\n    Q = [[1, 2], [2, 3], [1, 3], [1, 1], [2, 4]]\n    performQuery(arr, Q, q)\n",
        "output": "3 4 5 1 2 \n12\n1 2 3 4 5 \n2 3 4 5 1 \n14\n",
        "fn_call": "performQuery"
    },
    {
        "text": "minimize the number of steps required to reach the end of the array | python3 implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; ",
        "context": "\nmaxLen = 10\nmaskLen = 130\ndp = [[0 for i in range(maskLen)]for i in range(maxLen)]\nv = [[False for i in range(maskLen)]for i in range(maxLen)]\n\n",
        "code": "def minSteps(arr, i, mask, n):\n    if (i == n - 1):\n        return 0\n    if (i > n - 1 or i < 0):\n        return 9999999\n    if ((mask >> i) & 1):\n        return 9999999\n    if (v[i][mask]):\n        return dp[i][mask]\n    v[i][mask] = True\n    dp[i][mask] = 1 + min(minSteps(arr,\n                                   i - arr[i],\n                                   (mask | (1 << i)),\n                                   n),\n                          minSteps(arr,\n                                   i + arr[i],\n                                   (mask | (1 << i)),\n                                   n))\n    return dp[i][mask]\n",
        "test": "\narr = [1, 2, 2, 2, 1, 1]\nn = len(arr)\nans = minSteps(arr, 0, 0, n)\nif (ans >= 9999999):\n    print(-1)\nelse:\n    print(ans)\n",
        "output": "3\n",
        "fn_call": "minSteps"
    },
    {
        "text": "check if strings are rotations of each other or not | set 2 | python program to check if two strings are rotations of each other ; create lps [ ] that will hold the longest prefix suffix values for pattern ; length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; the loop calculates lps [ i ] for i = 1 to n - 1 ; match from that rotating point ; ",
        "context": "",
        "code": "def isRotation(a: str, b: str) -> bool:\n    n = len(a)\n    m = len(b)\n    if (n != m):\n        return False\n    lps = [0 for _ in range(n)]\n    length = 0\n    i = 1\n    lps[0] = 0\n    while (i < n):\n        if (a[i] == b[length]):\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if (length == 0):\n                lps[i] = 0\n                i += 1\n            else:\n                length = lps[length - 1]\n    i = 0\n    for k in range(lps[n - 1], m):\n        if (b[k] != a[i]):\n            return False\n        i += 1\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"ABACD\"\n    s2 = \"CDABA\"\n    print(\"1\"if isRotation(s1, s2)else \"0\")\n",
        "output": "1\n",
        "fn_call": "isRotation"
    },
    {
        "text": "combinations where every element appears twice and distance between appearances is equal to the value | find all combinations that satisfies given constraints ; if all elements are filled , print the solution ; try all possible combinations for element elem ; if position i and ( i + elem + 1 ) are not occupied in the vector ; place elem at position i and ( i + elem + 1 ) ; recurse for next element ; backtrack ( remove elem from position i and ( i + elem + 1 ) ) ; create a vector of double the size of given number with ; all its elements initialized by 1 ; start from element 1 ; ",
        "context": "",
        "code": "def allCombinationsRec(arr, elem, n):\n    if (elem > n):\n        for i in (arr):\n            print(i, end=\" \")\n        print(\"\")\n        return\n    for i in range(0, 2 * n):\n        if (arr[i] == -1 and (i + elem + 1) <\n                2 * n and arr[i + elem + 1] == -1):\n            arr[i] = elem\n            arr[i + elem + 1] = elem\n            allCombinationsRec(arr, elem + 1, n)\n            arr[i] = -1\n            arr[i + elem + 1] = -1\n\n\ndef allCombinations(n):\n    arr = [-1] * (2 * n)\n    elem = 1\n    allCombinationsRec(arr, elem, n)\n",
        "test": "\nn = 3\nallCombinations(n)\n",
        "output": "3 1 2 1 3 2 \n2 3 1 2 1 3 \n",
        "fn_call": "allCombinations"
    },
    {
        "text": "count the number of clumps in the given array | function to count the number of clumps in the given array arr [ ] ; initialise count of clumps as 0 ; traverse the arr [ ] ; whenever a sequence of same value is encountered ; return the count of clumps ; ",
        "context": "",
        "code": "def countClumps(arr, N):\n    clumps = 0\n    i = 0\n    while (i < N - 1):\n        flag = 0\n        while (i + 1 < N and arr[i] == arr[i + 1]):\n            flag = 1\n            i += 1\n        if (flag):\n            clumps += 1\n        i += 1\n    return clumps\n",
        "test": "\narr = [13, 15, 66, 66, 66, 37, 37, 8, 8, 11, 11]\nN = len(arr)\nprint(countClumps(arr, N))\n",
        "output": "4\n",
        "fn_call": "countClumps"
    },
    {
        "text": "sum of minimum and the maximum difference between two given strings | function to find the sum of the minimum and the maximum difference between two given strings ; variables to store the minimum difference and the maximum difference ; iterate through the length of the as both the given strings are of the same length ; for the maximum difference , we can replace \" + \" in both the strings with different char ; for the minimum difference , we can replace \" + \" in both the strings with the same char ; ",
        "context": "",
        "code": "def solve(a, b):\n    l = len(a)\n    min = 0\n    max = 0\n    for i in range(l):\n        if (a[i] == '+' or b[i] == '+' or a[i] != b[i]):\n            max += 1\n        if (a[i] != '+' and b[i] != '+' and a[i] != b[i]):\n            min += 1\n    print(min + max)\n",
        "test": "\nif __name__ == '__main__':\n    s1 = \"a+c\"\n    s2 = \"++b\"\n    solve(s1, s2)\n",
        "output": "4\n",
        "fn_call": "solve"
    },
    {
        "text": "rearrange array to make product of prefix sum array non zero | function to rearrange array that satisfies the given condition ; stores sum of elements of the given array ; calculate totalsum ; if the totalsum is equal to 0 ; no possible way to rearrange array ; if totalsum exceeds 0 ; rearrange the array in descending order ; otherwise ; rearrange the array in ascending order ; ",
        "context": "",
        "code": "def rearrangeArr(arr, N):\n    totalSum = 0\n    for i in range(N):\n        totalSum += arr[i]\n    if (totalSum == 0):\n        print(-1)\n    elif (totalSum > 0):\n        arr .sort(reverse=True)\n        print(*arr, sep=' ')\n    else:\n        arr .sort()\n        print(*arr, sep=' ')\n",
        "test": "\narr = [1, -1, -2, 3]\nN = len(arr)\nrearrangeArr(arr, N)\n",
        "output": "3 1 -1 -2\n",
        "fn_call": "rearrangeArr"
    },
    {
        "text": "check if all the pairs of an array are coprime with each other | python3 implementation of the above approach ; function to check if all the pairs of the array are coprime with each other or not ; check if gcd of the pair is not equal to 1 ; all pairs are non - coprime return false ;  ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef allCoprime(A, n):\n    all_coprime = True\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(A[i], A[j]) != 1:\n                all_coprime = False\n                break\n    return all_coprime\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [3, 5, 11, 7, 19]\n    arr_size = len(A)\n    if (allCoprime(A, arr_size)):\n        print('Yes')\n    else:\n        print('No')\n",
        "output": "Yes\n",
        "fn_call": "allCoprime"
    },
    {
        "text": "check for balanced parentheses in an expression | o ( 1 ) space | function1 to match closing bracket ; function1 to match opening bracket ; function to check balanced parentheses ; helper variables ; handling case of opening parentheses ; handling case of closing parentheses ; if corresponding matching opening parentheses doesn 't lie in given  interval return 0 ; else continue ; if corresponding closing parentheses doesn 't lie in given interval, return 0 ; if found , now check for each opening and closing parentheses in this interval ; ",
        "context": "",
        "code": "def matchClosing(X, start, end, open, close):\n    c = 1\n    i = start + 1\n    while (i <= end):\n        if (X[i] == open):\n            c += 1\n        elif (X[i] == close):\n            c -= 1\n        if (c == 0):\n            return i\n        i += 1\n    return i\n\n\ndef matchingOpening(X, start, end, open, close):\n    c = -1\n    i = end - 1\n    while (i >= start):\n        if (X[i] == open):\n            c += 1\n        elif (X[i] == close):\n            c -= 1\n        if (c == 0):\n            return i\n        i -= 1\n    return -1\n\n\ndef isBalanced(X, n):\n    for i in range(n):\n        if (X[i] == '('):\n            j = matchClosing(X, i, n - 1, '(', ')')\n        elif (X[i] == '{'):\n            j = matchClosing(X, i, n - 1, '{', '}')\n        elif (X[i] == '['):\n            j = matchClosing(X, i, n - 1, '[', ']')\n        else:\n            if (X[i] == ')'):\n                j = matchingOpening(X, 0, i, '(', ')')\n            elif (X[i] == '}'):\n                j = matchingOpening(X, 0, i, '{', '}')\n            elif (X[i] == ']'):\n                j = matchingOpening(X, 0, i, '[', ']')\n            if (j = i):\n                return False\n            continue\n        if (j >= n or j < 0):\n            return False\n        start = i\n        end = j\n        for k in range(start + 1, end):\n            if (X[k] == '('):\n                x = matchClosing(X, k, end, '(', ')')\n                if (not (k < x and x < end)):\n                    return False\n            elif (X[k] == ')'):\n                x = matchingOpening(X, start, k, '(', ')')\n                if (not (start < x and x < k)):\n                    return False\n            if (X[k] == '{'):\n                x = matchClosing(X, k, end, '{', '}')\n                if (not (k < x and x < end)):\n                    return False\n            elif (X[k] == '}'):\n                x = matchingOpening(X, start, k, '{', '}')\n                if (not (start < x and x < k)):\n                    return False\n            if (X[k] == '['):\n                x = matchClosing(X, k, end, '[', ']')\n                if (not (k < x and x < end)):\n                    return False\n            elif (X[k] == ']'):\n                x = matchingOpening(X, start, k, '[', ']')\n                if (not (start < x and x < k)):\n                    return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    X = \"[()]()\"\n    n = 6\n    if (isBalanced(X, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    Y = \"[[()]])\"\n    n = 7\n    if (isBalanced(Y, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\nNo\n",
        "fn_call": "isBalanced"
    },
    {
        "text": "minimum steps to reach the nth stair in jumps of perfect power of 2 | function to count the number of jumps required to reach nth stairs . ; till n becomes 0 ; removes the set bits from the right to left ; ",
        "context": "",
        "code": "def stepRequired(N):\n    cnt = 0\n    while (N > 0):\n        N = N & (N - 1)\n        cnt += 1\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    N = 23\n    print(stepRequired(N))\n",
        "output": "4\n",
        "fn_call": "stepRequired"
    },
    {
        "text": "number of ways to place two queens on a n * n chess | python3 implementation to find the number of ways to place two queens on the n * n chess board ; function to find number of valid positions for two queens in the n * n chess board ; ",
        "context": "\nimport math\n\n",
        "code": "def possiblePositions(n):\n    term1 = pow(n, 4)\n    term2 = pow(n, 3)\n    term3 = pow(n, 2)\n    term4 = n / 3\n    ans = ((math .ceil(term1)) / 2 - (math .ceil(5 * term2)) /\n           3 + (math .ceil(3 * term3)) / 2 - term4)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    ans = possiblePositions(n)\n    print(int(ans))\n",
        "output": "8\n",
        "fn_call": "possiblePositions"
    },
    {
        "text": "sub | function that counts all the sub - strings of length ' k ' which have all identical characters ; count of sub - strings , length , initial position of sliding window ; dictionary to store the frequency of the characters of sub - string ; increase the frequency of the character and length of the sub - string ; if the length of the sub - string is greater than k ; remove the character from the beginning of sub - string ; if the length of the sub string is equal to k and frequency of one of its characters is equal to the length of the sub - string i . e . all the characters are same increase the count ; display the number of valid sub - strings ; ",
        "context": "",
        "code": "def solve(s, k):\n    count, length, pos = 0, 0, 0\n    m = dict .fromkeys(s, 0)\n    for i in range(len(s)):\n        m[s[i]] += 1\n        length += 1\n        if length > k:\n            m[s[pos]] -= 1\n            pos += 1\n            length -= 1\n        if length == k and m[s[i]] == length:\n            count += 1\n    print(count)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"aaaabbbccdddd\"\n    k = 4\n    solve(s, k)\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "ceiling of every element in same array | python implementation of efficient algorithm to find floor of every element ; prints greater elements on left side of every element ; create a sorted copy of arr [ ] ; traverse through arr [ ] and do binary search for every element ; find the location of first element that is greater than the given element ; since arr [ i ] also exists in array , v [ it - 1 ] will be same as arr [ i ] . let us check v [ it - 2 ] is also same as arr [ i ] . if true , then arr [ i ] exists twice in array , so ceiling is same same as arr [ i ] ; if next element is also same , then there are multiple occurrences , so print it ; ",
        "context": "\nimport bisect\n\n",
        "code": "def printPrevGreater(arr, n):\n    if n == 1:\n        print(\"-1\")\n        return\n    v = list(arr)\n    v .sort()\n    for i in range(n):\n        it = bisect .bisect_right(v, arr[i])\n        if (it - 1) != 0 and v[it - 2] == arr[i]:\n            print(arr[i], end=\" \")\n        elif it <= n - 1:\n            print(v[it], end=\" \")\n        else:\n            print(-1, end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 5, 11, 10, 20, 12]\n    n = len(arr)\n    printPrevGreater(arr, n)\n",
        "output": "10 10 12 10 -1 20 ",
        "fn_call": "printPrevGreater"
    },
    {
        "text": "longest common subsequence | dp | dynamic programming implementation of lcs problem ; returns length of lcs for x [ 0. . m - 1 ] , y [ 0. . n - 1 ] ; following steps build l [ m + 1 ] [ n + 1 ] in bottom up fashion note : l [ i ] [ j ] contains length of lcs of x [ 0. . i - 1 ] and y [ 0. . j - 1 ] ; l [ m ] [ n ] contains the length of lcs of x [ 0. . n - 1 ] & y [ 0. . m - 1 ] ; end of function lcs ",
        "context": "",
        "code": "def lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    L = [[None] * (n + 1)for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    return L[m][n]\n",
        "test": "\nX = \"AGGTAB\"\nY = \"GXTXAYB\"\nprint(\"Length of LCS is \", lcs(X, Y))\n",
        "output": "Length of LCS is  4\n",
        "fn_call": "lcs"
    },
    {
        "text": "smallest number dividing minimum number of elements in the array | set 2 | function to return the smallest number that divides minimum number of elements in the given array ; m stores the maximum in the array ; frequency array ; sieve ; incrementing j ; if no multiples of j are in the array ; ",
        "context": "",
        "code": "def findMin(arr, n):\n    m = 0\n    for i in range(n):\n        m = max(m, arr[i])\n    freq = [0] * (m + 2)\n    for i in range(n):\n        freq[arr[i]] += 1\n    for i in range(1, m + 2):\n        j = i\n        cnt = 0\n        while (j <= m):\n            cnt += freq[j]\n            j += i\n        if (not cnt):\n            return i\n    return m + 1\n",
        "test": "\narr = [2, 12, 6]\nn = len(arr)\nprint(findMin(arr, n))\n",
        "output": "5\n",
        "fn_call": "findMin"
    },
    {
        "text": "path with maximum product in 2 | python program to find maximum product path from ( 0 , 0 ) to ( n - 1 , m - 1 ) ; function to find maximum product ; it will store the maximum product till a given cell . ; it will store the minimum product till a given cell ( for - ve elements ) ; if we are at topmost or leftmost , just copy the elements . ; if we 're not at the  above, we can consider  the above value. ; if we 're not on the  leftmost, we can consider  the left value. ; store max & min product till i , j . ; return the max product path from 0 , 0. n - 1 , m - 1. ; ",
        "context": "\nimport sys\nN = 3\nM = 3\n\n",
        "code": "def maxProductPath(arr):\n    maxPath = [[0 for i in range(M)]for j in range(N)]\n    minPath = [[0 for i in range(M)]for j in range(N)]\n    for i in range(N):\n        for j in range(M):\n            minVal = sys .maxsize\n            maxVal = -sys .maxsize\n            if (i == 0 and j == 0):\n                maxVal = arr[i][j]\n                minVal = arr[i][j]\n            if (i > 0):\n                tempMax = max(maxPath[i - 1][j] * arr[i]\n                              [j], minPath[i - 1][j] * arr[i][j])\n                maxVal = max(maxVal, tempMax)\n                tempMin = min(maxPath[i - 1][j] * arr[i]\n                              [j], minPath[i - 1][j] * arr[i][j])\n                minVal = min(minVal, tempMin)\n            if (j > 0):\n                tempMax = max(maxPath[i][j - 1] * arr[i]\n                              [j], minPath[i][j - 1] * arr[i][j])\n                maxVal = max(maxVal, tempMax)\n                tempMin = min(maxPath[i][j - 1] * arr[i]\n                              [j], minPath[i][j - 1] * arr[i][j])\n                minVal = min(minVal, tempMin)\n            maxPath[i][j] = maxVal\n            minPath[i][j] = minVal\n    return maxPath[N - 1][M - 1]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, -2, 3], [4, -5, 6], [-7, -8, 9]]\n    print(maxProductPath(arr))\n",
        "output": "2016\n",
        "fn_call": "maxProductPath"
    },
    {
        "text": "count array elements having sum of digits equal to k | function to calculate the sum of digits of the number n ; stores the sum of digits ; return the sum ; function to count array elements ; store the count of array elements having sum of digits k ; traverse the array ; if sum of digits is equal to k ; increment the count ; prthe count ; given array ; ",
        "context": "",
        "code": "def sumOfDigits(N):\n    sum = 0\n    while (N != 0):\n        sum += N % 10\n        N //= 10\n    return sum\n\n\ndef elementsHavingDigitSumK(arr, N, K):\n    count = 0\n    for i in range(N):\n        if (sumOfDigits(arr[i]) == K):\n            count += 1\n    print(count)\n",
        "test": "\narr = [23, 54, 87, 29, 92, 62]\nK = 11\nN = len(arr)\nelementsHavingDigitSumK(arr, N, K)\n",
        "output": "2\n",
        "fn_call": "elementsHavingDigitSumK"
    },
    {
        "text": "find area of the larger circle when radius of the smaller circle and difference in the area is given | python 3 implementation of the approach ; function to return the area of the bigger circle ; find the radius of the bigger circle ; calculate the area of the bigger circle ; ",
        "context": "\nfrom math import pow, sqrt\nPI = 3.14\n\n",
        "code": "def find_area(r, d):\n    R = d / PI\n    R += pow(r, 2)\n    R = sqrt(R)\n    area = PI * pow(R, 2)\n    return area\n",
        "test": "\nif __name__ == '__main__':\n    r = 4\n    d = 5\n    print(find_area(r, d))\n",
        "output": "55.24\n",
        "fn_call": "find_area"
    },
    {
        "text": "check if left and right shift of any string results into given string | function to check string exist or not as per above approach ; check if any character at position i and i + 2 are not equal , then string doesnot exist ; ",
        "context": "",
        "code": "def check_string_exist(S):\n    size = len(S)\n    check = True\n    for i in range(size):\n        if S[i] != S[(i + 2) % size]:\n            check = False\n            break\n    if check:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nS = \"papa\"\ncheck_string_exist(S)\n",
        "output": "Yes\n",
        "fn_call": "check_string_exist"
    },
    {
        "text": "check if two strings can be made equal by swapping one character among each other | function that returns true if the string can be made equal after one swap ; a and b are new a and b after we omit the same elements ; take only the characters which are different in both the strings for every pair of indices ; if the current characters differ ; the strings were already equal ; if the lengths of the strings are two ; if swapping these characters can make the strings equal ; ",
        "context": "",
        "code": "def canBeEqual(a, b, n):\n    A = []\n    B = []\n    for i in range(n):\n        if a[i] != b[i]:\n            A .append(a[i])\n            B .append(b[i])\n    if len(A) == len(B) == 0:\n        return True\n    if len(A) == len(B) == 2:\n        if A[0] == A[1] and B[0] == B[1]:\n            return True\n    return False\n",
        "test": "\nA = 'SEEKSFORGEEKS'\nB = 'GEEKSFORGEEKG'\nif (canBeEqual(A, B, len(A))):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canBeEqual"
    },
    {
        "text": "sum of product of proper divisors of all numbers lying in range [ l , r ] | python3 implementation to find the sum of the product of proper divisors of all the numbers lying in the range [ l , r ] ; vector to store the product of the proper divisors of a number ; variable to store the prefix sum of the product array ; function to precompute the product of proper divisors of a number at it 's corresponding index ; modificatino of sieve to store the product of the proper divisors ; multiplying the existing value with i because i is the proper divisor of ans [ j ] ; loop to store the prefix sum of the previously computed product array ; computing the prefix sum ; function to prthe sum for each query ; function to prte sum of product of proper divisors of a number in [ l , r ] ; calling the function that pre computes the sum of product of proper divisors ; iterate over all queries to prthe sum ; ",
        "context": "\nmod = 1000000007\nans = [1] * (100002)\npref = [0] * 100002\n\n",
        "code": "def preCompute():\n    for i in range(2, 100000 // 2 + 1):\n        for j in range(2 * i, 100000 + 1, i):\n            ans[j] = (ans[j] * i) % mod\n    for i in range(1, 100002):\n        pref[i] = pref[i - 1] + ans[i]\n        pref[i] %= mod\n\n\ndef printSum(L, R):\n    print(pref[R] - pref[L - 1], end=\" \")\n\n\ndef printSumProper(arr, Q):\n    preCompute()\n    for i in range(Q):\n        printSum(arr[i][0], arr[i][1])\n",
        "test": "\nif __name__ == '__main__':\n    Q = 2\n    arr = [[10, 20], [12, 16]]\n    printSumProper(arr, Q)\n",
        "output": "975 238 ",
        "fn_call": "printSumProper"
    },
    {
        "text": "maximum sum subsequence with values differing by at least 2 | python3 program to find maximum sum subsequence with values differing by at least 2 ; function to find maximum sum subsequence such that two adjacent values elements are not selected ; map to store the frequency of array elements ; make a dp array to store answer upto i th value ; base cases ; iterate for all possible values of arr [ i ] ; return the last value ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def get_max_sum(arr, n):\n    freq = defaultdict(lambda: 0)\n    for i in range(n):\n        freq[arr[i]] += 1\n    dp = [0] * 100001\n    dp[0] = 0\n    dp[1] = freq[0]\n    for i in range(2, 100000 + 1):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * freq[i])\n    return dp[100000]\n",
        "test": "\nN = 3\narr = [2, 2, 3]\nprint(get_max_sum(arr, N))\n",
        "output": "4\n",
        "fn_call": "get_max_sum"
    },
    {
        "text": "rearrange an array such that product of every two consecutive elements is a multiple of 4 | function to rearrange array elements such that the every two consecutive elements is a multiple of 4 ; if element is odd ; odd ; if element is divisible by 4 ; divisible by 4 ; if element is not divisible by 4 ; even but not divisible by 4 ; condition for rearrangement to be possible ; print odd [ i ] and four [ i ] consecutively ; print the remaining four [ i ] , if any ; condition for rearrangement to be possible ; print odd [ i ] and four [ i ] consecutively ; print the remaining four [ i ] , if any ; print the non_four [ i ] elements at the end ; no possible configuration ; ",
        "context": "",
        "code": "def Permute(arr, n):\n    odd = 0\n    four = 0\n    non_four = 0\n    ODD, FOUR, NON_FOUR = [], [], []\n    for x in arr:\n        if (x & 1):\n            odd += 1\n            ODD .append(x)\n        elif (x % 4 == 0):\n            four += 1\n            FOUR .append(x)\n        else:\n            non_four += 1\n            NON_FOUR .append(x)\n    if (non_four == 0 and four >= odd - 1):\n        x = len(ODD)\n        y = len(FOUR)\n        i = 0\n        while i < x:\n            print(ODD[i], end=\" \")\n            if (i < y):\n                print(FOUR[i], end=\" \")\n        while (i < y):\n            print(FOUR[i], end=\" \")\n            i += 1\n        print()\n    elif (non_four > 0 and four >= odd):\n        x = len(ODD)\n        y = len(FOUR)\n        i = 0\n        while i < x:\n            print(ODD[i], end=\" \")\n            if (i < y):\n                print(FOUR[i], end=\" \")\n            i += 1\n        while (i < y):\n            print(FOUR[i], end=\" \")\n            i += 1\n        for j in NON_FOUR:\n            print(j, end=\" \")\n    else:\n        print(\"Not Possible\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 7, 1, 8, 2, 8]\n    N = len(arr)\n    Permute(arr, N)\n",
        "output": "7 8 1 8 2 2 ",
        "fn_call": "Permute"
    },
    {
        "text": "print the longest prefix of the given string which is also the suffix of the same string | returns length of the longest prefix which is also suffix and the two do not overlap . this function mainly is copy of computelpsarray ( ) in kmp algorithm ; length of the previous longest prefix suffix ; loop to calculate lps [ i ] for i = 1 to n - 1 ; this is tricky . consider the example . aaacaaaa and i = 7. the idea is similar to search step . ; if len = 0 ; since we are looking for non overlapping parts ; function that returns the prefix ; get the length of the longest prefix ; stores the prefix ; traverse and add characters ; returns the prefix ; ",
        "context": "",
        "code": "def LengthlongestPrefixSuffix(s):\n    n = len(s)\n    lps = [0 for i in range(n)]\n    len1 = 0\n    i = 1\n    while (i < n):\n        if (s[i] == s[len1]):\n            len1 += 1\n            lps[i] = len1\n            i += 1\n        else:\n            if (len1 != 0):\n                len1 = lps[len1 - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    res = lps[n - 1]\n    if (res > int(n / 2)):\n        return int(n / 2)\n    else:\n        return res\n\n\ndef longestPrefixSuffix(s):\n    len1 = LengthlongestPrefixSuffix(s)\n    prefix = \"\"\n    for i in range(len1):\n        prefix += s[i]\n    return prefix\n",
        "test": "\nif __name__ == '__main__':\n    s = \"abcab\"\n    ans = longestPrefixSuffix(s)\n    if (ans == \"\"):\n        print(\"-1\")\n    else:\n        print(ans)\n",
        "output": "ab\n",
        "fn_call": "longestPrefixSuffix"
    },
    {
        "text": "count of times second string can be formed from the characters of first string | python3 implementation of the approach ; function to update the freq [ ] array to store the frequencies of all the characters of strr ; update the frequency of the characters ; function to return the maximum count of times patt can be formed using the characters of strr ; to store the frequencies of all the characters of strr ; to store the frequencies of all the characters of patt ; to store the result ; for every character ; if the current character doesn 't appear in patt ; update the result ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def updateFreq(strr, freq):\n    lenn = len(strr)\n    for i in range(lenn):\n        freq[ord(strr[i]) - ord('a')] += 1\n\n\ndef maxCount(strr, patt):\n    strrFreq = [0 for i in range(MAX)]\n    updateFreq(strr, strrFreq)\n    pattFreq = [0 for i in range(MAX)]\n    updateFreq(patt, pattFreq)\n    ans = 10 ** 9\n    for i in range(MAX):\n        if (pattFreq[i] == 0):\n            continue\n        ans = min(ans, strrFreq[i] // pattFreq[i])\n    return ans\n",
        "test": "\nstrr = \"geeksforgeeks\"\npatt = \"geeks\"\nprint(maxCount(strr, patt))\n",
        "output": "2\n",
        "fn_call": "maxCount"
    },
    {
        "text": "minimum size of set having either element in range [ 0 , x ] or an odd power of 2 with sum n | python program for the above approach ; function to find the highest odd power of 2 in the range [ 0 , n ] ; if p is even , subtract 1 ; function to find the minimum operations to make n ; if n is odd and x = 0 , then no valid set exist ; stores the minimum possible size of the valid set ; loop to subtract highest odd power of 2 while x  0 , then increment the value of answer by 1 ; return the resultant size of set ; ",
        "context": "\nimport math\n\n",
        "code": "def highestPowerof2(n):\n    p = int(math .log(n, 2))\n    if p % 2 == 0:\n        p -= 1\n    return int(pow(2, p))\n\n\ndef minStep(N, X):\n    if N % 2 and X == 0:\n        return -1\n    size = 0\n    while X < N:\n        N -= highestPowerof2(N)\n        size += 1\n    if N:\n        size += 1\n    return size\n",
        "test": "\nif __name__ == '__main__':\n    N = 11\n    X = 2\n    print(minStep(N, X))\n",
        "output": "3\n",
        "fn_call": "minStep"
    },
    {
        "text": "two elements whose sum is closest to zero | python3 implementation using stl ; modified to sort by abolute values ; absolute value shows how close it is to zero ; if found an even close value update min and store the index ; ",
        "context": "\nimport sys\n\n",
        "code": "def findMinSum(arr, n):\n    for i in range(1, n):\n        if (not abs(arr[i - 1]) < abs(arr[i])):\n            arr[i - 1], arr[i] = arr[i], arr[i - 1]\n    Min = sys .maxsize\n    x = 0\n    y = 0\n    for i in range(1, n):\n        if (abs(arr[i - 1] + arr[i]) <= Min):\n            Min = abs(arr[i - 1] + arr[i])\n            x = i - 1\n            y = i\n    print(\"The two elements whose sum is minimum are\", arr[x], \"and\", arr[y])\n",
        "test": "\narr = [1, 60, -10, 70, -80, 85]\nn = len(arr)\nfindMinSum(arr, n)\n",
        "output": "The two elements whose sum is minimum are -80 and 85\n",
        "fn_call": "findMinSum"
    },
    {
        "text": "check if all sub | function to calculate product of digits between given indexes ; function to check if all sub - numbers have distinct digit product ; length of number n ; digit array ; set to maintain digit products ; finding all possible subarrays ; ",
        "context": "",
        "code": "def digitProduct(digits, start, end):\n    pro = 1\n    for i in range(start, end + 1):\n        pro *= digits[i]\n    return pro\n\n\ndef isDistinct(N):\n    s = str(N)\n    length = len(s)\n    digits = [None] * length\n    products = set()\n    for i in range(0, length):\n        digits[i] = int(s[i])\n    for i in range(0, length):\n        for j in range(i, length):\n            val = digitProduct(digits, i, j)\n            if val in products:\n                return False\n            else:\n                products .add(val)\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 324\n    if isDistinct(N):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isDistinct"
    },
    {
        "text": "number of relations that are neither reflexive nor irreflexive on a set | python program for the above approach ; function to calculate x ^ y modulo 10 ^ 9 + 7 in o ( log y ) ; stores the result of ( x ^ y ) ; update x , if it exceeds mod ; if x is divisible by mod ; if y is odd , then multiply x with res ; divide y by 2 ; update the value of x ; return the value of x ^ y ; function to count the number of relations that are neither reflexive nor irreflexive ; return the resultant count ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def power(x, y):\n    res = 1\n    x = x % mod\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if (y % 2 == 1):\n            res = (res * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return res\n\n\ndef countRelations(N):\n    print((power(2, N) - 2) * power(2, N * N - N))\n",
        "test": "\nN = 2\ncountRelations(N)\n",
        "output": "8\n",
        "fn_call": "countRelations"
    },
    {
        "text": "possible cuts of a number such that maximum parts are divisible by 3 | python3 program to find the maximum number of numbers divisible by 3 in a large number ; function to find the maximum number of numbers divisible by 3 in a large number ; store size of the string ; stores last index of a remainder ; last visited place of remainder zero is at 0. ; to store result from 0 to i ; get the remainder ; get maximum res [ i ] value ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def MaximumNumbers(string):\n    n = len(string)\n    remIndex = [-1 for i in range(3)]\n    remIndex[0] = 0\n    res = [-1 for i in range(n + 1)]\n    r = 0\n    for i in range(n + 1):\n        r = (r + ord(string[i - 1]) - ord('0')) % 3\n        res[i] = res[i - 1]\n        if (remIndex[r] != -1):\n            res[i] = max(res[i], res[remIndex[r]] + 1)\n        remIndex[r] = i + 1\n    return res[n]\n",
        "test": "\ns = \"12345\"\nprint(MaximumNumbers(s))\n",
        "output": "3\n",
        "fn_call": "MaximumNumbers"
    },
    {
        "text": "maximum number of mangoes that can be bought | ''function to check if mid number of mangoes can be bought ; '' store the coins ; '' if watermelons needed are greater  than given watermelons ; '' store remaining watermelons if vl  watermelons are used to buy mangoes ; '' store the value of coins if these  watermelon get sold ; '' increment coins by ex ; '' number of mangoes that can be buyed  if only x coins needed for one mango ; '' if the condition is satisfied,  return true ; '' otherwise return false ; ''function to find the maximum number of mangoes that can be bought by selling watermelons ; '' initialize the boundary values ; '' store the required result ; '' binary search ; '' store the mid value ; '' check if it is possible to  buy mid number of mangoes ; '' otherwise, update r to mid -1 ; '' return the result ; ''",
        "context": "",
        "code": "def check(n, m, x, y, vl):\n    temp = m\n    if (vl > n):\n        return False\n    ex = n - vl\n    ex *= y\n    temp += ex\n    cr = temp // x\n    if (cr >= vl):\n        return True\n    return False\n\n\ndef maximizeMangoes(n, m, x, y):\n    l = 0\n    r = n\n    ans = 0\n    while (l <= r):\n        mid = l + (r - l) // 2\n        if (check(n, m, x, y, mid)):\n            ans = mid\n            l = mid + 1\n        else:\n            r = mid - 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    W = 4\n    C = 8\n    x = 4\n    y = 4\n    print(maximizeMangoes(W, C, x, y))\n",
        "output": "3\n",
        "fn_call": "maximizeMangoes"
    },
    {
        "text": "find maximum sum array of length less than or equal to m | n and m to define sizes of arr , dp , current_arr and maxsum ; inf to define min value ; function to find maximum sum ; dp array of size n x m ; current_arr of size m ; maxsum of size m ; if we have 0 elements from 0 th array ; compute the cumulative sum array ; calculating the maximum contiguous array for every length j , j is from 1 to lengtn of the array ; every state is depending on its previous state ; computation of dp table similar approach as knapsack problem ; now we have done processing with the last array lets find out what is the maximum sum possible ; ",
        "context": "\nN = 105\nM = 1001\nINF = -1111111111\n\n",
        "code": "def maxSum(arr):\n    dp = [[-1 for x in range(M)]for y in range(N)]\n    current_arr = [0] * M\n    maxsum = [0] * M\n    current_arr[0] = 0\n    dp[0][0] = 0\n    for i in range(1, 6):\n        len = arr[i - 1][0]\n        for j in range(1, len + 1):\n            current_arr[j] = arr[i - 1][j]\n            current_arr[j] += current_arr[j - 1]\n            maxsum[j] = INF\n        j = 1\n        while j <= len and j <= 6:\n            for k in range(1, len + 1):\n                if (j + k - 1 <= len):\n                    maxsum[j] = max(maxsum[j],\n                                    current_arr[j + k - 1] - current_arr[k - 1])\n            j += 1\n        for j in range(7):\n            dp[i][j] = dp[i - 1][j]\n        for j in range(1, 7):\n            cur = 1\n            while cur <= j and cur <= len:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + maxsum[cur])\n                cur += 1\n    ans = 0\n    for i in range(7):\n        ans = max(ans, dp[5][i])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [[3, 2, 3, 5], [2, 7, -1], [2, 8, 10],\n           [4, 5, 2, 6, 1], [3, 2, 3, -2]]\n    print(\"Maximum sum can be obtained\", \"is : \", maxSum(arr))\n",
        "output": "Maximum sum can be obtained is :  39\n",
        "fn_call": "maxSum"
    },
    {
        "text": "collect maximum points in a grid using two traversals | a memoization based program to find maximum collection using two traversals of a grid ; checks whether a given input is valid or not ; driver function to collect max value ; if p1 or p2 is at an invalid cell ; if both traversals reach their destinations ; if both traversals are at last row but not at their destination ; if subproblem is already solved ; initialize answer for this subproblem ; this variable is used to store gain of current cell ( s ) ; recur for all possible cases , then store and return the one with max value ; this is mainly a wrapper over recursive function getmaxutil ( ) . this function creates a table for memoization and calls getmaxutil ( ) ; create a memoization table and initialize all entries as - 1 ; calculation maximum value using memoization based function getmaxutil ( ) ; ",
        "context": "\nR = 5\nC = 4\nintmin = -10000000\nintmax = 10000000\n\n",
        "code": "def isValid(x, y1, y2):\n    return ((x >= 0 and x = 0 and y1 = 0 and y2 < C))\n\n\ndef getMaxUtil(arr, mem, x, y1, y2):\n    if isValid(x, y1, y2) == False:\n        return intmin\n    if x == R - 1 and y1 == 0 and y2 == C - 1:\n        if y1 == y2:\n            return arr[x][y1]\n        else:\n            return arr[x][y1] + arr[x][y2]\n    if x == R - 1:\n        return intmin\n    if mem[x][y1][y2] != -1:\n        return mem[x][y1][y2]\n    ans = intmin\n    temp = 0\n    if y1 == y2:\n        temp = arr[x][y1]\n    else:\n        temp = arr[x][y1] + arr[x][y2]\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1, y2 - 1))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1, y2 + 1))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1, y2))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 - 1, y2))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 - 1, y2 - 1))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 - 1, y2 + 1))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 + 1, y2))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 + 1, y2 - 1))\n    ans = max(ans, temp + getMaxUtil(arr, mem, x + 1, y1 + 1, y2 + 1))\n    mem[x][y1][y2] = ans\n    return ans\n\n\ndef geMaxCollection(arr):\n    mem = [[[-1 for i in range(C)]for i in range(C)]for i in range(R)]\n    return getMaxUtil(arr, mem, 0, 0, C - 1)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[3, 6, 8, 2], [5, 2, 4, 3], [1, 1, 20, 10],\n           [1, 1, 20, 10], [1, 1, 20, 10], ]\n    print('Maximum collection is ', geMaxCollection(arr))\n",
        "output": "Maximum collection is  73\n",
        "fn_call": "geMaxCollection"
    },
    {
        "text": "maximize sum possible from an array by the given moves | function to find the maximum sum possible by given moves from the array ; checking for boundary ; if previously computed subproblem occurs ; if element can be moved left ; calculate maximum possible sum by moving left from current index ; if element can be moved right ; calculate maximum possible sum by moving right from current index and update the maximum sum ; store the maximum sum ; ",
        "context": "",
        "code": "def maxValue(a, n, pos, moves, left, dp):\n    if (moves == 0 or (pos > n - 1 or pos < 0)):\n        return 0\n    if (dp[pos][left] != -1):\n        return dp[pos][left]\n    value = 0\n    if (left > 0 and pos >= 1):\n        value = max(\n            value,\n            a[pos] +\n            maxValue(\n                a,\n                n,\n                pos -\n                1,\n                moves -\n                1,\n                left -\n                1,\n                dp))\n    if (pos <= n - 1):\n        value = max(\n            value,\n            a[pos] +\n            maxValue(\n                a,\n                n,\n                pos +\n                1,\n                moves -\n                1,\n                left,\n                dp))\n    dp[pos][left] = value\n    return dp[pos][left]\n",
        "test": "\nn = 5\na = [1, 5, 4, 3, 2]\nk = 1\nm = 4\ndp = [[-1 for x in range(k + 1)]for y in range(n + 1)]\nprint(a[0] + maxValue(a, n, 1, m, k, dp))\n",
        "output": "19\n",
        "fn_call": "maxValue"
    },
    {
        "text": "partition an array into two subsets with equal count of unique elements | function to partition the array into two subsets such that count of unique elements in both subsets is the same ; stores the subset number for each array elements ; stores the count of unique array elements ; stores the frequency of elements ; traverse the array ; count of elements having a frequency of 1 ; check if there exists any element with frequency > 2 ; count of elements needed to have frequency exactly 1 in each subset ; initialize all values in the array ans [ ] as 1 ; traverse the array ans [ ] ; this array element is a part of first subset ; half array elements with frequency 1 are part of the second subset ; if count of elements is exactly 1 are odd and has no element with frequency > 2 ; if count of elements that occurs exactly once are even ; print the result ; if the count of elements has exactly 1 frequency are odd and there is an element with frequency greater than 2 ; print the result ; ",
        "context": "",
        "code": "def arrayPartition(a, n):\n    ans = [0] * n\n    cnt = 0\n    ind, flag = 0, 0\n    mp = {}\n    for i in a:\n        mp[i] = mp .get(i, 0) + 1\n    for i in range(n):\n        if ((a[i] in mp) and mp[a[i]] == 1):\n            cnt += 1\n        if (mp[a[i]] > 2 and flag == 0):\n            flag = 1\n            ind = i\n    p = (cnt + 1) // 2\n    ans1 = 0\n    for i in range(n):\n        ans[i] = 1\n    for i in range(n):\n        if ((a[i] in mp) and mp[a[i]] == 1 and ans1 < p):\n            ans[i] = 1\n            ans1 += 1\n        elif ((a[i] in mp) and mp[a[i]] == 1):\n            ans[i] = 2\n    if (cnt % 2 == 1 and flag == 0):\n        print(-1)\n        return\n    if (cnt % 2 == 0):\n        print(*ans)\n    else:\n        for i in range(n):\n            if (ind == i):\n                print(2, end=\" \")\n            else:\n                print(ans[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 2, 3, 4, 4]\n    N = len(arr)\n    arrayPartition(arr, N)\n",
        "output": "1 1 1 2 1 1\n",
        "fn_call": "arrayPartition"
    },
    {
        "text": "find binary string by converting all 01 or 10 to 11 after m iterations | function to find the modified binary string after m iterations ; set the value of m to the minimum of n or m . ; declaration of current string state ; loop over m iterations ; set the current state as null before each iteration ; check if this zero has exactly one 1 as neighbour ; flip the zero ; if there is no change , then no need for further iterations . ; set the current state as the new previous state ; ",
        "context": "",
        "code": "def findString(str, M):\n    N = len(str)\n    M = min(M, N)\n    s1 = \"\"\n    while (M != 0):\n        s1 = \"\"\n        for i in range(N - 1):\n            if (str[i] == '0'):\n                if ((str[i - 1] == '1' and str[i + 1] != '1')\n                        or (str[i - 1] != '1' and str[i + 1] == '1')):\n                    s1 += '1'\n                else:\n                    s1 += '0'\n            else:\n                s1 += '1'\n        if (str == s1):\n            break\n        s1 += '1'\n        str = s1\n        M -= 1\n    print(s1)\n",
        "test": "\nif __name__ == '__main__':\n    str = \"0110100\"\n    M = 3\n    findString(str, M)\n",
        "output": "1110111\n",
        "fn_call": "findString"
    },
    {
        "text": "print all ways to reach the nth stair with the jump of 1 or 2 units at a time | function to find all the ways to reach nth stair using one or two jumps ; base cases ; recur for jump1 and jump2 ; stores the total possible jumps ; add \"1\" with every element present in jump1 ; add \"2\" with every element present in jump2 ; ",
        "context": "",
        "code": "def TotalPossibleJumps(N):\n    if ((N - 1) == 0):\n        newvec = []\n        newvec .append(\"\")\n        return newvec\n    else:\n        if (N < 0):\n            newvec = []\n            return newvec\n    jump1 = TotalPossibleJumps(N - 1)\n    jump2 = TotalPossibleJumps(N - 2)\n    totaljumps = []\n    for s in jump1:\n        totaljumps .append(\"1\" + s)\n    for s in jump2:\n        totaljumps .append(\"2\" + s)\n    return totaljumps\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    Ans = TotalPossibleJumps(N)\n    for it in Ans:\n        print(it)\n",
        "output": "11\n2\n",
        "fn_call": "TotalPossibleJumps"
    },
    {
        "text": "last element of an array after repeatedly removing the first element and appending it to the end of the array twice exactly k times | function to find the last element after performing given operations ; length of the array ; increment j until condition is satisfied ; in each pair every value is repeating r number of times ; print the result according to the value of k ; ",
        "context": "",
        "code": "def findLastElement(N, A):\n    l = len(A)\n    j = 0\n    while (N > l * (2 ** j)):\n        N = N - l * 2 ** j\n        j += 1\n    k = 1\n    r = 2 ** j\n    for i in range(1, l):\n        if N > r * i:\n            k += 1\n    for i in range(0, len(A)):\n        if (i + 1 == k):\n            print(A[i])\n            return\n",
        "test": "\nif __name__ == '__main__':\n    K = 7\n    A = [1, 2, 3]\n    findLastElement(K, A)\n",
        "output": "2\n",
        "fn_call": "findLastElement"
    },
    {
        "text": "find any k distinct odd integers such that their sum is equal to n | function to find k odd integers such that their sum is n ; condition to check if there exist such k integers ; loop to find first k - 1 distinct odd integers ; final kth odd number ; ",
        "context": "",
        "code": "def oddIntegers(n, k):\n    if (n % 2 != k % 2):\n        print(\"-1\")\n        return\n    sum = 0\n    i = 1\n    j = 1\n    while (j < k):\n        sum += i\n        print(i, end=\" \")\n        i += 2\n        j += 1\n    finalOdd = n - sum\n    print(finalOdd)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10\n    k = 2\n    oddIntegers(n, k)\n",
        "output": "1 9\n",
        "fn_call": "oddIntegers"
    },
    {
        "text": "check whether product of ' n ' numbers is even or odd | function to check whether product of ' n ' numbers is even or odd ; if a single even number is found , then final product will be an even number ; product is an odd number ; ",
        "context": "",
        "code": "def isProductEven(arr, n):\n    for i in range(0, n):\n        if ((arr[i] & 1) == 0):\n            return True\n    return False\n",
        "test": "\narr = [2, 4, 3, 5]\nn = len(arr)\nif (isProductEven(arr, n)):\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n",
        "output": "Even\n",
        "fn_call": "isProductEven"
    },
    {
        "text": "check if a given number divides the sum of the factorials of its digits | function that returns true if n divides the sum of the factorials of its digits ; to store factorials of digits ; to store sum of the factorials of the digits ; store copy of the given number ; store sum of the factorials of the digits ; if it is divisible ; ",
        "context": "",
        "code": "def isPossible(n):\n    fac = [0 for i in range(10)]\n    fac[0] = 1\n    fac[1] = 1\n    for i in range(2, 10, 1):\n        fac[i] = fac[i - 1] * i\n    sum = 0\n    x = n\n    while (x):\n        sum += fac[x % 10]\n        x = int(x / 10)\n    if (sum % n == 0):\n        return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    n = 19\n    if (isPossible(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "maximum product of the remaining pair after repeatedly replacing pairs of adjacent array elements with their sum | python program for the above approach ; function to find the maximum product possible after repeatedly replacing pairs of adjacent array elements with their sum ; store the maximum product ; store the prefix sum ; store the total sum of array ; traverse the array to find the total sum ; iterate in the range [ 0 , n - 2 ] ; add arr [ i ] to prefix_sum ; store the value of prefix_sum ; store the value of ( total sum - prefix sum ) ; update the maximum product ; print the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxProduct(arr, N):\n    max_product = -sys .maxsize\n    prefix_sum = 0\n    sum = 0\n    for i in range(N):\n        sum += arr[i]\n    for i in range(N - 1):\n        prefix_sum += arr[i]\n        X = prefix_sum\n        Y = sum - prefix_sum\n        max_product = max(max_product, X * Y)\n    print(max_product)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 5, 6, 7]\n    N = len(arr)\n    maxProduct(arr, N)\n",
        "output": "130\n",
        "fn_call": "maxProduct"
    },
    {
        "text": "program to check if n is a star number | python3 implementation to check that a number is a star number or not ; function to check that the number is a star number ; condition to check if the number is a star number ; ",
        "context": "\nimport math\n\n",
        "code": "def isStar(N):\n    n = (math .sqrt(24 * N + 12) + 6) / 6\n    return (n - int(n)) == 0\n",
        "test": "\ni = 13\nif isStar(i):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isStar"
    },
    {
        "text": "maximize array sum after k negations | set 1 | this function does k operations on array in a way that maximize the array sum . index -- > stores the index of current minimum element for j 'th operation ; modify array k number of times ; find minimum element in array for current operation and modify it i . e ; arr [ j ] -- > - arr [ j ] ; this the condition if we find 0 as minimum element , so it will useless to replace 0 by - ( 0 ) for remaining operations ; modify element of array ; calculate sum of array ; ",
        "context": "",
        "code": "def maximumSum(arr, n, k):\n    for i in range(1, k + 1):\n        min = +2147483647\n        index = -1\n        for j in range(n):\n            if (arr[j] < min):\n                min = arr[j]\n                index = j\n        if (min == 0):\n            break\n        arr[index] = -arr[index]\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    return sum\n",
        "test": "\narr = [-2, 0, 5, -1, 2]\nk = 4\nn = len(arr)\nprint(maximumSum(arr, n, k))\n",
        "output": "10\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "minimum cost to form a number x by adding up powers of 2 | function to return the minimum cost ; re - compute the array ; add answers for set bits ; if bit is set ; increase the counter ; right shift the number ; ",
        "context": "",
        "code": "def MinimumCost(a, n, x):\n    for i in range(1, n, 1):\n        a[i] = min(a[i], 2 * a[i - 1])\n    ind = 0\n    sum = 0\n    while (x):\n        if (x & 1):\n            sum += a[ind]\n        ind += 1\n        x = x >> 1\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    a = [20, 50, 60, 90]\n    x = 7\n    n = len(a)\n    print(MinimumCost(a, n, x))\n",
        "output": "120\n",
        "fn_call": "MinimumCost"
    },
    {
        "text": "program to print pentatope numbers upto nth term | function to generate nth tetrahedral number ; function to print pentatope number series upto nth term . ; initialize prev as 0. it store the sum of all previously generated pentatope numbers ; loop to print pentatope series ; find ith tetrahedral number ; add ith tetrahedral number to sum of all previously generated tetrahedral number to get ith pentatope number ; update sum of all previously generated tetrahedral number ; ",
        "context": "",
        "code": "def findTetrahedralNumber(n):\n    return (int((n * (n + 1) * (n + 2)) / 6))\n\n\ndef printSeries(n):\n    prev = 0\n    for i in range(1, n + 1):\n        curr = findTetrahedralNumber(i)\n        curr = curr + prev\n        print(curr, end=' ')\n        prev = curr\n",
        "test": "\nn = 10\nprintSeries(n)\n",
        "output": "1 5 15 35 70 126 210 330 495 715 ",
        "fn_call": "printSeries"
    },
    {
        "text": "count substring of binary string such that each character belongs to a palindrome of size greater than 1 | function to find the substrings in binary string such that every character belongs to a palindrome ; total substrings ; loop to store the count of continuous characters in the given string ; subtract non special strings from answer ; ",
        "context": "",
        "code": "def countSubstrings(s):\n    n = len(s)\n    answer = (n * (n - 1)) // 2\n    cnt = 1\n    v = []\n    for i in range(1, n):\n        if (s[i] == s[i - 1]):\n            cnt += 1\n        else:\n            v .append(cnt)\n            cnt = 1\n    if (cnt > 0):\n        v .append(cnt)\n    for i in range(len(v) - 1):\n        answer -= (v[i] + v[i + 1] - 1)\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    s = \"00111\"\n    print(countSubstrings(s))\n",
        "output": "6\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "sorting array elements with set bits equal to k | function to sort elements with set bits equal to k ; initialise two vectors ; first vector contains indices of required element ; second vector contains required elements ; sorting the elements in second vector ; replacing the elements with k set bits with the sorted elements ; printing the new sorted array elements ; ",
        "context": "",
        "code": "def sortWithSetbits(arr, n, k):\n    v1 = []\n    v2 = []\n    for i in range(0, n, 1):\n        if (bin(arr[i]).count('1') == k):\n            v1 .append(i)\n            v2 .append(arr[i])\n    v2 .sort(reverse=False)\n    for i in range(0, len(v1), 1):\n        arr[v1[i]] = v2[i]\n    for i in range(0, n, 1):\n        print(arr[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [14, 255, 1, 7, 13]\n    n = len(arr)\n    k = 3\n    sortWithSetbits(arr, n, k)\n",
        "output": "7 255 1 13 14 ",
        "fn_call": "sortWithSetbits"
    },
    {
        "text": "maximum average of subtree values in a given binary tree | structure of the tree node ; stores the result ; function for finding maximum subtree average ; checks if current node is not none and doesn 't have any children ; stores sum of its subtree in index 0 and count number of nodes in index 1 ; traverse all children of the current node ; recursively calculate max average of subtrees among its children ; increment sum by sum of its child 's subtree ; increment number of nodes by its child 's node ; increment sum by current node 's value ; increment number of nodes by one ; take maximum of ans and current node 's average ; finally return pair of { sum , count } ; ",
        "context": "\nclass TreeNode:\n    def __init__(self, val):\n        self .val = val\n        self .children = []\n\n\nans = 0.0\n\n",
        "code": "def MaxAverage(root):\n    global ans\n    if (root is not None and len(root .children) == 0):\n        ans = max(ans, (root .val))\n        return [root .val, 1]\n    childResult = [0 for i in range(2)]\n    for child in root .children:\n        childTotal = MaxAverage(child)\n        childResult[0] = childResult[0] + childTotal[0]\n        childResult[1] = childResult[1] + childTotal[1]\n    sum = childResult[0] + root .val\n    count = childResult[1] + 1\n    ans = max(ans, sum / count)\n    return [sum, count]\n",
        "test": "\nif __name__ == '__main__':\n    root = TreeNode(20)\n    left = TreeNode(12)\n    right = TreeNode(18)\n    root .children .append(left)\n    root .children .append(right)\n    left .children .append(TreeNode(11))\n    left .children .append(TreeNode(3))\n    right .children .append(TreeNode(15))\n    right .children .append(TreeNode(8))\n    MaxAverage(root)\n    print(ans * 1.0)\n",
        "output": "15.0\n",
        "fn_call": "MaxAverage"
    },
    {
        "text": "program to check if n is a decagonal number | python3 program for the above approach ; function to check if n is a decagonal number ; condition to check if the number is a decagonal number ; ",
        "context": "\nimport math\n\n",
        "code": "def isdecagonal(N):\n    n = (3 + math .sqrt(16 * N + 9)) / 8\n    return (n - int(n)) == 0\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    if isdecagonal(N):\n        print('Yes')\n    else:\n        print('No')\n",
        "output": "Yes\n",
        "fn_call": "isdecagonal"
    },
    {
        "text": "overall percentage change from successive changes | python implementation of above approach ; calculate successive change of 1 st 2 change ; calculate successive change for rest of the value ; ",
        "context": "",
        "code": "def successiveChange(arr, N):\n    result = 0\n    var1 = arr[0]\n    var2 = arr[1]\n    result = float(var1 + var2 + (float(var1 * var2) / 100))\n    for i in range(2, N):\n        result = (result + arr[i] + (float(result * arr[i]) / 100))\n    return result\n",
        "test": "\narr = [10, 20, 30, 10]\nN = len(arr)\nresult = successiveChange(arr, N)\nprint(\"Percentage change is = %.2f\" % (result), \"%\")\n",
        "output": "Percentage change is = 88.76 %\n",
        "fn_call": "successiveChange"
    },
    {
        "text": "count of elements which is product of a pair or an element square | python3 program to implement the above approach ; stores all factors a number ; function to calculate and store in a vector ; function to return the count of array elements which are a product of two array elements ; copy elements into a a duplicate array ; sort the duplicate array ; store the count of elements ; if the factors are not calculated already ; traverse its factors ; if a pair of factors is found ; ",
        "context": "\nimport math\nv = [[]for i in range(100000)]\n\n",
        "code": "def div(n):\n    global v\n    for i in range(2, int(math .sqrt(n)) + 1):\n        if (n % i == 0):\n            v[n].append(i)\n\n\ndef prodof2elements(arr, n):\n    arr2 = sorted(arr .copy())\n    ans = 0\n    for i in range(n):\n        if (len(v[arr[i]]) == 0):\n            div(arr[i])\n        for j in v[arr[i]]:\n            if j in arr2:\n                if int(arr[i] / j) in arr2:\n                    ans += 1\n                    break\n    return ans\n",
        "test": "\narr = [2, 1, 8, 4, 32, 18]\nN = len(arr)\nprint(prodof2elements(arr, N))\n",
        "output": "3\n",
        "fn_call": "prodof2elements"
    },
    {
        "text": "count all possible paths from top left to bottom right of a mxn matrix | returns count of possible paths to reach cell at row number m and column number n from the topmost leftmost cell ( cell at 1 , 1 ) ; create a 2d table to store results of subproblems one - liner logic to take input for rows and columns mat = [ [ int ( input ( ) ) for x in range ( c ) ] for y in range ( r ) ] ; count of paths to reach any cell in first column is 1 ; count of paths to reach any cell in first column is 1 ; calculate count of paths for other cells in bottom - up manner using the recursive solution ; by uncommenting the last part the code calculates the total possible paths if the diagonal movements are allowed ; ",
        "context": "",
        "code": "def numberOfPaths(m, n):\n    count = [[0 for x in range(n)]for y in range(m)]\n    for i in range(m):\n        count[i][0] = 1\n    for j in range(n):\n        count[0][j] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            count[i][j] = count[i - 1][j] + count[i][j - 1]\n    return count[m - 1][n - 1]\n",
        "test": "\nm = 3\nn = 3\nprint(numberOfPaths(m, n))\n",
        "output": "6\n",
        "fn_call": "numberOfPaths"
    },
    {
        "text": "vertical and horizontal retrieval ( mrt ) on tapes | python3 program to print horizontal filling ; it is used for checking whether tape is full or not ; it is used for calculating total retrieval time ; it is used for calculating mean retrieval time ; vector is used because n number of records can insert in one tape with size constraint ; null vector obtained to use fresh vector 'v ; initialize variables to 0 for each iteration ; sum is used for checking whether i 'th tape is full or not ; check sum less than size of tape ; increment in j for next record ; calculating total retrieval time ; mrt formula ; calculating mean retrieval time using formula ; v . size ( ) is function of vector is used to get size of vector ; ",
        "context": "",
        "code": "def horizontalFill(records,  tape, nt):\n    sum = 0\n    Retrieval_Time = 0\n    current = 0\n    v = []\n\n    for i in range(nt):\n        v.clear()\n        Retrieval_Time = 0\n        sum = 0\n        print(\"tape\", i + 1, \": [ \", end=\"\")\n        sum += records[current]\n        while (sum <= tape[i]):\n            print(records[current], end=\" \")\n            v.append(records[current])\n            current += 1\n            sum += records[current]\n\n        print(\"]\", end=\"\")\n        for i in range(len(v)):\n            Retrieval_Time += v[i] * (len(v) - i)\n        Mrt = Retrieval_Time / len(v)\n        print(\"tMRT :\", Mrt)\n",
        "test": "\nif __name__ == \"__main__\":\n\n    records = [15, 2, 8, 23, 45, 50, 60, 120]\n    tape = [25, 80, 160]\n    n = len(records)\n    m = len(tape)\n    records.sort()\n    horizontalFill(records, tape, m)\n",
        "output": "tape 1 : [ 2 8 15 ]tMRT : 12.333333333333334\ntape 2 : [ 23 45 ]tMRT : 45.5\ntape 3 : [ 50 60 ]tMRT : 80.0\n",
        "fn_call": "horizontalFill"
    },
    {
        "text": "cumulative frequency of count of each element in an unsorted array | function to print the cumulative frequency according to the order given ; insert elements and their frequencies in hash map . ; traverse in the array ; add the frequencies ; if the element has not been visited previously ; mark the hash 0 as the element 's cumulative  frequency has been printed ; ",
        "context": "",
        "code": "def countFreq(a, n):\n    hm = dict()\n    for i in range(n):\n        hm[a[i]] = hm .get(a[i], 0) + 1\n    cumul = 0\n    for i in range(n):\n        cumul += hm[a[i]]\n        if (hm[a[i]] > 0):\n            print(a[i], \"->\", cumul)\n        hm[a[i]] = 0\n",
        "test": "\na = [1, 3, 2, 4, 2, 1]\nn = len(a)\ncountFreq(a, n)\n",
        "output": "1 -> 2\n3 -> 3\n2 -> 5\n4 -> 6\n",
        "fn_call": "countFreq"
    },
    {
        "text": "move all negative numbers to beginning and positive to end with constant extra space | a python 3 program to put all negative numbers before positive numbers ; print an array ; ",
        "context": "",
        "code": "def rearrange(arr, n):\n    j = 0\n    for i in range(0, n):\n        if (arr[i] < 0):\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            j = j + 1\n    print(arr)\n",
        "test": "\narr = [-1, 2, -3, 4, 5, 6, -7, 8, 9]\nn = len(arr)\nrearrange(arr, n)\n",
        "output": "[-1, -3, -7, 4, 5, 6, 2, 8, 9]\n",
        "fn_call": "rearrange"
    },
    {
        "text": "number of elements that can be seen from right side | python3 program to find number of elements that can be seen from right side ; ",
        "context": "",
        "code": "def numberOfElements(height, n):\n    max_so_far = 0\n    coun = 0\n    for i in range(n - 1, -1, -1):\n        if height[i] > max_so_far:\n            max_so_far = height[i]\n            coun = coun + 1\n    return coun\n",
        "test": "\nif __name__ == '__main__':\n    n = 6\n    height = [4, 8, 2, 0, 0, 5]\n    print(numberOfElements(height, n))\n",
        "output": "2\n",
        "fn_call": "numberOfElements"
    },
    {
        "text": "array sum after replacing all occurrences of x by y for q queries | function that print the sum of the array for q queries ; stores the frequencies of array elements ; calculate the sum of the initial array and store the frequency of each element in map ; iterate for all the queries ; store query values ; decrement the sum accordingly ; increment the sum accordingly ; set count of y [ i ] ; reset count of x [ i ] ; print the sum ; ",
        "context": "",
        "code": "def sumOfTheArrayForQuery(A, N, X, Y, Q):\n    sum = 0\n    count = {}\n    for i in range(N):\n        sum += A[i]\n        if A[i] in count:\n            count[A[i]] += 1\n        else:\n            count[A[i]] = 1\n    for i in range(Q):\n        x = X[i]\n        y = Y[i]\n        if X[i]not in count:\n            count[X[i]] = 0\n        if Y[i]not in count:\n            count[Y[i]] = 0\n        sum -= (count[X[i]] * X[i])\n        sum += count[X[i]] * Y[i]\n        count[Y[i]] += count[X[i]]\n        count[X[i]] = 0\n        print(sum, end=\" \")\n",
        "test": "\narr = [1, 2, 1, 3, 2, ]\nX = [2, 3, 5]\nY = [3, 1, 2]\nN = len(arr)\nQ = len(X)\nsumOfTheArrayForQuery(arr, N, X, Y, Q)\n",
        "output": "11 5 5 ",
        "fn_call": "sumOfTheArrayForQuery"
    },
    {
        "text": "discrete logarithm ( find an integer k such that a ^ k is congruent modulo b ) | python3 program to calculate discrete logarithm ; iterative function to calculate ( x ^ y ) % p in o ( log y ) ; x = x % p ; update x if it is more than or equal to p ; if y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; function to calculate k for given a , b , m ; store all values of a ^ ( n * i ) of lhs ; calculate ( a ^ j ) * b and check for collision ; if collision occurs i . e . , lhs = rhs ; check whether ans lies below m or not ; ",
        "context": "\nimport math\n\n",
        "code": "def powmod(x, y, p):\n\n    res = 1\n\n    x = x % p\n\n    while (y > 0):\n\n        if (y & 1):\n            res = (res * x) % p\n\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef discreteLogarithm(a, b, m):\n    n = int(math.sqrt(m) + 1)\n\n    value = [0] * m\n    for i in range(n, 0, -1):\n        value[powmod(a, i * n, m)] = i\n\n    for j in range(n):\n        cur = (powmod(a, j, m) * b) % m\n        if (value[cur]):\n            ans = value[cur] * n - j\n            if (ans < m):\n                return ans\n\n    return -1\n",
        "test": "\na = 2\nb = 3\nm = 5\nprint(discreteLogarithm(a, b, m))\n\na = 3\nb = 7\nm = 11\nprint(discreteLogarithm(a, b, m))\n",
        "output": "3\n-1\n",
        "fn_call": "discreteLogarithm"
    },
    {
        "text": "number of subsequences with negative product | python 3 implementation of the approach ; function to return the count of all the subsequences with negative product ; to store the count of positive elements in the array ; to store the count of negative elements in the array ; if the current element is positive ; if the current element is negative ; for all the positive elements of the array ; for all the negative elements of the array ; ",
        "context": "\nimport math\n\n",
        "code": "def cntSubSeq(arr, n):\n    pos_count = 0\n    neg_count = 0\n    for i in range(n):\n        if (arr[i] > 0):\n            pos_count += 1\n        if (arr[i] < 0):\n            neg_count += 1\n    result = int(math .pow(2, pos_count))\n    if (neg_count > 0):\n        result *= int(math .pow(2, neg_count - 1))\n    else:\n        result = 0\n    return result\n",
        "test": "\narr = [2, -3, -1, 4]\nn = len(arr)\nprint(cntSubSeq(arr, n))\n",
        "output": "8\n",
        "fn_call": "cntSubSeq"
    },
    {
        "text": "minimum number of digits required to be removed to make a number divisible by 4 | function to count the minimum number of digits required to be removed to make a given number divisible by 4 ; store the size of the string ; stores the required result ; check for every pair of digits if the number formed by them is divisible by 4 or not ; store s [ i ] in a variable ; if it is divisible by 2 ; store the number formed by s [ j ] and s [ i ] ; check if it is divisible by 4 ; store the number of digits required to be deleted ; update ans ; if value of ans is unchanged , then check if any s [ i ] is divisible by 4 ; if true , update ans to n - 1 ; prthe result ; ",
        "context": "",
        "code": "def minimumDeletions(s):\n    n = len(s)\n    ans = n\n    for i in range(n - 1, -1, -1):\n        t = ord(s[i]) - ord('0')\n        if (t % 2 == 0):\n            for j in range(i - 1, -1, -1):\n                num = (ord(s[j]) - ord('0')) * 10 + t\n                if (num % 4 == 0):\n                    k1 = i - j - 1\n                    k2 = n - i - 1\n                    ans = min(ans, k1 + k2)\n    if (ans == n):\n        for i in range(n):\n            num = ord(s[i]) - ord('0')\n            if (num % 4 == 0):\n                ans = n - 1\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    str = \"12367\"\n    minimumDeletions(str)\n",
        "output": "1\n",
        "fn_call": "minimumDeletions"
    },
    {
        "text": "minimize deletions in a binary string to remove all subsequences of the form \"0101\" | function to find minimum characters to be removed such that no subsequence of the form \"0101\" exists in the string ; stores the partial sums ; calculate partial sums ; setting endpoints and deleting characters indices . ; return count of deleted characters ; ",
        "context": "",
        "code": "def findmin(s):\n    n = len(s)\n    maximum = 0\n    incr = [0] * (n + 1)\n    for i in range(0, n):\n        incr[i + 1] = incr[i]\n        if (s[i] == '0'):\n            incr[i + 1] = incr[i + 1] + 1\n    for i in range(0, n + 1):\n        for j in range(i + 1, n):\n            maximum = max(\n                maximum, incr[i] + j - i + 1 - (incr[j + 1] - incr[i]) + incr[n] - incr[j + 1])\n    return n - maximum\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"0110100110\"\n    minimum = findmin(S)\n    print(minimum)\n",
        "output": "3\n",
        "fn_call": "findmin"
    },
    {
        "text": "sum of all numbers up to n that are co | function to return gcd of a and b ; base case ; recursive gcd ; function to calculate the sum of all numbers till n that are coprime with n ; stores the resultant sum ; iterate over [ 1 , n ] ; if gcd is 1 ; update sum ; return the final sum ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef findSum(N):\n    sum = 0\n    for i in range(1, N):\n        if (gcd(i, N) == 1):\n            sum += i\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    print(findSum(N))\n",
        "output": "10\n",
        "fn_call": "findSum"
    },
    {
        "text": "check if ceil of number divided by power of two exist in sorted array | function to find there exist a number or not in the array ; loop to check if there exist a number by divided by power of 2 ; binary search ; condition to check the number is found in the array or not ; otherwise divide the number by increasing the one more power of 2 ; ",
        "context": "",
        "code": "def findNumberDivByPowerofTwo(ar, k, n):\n    found = -1\n    m = k\n    while (m > 0):\n        l = 0\n        r = n - 1\n        while (l <= r):\n            mid = (l + r) // 2\n            if (ar[mid] == m):\n                found = m\n                break\n            elif (ar[mid] > m):\n                r = mid - 1\n            elif (ar[mid] < m):\n                l = mid + 1\n        if (found != -1):\n            break\n        m = m // 2\n    return found\n",
        "test": "\narr = [3, 5, 7, 8, 10]\nk = 4\nn = 5\nprint(findNumberDivByPowerofTwo(arr, k, n))\n",
        "output": "-1\n",
        "fn_call": "findNumberDivByPowerofTwo"
    },
    {
        "text": "shortest palindromic substring | function return the shortest palindromic substring ; one by one consider every character as center point of even and length palindromes ; find the longest odd length palindrome with center point as i ; find the even length palindrome with center points as i - 1 and i . ; smallest substring which is not empty ; ",
        "context": "",
        "code": "def ShortestPalindrome(s):\n    n = len(s)\n    v = []\n    for i in range(n):\n        l = i\n        r = i\n        ans1 = \"\"\n        ans2 = \"\"\n        while ((l >= 0) and (r < n) and (s[l] == s[r])):\n            ans1 += s[l]\n            l -= 1\n            r += 1\n        l = i - 1\n        r = i\n        while ((l >= 0) and (r < n) and (s[l] == s[r])):\n            ans2 += s[l]\n            l -= 1\n            r += 1\n        v .append(ans1)\n        v .append(ans2)\n    ans = v[0]\n    for i in range(len(v)):\n        if (v[i] != \"\"):\n            ans = min(ans, v[i])\n    return ans\n",
        "test": "\ns = \"geeksforgeeks\"\nprint(ShortestPalindrome(s))\n",
        "output": "e\n",
        "fn_call": "ShortestPalindrome"
    },
    {
        "text": "maximum number of parallelograms that can be made using the given length of line segments | function to find the maximum number of parallelograms can be made ; finding the length of the frequency array ; increasing the occurrence of each segment ; to store the count of parallelograms ; counting parallelograms that can be made using 4 similar sides ; counting segments which have occurrence left >= 2 ; adding parallelograms that can be made using 2 similar sides ; ",
        "context": "",
        "code": "def convert(n, a):\n    z = max(a) + 1\n    ff = [0] * z\n    for i in range(n):\n        ff[a[i]] += 1\n    cc = 0\n    for i in range(z):\n        cc += ff[i] // 4\n        ff[i] = ff[i] % 4\n    vv = 0\n    for i in range(z):\n        if (ff[i] >= 2):\n            vv += 1\n    cc += vv // 2\n    print(cc)\n",
        "test": "\nn = 4\na = [1, 2, 1, 2]\nconvert(n, a)\n",
        "output": "1\n",
        "fn_call": "convert"
    },
    {
        "text": "count pairs ( a , b ) such that a has x and b has y number of set bits and a + b = c | initial dp array ; recursive function to generate all combinations of bits ; if the state has already been visited ; find if c has no more set bits on left ; if no set bits are left for c and there are no set bits for a and b and the carry is 0 , then this combination is possible ; if no set bits are left for c and requirement of set bits for a and b have exceeded ; find if the bit is 1 or 0 at third index to the left ; carry = 1 and bit set = 1 ; since carry is 1 , and we need 1 at c 's bit position we can use 0 and 0  or 1 and 1 at a and b bit position ; carry = 0 and bit set = 1 ; since carry is 0 , and we need 1 at c 's  bit position we can use 1 and 0  or 0 and 1 at a and b bit position ; carry = 1 and bit set = 0 ; since carry is 1 , and we need 0 at c 's  bit position we can use 1 and 0  or 0 and 1 at a and b bit position ; carry = 0 and bit set = 0 ; since carry is 0 , and we need 0 at c 's  bit position we can use 0 and 0  or 1 and 1 at a and b bit position ; function to count ways ; function call that returns the answer ; ",
        "context": "\ndp = [[[[-1, -1]for i in range(64)]for j in range(64)]for k in range(64)]\n\n",
        "code": "def func(third, seta, setb, carry, number):\n    if dp[third][seta][setb][carry] != -1:\n        return dp[third][seta][setb][carry]\n    shift = number >> third\n    if (shift == 0 and seta == 0 and setb == 0 and carry == 0):\n        return 1\n    if (shift == 0 or seta < 0 or setb < 0):\n        return 0\n    mask = shift & 1\n    dp[third][seta][setb][carry] = 0\n    if (mask) and carry:\n        dp[third][seta][setb][carry] += func(third + 1,\n                                             seta,\n                                             setb,\n                                             0,\n                                             number) + func(third + 1,\n                                                            seta - 1,\n                                                            setb - 1,\n                                                            1,\n                                                            number)\n    elif mask and not carry:\n        dp[third][seta][setb][carry] += func(third + 1,\n                                             seta - 1,\n                                             setb,\n                                             0,\n                                             number) + func(third + 1,\n                                                            seta,\n                                                            setb - 1,\n                                                            0,\n                                                            number)\n    elif not mask and carry:\n        dp[third][seta][setb][carry] += func(third + 1,\n                                             seta - 1,\n                                             setb,\n                                             1,\n                                             number) + func(third + 1,\n                                                            seta,\n                                                            setb - 1,\n                                                            1,\n                                                            number)\n    elif not mask and not carry:\n        dp[third][seta][setb][carry] += func(third + 1,\n                                             seta,\n                                             setb,\n                                             0,\n                                             number) + func(third + 1,\n                                                            seta - 1,\n                                                            setb - 1,\n                                                            1,\n                                                            number)\n    return dp[third][seta][setb][carry]\n\n\ndef possibleSwaps(a, b, c):\n    ans = func(0, a, b, 0, c)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    x, y, c = 2, 2, 20\n    print(possibleSwaps(x, y, c))\n",
        "output": "3\n",
        "fn_call": "possibleSwaps"
    },
    {
        "text": "count of subarrays of an array having all unique digits | function to obtain the mask for any integer ; function to count the number of ways ; subarray must not be empty ; if subproblem has been solved ; excluding this element in the subarray ; if there are no common digits then only this element can be included ; calculate the new mask if this element is included ; store and return the answer ; function to find the count of subarray with all digits unique ; initializing dp ; ",
        "context": "",
        "code": "def getmask(val):\n    mask = 0\n    if val == 0:\n        return 1\n    while (val):\n        d = val % 10\n        mask |= (1 << d)\n        val = val // 10\n    return mask\n\n\ndef countWays(pos, mask, a, n):\n    if pos == n:\n        if mask > 0:\n            return 1\n        else:\n            return 0\n    if dp[pos][mask] != -1:\n        return dp[pos][mask]\n    count = 0\n    count = (count + countWays(pos + 1, mask, a, n))\n    if (getmask(a[pos]) & mask) == 0:\n        new_mask = (mask | (getmask(a[pos])))\n        count = (count + countWays(pos + 1, new_mask, a, n))\n    dp[pos][mask] = count\n    return count\n\n\ndef numberOfSubarrays(a, n):\n    return countWays(0, 0, a, n)\n",
        "test": "\nN = 4\nA = [1, 12, 23, 34]\nrows = 5000\ncols = 1100\ndp = [[-1 for i in range(cols)]for j in range(rows)]\nprint(numberOfSubarrays(A, N))\n",
        "output": "7\n",
        "fn_call": "numberOfSubarrays"
    },
    {
        "text": "multiplication with a power of 2 | efficient python3 code to compute x * ( 2 ^ n ) ; ",
        "context": "",
        "code": "def multiply(x, n):\n    return x << n\n",
        "test": "\nx = 70\nn = 2\nprint(multiply(x, n))\n",
        "output": "280\n",
        "fn_call": "multiply"
    },
    {
        "text": "check if a string can become empty by recursively deleting a given sub | returns true if str can be made empty by recursively removing sub_str . ; idx : to store starting index of sub - string found in the original string ; erasing the found sub - string from the original string ; ",
        "context": "",
        "code": "def canBecomeEmpty(string, sub_str):\n    while len(string) > 0:\n        idx = string .find(sub_str)\n        if idx == -1:\n            break\n        string = string .replace(sub_str, \"\", 1)\n    return (len(string) == 0)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"GEEGEEKSKS\"\n    sub_str = \"GEEKS\"\n    if canBecomeEmpty(string, sub_str):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canBecomeEmpty"
    },
    {
        "text": "convert to a string that is repetition of a substring of k length | returns true if s can be converted to a with k repeated subs after replacing k characters . ; length of must be a multiple of k ; map to store s of length k and their counts ; if is already a repetition of k subs , return true . ; if number of distinct subs is not 2 , then not possible to replace a . ; one of the two distinct must appear exactly once . either the first entry appears once , or it appears n / k - 1 times to make other sub appear once . ; ",
        "context": "",
        "code": "def check(S, k):\n    n = len(S)\n    if (n % k != 0):\n        return False\n    mp = {}\n    for i in range(0, n, k):\n        mp[S[i:k]] = mp .get(S[i:k], 0) + 1\n    if (len(mp) == 1):\n        return True\n    if (len(mp) != 2):\n        return False\n    for i in mp:\n        if i == (n // k - 1) or mp[i] == 1:\n            return True\n    return False\n",
        "test": "\nif check(\"abababcd\", 2):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "stein 's algorithm for finding gcd | function to implement stein 's algorithm ; gcd ( 0 , b ) == b ; gcd ( a , 0 ) == a , gcd ( 0 , 0 ) == 0 ; look for factors of 2 a is even ; b is odd ; both a and b are even ; a is odd , b is even ; reduce larger number ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == b):\n        return a\n    if (a == 0):\n        return b\n    if (b == 0):\n        return a\n    if ((~a & 1) == 1):\n        if ((b & 1) == 1):\n            return gcd(a >> 1, b)\n        else:\n            return (gcd(a >> 1, b >> 1) << 1)\n    if ((~b & 1) == 1):\n        return gcd(a, b >> 1)\n    if (a > b):\n        return gcd((a - b) >> 1, b)\n    return gcd((b - a) >> 1, a)\n",
        "test": "\na, b = 34, 17\nprint(\"Gcd of given numbers is \", gcd(a, b))\n",
        "output": "Gcd of given numbers is  17\n",
        "fn_call": "gcd"
    },
    {
        "text": "minimum size binary string required such that probability of deleting two 1 's at random is 1/x | python3 implementation of the above approach ; function returns the minimum size of the string ; from formula ; left limit of r ; right limit of r ; smallest integer in the valid range ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def MinimumString(x):\n    b = 1\n    left_lim = sqrt(x) + 1.0\n    right_lim = sqrt(x) + 2.0\n    for i in range(int(left_lim), int(right_lim) + 1):\n        if (i > left_lim and i < right_lim):\n            r = i\n            break\n    return b + r\n",
        "test": "\nif __name__ == '__main__':\n    X = 2\n    print(MinimumString(X))\n",
        "output": "4\n",
        "fn_call": "MinimumString"
    },
    {
        "text": "interprime | utility function to check if a number is prime or not ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to check if the given number is interprime or not ; smallest interprime is 4 so the number less than 4 can not be a interprime ; calculate first prime number  n ; check if next_prime and prev_prime have the same average ; ",
        "context": "",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef isInterprime(n):\n    if (n < 4):\n        return False\n    prev_prime = n\n    next_prime = n\n    while (isPrime(prev_prime) == 0):\n        prev_prime = prev_prime - 1\n    while (isPrime(next_prime) == 0):\n        next_prime = next_prime + 1\n    if ((prev_prime + next_prime) == 2 * n):\n        return True\n    else:\n        return False\n",
        "test": "\nn = 9\nif (isInterprime(n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isInterprime"
    },
    {
        "text": "find maximum value of the last element after reducing the array with given operations | function to return the maximized value ; overall minimum absolute value of some element from the array ; add all absolute values ; count positive and negative elements ; both positive and negative values are present ; only positive or negative values are present ; ",
        "context": "",
        "code": "def find_maximum_value(a, n):\n    sum = 0\n    minimum = 10 ** 9\n    pos = 0\n    neg = 0\n    for i in range(n):\n        minimum = min(minimum, abs(a[i]))\n        sum += abs(a[i])\n        if (a[i] >= 0):\n            pos += 1\n        else:\n            neg += 1\n    if (pos > 0 and neg > 0):\n        return sum\n    return (sum - 2 * minimum)\n",
        "test": "\na = [5, 4, 6, 2]\nn = len(a)\nprint(find_maximum_value(a, n))\n",
        "output": "13\n",
        "fn_call": "find_maximum_value"
    },
    {
        "text": "minimum length of subsequence having unit gcd | function that finds the prime factors of a number ; to store the prime factor ; 2 s that divide n ; n must be odd at this point skip one element ; update the prime factor ; if n is a prime number greater than 2 ; function that finds the shortest subsequence ; check if the prime factor of first number , is also the prime factor of the rest numbers in array ; set corresponding bit of prime factor to 1 , it means both these numbers have the same prime factor ; if no states encountered so far continue for this combination of bits ; update this state with minimum ways to reach this state ; function that print the minimum length of subsequence ; find the prime factors of the first number ; initialize the array with maximum steps , size of the array + 1 for instance ; total number of set bits is equal to the total number of prime factors ; indicates there is one way to reach the number under consideration ; state 0 corresponds to gcd of 1 ; if not found such subsequence then print \" - 1\" ; else print the length ; ",
        "context": "",
        "code": "def findPrimeFactors(n):\n    primeFactors = [0 for i in range(9)]\n    j = 0\n    if (n % 2 == 0):\n        primeFactors[j] = 2\n        j += 1\n        while (n % 2 == 0):\n            n >>= 1\n    i = 3\n    while (i * i <= n):\n        if (n % i == 0):\n            primeFactors[j] = i\n            j += 1\n            while (n % i == 0):\n                n //= i\n        i += 2\n    if (n > 2):\n        primeFactors[j] = n\n        j += 1\n    for i in range(0, j + 1):\n        primeFactors[i] = 0\n    return primeFactors\n\n\ndef findShortestSubsequence(dp, a, index, primeFactors):\n    n = len(a)\n    for j in range(index, n):\n        bitmask = 0\n        for p in range(len(primeFactors)):\n            if (primeFactors[p] != 0 and a[j] % primeFactors[p] == 0):\n                bitmask ^= (1 << p)\n        for i in range(len(dp)):\n            if (dp[i] == n + 1):\n                continue\n            dp[bitmask & i] = min(dp[bitmask & i], dp[i] + 1)\n\n\ndef printMinimumLength(a):\n    mn = len(a) + 1\n    for i in range(len(a) - 1):\n        primeFactors = findPrimeFactors(a[i])\n        n = len(primeFactors)\n        dp = [0 for i in range(1 << n)]\n        dp = [len(a) + 1 for i in range(len(dp))]\n        setBits = (1 << n) - 1\n        dp[setBits] = 1\n        findShortestSubsequence(dp, a, i + 1, primeFactors)\n        mn = min(dp[0], mn)\n    if (mn == len(a) + 1):\n        print(-1)\n    else:\n        print(mn)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 6, 12, 3]\n    printMinimumLength(arr)\n",
        "output": "2\n",
        "fn_call": "printMinimumLength"
    },
    {
        "text": "minimum matches the team needs to win to qualify | function to return the minimum number of matches to win to qualify for next round ; do a binary search to find ; find mid element ; check for condition to qualify for next round ; ",
        "context": "",
        "code": "def findMinimum(x, y):\n    low = 0\n    high = y\n    while (low <= high):\n        mid = (low + high) >> 1\n        if ((mid * 2 + (y - mid)) >= x):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n",
        "test": "\nif __name__ == '__main__':\n    x = 6\n    y = 5\n    print(findMinimum(x, y))\n",
        "output": "1\n",
        "fn_call": "findMinimum"
    },
    {
        "text": "string matching with * ( that matches with any ) in any of the two strings | function to check if the two strings can be matched or not ; if the string don 't have *  then character t that position  must be same. ; ",
        "context": "",
        "code": "def doMatch(A, B):\n    for i in range(len(A)):\n        if A[i] != '*' and B[i] != '*':\n            if A[i] != B[i]:\n                return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    A = \"gee*sforgeeks\"\n    B = \"geeksforgeeks\"\n    print(int(doMatch(A, B)))\n",
        "output": "1\n",
        "fn_call": "doMatch"
    },
    {
        "text": "Sub | Tree traversal to compute minimum difference ; Initial min difference is the color of node ; Traversing its children ; Not traversing the parent ; If the child is Adding positively to difference , we include it in the answer Otherwise , we leave the sub - tree and include 0 ( nothing ) in the answer ; DFS for colour difference : 1 colour - 2 colour ; Minimum colour difference is maximum answer value ; Clearing the current value to check for colour2 as well ; Interchanging the colours ; DFS for colour difference : 2 colour - 1 colour ; Checking if colour2 makes the minimum colour difference ; Nodes ; Adjacency list representation ; Edges ; Index represent the colour of that node There is no Node 0 , so we start from index 1 to N ; Printing the result",
        "context": "",
        "code": "def dfs(node, parent, tree, colour, answer):\n    answer[node] = colour[node]\n    for u in tree[node]:\n        if (u == parent):\n            continue\n        dfs(u, node, tree, colour, answer)\n        answer[node] += max(answer[u], 0)\n\n\ndef maxDiff(tree, colour, N):\n    answer = [0 for _ in range(N + 1)]\n    dfs(1, 0, tree, colour, answer)\n    high = 0\n    for i in range(1, N + 1):\n        high = max(high, answer[i])\n        answer[i] = 0\n    for i in range(1, N + 1):\n        if colour[i] == -1:\n            colour[i] = 1\n        else:\n            colour[i] = -1\n    dfs(1, 0, tree, colour, answer)\n    for i in range(1, N):\n        high = max(high, answer[i])\n    return high\n",
        "test": "\nN = 5\ntree = [list()for _ in range(N + 1)]\ntree[1].append(2)\ntree[2].append(1)\ntree[1].append(3)\ntree[3].append(1)\ntree[2].append(4)\ntree[4].append(2)\ntree[3].append(5)\ntree[5].append(3)\ncolour = [0, 1, 1, -1, -1, 1]\nprint(maxDiff(tree, colour, N))\n",
        "output": "2\n",
        "fn_call": "maxDiff"
    },
    {
        "text": "check if any large number is divisible by 17 or not | function to check if the number is divisible by 17 or not ; extracting the last digit ; truncating the number ; subtracting the five times the last digit from the remaining number ; return n is divisible by 17 ; ",
        "context": "",
        "code": "def isDivisible(n):\n    while (n // 100):\n        d = n % 10\n        n //= 10\n        n -= d * 5\n    return (n % 17 == 0)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 19877658\n    if isDivisible(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isDivisible"
    },
    {
        "text": "number of subarrays have bitwise or >= k | python implementation of the approach ; function to build the segment tree ; function to return the bitwise or of segment [ l . . r ] ; function to return the count of required sub - arrays ; build segment tree ; query segment tree for bitwise or of sub - array [ i . . j ] ; ",
        "context": "\nN = 100002\ntree = [0] * (4 * N)\n\n",
        "code": "def build(arr, node, start, end):\n    if start == end:\n        tree[node] = arr[start]\n        return\n    mid = (start + end) >> 1\n    build(arr, 2 * node, start, mid)\n    build(arr, 2 * node + 1, mid + 1, end)\n    tree[node] = tree[2 * node] | tree[2 * node + 1]\n\n\ndef query(node, start, end, l, r):\n    if start > end or start > r or end < l:\n        return 0\n    if start >= l and end <= r:\n        return tree[node]\n    mid = (start + end) >> 1\n    q1 = query(2 * node, start, mid, l, r)\n    q2 = query(2 * node + 1, mid + 1, end, l, r)\n    return q1 or q2\n\n\ndef countSubArrays(arr, n, K):\n    build(arr, 1, 0, n - 1)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            bitwise_or = query(1, 0, n - 1, i, j)\n            if bitwise_or >= K:\n                count += 1\n    return count\n",
        "test": "\narr = [3, 4, 5]\nn = len(arr)\nk = 6\nprint(countSubArrays(arr, n, k))\n",
        "output": "2\n",
        "fn_call": "countSubArrays"
    },
    {
        "text": "mirror characters of a string | function which take the given string and the position from which the reversing shall be done and returns the modified string ; creating a string having reversed alphabetical order ; the string up to the point specified in the question , the string remains unchanged and from the point up to the length of the string , we reverse the alphabetical order ; ",
        "context": "",
        "code": "def compute(st, n):\n    reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\"\n    l = len(st)\n    answer = \"\"\n    for i in range(0, n):\n        answer = answer + st[i]\n    for i in range(n, l):\n        answer = (answer + reverseAlphabet[ord(st[i]) - ord('a')])\n    return answer\n",
        "test": "\nst = \"pneumonia\"\nn = 4\nanswer = compute(st, n - 1)\nprint(answer)\n",
        "output": "pnefnlmrz\n",
        "fn_call": "compute"
    },
    {
        "text": "last digit of a number raised to last digit of n factorial | function to find a ^ b using binary exponentiation ; initialise result ; if b is odd then , multiply result by a ; b must be even now change b to b / 2 ; change a = a ^ 2 ; function to find the last digit of the given equation ; to store cyclicity ; store cyclicity from 1 - 10 ; observation 1 ; observation 3 ; to store the last digits of factorial 2 , 3 , and 4 ; find the last digit of x ; step 1 ; divide a [ n ] by cyclicity of v ; if remainder is 0 ; step 1.1 ; step 1.2 ; step 1.3 ; if r is non - zero , then return ( l ^ r ) % 10 ; else return 0 ; else return 1 ; ",
        "context": "",
        "code": "def power(a, b, c):\n    result = 1\n    while (b > 0):\n        if ((b & 1) == 1):\n            result = (result * a) % c\n        b //= 2\n        a = (a * a) % c\n    return result\n\n\ndef calculate(X, N):\n    a = 10 * [0]\n    cyclicity = 11 * [0]\n    cyclicity[1] = 1\n    cyclicity[2] = 4\n    cyclicity[3] = 4\n    cyclicity[4] = 2\n    cyclicity[5] = 1\n    cyclicity[6] = 1\n    cyclicity[7] = 4\n    cyclicity[8] = 4\n    cyclicity[9] = 2\n    cyclicity[10] = 1\n    if (N == 0 or N == 1):\n        return (X % 10)\n    elif (N == 2 or N == 3 or N == 4):\n        temp = 1e18\n        a[2] = 2\n        a[3] = 6\n        a[4] = 4\n        v = X % 10\n        if (v != 0):\n            u = cyclicity[v]\n            r = a[N] % u\n            if (r == 0):\n                if (v == 2 or v == 4 or v == 6 or v == 8):\n                    return 6\n                elif (v == 5):\n                    return 5\n                elif (v == 1 or v == 3 or v == 7 or v == 9):\n                    return 1\n            else:\n                return (power(v, r, temp) % 10)\n        else:\n            return 0\n    return 1\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 18\n    N = 4\n    result = calculate(X, N)\n    print(result)\n",
        "output": "6\n",
        "fn_call": "calculate"
    },
    {
        "text": "minimum cost to modify a string | function to return the minimum cost ; initialize result ; to store the frequency of characters of the string ; update the frequencies of the characters of the string ; loop to check all windows from a - z where window size is k ; starting index of window ; ending index of window ; check if the string contains character ; check if the character is on left side of window find the cost of modification for character add value to count calculate nearest distance of modification ; check if the character is on right side of window find the cost of modification for character add value to count calculate nearest distance of modification ; find the minimum of all costs for modifying the string ; loop to check all windows here window contains characters before z and after z of window size k ; starting index of window ; ending index of window ; check if the string contains character ; if characters are outside window find the cost for modifying character add value to count ; find the minimum of all costs for modifying the string ; ",
        "context": "",
        "code": "def minCost(str1, K):\n    n = len(str1)\n    res = 999999999\n    count = 0\n    cnt = [0 for i in range(27)]\n    for i in range(n):\n        cnt[ord(str1[i]) - ord('a') + 1] += 1\n    for i in range(1, 26 - K + 1, 1):\n        a = i\n        b = i + K\n        count = 0\n        for j in range(1, 27, 1):\n            if (cnt[j] > 0):\n                if (j >= a and j >= b):\n                    count = count + (min(j - b, 25 - j + a + 1)) * cnt[j]\n                elif (j <= a and j <= b):\n                    count = count + (min(a - j, 25 + j - b + 1)) * cnt[j]\n        res = min(res, count)\n    for i in range(26 - K + 1, 27, 1):\n        a = i\n        b = (i + K) % 26\n        count = 0\n        for j in range(1, 27, 1):\n            if (cnt[j] > 0):\n                if (j >= b and j <= a):\n                    count = count + (min(j - b, a - j)) * cnt[j]\n        res = min(res, count)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"abcdefghi\"\n    K = 2\n    print(minCost(str1, K))\n",
        "output": "12\n",
        "fn_call": "minCost"
    },
    {
        "text": "sum of areas of rectangles possible for an array | function to find area of rectangles ; sorting the array in descending order ; store the final sum of all the rectangles area possible ; temporary variable to store the length of rectangle ; selecting the length of rectangle so that difference between any two number is 1 only . here length is selected so flag is set ; flag is set means we have got length of rectangle ; length is set to a [ i + 1 ] so that if a [ i + 1 ] is less than a [ i ] by 1 then also we have the correct chice for length ; incrementing the counter one time more as we have considered a [ i + 1 ] element also so . ; selecting the width of rectangle so that difference between any two number is 1 only . here width is selected so now flag is again unset for next rectangle ; area is calculated for rectangle ; flag is set false for another rectangle which we can get from elements in array ; incrementing the counter one time more as we have considered a [ i + 1 ] element also so . ; ",
        "context": "",
        "code": "def MaxTotalRectangleArea(a, n):\n    a .sort(reverse=True)\n    sum = 0\n    flag = False\n    len = 0\n    i = 0\n    while (i < n - 1):\n        if (i != 0):\n            i = i + 1\n        if ((a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and flag == False):\n            flag = True\n            len = a[i + 1]\n            i = i + 1\n        elif ((a[i] == a[i + 1] or a[i] - a[i + 1] == 1) and flag):\n            sum = sum + a[i + 1] * len\n            flag = False\n            i = i + 1\n    return sum\n",
        "test": "\na = [10, 10, 10, 10, 11, 10, 11, 10, 9, 9, 8, 8]\nn = len(a)\nprint(MaxTotalRectangleArea(a, n))\n",
        "output": "282\n",
        "fn_call": "MaxTotalRectangleArea"
    },
    {
        "text": "program to find nth term of series 2 , 12 , 28 , 50 , 77 , 112 , 152 , 198 , ... . . | calculate nth term of series ; ",
        "context": "",
        "code": "def nthTerm(n):\n    return 3 * pow(n, 2) + n - 2\n",
        "test": "\nN = 4\nprint(nthTerm(N))\n",
        "output": "50\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "find the sum of the first n centered decagonal numbers | function to find the n - th centred decagonal number ; formula to calculate nth centered_decagonal number & return it into main function . ; function to find the sum of the first n centered decagonal numbers ; variable to store the sum ; iterating through the range ; ",
        "context": "",
        "code": "def Centered_decagonal_num(n):\n    return (5 * n * n - 5 * n + 1)\n\n\ndef sum_Centered_decagonal_num(n):\n    summ = 0\n    for i in range(1, n + 1):\n        summ += Centered_decagonal_num(i)\n    return summ\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    print(sum_Centered_decagonal_num(n))\n",
        "output": "205\n",
        "fn_call": "sum_Centered_decagonal_num"
    },
    {
        "text": "number of elements with even factors in the given range | function to count the perfect squares ; ",
        "context": "",
        "code": "def countOddSquares(n, m):\n    return (int(pow(m, 0.5)) - int(pow(n - 1, 0.5)))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    m = 100\n    print(\"Count is\", (m - n + 1) - countOddSquares(n, m))\n",
        "output": "Count is 88\n",
        "fn_call": "countOddSquares"
    },
    {
        "text": "count rotations divisible by 4 | returns count of all rotations divisible by 4 ; for single digit number ; at - least 2 digit number ( considering all pairs ) ; considering the number formed by the pair of last digit and 1 st digit ; ",
        "context": "",
        "code": "def countRotations(n):\n    l = len(n)\n    if (l == 1):\n        oneDigit = (int)(n[0])\n        if (oneDigit % 4 == 0):\n            return 1\n        return 0\n    count = 0\n    for i in range(0, l - 1):\n        twoDigit = (int)(n[i]) * 10 + (int)(n[i + 1])\n        if (twoDigit % 4 == 0):\n            count = count + 1\n    twoDigit = (int)(n[l - 1]) * 10 + (int)(n[0])\n    if (twoDigit % 4 == 0):\n        count = count + 1\n    return count\n",
        "test": "\nn = \"4834\"\nprint(\"Rotations: \", countRotations(n))\n",
        "output": "Rotations:  2\n",
        "fn_call": "countRotations"
    },
    {
        "text": "count of array elements greater than or equal to twice the median of k trailing array elements | python3 program to implement the above approach ; function to find the count of array elements >= twice the median of k trailing array elements ; stores frequencies ; stores the array elements ; count the frequencies of the array elements ; iterating from d to n - 1 index means ( d + 1 ) th element to nth element ; to check the median ; iterate over the frequencies of the elements ; add the frequencies ; check if the low_median value is obtained or not , if yes then do not change as it will be minimum ; check if the high_median value is obtained or not , if yes then do not change it as it will be maximum ; store 2 * median of k trailing elements ; if the current >= 2 * median ; decrease the frequency for ( k - 1 ) - th element ; increase the frequency of the current element ; print the count ; ",
        "context": "\nimport math\nN = 200000\nV = 500\n\n",
        "code": "def solve(n, d, input1):\n    a = [0] * N\n    cnt = [0] * (V + 1)\n    for i in range(n):\n        a[i] = input1[i]\n    answer = 0\n    for i in range(d):\n        cnt[a[i]] += 1\n    for i in range(d, n):\n        acc = 0\n        low_median = -1\n        high_median = -1\n        for v in range(V + 1):\n            acc += cnt[v]\n            if (low_median == -1 and acc >= int(math .floor((d + 1) / 2.0))):\n                low_median = v\n            if (high_median == -1 and acc >= int(math .ceil((d + 1) / 2.0))):\n                high_median = v\n        double_median = low_median + high_median\n        if (a[i] >= double_median):\n            answer += 1\n        cnt[a[i - d]] -= 1\n        cnt[a[i]] += 1\n    print(answer)\n",
        "test": "\nif __name__ == \"__main__\":\n    input1 = [1, 2, 2, 4, 5]\n    n = len(input1)\n    k = 3\n    solve(n, k, input1)\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "maximum possible score that can be obtained by constructing a binary tree based on given conditions | function to find the maximum score for one possible tree having n nodes n - 1 edges ; number of nodes ; initialize dp [ ] [ ] ; score with 0 vertices is 0 ; traverse the nodes from 1 to n ; find maximum scores for each sum ; iterate over degree of new node ; update the current state ; return maximum score for n node tree having 2 ( n - 1 ) sum of degree ; ",
        "context": "",
        "code": "def maxScore(arr):\n    N = len(arr)\n    N += 1\n    dp = [[-100000 for i in range(2 * N)]for i in range(N + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for s in range(1, 2 * (N - 1) + 1):\n            j = 1\n            while j <= N - 1 and j <= s:\n                dp[i][s] = max(dp[i][s], arr[j - 1] + dp[i - 1][s - j])\n                j += 1\n    return dp[N][2 * (N - 1)]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 0]\n    print(maxScore(arr))\n",
        "output": "8\n",
        "fn_call": "maxScore"
    },
    {
        "text": "count of fibonacci divisors of a given number | python3 program to count number of divisors of n which are fibonacci numbers ; function to create hash table to check fibonacci numbers ; function to count number of divisors of n which are fibonacci numbers ; if divisors are equal , check and count only one ; otherwise check and count both ; ",
        "context": "\nfrom math import sqrt, ceil, floor\n\n",
        "code": "def createHash(maxElement):\n    prev = 0\n    curr = 1\n    d = dict()\n    d[prev] = 1\n    d[curr] = 1\n    while (curr <= maxElement):\n        temp = curr + prev\n        d[temp] = 1\n        prev = curr\n        curr = temp\n    return d\n\n\ndef countFibonacciDivisors(n):\n    hash = createHash(n)\n    cnt = 0\n    for i in range(1, ceil(sqrt(n))):\n        if (n % i == 0):\n            if ((n // i == i) and (n // i in hash)):\n                cnt += 1\n            else:\n                if (n // i in hash):\n                    cnt += 1\n                if (n // (n // i) in hash):\n                    cnt += 1\n    return cnt\n",
        "test": "\nn = 12\nprint(countFibonacciDivisors(n))\n",
        "output": "3\n",
        "fn_call": "countFibonacciDivisors"
    },
    {
        "text": "program to check strength of password | python3 program to check if a given password is strong or not . ; checking lower alphabet in string ; strength of password ; ",
        "context": "",
        "code": "def printStrongNess(input_string):\n    n = len(input_string)\n    hasLower = False\n    hasUpper = False\n    hasDigit = False\n    specialChar = False\n    normalChars = \"abcdefghijklmnopqrstu\"\n    for i in range(n):\n        if input_string[i].islower():\n            hasLower = True\n        if input_string[i].isupper():\n            hasUpper = True\n        if input_string[i].isdigit():\n            hasDigit = True\n        if input_string[i]not in normalChars:\n            specialChar = True\n    print(\"Strength of password:-\", end=\"\")\n    if (hasLower and hasUpper and hasDigit and specialChar and n >= 8):\n        print(\"Strong\")\n    elif ((hasLower or hasUpper) and specialChar and n >= 6):\n        print(\"Moderate\")\n    else:\n        print(\"Weak\")\n",
        "test": "\nif __name__ == \"__main__\":\n    input_string = \"GeeksforGeeks!@12\"\n    printStrongNess(input_string)\n",
        "output": "Strength of password:-Strong\n",
        "fn_call": "printStrongNess"
    },
    {
        "text": "angle subtended by an arc at the centre of a circle | function to find angle subtended by an arc at the centre of a circle ; ",
        "context": "",
        "code": "def angle(n):\n    return 2 * n\n",
        "test": "\nn = 30\nprint(angle(n))\n",
        "output": "60\n",
        "fn_call": "angle"
    },
    {
        "text": "find the nearest perfect square for each element of the array | function to find the nearest perfect square for every element in the given array import the math module ; traverse the array ; calculate square root of current element ; calculate perfect square ; find the nearest ; ",
        "context": "\nimport math\n\n",
        "code": "def nearestPerfectSquare(arr, N):\n    for i in range(0, N):\n        sr = math .floor(math .sqrt(arr[i]))\n        a = sr * sr\n        b = (sr + 1) * (sr + 1)\n        if ((arr[i] - a) < (b - arr[i])):\n            print(a, end=\" \")\n        else:\n            print(b, end=\" \")\n",
        "test": "\narr = [5, 2, 7, 13]\nN = len(arr)\nnearestPerfectSquare(arr, N)\n",
        "output": "4 1 9 16 ",
        "fn_call": "nearestPerfectSquare"
    },
    {
        "text": "how to validate pan card number using regular expression | python3 program to validate the pan card number using regular expression ; function to validate the pan card number . ; regex to check valid pan card number ; compile the regex ; if the pan card number is empty return false ; return if the pan card number matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidPanCardNo(panCardNo):\n    regex = \"[A-Z]{5}[0-9]{4}[A-Z]{1}\"\n    p = re .compile(regex)\n    if (panCardNo is None):\n        return False\n    if (re .search(p, panCardNo) and len(panCardNo) == 10):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"BNZAA2318J\"\nprint(isValidPanCardNo(str1))\nstr2 = \"23ZAABN18J\"\nprint(isValidPanCardNo(str2))\nstr3 = \"BNZAA2318JM\"\nprint(isValidPanCardNo(str3))\nstr4 = \"BNZAA23184\"\nprint(isValidPanCardNo(str4))\nstr5 = \"BNZAA 23184\"\nprint(isValidPanCardNo(str5))\n",
        "output": "True\nFalse\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidPanCardNo"
    },
    {
        "text": "sum of sides of largest and smallest child polygons possible from a given polygon | function to find the sum of largest and smallest secondary polygons if possible ; count edges of primary polygon ; calculate edges present in the largest secondary polygon ; ",
        "context": "",
        "code": "def secondary_polygon(Angle):\n    edges_primary = 360 // Angle\n    if edges_primary >= 6:\n        edges_max_secondary = edges_primary // 2\n        return edges_max_secondary + 3\n    else:\n        return \"Not Possible\"\n",
        "test": "\nif __name__ == '__main__':\n    Angle = 45\n    print(secondary_polygon(Angle))\n",
        "output": "7\n",
        "fn_call": "secondary_polygon"
    },
    {
        "text": "check if two given strings are isomorphic to each other | python program to check if two strings are isomorphic ; this function returns true if str1 and str2 are isomorphic ; length of both strings must be same for one to one corresponance ; to mark visited characters in str2 ; to store mapping of every character from str1 to that of str2 . initialize all entries of map as - 1 ; process all characters one by one ; if current character of str1 is seen first time in it . ; if current character of st2 is already seen , one to one mapping not possible ; mark current character of str2 as visited ; store mapping of current characters ; if this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; ",
        "context": "\nMAX_CHARS = 256\n\n",
        "code": "def areIsomorphic(string1, string2):\n    m = len(string1)\n    n = len(string2)\n    if m != n:\n        return False\n    marked = [False] * MAX_CHARS\n    map = [-1] * MAX_CHARS\n    for i in range(n):\n        if map[ord(string1[i])] == -1:\n            if marked[ord(string2[i])]:\n                return False\n            marked[ord(string2[i])] = True\n            map[ord(string1[i])] = string2[i]\n        elif map[ord(string1[i])] != string2[i]:\n            return False\n    return True\n",
        "test": "\nprint(areIsomorphic(\"aab\", \"xxy\"))\nprint(areIsomorphic(\"aab\", \"xyz\"))\n",
        "output": "True\nFalse\n",
        "fn_call": "areIsomorphic"
    },
    {
        "text": "p | python 3 program to check if a number is a p - smooth number or not ; function to check if number n is a p - smooth number or not ; prime factorise it by 2 ; if the number is divisible by 2 ; check for all the possible numbers that can divide it ; prime factorize it by i ; stores the maximum if maximum and i , if i divides the number ; if n at the end is a prime number , then it a divisor itself ; ",
        "context": "\nimport math\n\n",
        "code": "def check(n, p):\n    maximum = -1\n    while (not (n % 2)):\n        maximum = max(maximum, 2)\n        n = int(n / 2)\n    for i in range(3, int(math .sqrt(n)), 2):\n        while (n % i == 0):\n            maximum = max(maximum, i)\n            n = int(n / i)\n    if (n > 2):\n        maximum = max(maximum, n)\n    return (maximum <= p)\n",
        "test": "\nn = 24\np = 7\nif (check(n, p)):\n    print(\"yes\")\nelse:\n    print(\"no\")\n",
        "output": "yes\n",
        "fn_call": "check"
    },
    {
        "text": "lucky numbers | returns 1 if n is a lucky number otherwise returns 0 ; function attribute will act as static variable just for readability , can be removed and used n instead ; calculate next position of input number ; ",
        "context": "",
        "code": "def isLucky(n):\n    next_position = n\n    if isLucky .counter > n:\n        return 1\n    if n % isLucky .counter == 0:\n        return 0\n    next_position = next_position - next_position / isLucky .counter\n    isLucky .counter = isLucky .counter + 1\n    return isLucky(next_position)\n",
        "test": "\nisLucky .counter = 2\nx = 5\nif isLucky(x):\n    print(x, \"is a Lucky number\")\nelse:\n    print(x, \"is not a Lucky number\")\n",
        "output": "5 is a Lucky number\n",
        "fn_call": "isLucky"
    },
    {
        "text": "longest palindromic string possible after removal of a substring | function to find the longest palindrome from the start of the string using kmp match ; append s ( reverse of c ) to c ; use kmp algorithm ; function to return longest palindromic string possible from the given string after removal of any substring ; initialize three strings a , b and f ; loop to find longest substrings from both ends which are reverse of each other ; proceed to third step of our approach ; remove the substrings a and b ; find the longest palindromic substring from beginning of c ; find the longest palindromic substring from end of c ; store the maximum of d and e in f ; find the final answer ; ",
        "context": "",
        "code": "def findPalindrome(C):\n    S = C[::-1]\n    C = C[:] + '&' + S\n    n = len(C)\n    longestPalindrome = [0 for i in range(n)]\n    longestPalindrome[0] = 0\n    ll = 0\n    i = 1\n    while (i < n):\n        if (C[i] == C[ll]):\n            ll += 1\n            longestPalindrome[i] = ll\n            i += 1\n        else:\n            if (ll != 0):\n                ll = longestPalindrome[ll - 1]\n            else:\n                longestPalindrome[i] = 0\n                i += 1\n    ans = C[0:longestPalindrome[n - 1]]\n    return ans\n\n\ndef findAns(s):\n    A = \"\"\n    B = \"\"\n    F = \"\"\n    i = 0\n    j = len(s) - 1\n    ll = len(s)\n    while (i < j and s[i] == s[j]):\n        i = i + 1\n        j = j - 1\n    if (i > 0):\n        A = s[0:i]\n        B = s[ll - i:ll]\n    if (ll > 2 * i):\n        C = s[i:i + (len(s) - 2 * i)]\n        D = findPalindrome(C)\n        C = C[::-1]\n        E = findPalindrome(C)\n        if (len(D) > len(E)):\n            F = D\n        else:\n            F = E\n    answer = A + F + B\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"abcdefghiedcba\"\n    print(findAns(str))\n",
        "output": "abcdeiedcba\n",
        "fn_call": "findAns"
    },
    {
        "text": "minimum operations required to change the array such that | arr [ i ] | python3 implementation of the approach ; function to return the minimum number of operations required ; minimum and maximum elements from the array ; to store the minimum number of operations required ; to store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; if current element is not already num ; add the count of operations required to change arr [ i ] ; update the minimum operations so far ; ",
        "context": "\nimport math\nimport sys\n\n",
        "code": "def changeTheArray(arr, n):\n    minEle = min(arr)\n    maxEle = max(arr)\n    minOperations = sys .maxsize\n    for num in range(minEle, maxEle + 1):\n        operations = 0\n        for i in range(n):\n            if arr[i] != num:\n                operations += (abs(num - arr[i]) - 1)\n        minOperations = min(minOperations, operations)\n    return minOperations\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 1, 4]\n    n = len(arr)\n    print(changeTheArray(arr, n))\n",
        "output": "7\n",
        "fn_call": "changeTheArray"
    },
    {
        "text": "positive elements at even and negative at odd positions ( relative order not maintained ) | print array function ; ",
        "context": "",
        "code": "def printArray(a, n):\n    for i in a:\n        print(i, end=\" \")\n    print()\n",
        "test": "\narr = [1, -3, 5, 6, -3, 6, 7, -4, 9, 10]\nn = len(arr)\nprintArray(arr, n)\nfor i in range(n):\n    if (arr[i] >= 0 and i % 2 == 1):\n        for j in range(i + 1, n):\n            if (arr[j] < 0 and j % 2 == 0):\n                arr[i], arr[j] = arr[j], arr[i]\n                break\n    elif (arr[i] < 0 and i % 2 == 0):\n        for j in range(i + 1, n):\n            if (arr[j] >= 0 and j % 2 == 1):\n                arr[i], arr[j] = arr[j], arr[i]\n                break\nprintArray(arr, n)\n",
        "output": "1 -3 5 6 -3 6 7 -4 9 10 \n1 -3 5 -3 6 6 7 -4 9 10 \n",
        "fn_call": "printArray"
    },
    {
        "text": "smallest greater elements in whole array | simple python3 program to find smallest greater element in whole array for every element . ; find the closest greater element for arr [ j ] in the entire array . ; check if arr [ i ] is largest ; ",
        "context": "",
        "code": "def smallestGreater(arr, n):\n    for i in range(0, n):\n        diff = 1000\n        closest = -1\n        for j in range(0, n):\n            if (arr[i] < arr[j] and arr[j] - arr[i] < diff):\n                diff = arr[j] - arr[i]\n                closest = j\n        if (closest == -1):\n            print(\"_ \", end=\"\")\n        else:\n            print(\"{} \".format(arr[closest]), end=\"\")\n",
        "test": "\nar = [6, 3, 9, 8, 10, 2, 1, 15, 7]\nn = len(ar)\nsmallestGreater(ar, n)\n",
        "output": "7 6 10 9 15 3 2 _ 8 ",
        "fn_call": "smallestGreater"
    },
    {
        "text": "longest common subsequence ( lcs ) by repeatedly swapping characters of a string with characters of another string | function to find the length of lcs possible by swapping any character of a with that of another string ; store the size of the strings ; stores frequency of characters ; iterate over characters of the a ; update frequency of character a [ i ] ; iterate over characters of the b ; update frequency of character b [ i ] ; store the count of all pairs of similar characters ; traverse the array freq [ ] ; update cnt ; print the minimum of cnt , n and m ; ",
        "context": "",
        "code": "def lcsBySwapping(A, B):\n    N = len(A)\n    M = len(B)\n    freq = [0] * 26\n    for i in range(len(A)):\n        freq[ord(A[i]) - ord('a')] += 1\n    for i in range(len(B)):\n        freq[ord(B[i]) - ord('a')] += 1\n    cnt = 0\n    for i in range(26):\n        cnt += freq[i] // 2\n    print(min(cnt, min(N, M)))\n",
        "test": "\nif __name__ == '__main__':\n    A = \"abdeff\"\n    B = \"abbet\"\n    lcsBySwapping(A, B)\n",
        "output": "4\n",
        "fn_call": "lcsBySwapping"
    },
    {
        "text": "circumradius of a cyclic quadrilateral using the length of sides | program to find circumradius of a cyclic quadrilateral using sides ; function to return the circumradius of a cyclic quadrilateral using sides ; find semiperimeter ; calculate the radius ; ",
        "context": "\nimport math\n\n",
        "code": "def Circumradius(a, b, c, d):\n    s = (a + b + c + d) / 2\n    radius = (1 / 4) * math .sqrt(((a * b) + (c * d)) * ((a * c) + (b * d))\n                                  * ((a * d) + (b * c)) / ((s - a) * (s - b) * (s - c) * (s - d)))\n    return radius\n",
        "test": "\nA = 3\nB = 4\nC = 5\nD = 6\nans = Circumradius(A, B, C, D)\nprint(round(ans, 2))\n",
        "output": "3.29\n",
        "fn_call": "Circumradius"
    },
    {
        "text": "number of ways to select exactly k even numbers from given array | python3 program for the above approach ; function for calculating factorial ; factorial of n defined as : n ! = n * ( n - 1 ) * ... * 1 ; function to find the number of ways to select exactly k even numbers from the given array ; count even numbers ; check if the current number is even ; check if the even numbers to be chosen is greater than n . then , there is no way to pick it . ; the number of ways will be nck ; given array arr [ ] ; ",
        "context": "\nf = [0] * 12\n\n",
        "code": "def fact():\n    f[0] = f[1] = 1\n    for i in range(2, 11):\n        f[i] = i * 1 * f[i - 1]\n\n\ndef solve(arr, n, k):\n    fact()\n    even = 0\n    for i in range(n):\n        if (arr[i] % 2 == 0):\n            even += 1\n    if (k > even):\n        print(0)\n    else:\n        print(f[even] // (f[k] * f[even - k]))\n",
        "test": "\narr = [1, 2, 3, 4]\nn = len(arr)\nk = 1\nsolve(arr, n, k)\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "sort string of characters | python 3 program to sort a string of characters ; function to print string in sorted order ; hash array to keep count of characters . initially count of all charters is initialized to zero . ; traverse string and increment count of characters ; ' a ' - ' a ' will be 0 , ' b ' - ' a ' will be 1 , so for location of character in count array we wil do str [ i ] - ' a ' . ; traverse the hash array and print characters ; ",
        "context": "\nMAX_CHAR = 26\n\n",
        "code": "def sortString(str):\n    charCount = [0 for i in range(MAX_CHAR)]\n    for i in range(0, len(str), 1):\n        charCount[ord(str[i]) - ord('a')] += 1\n    for i in range(0, MAX_CHAR, 1):\n        for j in range(0, charCount[i], 1):\n            print(chr(ord('a') + i), end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    s = \"geeksforgeeks\"\n    sortString(s)\n",
        "output": "eeeefggkkorss",
        "fn_call": "sortString"
    },
    {
        "text": "number of trailing zeroes in base b representation of n ! | python 3 program to find the number of trailing zeroes in base b representation of n ! ; to find the power of a prime p in factorial n ; calculating floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of b ; returns largest power of b that divides n ! ; calculating minimum power of all the prime factors of b ; ",
        "context": "\nimport sys\n\n",
        "code": "def findPowerOfP(N, p):\n    count = 0\n    r = p\n    while (r <= N):\n        count += int(N / r)\n        r = r * p\n\n    return count\n\n\ndef primeFactorsofB(B):\n    ans = []\n    i = 2\n\n    while (B != 1):\n        if (B % i == 0):\n            count = 0\n            while (B % i == 0):\n\n                B = int(B / i)\n                count += 1\n\n            ans.append((i, count))\n\n        i += 1\n\n    return ans\n\n\ndef largestPowerOfB(N, B):\n    vec = []\n    vec = primeFactorsofB(B)\n    ans = sys.maxsize\n    ans = min(ans, int(findPowerOfP(N, vec[0][0]) /\n                       vec[0][1]))\n\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    print(largestPowerOfB(5, 2))\n    print(largestPowerOfB(6, 9))\n",
        "output": "3\n1\n",
        "fn_call": "largestPowerOfB"
    },
    {
        "text": "maximize sum of topmost elements of s stacks by popping at most n elements | python3 program to maximize the sum of top of the stack values of s stacks by popping at most n element ; function for computing the maximum sum at the top of the stacks after popping at most n elements from s stack ; constructing a dp matrix of dimensions ( s + 1 ) x ( n + 1 ) ; loop over all i stacks ; store the maximum of popping j elements up to the current stack by popping k elements from current stack and j - k elements from all previous stacks combined ; store the maximum sum of popping n elements across all stacks ; dp [ s ] [ n ] has the maximum sum ; ",
        "context": "\nimport sys\n\n",
        "code": "def maximumSum(S, M, N, stacks):\n    dp = [[0 for x in range(N + 1)]for y in range(S + 1)]\n    for i in range(S):\n        for j in range(N + 1):\n            for k in range(min(j, M) + 1):\n                dp[i + 1][j] = max(dp[i + 1][j], stacks[i][k] + dp[i][j - k])\n    result = -sys .maxsize - 1\n    for i in range(N + 1):\n        result = max(result, dp[S][i])\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    S = 2\n    M = 4\n    stacks = [[2, 6, 4, 5], [1, 6, 15, 10]]\n    N = 3\n    print(maximumSum(S, M, N, stacks))\n",
        "output": "21\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "check if two numbers are bit rotations of each other or not | function to check if two numbers are equal after bit rotation ; x64 has concatenation of x with itself . ; comapring only last 32 bits ; right shift by 1 unit ; ",
        "context": "",
        "code": "def isRotation(x, y):\n    x64 = x | (x << 32)\n    while (x64 >= y):\n        if ((x64) == y):\n            return True\n        x64 >>= 1\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 122\n    y = 2147483678\n    if (isRotation(x, y) == False):\n        print(\"yes\")\n    else:\n        print(\"no\")\n",
        "output": "yes\n",
        "fn_call": "isRotation"
    },
    {
        "text": "print the frequency of each character in alphabetical order | python3 implementation of the approach ; function to print the frequency of each of the characters of s in alphabetical order ; to store the frequency of the characters ; update the frequency array ; print the frequency in alphatecial order ; if the current alphabet doesn 't  appear in the string ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def compressString(s, n):\n    freq = [0] * MAX\n    for i in range(n):\n        freq[ord(s[i]) - ord('a')] += 1\n    for i in range(MAX):\n        if (freq[i] == 0):\n            continue\n        print((chr)(i + ord('a')), freq[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"geeksforgeeks\"\n    n = len(s)\n    compressString(s, n)\n",
        "output": "e 4 f 1 g 2 k 2 o 1 r 1 s 2 ",
        "fn_call": "compressString"
    },
    {
        "text": "find the last remaining element after repeated removal of an element from pairs of increasing adjacent array elements | function to print the last remaining array element after after performing given operations ; if size of the array is 1 ; check for the condition ; if condition is not satisfied ; ",
        "context": "",
        "code": "def canArrayBeReduced(arr, N):\n    if (N == 1):\n        print(arr[0])\n        return\n    if (arr[0] < arr[N - 1]):\n        print(arr[N - 1])\n    else:\n        print(\"Not Possible\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 5, 2, 4, 1, 3, 7]\n    N = len(arr)\n    canArrayBeReduced(arr, N)\n",
        "output": "7\n",
        "fn_call": "canArrayBeReduced"
    },
    {
        "text": "find largest factor of n such that n / f is less than k | function to find the largest factor of n which is less than or equal to k ; initialise the variable to store the largest factor of n <= k ; loop to find all factors of n ; check if j is a factor of n or not ; check if j <= k if yes , then store the larger value between ans and j in ans ; check if n / j <= k if yes , then store the larger value between ans and j in ans ; since max value is always stored in ans , the maximum value divisible by n less than or equal to k will be returned . ; ",
        "context": "",
        "code": "def solve(n, k):\n    ans = 0\n    for j in range(1, n + 1):\n        if (j * j > n):\n            break\n        if (n % j == 0):\n            if (j <= k):\n                ans = max(ans, j)\n            if (n // j <= k):\n                ans = max(ans, n // j)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 8\n    K = 7\n    print((N // solve(N, K)))\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "count subarrays with sum equal to its xor value | function to count the number of subarrays such that xor of all the elements of that subarray is equal to sum of the elements ; maintain two pointers left and right ; iterating through the array ; calculate the window where the above condition is satisfied ; count will be ( right - left ) ; remove the previous element as it is already included ; ",
        "context": "",
        "code": "def operation(arr, N):\n    right = 0\n    ans = 0\n    num = 0\n    for left in range(0, N):\n        while (right < N and num + arr[right] == (num ^ arr[right])):\n            num += arr[right]\n            right += 1\n        ans += right - left\n        if (left == right):\n            right += 1\n        else:\n            num -= arr[left]\n    return ans\n",
        "test": "\narr = [1, 2, 3, 4, 5]\nN = len(arr)\nprint(operation(arr, N))\n",
        "output": "7\n",
        "fn_call": "operation"
    },
    {
        "text": "dynamic convex hull | adding points to an existing convex hull | python 3 program to add given a point p to a given convext hull . the program assumes that the point of given convext hull are in anti - clockwise order . ; checks whether the point crosses the convex hull or not ; returns the square of distance between two input points ; checks whether the point is inside the convex hull or not ; initialize the centroid of the convex hull ; multiplying with n to avoid floating point arithmetic . ; if the mid and the given point lies always on the same side w . r . t every edge of the convex hull , then the point lies inside the convex hull ; adds a point p to given convex hull a [ ] ; if point is inside p ; point having minimum distance from the point p ; find the upper tangent ; find the lower tangent ; initialize result ; making the final hull by traversing points from up to low of given convex hull . ; modify the original vector ; ",
        "context": "\nimport copy\n\n",
        "code": "def orientation(a, b, c):\n    res = ((b[1] - a[1]) * (c[0] - b[0]) - (c[1] - b[1]) * (b[0] - a[0]))\n    if (res == 0):\n        return 0\n    if (res > 0):\n        return 1\n    return -1\n\n\ndef sqDist(p1, p2):\n    return ((p1[0] - p2[0]) * (p1[0] - p2[0]) +\n            (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\n\ndef inside(a, p):\n    mid = [0, 0]\n    n = len(a)\n    p[0] *= n\n    p[1] *= n\n    for i in range(n):\n        mid[0] += a[i][0]\n        mid[1] += a[i][1]\n        a[i][0] *= n\n        a[i][1] *= n\n    for i in range(n):\n        j = (i + 1) % n\n        x1 = a[i][0]\n        x2 = a[j][0]\n        y1 = a[i][1]\n        y2 = a[j][1]\n        a1 = y1 - y2\n        b1 = x2 - x1\n        c1 = x1 * y2 - y1 * x2\n        for_mid = a1 * mid[0] + b1 * mid[1] + c1\n        for_p = a1 * p[0] + b1 * p[1] + c1\n        if (for_mid * for_p < 0):\n            return False\n    return True\n\n\ndef addPoint(a, p):\n    arr = copy .deepcopy(a)\n    prr = p .copy()\n    if (inside(arr, prr)):\n        return\n    ind = 0\n    n = len(a)\n    for i in range(1, n):\n        if (sqDist(p, a[i]) < sqDist(p, a[ind])):\n            ind = i\n    up = ind\n    while (orientation(p, a[up], a[(up + 1) % n]) >= 0):\n        up = (up + 1) % n\n    low = ind\n    while (orientation(p, a[low], a[(n + low - 1) % n]) <= 0):\n        low = (n + low - 1) % n\n    ret = []\n    curr = up\n    ret .append(a[curr])\n    while (curr != low):\n        curr = (curr + 1) % n\n        ret .append(a[curr])\n    ret .append(p)\n    a .clear()\n    for i in range(len(ret)):\n        a .append(ret[i])\n",
        "test": "\nif __name__ == \"__main__\":\n    a = []\n    a .append([0, 0])\n    a .append([3, -1])\n    a .append([4, 5])\n    a .append([-1, 4])\n    n = len(a)\n    p = [100, 100]\n    addPoint(a, p)\n    for e in a:\n        print(\"(\", e[0], \", \", e[1], \") \", end=\" \")\n",
        "output": "( -1 ,  4 )  ( 0 ,  0 )  ( 3 ,  -1 )  ( 100 ,  100 )  ",
        "fn_call": "addPoint"
    },
    {
        "text": "check in binary array the number represented by a subarray is odd or even | prints if subarray is even or odd ; if arr [ r ] = 1 print odd ; if arr [ r ] = 0 print even ; ",
        "context": "",
        "code": "def checkEVENodd(arr, n, l, r):\n    if (arr[r] == 1):\n        print(\"odd\")\n    else:\n        print(\"even\")\n",
        "test": "\narr = [1, 1, 0, 1]\nn = len(arr)\ncheckEVENodd(arr, n, 1, 3)\n",
        "output": "odd\n",
        "fn_call": "checkEVENodd"
    },
    {
        "text": "minimize cost to sort a string in increasing order of frequencies of characters | python3 program to implement the above approach ; for a single character ; stores count of repetitions of a character ; if repeating character ; otherwise ; store frequency ; reset count ; insert the last character block ; sort the frequencies ; stores the minimum cost of all operations ; store the absolute difference of i - th frequencies of ordered and unordered sequences ; return the minimum cost ; ",
        "context": "",
        "code": "def sortString(S):\n    sorted1 = []\n    original = []\n    insert = False\n    if (len(S) == 1):\n        print(0)\n    curr = 1\n    for i in range(len(S) - 1):\n        if (S[i] == S[i + 1]):\n            curr += 1\n            insert = False\n        else:\n            sorted1 .append(curr)\n            original .append(curr)\n            curr = 1\n            insert = True\n    if ((S[(len(S) - 1)] != S[(len(S) - 2)]) or insert == False):\n        sorted1 .append(curr)\n        original .append(curr)\n    sorted1 .sort()\n    t_cost = 0\n    for i in range(len(sorted1)):\n        t_cost += abs(sorted1[i] - original[i])\n    return (t_cost // 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"aabbcccdeffffggghhhhhii\"\n    print(sortString(S))\n",
        "output": "5\n",
        "fn_call": "sortString"
    },
    {
        "text": "minimum number of fibonacci jumps to reach end | a dynamic programming based python3 program to find minimum number of jumps to reach destination ; function that returns the min number of jump to reach the destination ; we consider only those fibonacci numbers which are less than n , where we can consider fib [ 30 ] to be the upper bound as this will cross 10 ^ 5 ; dp [ i ] will be storing the minimum number of jumps required for the position i . so dp [ n + 1 ] will have the result we consider 0 as source and n + 1 as the destination ; base case ( steps to reach source is ) ; initialize all table values as infinite ; go through each positions till destination . ; calculate the minimum of that position if all the fibonacci numbers are considered ; if the position is safe or the position is the destination then only we calculate the minimum otherwise the cost is max as default ; - 1 denotes if there is no path possible ; ",
        "context": "\nMAX = 1e9\n\n",
        "code": "def minJumps(arr, N):\n    fib = [0 for i in range(30)]\n    fib[0] = 0\n    fib[1] = 1\n    for i in range(2, 30):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    DP = [0 for i in range(N + 2)]\n    DP[0] = 0\n    for i in range(1, N + 2):\n        DP[i] = MAX\n    for i in range(1, N + 2):\n        for j in range(1, 30):\n            if ((arr[i - 1] == 1 or i == N + 1) and i - fib[j] >= 0):\n                DP[i] = min(DP[i], 1 + DP[i - fib[j]])\n    if (DP[N + 1] != MAX):\n        return DP[N + 1]\n    else:\n        return -1\n",
        "test": "\narr = [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]\nn = len(arr)\nprint(minJumps(arr, n - 1))\n",
        "output": "3\n",
        "fn_call": "minJumps"
    },
    {
        "text": "unbounded knapsack ( repetition of items allowed ) | returns the maximum value with knapsack of w capacity ; dp [ i ] is going to store maximum value with knapsack capacity i . ; fill dp [ ] using above recursive formula ; ",
        "context": "",
        "code": "def unboundedKnapsack(W, n, val, wt):\n    dp = [0 for i in range(W + 1)]\n    ans = 0\n    for i in range(W + 1):\n        for j in range(n):\n            if (wt[j] <= i):\n                dp[i] = max(dp[i], dp[i - wt[j]] + val[j])\n    return dp[W]\n",
        "test": "\nW = 100\nval = [10, 30, 20]\nwt = [5, 10, 15]\nn = len(val)\nprint(unboundedKnapsack(W, n, val, wt))\n",
        "output": "300\n",
        "fn_call": "unboundedKnapsack"
    },
    {
        "text": "subsequence of size k with maximum possible gcd | python 3 program to find subsequence of size k with maximum possible gcd . ; function to find gcd of sub sequence of size k with max gcd in the array ; computing highest element ; array to store the count of divisors i . e . potential gcds ; iterating over every element ; calculating all the divisors ; divisor found ; incrementing count for divisor ; element / divisor is also a divisor checking if both divisors are not same ; checking the highest potential gcd ; if this divisor can divide at least k numbers , it is a gcd of at least one sub sequence of size k ; ",
        "context": "\nimport math\n\n",
        "code": "def findMaxGCD(arr, n, k):\n    high = max(arr)\n    divisors = [0] * (high + 1)\n    for i in range(n):\n        for j in range(1, int(math .sqrt(arr[i])) + 1):\n            if (arr[i] % j == 0):\n                divisors[j] += 1\n                if (j != arr[i] // j):\n                    divisors[arr[i] // j] += 1\n    for i in range(high, 0, -1):\n        if (divisors[i] >= k):\n            return i\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 4, 8, 8, 12]\n    k = 3\n    n = len(arr)\n    print(findMaxGCD(arr, n, k))\n",
        "output": "4\n",
        "fn_call": "findMaxGCD"
    },
    {
        "text": "smallest subarray containing minimum and maximum values | python3 implementation of above approach ; function to return length of smallest subarray containing both maximum and minimum value ; find maximum and minimum values in the array ; iterate over the array and set answer to smallest difference between position of maximum and position of minimum value ; last occurrence of minvalue ; last occurrence of maxvalue ; ",
        "context": "\nimport sys\n\n",
        "code": "def minSubarray(A, n):\n    minValue = min(A)\n    maxValue = max(A)\n    pos_min, pos_max, ans = -1, -1, sys .maxsize\n    for i in range(0, n):\n        if A[i] == minValue:\n            pos_min = i\n        if A[i] == maxValue:\n            pos_max = i\n        if pos_max != -1 and pos_min != -1:\n            ans = min(ans, abs(pos_min - pos_max) + 1)\n    return ans\n",
        "test": "\nA = [1, 5, 9, 7, 1, 9, 4]\nn = len(A)\nprint(minSubarray(A, n))\n",
        "output": "2\n",
        "fn_call": "minSubarray"
    },
    {
        "text": "minimum volume of cone that can be circumscribed about a sphere of radius r | python3 program to find the minimum volume of the cone that can be circumscribed about a sphere of radius r ; function to find the volume of the cone ; r = radius of cone h = height of cone volume of cone = ( 1 / 3 ) * ( 3.14 ) * ( r * * 2 ) * ( h ) we get radius of cone from the derivation is root ( 2 ) times multiple of r we get height of cone from the derivation is 4 times multiple of r ; ",
        "context": "\nimport math\n\n",
        "code": "def Volume_of_cone(R):\n    V = (1 / 3) * (3.14) * (2 * (R ** 2)) * (4 * R)\n    return V\n",
        "test": "\nif __name__ == \"__main__\":\n    R = 10\n    print(Volume_of_cone(R))\n",
        "output": "8373.333333333332\n",
        "fn_call": "Volume_of_cone"
    },
    {
        "text": "count of subarrays having exactly k prime numbers | python3 program for the above approach ; a utility function to check if the number n is prime or not ; base cases ; check to skip middle five numbers in below loop ; if n is divisible by i & i + 2 then it is not prime ; function to find number of subarrays with sum exactly equal to k ; stl map to store number of subarrays starting from index zero having particular value of sum . ; to store the sum of element traverse so far ; add current element to currsum ; if currsum = k , then a new subarray is found ; if currsum > k then find the no . of subarrays with sum currsum - k and exclude those subarrays ; add currsum to count of different values of sum ; return the final result ; function to count the subarray with k primes ; update the array element ; if current element is prime then update the arr [ i ] to 1 ; else change arr [ i ] to 0 ; function call ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    for i in range(5, int(sqrt(n)) + 1, 6):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n    return True\n\n\ndef findSubarraySum(arr, n, K):\n    prevSum = {i: 0 for i in range(100)}\n    res = 0\n    currsum = 0\n    for i in range(n):\n        currsum += arr[i]\n        if (currsum == K):\n            res += 1\n        if (currsum - K) in prevSum:\n            res += (prevSum[currsum - K])\n        prevSum[currsum] += 1\n    return res\n\n\ndef countSubarray(arr, n, K):\n    for i in range(n):\n        if (isPrime(arr[i])):\n            arr[i] = 1\n        else:\n            arr[i] = 0\n    print(findSubarraySum(arr, n, K))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    K = 2\n    N = len(arr)\n    countSubarray(arr, N, K)\n",
        "output": "4\n",
        "fn_call": "countSubarray"
    },
    {
        "text": "count of ways to distribute n items among 3 people with one person receiving maximum | function to find the number of ways to distribute n items among 3 people ; no distribution possible ; total number of ways to distribute n items among 3 people ; store the number of distributions which are not possible ; count possibilities of two persons receiving the maximum ; if n is divisible by 3 ; return the final count of ways to distribute ; ",
        "context": "",
        "code": "def countWays(N):\n    if (N < 4):\n        return 0\n    ans = ((N - 1) * (N - 2)) // 2\n    s = 0\n    for i in range(2, N - 2, 1):\n        for j in range(1, i, 1):\n            if (N == 2 * i + j):\n                s += 1\n    if (N % 3 == 0):\n        s = 3 * s + 1\n    else:\n        s = 3 * s\n    return ans - s\n",
        "test": "\nN = 10\nprint(countWays(N))\n",
        "output": "33\n",
        "fn_call": "countWays"
    },
    {
        "text": "ways to express a number as product of two different factors | to count number of ways in which number expressed as product of two different numbers ; to store count of such pairs ; counting number of pairs upto sqrt ( n ) - 1 ; to return count of pairs ; ",
        "context": "",
        "code": "def countWays(n):\n    count = 0\n    i = 1\n    while ((i * i) < n):\n        if (n % i == 0):\n            count += 1\n        i += 1\n    return count\n",
        "test": "\nn = 12\nprint(countWays(n))\n",
        "output": "3\n",
        "fn_call": "countWays"
    },
    {
        "text": "check if an array element is concatenation of two elements from another array | python3 program for the above approach ; function to find elements present in the array b [ ] which are concatenation of any pair of elements in the array a [ ] ; stores if there doesn 't any such  element in the array brr[] ; stored the size of both the arrays ; store the presence of an element of array a [ ] ; traverse the array a [ ] ; traverse the array b [ ] ; traverse over all possible concatenations of b [ i ] ; update right and left parts ; check if both left and right parts are present in a [ ] ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def findConcatenatedNumbers(a, b):\n    ans = True\n    n1 = len(a)\n    n2 = len(b)\n    cnt = defaultdict(int)\n    for i in range(n1):\n        cnt[a[i]] = 1\n    for i in range(n2):\n        left = b[i]\n        right = 0\n        mul = 1\n        while (left > 9):\n            right += (left % 10) * mul\n            left //= 10\n            mul *= 10\n            if (cnt[left] == 1 and cnt[right] == 1):\n                ans = False\n                print(b[i], end=\" \")\n    if (ans):\n        print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 34, 4, 5]\n    b = [26, 24, 345, 4, 22]\n    findConcatenatedNumbers(a, b)\n",
        "output": "24 345 22 ",
        "fn_call": "findConcatenatedNumbers"
    },
    {
        "text": "minimum flip required to make binary matrix symmetric | python3 code to find minimum flip required to make binary matrix symmetric along main diagonal ; return the minimum flip required to make binary matrix symmetric along main diagonal . ; comparing elements across diagonal ; ",
        "context": "\nN = 3\n\n",
        "code": "def minimumflip(mat, n):\n    flip = 0\n    for i in range(n):\n        for j in range(i):\n            if mat[i][j] != mat[j][i]:\n                flip += 1\n    return flip\n",
        "test": "\nn = 3\nmat = [[0, 0, 1], [1, 1, 1], [1, 0, 0]]\nprint(minimumflip(mat, n))\n",
        "output": "2\n",
        "fn_call": "minimumflip"
    },
    {
        "text": "minimize remaining array element by repeatedly replacing pairs by half of one more than their sum | function to print smallest element left in the array and the pairs by given operation ; stores array elements and return the minimum element of arr [ ] in o ( 1 ) ; stores all the pairs that can be selected by the given operations ; traverse the array arr [ ] ; traverse pq while count of elements left in pq greater than 1 ; stores top element of pq ; pop top element of pq ; stores top element of pq ; pop top element of pq ; insert ( x + y + 1 ) / 2 in pq ; insert the pair ( x , y ) in pairsarr [ ] ; print element left in pq by performing the given operations ; stores count of elements in pairsarr [ ] ; print the pairs that can be selected in given operations ; if i is the first index of pairsarr [ ] ; print pairs of pairsarr [ ] ; if i is not the last index of pairsarr [ ] ; if i is the last index of pairsarr [ ] ; ",
        "context": "",
        "code": "def smallestNumberLeftInPQ(arr, N):\n    pq = []\n    pairsArr = []\n    for i in range(N):\n        pq .append(arr[i])\n    pq = sorted(pq)\n    while (len(pq) > 1):\n        X = pq[-1]\n        del pq[-1]\n        Y = pq[-1]\n        del pq[-1]\n        pq .append((X + Y + 1) // 2)\n        pairsArr .append([X, Y])\n        pq = sorted(pq)\n    print(\"{\", pq[-1], \"}, \", end=\"\")\n    sz = len(pairsArr)\n    for i in range(sz):\n        if (i == 0):\n            print(\"{ \", end=\"\")\n        print(\"(\", pairsArr[i][0], \",\", pairsArr[i][1], \")\", end=\"\")\n        if (i != sz - 1):\n            print(end=\", \")\n        if (i == sz - 1):\n            print(end=\" }\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 2, 1]\n    N = len(arr)\n    smallestNumberLeftInPQ(arr, N)\n",
        "output": "{ 2 }, { ( 3 , 2 ), ( 3 , 1 ) }",
        "fn_call": "smallestNumberLeftInPQ"
    },
    {
        "text": "count numbers whose maximum sum of distinct digit | function to find the digit - sum of a number ; loop to iterate the number digit - wise to find digit - sum ; variable to store last digit ; function to find the count of number ; vector to store the sum of digits ; sum of digits for each element in vector ; sorting the digitsum vector ; removing the duplicate elements ; count variable to store the count ; finding the count of numbers ; ",
        "context": "",
        "code": "def SumofDigits(digit):\n    sum = 0\n    while (digit != 0):\n        rem = digit % 10\n        sum += rem\n        digit //= 10\n    return sum\n\n\ndef findCountofNumbers(arr, n, M):\n    SumDigits = []\n    for i in range(n):\n        s = SumofDigits(arr[i])\n        SumDigits .append(s)\n    SumDigits .sort()\n    ip = list(set(SumDigits))\n    count = 0\n    sum = 0\n    for i in range(len(SumDigits)):\n        if (sum > M):\n            break\n        sum += SumDigits[i]\n        if (sum <= M):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 45, 16, 17, 219, 32, 22]\n    M = 10\n    n = len(arr)\n    print(findCountofNumbers(arr, n, M))\n",
        "output": "3\n",
        "fn_call": "findCountofNumbers"
    },
    {
        "text": "maximizing unique pairs from two arrays | returns count of maximum pairs that caan be formed from a [ ] and b [ ] under given constraints . ; sorting the first array . ; sorting the second array . ; increasing array pointer of both the first and the second array . ; increasing array pointer of the second array . ; ",
        "context": "",
        "code": "def findMaxPairs(a, b, n, k):\n    a .sort()\n    b .sort()\n    result = 0\n    j = 0\n    for i in range(n):\n        if j < n:\n            if abs(a[i] - b[j]) <= k:\n                result += 1\n                j += 1\n            elif a[i] > b[j]:\n                j += 1\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    a = [10, 15, 20]\n    b = [17, 12, 24]\n    n = len(a)\n    k = 3\n    print(findMaxPairs(a, b, n, k))\n",
        "output": "2\n",
        "fn_call": "findMaxPairs"
    },
    {
        "text": "check whether a given string is heterogram or not | python3 code to check whether the given string is heterogram or not . ; traversing the string . ; ignore the space ; if already encountered ; else return false . ; ",
        "context": "",
        "code": "def isHeterogram(s, n):\n    hash = [0] * 26\n    for i in range(n):\n        if s[i] != ' ':\n            if hash[ord(s[i]) - ord('a')] == 0:\n                hash[ord(s[i]) - ord('a')] = 1\n            else:\n                return False\n    return True\n",
        "test": "\ns = \"the big dwarf only jumps\"\nn = len(s)\nprint(\"YES\"if isHeterogram(s, n)else \"NO\")\n",
        "output": "YES\n",
        "fn_call": "isHeterogram"
    },
    {
        "text": "count of arrays in which all adjacent elements are such that one of them divide the another | python3 program to count the number of arrays of size n such that every element is in range [ 1 , m ] and adjacent are divisible ; for storing factors . ; for storing multiples . ; calculating the factors and multiples of elements [ 1. . . m ] . ; initialising for size 1 array for each i <= m . ; calculating the number of array possible of size i and starting with j . ; for all previous possible values . adding number of factors . ; adding number of multiple . ; calculating the total count of array which start from [ 1. . . m ] . ; ",
        "context": "\nMAX = 1000\n\n",
        "code": "def numofArray(n, m):\n    dp = [[0 for i in range(MAX)]for j in range(MAX)]\n    di = [[]for i in range(MAX)]\n    mu = [[]for i in range(MAX)]\n    for i in range(1, m + 1):\n        for j in range(2 * i, m + 1, i):\n            di[j].append(i)\n            mu[i].append(j)\n        di[i].append(i)\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = 0\n            for x in di[j]:\n                dp[i][j] += dp[i - 1][x]\n            for x in mu[j]:\n                dp[i][j] += dp[i - 1][x]\n    ans = 0\n    for i in range(1, m + 1):\n        ans += dp[n][i]\n        di[i].clear()\n        mu[i].clear()\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = m = 3\n    print(numofArray(n, m))\n",
        "output": "17\n",
        "fn_call": "numofArray"
    },
    {
        "text": "find a pair in array with second largest product | function to find second largest product pair in arr [ 0. . n - 1 ] ; no pair exits ; initialize max product pair ; traverse through every possible pair and keep track of largest product ; if pair is largest ; second largest ; if pair dose not largest but larger then second largest ; print the pairs ; ",
        "context": "",
        "code": "def maxProduct(arr, N):\n    if (N < 3):\n        return\n    a = arr[0]\n    b = arr[1]\n    c = 0\n    d = 0\n    for i in range(0, N, 1):\n        for j in range(i + 1, N - 1, 1):\n            if (arr[i] * arr[j] > a * b):\n                c = a\n                d = b\n                a = arr[i]\n                b = arr[j]\n            if (arr[i] * arr[j]  c * d):\n                c = arr[i]\n            d = arr[j]\n    print(c, \" \", d)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 2, 67, 45, 160, 78]\n    N = len(arr)\n    maxProduct(arr, N)\n",
        "output": "67   160\n",
        "fn_call": "maxProduct"
    },
    {
        "text": "nth root of a number using log | python3 implementation to find the kth root of a number using log ; function to find the kth root of the number using log function ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def kthRoot(n, k):\n    return pow(k, ((1.0 / k) * (np .log(n) / np .log(k))))\n",
        "test": "\nn = 81\nk = 4\nprint(\"%.6f\" % kthRoot(n, k))\n",
        "output": "3.000000\n",
        "fn_call": "kthRoot"
    },
    {
        "text": "sum of bitwise and of the sum of all leaf and non | structure of a binary tree node ; helper function to allocate a new node with the given data and left and right pointers as none ; function to calculate the sum of bitwise and of the sum of all leaf nodes and non - leaf nodes for each level ; initialize a queue and append root to it ; store the required answer ; stores the sum of leaf nodes at the current level ; stores the sum of non - leaf nodes at the current level ; get the size of the queue ; iterate for all the nodes in the queue currently ; dequeue a node from queue ; check if the node is a leaf node ; if true , update the leaf node sum ; otherwise , update the non - leaf node sum ; enqueue left and right children of removed node ; update the answer ; return the answer ; ",
        "context": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self .val = val\n        self .left = left\n        self .right = right\n\n",
        "code": "def findSum(root):\n    que = [root]\n    ans = 0\n    while (len(que)):\n        leaf = 0\n        nonleaf = 0\n        length = len(que)\n        while length:\n            temp = que .pop(0)\n            if not temp .left and not temp .right:\n                leaf += temp .val\n            else:\n                nonleaf += temp .val\n            if temp .left:\n                que .append(temp .left)\n            if temp .right:\n                que .append(temp .right)\n            length -= 1\n        ans += leaf & nonleaf\n    return ans\n",
        "test": "\nroot = TreeNode(5)\nroot .left = TreeNode(3)\nroot .right = TreeNode(9)\nroot .left .left = TreeNode(6)\nroot .left .right = TreeNode(4)\nroot .left .left .right = TreeNode(7)\nprint(findSum(root))\n",
        "output": "5\n",
        "fn_call": "findSum"
    },
    {
        "text": "program for first fit algorithm in memory management | function to allocate memory to blocks as per first fit algorithm ; stores block id of the block allocated to a process ; pick each process and find suitable blocks according to its size ad assign to it ; allocate block j to p [ i ] process ; reduce available memory in this block . ; ",
        "context": "",
        "code": "def firstFit(blockSize, m, processSize, n):\n    allocation = [-1] * n\n    for i in range(n):\n        for j in range(m):\n            if blockSize[j] >= processSize[i]:\n                allocation[i] = j\n                blockSize[j] -= processSize[i]\n                break\n    print(\" Process No. Process Size Block no.\")\n    for i in range(n):\n        print(\" \", i + 1, \" \", processSize[i], \" \", end=\" \")\n        if allocation[i] != -1:\n            print(allocation[i] + 1)\n        else:\n            print(\"Not Allocated\")\n",
        "test": "\nif __name__ == '__main__':\n    blockSize = [100, 500, 200, 300, 600]\n    processSize = [212, 417, 112, 426]\n    m = len(blockSize)\n    n = len(processSize)\n    firstFit(blockSize, m, processSize, n)\n",
        "output": " Process No. Process Size Block no.\n  1   212   2\n  2   417   5\n  3   112   2\n  4   426   Not Allocated\n",
        "fn_call": "firstFit"
    },
    {
        "text": "check if a number is bleak | an efficient python 3 program to check bleak number ; function to get no of set bits in binary representation of passed binary no . ; a function to return ceiling of log x in base 2. for example , it returns 3 for 8 and 4 for 9. ; returns true if n is bleak ; check for all numbers ' x ' smaller than n . if x + countsetbits ( x ) becomes n , then n can 't be bleak ; ",
        "context": "\nimport math\n\n",
        "code": "def countSetBits(x):\n    count = 0\n    while (x):\n        x = x & (x - 1)\n        count = count + 1\n    return count\n\n\ndef ceilLog2(x):\n    count = 0\n    x = x - 1\n    while (x > 0):\n        x = x >> 1\n        count = count + 1\n    return count\n\n\ndef isBleak(n):\n    for x in range((n - ceilLog2(n)), n):\n        if (x + countSetBits(x) == n):\n            return False\n    return True\n",
        "test": "\nif (isBleak(3)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\nif (isBleak(4)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\nYes\n",
        "fn_call": "isBleak"
    },
    {
        "text": "set the k | function to set the kth bit ; kth bit of n is being set by this operation ; ",
        "context": "",
        "code": "def setKthBit(n, k):\n    return ((1 << k) | n)\n",
        "test": "\nn = 10\nk = 2\nprint(\"Kth bit set number = \", setKthBit(n, k))\n",
        "output": "Kth bit set number =  14\n",
        "fn_call": "setKthBit"
    },
    {
        "text": "pythagorean triplet with given sum using single loop | function to calculate the pythagorean triplet in o ( n ) ; iterate a from 1 to n - 1. ; calculate value of b ; the value of c = n - a - b ; ",
        "context": "",
        "code": "def PythagoreanTriplet(n):\n    flag = 0\n    for a in range(1, n, 1):\n        b = (n * n - 2 * n * a) // (2 * n - 2 * a)\n        c = n - a - b\n        if (a * a + b * b == c * c and b > 0 and c > 0):\n            print(a, b, c)\n            flag = 1\n            break\n    if (flag == 0):\n        print(\"-1\")\n    return\n",
        "test": "\nif __name__ == '__main__':\n    N = 12\n    PythagoreanTriplet(N)\n",
        "output": "3 4 5\n",
        "fn_call": "PythagoreanTriplet"
    },
    {
        "text": "check if frequency of all characters can become same by one removal | python3 program to get same frequency character string by removal of at most one char ; utility method to get index of character ch in lower alphabet characters ; returns true if all non - zero elements values are same ; get first non - zero element ; check equality of each element with variable same ; returns true if we can make all character frequencies same ; fill frequency array ; if all frequencies are same , then return true ; try decreasing frequency of all character by one and then check all equality of all non - zero frequencies ; check character only if it occurs in str ; ",
        "context": "\nM = 26\n\n",
        "code": "def getIdx(ch):\n    return (ord(ch) - ord('a'))\n\n\ndef allSame(freq, N):\n    for i in range(0, N):\n        if (freq[i] > 0):\n            same = freq[i]\n            break\n    for j in range(i + 1, N):\n        if (freq[j] > 0 and freq[j] != same):\n            return False\n    return True\n\n\ndef possibleSameCharFreqByOneRemoval(str1):\n    l = len(str1)\n    freq = [0] * M\n    for i in range(0, l):\n        freq[getIdx(str1[i])] += 1\n    if (allSame(freq, M)):\n        return True\n    for i in range(0, 26):\n        if (freq[i] > 0):\n            freq[i] -= 1\n            if (allSame(freq, M)):\n                return True\n            freq[i] += 1\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    str1 = \"xyyzz\"\n    if (possibleSameCharFreqByOneRemoval(str1)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "possibleSameCharFreqByOneRemoval"
    },
    {
        "text": "length of second longest sequence of consecutive 1 s in a binary array | ''function to find maximum and second maximum length ; '' initialise maximum length ; '' initialise second maximum length ; '' initialise count ; '' iterate over the array ; '' if sequence ends ; '' reset count ; '' otherwise ; '' increase length  of current sequence ; '' update maximum ; '' traverse the given array ; '' if sequence continues ; '' increase length  of current sequence ; '' update second max ; '' reset count when 0 is found ; '' print the result ; ''",
        "context": "",
        "code": "def FindMax(arr, N):\n    maxi = -1\n    maxi2 = -1\n    count = 0\n    for i in range(N):\n        if (arr[i] == 0):\n            count = 0\n        else:\n            count += 1\n            maxi = max(maxi, count)\n    for i in range(N):\n        if (arr[i] == 1):\n            count += 1\n            if (count > maxi2 and count < maxi):\n                maxi2 = count\n        if (arr[i] == 0):\n            count = 0\n    maxi = max(maxi, 0)\n    maxi2 = max(maxi2, 0)\n    print(maxi2)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 1, 0, 0, 1, 1]\n    N = len(arr)\n    FindMax(arr, N)\n",
        "output": "2\n",
        "fn_call": "FindMax"
    },
    {
        "text": "sum of fourth power of first n even natural numbers | calculate the sum of fourth power of first n even natural numbers ; ",
        "context": "",
        "code": "def evenPowerSum(n):\n    return (8 * n * (n + 1) * (2 * n + 1) * (3 * n * n + 3 * n - 1)) / 15\n",
        "test": "\nn = 4\nprint(int(evenPowerSum(n)))\n",
        "output": "5664\n",
        "fn_call": "evenPowerSum"
    },
    {
        "text": "check if a given string is a comment or not | function to check if the given string is a comment or not ; if two continuous slashes preceeds the comment ; ",
        "context": "",
        "code": "def isComment(line):\n    if (line[0] == '/' and line[1] == '/' and line[2] != '/'):\n        print(\"It is a single-line comment\")\n        return\n    if (line[len(line) - 2] == '*' and line[len(line) - 1]\n            == '/' and line[0] == '/' and line[1] == '*'):\n        print(\"It is a multi-line comment\")\n        return\n    print(\"It is not a comment\")\n",
        "test": "\nif __name__ == '__main__':\n    line = \"GeeksForGeeks GeeksForGeeks\"\n    isComment(line)\n",
        "output": "It is not a comment\n",
        "fn_call": "isComment"
    },
    {
        "text": "how to validate ifsc code using regular expression | python3 program to validate ifsc ( indian financial system ) code using regular expression ; function to validate ifsc ( indian financial system ) code using regular expression . ; regex to check valid ifsc code . ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidIFSCode(str):\n    regex = \"^[A-Z]{4}0[A-Z0-9]{6}$\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"SBIN0125620\"\nprint(isValidIFSCode(str1))\nstr2 = \"SBIN0125\"\nprint(isValidIFSCode(str2))\nstr3 = \"1234SBIN012\"\nprint(isValidIFSCode(str3))\nstr4 = \"SBIN7125620\"\nprint(isValidIFSCode(str4))\n",
        "output": "True\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidIFSCode"
    },
    {
        "text": "recursive program to print multiplication table of a number | function that print the table of a ",
        "context": "",
        "code": "def mul_table(N, i):\n    if (i > 10):\n        return\n    print(N, \"*\", i, \"=\", N * i)\n    return mul_table(N, i + 1)\n",
        "test": "\nN = 8\nmul_table(N, 1)\n",
        "output": "8 * 1 = 8\n8 * 2 = 16\n8 * 3 = 24\n8 * 4 = 32\n8 * 5 = 40\n8 * 6 = 48\n8 * 7 = 56\n8 * 8 = 64\n8 * 9 = 72\n8 * 10 = 80\n",
        "fn_call": "mul_table"
    },
    {
        "text": "super niven numbers | checks if sums of all subsets of digits array divides the number n ; to calculate length of array arr ; there are totoal 2 ^ n subsets ; consider all numbers from 0 to 2 ^ n - 1 ; consider binary representation of current i to decide which elements to pick . ; check sum of picked elements . ; function to check if a number is a super - niven number ; to store digits of n ; ",
        "context": "",
        "code": "def isDivBySubsetSums(arr, num):\n    n = len(arr)\n    total = 1 << n\n    i = 0\n    while i < total:\n        sum = 0\n        j = 0\n        while j < n:\n            if (i & (1 << j)):\n                sum += arr[j]\n            j += 1\n        if (sum != 0) and (num % sum != 0):\n            return False\n        i += 1\n    return True\n\n\ndef isSuperNivenNum(n):\n    temp = n\n    digits = []\n    while (n > 1):\n        digit = int(n) % 10\n        digits .append(digit)\n        n = n / 10\n    return isDivBySubsetSums(digits, temp)\n",
        "test": "\nif __name__ == '__main__':\n    n = 500\n    if isSuperNivenNum(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isSuperNivenNum"
    },
    {
        "text": "queries to find the count of vowels in the substrings of the given string | python3 implementation of the approach ; function that returns true if ch is a vowel ; function to return the count of vowels in the substring str [ l ... r ] ; to store the count of vowels ; for every character in the index range [ l , r ] ; if the current character is a vowel ; for every query ; find the count of vowels for the current query ; ",
        "context": "\nN = 2\n\n",
        "code": "def isVowel(ch):\n    return (ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u')\n\n\ndef countVowels(string, l, r):\n    cnt = 0\n    for i in range(l, r + 1):\n        if (isVowel(string[i])):\n            cnt += 1\n    return cnt\n\n\ndef performQueries(string, queries, q):\n    for i in range(q):\n        print(countVowels(string, queries[i][0], queries[i][1]))\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    queries = [[1, 3], [2, 4], [1, 9]]\n    q = len(queries)\n    performQueries(string, queries, q)\n",
        "output": "2\n1\n4\n",
        "fn_call": "performQueries"
    },
    {
        "text": "number of pairs whose sum is a power of 2 | function to return the count of valid pairs ; storing occurrences of each element ; sort the array in deceasing order ; start taking largest element each time ; if element has already been paired ; find the number which is greater than a [ i ] and power of two ; if there is a number which adds up with a [ i ] to form a power of two ; edge case when a [ i ] and crr - a [ i ] is same and we have only one occurrence of a [ i ] then it cannot be paired ; remove already paired elements ; return the count ; ",
        "context": "",
        "code": "def countPairs(a, n):\n    mp = dict .fromkeys(a, 0)\n    for i in range(n):\n        mp[a[i]] += 1\n    a .sort(reverse=True)\n    count = 0\n    for i in range(n):\n        if (mp[a[i]] < 1):\n            continue\n        cur = 1\n        while (cur <= a[i]):\n            cur = cur << 1\n        if (cur - a[i] in mp .keys()):\n            if (cur - a[i] == a[i] and mp[a[i]] == 1):\n                continue\n            count += 1\n            mp[cur - a[i]] -= 1\n            mp[a[i]] -= 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [3, 11, 14, 5, 13]\n    n = len(a)\n    print(countPairs(a, n))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "find the largest contiguous pair sum in given array | python3 program to find the a contiguous pair from the which has the largest sum ; function to find and return the largest sum contiguous pair ; stores the contiguous pair ; initialize maximum sum ; compare sum of pair with max_sum ; insert the pair ; ",
        "context": "\nimport sys\n\n",
        "code": "def largestSumpair(arr, n):\n    pair = []\n    max_sum = -sys .maxsize - 1\n    for i in range(1, n):\n        if max_sum < (arr[i] + arr[i - 1]):\n            max_sum = arr[i] + arr[i - 1]\n            if pair == []:\n                pair .append(arr[i - 1])\n                pair .append(arr[i])\n            else:\n                pair[0] = arr[i - 1]\n                pair[1] = arr[i]\n    return pair\n",
        "test": "\narr = [11, -5, 9, -3, 2]\nN = len(arr)\npair = largestSumpair(arr, N)\nprint(pair[0], end=\" \")\nprint(pair[1], end=\" \")\n",
        "output": "11 -5 ",
        "fn_call": "largestSumpair"
    },
    {
        "text": "minimum number that can be obtained by applying ' + ' and ' * ' operations on array elements | function to find the smallest number that can be obtained after applying the arithmetic operations mentioned in the string s ; stores the count of multiplication operator in the string ; store the required result ; iterate in the range to create the mask ; checking the number of bits that are set in the mask ; check if the number of bits that are set in the mask is multiplication operation ; storing the elements that is to be added ; apply the multiplications operation first ; if sign is ' * ' , then multiply last element of deque with arr [ i ] ; append last multiplied element in the deque ; if the element is to be added , then add it to the deque ; add all the element of the deque ; minimize the answer with the given sum ; ",
        "context": "",
        "code": "def minimumSum(A, N, S):\n    mul = 0\n    for i in range(len(S)):\n        if (S[i] == \"*\"):\n            mul += 1\n    ans = 1000000\n    for i in range(1 << (N - 1)):\n        cnt = 0\n        v = []\n        for j in range(N - 1):\n            if ((1 << j) & i):\n                cnt += 1\n                v .append(\"*\")\n            else:\n                v .append(\"+\")\n        if (cnt == mul):\n            d = []\n            d .append(A[0])\n            for j in range(N - 1):\n                if (v[j] == \"*\"):\n                    x = d[len(d) - 1]\n                    d .pop()\n                    x = x * A[j + 1]\n                    d .append(x)\n                else:\n                    d .append(A[j + 1])\n            sum = 0\n            while (len(d) > 0):\n                x = d[0]\n                sum += x\n                d .pop(0)\n            ans = min(ans, sum)\n    return ans\n",
        "test": "\nA = [2, 2, 2, 2]\nS = \"**+\"\nN = len(A)\nprint(minimumSum(A, N, S))\n",
        "output": "8\n",
        "fn_call": "minimumSum"
    },
    {
        "text": "program to check if n is a dodecagonal number | python3 program for the above approach ; function to check if number n is a dodecagonal number or not ; condition to check if the n is a dodecagonal number ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def isdodecagonal(N):\n    n = (4 + np .sqrt(20 * N + 16)) / 10\n    return (n - int(n)) == 0\n",
        "test": "\nN = 12\nif (isdodecagonal(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isdodecagonal"
    },
    {
        "text": "count number of pairs ( i , j ) up to n that can be made equal on multiplying with a pair from the range [ 1 , n / 2 ] | function to compute totient of all numbers smaller than or equal to n ; iterate over the range [ 2 , n ] ; if phi [ p ] is not computed already then p is prime ; phi of a prime number p is ( p - 1 ) ; update phi values of all multiples of p ; add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; function to count the pairs ( i , j ) from the range [ 1 , n ] , satisfying the given condition ; stores the counts of first and second type of pairs respectively ; count of first type of pairs ; stores the phi or totient values ; calculate the phi values ; iterate over the range [ n / 2 + 1 , n ] ; update the value of cnt_type2 ; print the total count ; ",
        "context": "",
        "code": "def computeTotient(N, phi):\n    for p in range(2, N + 1):\n        if phi[p] == p:\n            phi[p] = p - 1\n            for i in range(2 * p, N + 1, p):\n                phi[i] = (phi[i] // p) * (p - 1)\n\n\ndef countPairs(N):\n    cnt_type1 = 0\n    cnt_type2 = 0\n    half_N = N // 2\n    cnt_type1 = (half_N * (half_N - 1)) // 2\n    phi = [0 for i in range(N + 1)]\n    for i in range(1, N + 1):\n        phi[i] = i\n    computeTotient(N, phi)\n    for i in range((N // 2) + 1, N + 1):\n        cnt_type2 += (i - phi[i] - 1)\n    print(cnt_type1 + cnt_type2)\n",
        "test": "\nif __name__ == '__main__':\n    N = 6\n    countPairs(N)\n",
        "output": "7\n",
        "fn_call": "countPairs"
    },
    {
        "text": "find if an array contains a string with one mismatch | python 3 program to find if given string is present with one mismatch . ; if the array is empty ; if sizes are same ; if first mismatch ; second mismatch ; ",
        "context": "",
        "code": "def check(list, s):\n    n = len(list)\n    if (n == 0):\n        return False\n    for i in range(0, n, 1):\n        if (len(list[i]) != len(s)):\n            continue\n        diff = False\n        for j in range(0, len(list[i]), 1):\n            if (list[i][j] != s[j]):\n                if (diff == False):\n                    diff = True\n                else:\n                    diff = False\n                    break\n        if (diff):\n            return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    s = []\n    s .append(\"bana\")\n    s .append(\"apple\")\n    s .append(\"banacb\")\n    s .append(\"bonanza\")\n    s .append(\"banamf\")\n    print(int(check(s, \"banana\")))\n",
        "output": "0\n",
        "fn_call": "check"
    },
    {
        "text": "check if the bracket sequence can be balanced with at most one change in the position of a bracket | function that returns true if the sequence can be balanced by changing the position of at most one bracket ; odd length string can never be balanced ; add ' ( ' in the beginning and ' ) ' in the end of the string ; if its an opening bracket then append it to the temp string ; if its a closing bracket ; there was an opening bracket to match it with ; no opening bracket to match it with ; sequence is balanced ; ",
        "context": "",
        "code": "def canBeBalanced(s, n):\n    if n % 2 == 1:\n        return False\n    k = \"(\"\n    k = k + s + \")\"\n    d = []\n    count = 0\n    for i in range(len(k)):\n        if k[i] == \"(\":\n            d .append(\"(\")\n        else:\n            if len(d) != 0:\n                d .pop()\n            else:\n                return False\n    if len(d) == 0:\n        return True\n    return False\n",
        "test": "\nS = \")(()\"\nn = len(S)\nif (canBeBalanced(S, n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canBeBalanced"
    },
    {
        "text": "maximum subarray sum possible by replacing an array element by its square | function to find the maximum subarray sum possible ; stores sum without squaring ; stores sum squaring ; stores the maximum subarray sum ; either extend the subarray or start a new subarray ; either extend previous squared subarray or start a new subarray by squaring the current element ; update maximum subarray sum ; return answer ; ",
        "context": "",
        "code": "def getMaxSum(a, n):\n    dp = [[0 for x in range(2)]for y in range(n)]\n    dp[0][0] = a[0]\n    dp[0][1] = a[0] * a[0]\n    max_sum = max(dp[0][0], dp[0][1])\n    for i in range(1, n):\n        dp[i][0] = max(a[i], dp[i - 1][0] + a[i])\n        dp[i][1] = max(dp[i - 1][1] + a[i], a[i] * a[i])\n        dp[i][1] = max(dp[i][1], dp[i - 1][0] + a[i] * a[i])\n        max_sum = max(max_sum, dp[i][1])\n        max_sum = max(max_sum, dp[i][0])\n    return max_sum\n",
        "test": "\nn = 5\na = [1, -5, 8, 12, -8]\nprint(getMaxSum(a, n))\n",
        "output": "152\n",
        "fn_call": "getMaxSum"
    },
    {
        "text": "find integers that divides maximum number of elements of the array | function to print the integers that divide the maximum number of elements from the array ; initialize two lists to store rank and factors ; start from 2 till the maximum element in arr ; initialize a variable to count the number of elements it is a factor of ; maximum rank in the rank list ; print all the elements with rank m ; ",
        "context": "",
        "code": "def maximumFactor(arr):\n    rank, factors = [], []\n    for i in range(2, max(arr) + 1):\n        count = 0\n        for j in arr:\n            if j % i == 0:\n                count += 1\n        rank .append(count)\n        factors .append(i)\n    m = max(rank)\n    for i in range(len(rank)):\n        if rank[i] == m:\n            print(factors[i], end=\" \")\n",
        "test": "\narr = [120, 15, 24, 63, 18]\nmaximumFactor(arr)\n",
        "output": "3 ",
        "fn_call": "maximumFactor"
    },
    {
        "text": "recursive sum of digits of a number formed by repeated appends | return single digit sum of a number ; returns recursive sum of digits of a number formed by repeating a number x number of times until sum become single digit . ; ",
        "context": "",
        "code": "def digSum(n):\n    if n == 0:\n        return 0\n    return (n % 9 == 0) and 9 or (n % 9)\n\n\ndef repeatedNumberSum(n, x):\n    sum = x * digSum(n)\n    return digSum(sum)\n",
        "test": "\nn = 24\nx = 3\nprint(repeatedNumberSum(n, x))\n",
        "output": "9\n",
        "fn_call": "repeatedNumberSum"
    },
    {
        "text": "create a matrix with alternating rectangles of o and x | function to pralternating rectangles of 0 and x ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; store given number of rows and columns for later use ; a 2d array to store the output to be printed ; iniitialize the character to be stoed in a [ ] [ ] ; fill characters in a [ ] [ ] in spiral form . every iteration fills one rectangle of either xs or os ; fill the first row from the remaining rows ; fill the last column from the remaining columns ; fill the last row from the remaining rows ; print the first column from the remaining columns ; flip character for next iteration ; print the filled matrix ; ",
        "context": "",
        "code": "def fill0X(m, n):\n    i, k, l = 0, 0, 0\n    r = m\n    c = n\n    a = [[None] * n for i in range(m)]\n    x = 'X'\n    while k < m and l < n:\n        for i in range(l, n):\n            a[k][i] = x\n        k += 1\n        for i in range(k, m):\n            a[i][n - 1] = x\n        n -= 1\n        if k < m:\n            for i in range(n - 1, l - 1, -1):\n                a[m - 1][i] = x\n            m -= 1\n        if l < n:\n            for i in range(m - 1, k - 1, -1):\n                a[i][l] = x\n            l += 1\n        x = 'X'if x == '0'else '0'\n    for i in range(r):\n        for j in range(c):\n            print(a[i][j], end=\" \")\n        print()\n",
        "test": "\nif __name__ == '__main__':\n    print(\"Output for m = 5, n = 6\")\n    fill0X(5, 6)\n    print(\"Output for m = 4, n = 4\")\n    fill0X(4, 4)\n    print(\"Output for m = 3, n = 4\")\n    fill0X(3, 4)\n",
        "output": "Output for m = 5, n = 6\nX X X X X X \nX 0 0 0 0 X \nX 0 X X 0 X \nX 0 0 0 0 X \nX X X X X X \nOutput for m = 4, n = 4\nX X X X \nX 0 0 X \nX 0 0 X \nX X X X \nOutput for m = 3, n = 4\nX X X X \nX 0 0 X \nX X X X \n",
        "fn_call": "fill0X"
    },
    {
        "text": "expectation or expected value of an array | function to calculate expectation ; variable prb is for probability of each element which is same for each element ; calculating expectation overall ; returning expectation as sum ; ",
        "context": "",
        "code": "def calc_Expectation(a, n):\n    prb = 1 / n\n    sum = 0\n    for i in range(0, n):\n        sum += (a[i] * prb)\n    return float(sum)\n",
        "test": "\nn = 6\na = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\nexpect = calc_Expectation(a, n)\nprint(\"Expectation of array E(X) is : \", expect)\n",
        "output": "Expectation of array E(X) is :  3.5\n",
        "fn_call": "calc_Expectation"
    },
    {
        "text": "maximum sum of bitwise xor of all elements of two equal length subsets | function that finds the maximum bitwise xor sum of the two subset ; check if the current state is already computed ; initialize answer to minimum value ; iterate through all possible pairs ; check whether ith bit and jth bit of mask is not set then pick the pair ; for all possible pairs find maximum value pick current a [ i ] , a [ j ] and set i , j th bits in mask ; store the maximum value and return the answer ; ",
        "context": "",
        "code": "def xorSum(a, n, mask, dp):\n    if (dp[mask] != -1):\n        return dp[mask]\n    max_value = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i != j and (mask & (1 << i)) == 0 and (mask & (1 << j)) == 0):\n                max_value = max(\n                    max_value,\n                    (a[i] ^ a[j]) +\n                    xorSum(\n                        a,\n                        n,\n                        (mask | (\n                            1 << i) | (\n                            1 << j)),\n                        dp))\n    dp[mask] = max_value\n    return dp[mask]\n",
        "test": "\nn = 4\narr = [1, 2, 3, 4]\ndp = [-1] * ((1 << n) + 5)\nprint(xorSum(arr, n, 0, dp))\n",
        "output": "10\n",
        "fn_call": "xorSum"
    },
    {
        "text": "minimum number of moves to reach n starting from ( 1 , 1 ) | python3 implementation of the approach ; function to return the minimum number of moves required to reach the cell containing n starting from ( 1 , 1 ) ; to store the required answer ; for all possible values of divisors ; if i is a divisor of n ; get the moves to reach n ; return the required answer ; ",
        "context": "\nimport sys\nfrom math import sqrt\n\n",
        "code": "def min_moves(n):\n    ans = sys .maxsize\n    for i in range(1, int(sqrt(n)) + 1):\n        if (n % i == 0):\n            ans = min(ans, i + n // i - 2)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10\n    print(min_moves(n))\n",
        "output": "5\n",
        "fn_call": "min_moves"
    },
    {
        "text": "find nth hermite number | python 3 program to find nth hermite number ; utility function to calculate double factorial of a number ; function to return nth hermite number ; if n is even then return 0 ; if n is odd ; calculate double factorial of ( n - 1 ) and multiply it with 2 ^ ( n / 2 ) ; if n / 2 is odd then nth hermite number will be negative ; return nth hermite number ; ",
        "context": "\nfrom math import pow\n\n",
        "code": "def doubleFactorial(n):\n    fact = 1\n    for i in range(1, n + 1, 2):\n        fact = fact * i\n    return fact\n\n\ndef hermiteNumber(n):\n    if (n % 2 == 1):\n        return 0\n    else:\n        number = ((pow(2, n / 2)) * doubleFactorial(n - 1))\n        if ((n / 2) % 2 == 1):\n            number = number * -1\n        return number\n",
        "test": "\nif __name__ == '__main__':\n    n = 6\n    print(int(hermiteNumber(n)))\n",
        "output": "-120\n",
        "fn_call": "hermiteNumber"
    },
    {
        "text": "next greater number than n with the same quantity of digits a and b | recursive function to find the required number ; if the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; function to find the number next greater number than n with the same quantity of digits a and b ; ",
        "context": "",
        "code": "def findNumUtil(res, a, aCount, b, bCount, n):\n    if (res > 1e11):\n        return 1e11\n    if (aCount == bCount and res >= n):\n        return res\n    return min(\n        findNumUtil(\n            res * 10 + a,\n            a,\n            aCount + 1,\n            b,\n            bCount,\n            n),\n        findNumUtil(\n            res * 10 + b,\n            a,\n            aCount,\n            b,\n            bCount + 1,\n            n))\n\n\ndef findNum(n, a, b):\n    result = 0\n    aCount = 0\n    bCount = 0\n    return findNumUtil(result, a, aCount, b, bCount, n)\n",
        "test": "\nif __name__ == '__main__':\n    N = 4500\n    A = 4\n    B = 7\n    print(findNum(N, A, B))\n",
        "output": "4747\n",
        "fn_call": "findNum"
    },
    {
        "text": "diameter of a binary tree | a binary tree node ; the function compute the \" height \" of a tree . height is the number of nodes along the longest path from the root node down to the farthest leaf node . ; base case : tree is empty ; if tree is not empty then height = 1 + max of left height and right heights ; function to get the diameter of a binary tree ; base case when tree is empty ; get the height of left and right sub - trees ; get the diameter of left and right sub - trees ; return max of the following tree : 1 ) diameter of left subtree 2 ) diameter of right subtree 3 ) height of left subtree + height of right subtree + 1 ; constructed binary tree is 1 / \\ 2 3 / \\ 4 5 ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def height(node):\n    if node is None:\n        return 0\n    return 1 + max(height(node .left), height(node .right))\n\n\ndef diameter(root):\n    if root is None:\n        return 0\n    lheight = height(root .left)\n    rheight = height(root .right)\n    ldiameter = diameter(root .left)\n    rdiameter = diameter(root .right)\n    return max(lheight + rheight + 1, max(ldiameter, rdiameter))\n",
        "test": "\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nroot .left .left = Node(4)\nroot .left .right = Node(5)\nprint(diameter(root))\n",
        "output": "4\n",
        "fn_call": "diameter"
    },
    {
        "text": "minimize difference between maximum and minimum array elements by removing a k | function to minimize difference between maximum and minimum array elements by removing a k - length subarray ; size of array ; stores the maximum and minimum in the suffix subarray [ i . . n - 1 ] ; traverse the array ; stores the maximum and minimum in the prefix subarray [ 0 . . i - 1 ] ; store the minimum difference ; traverse the array ; if the suffix doesn 't exceed  the end of the array ; store the maximum element in array after removing subarray of size k ; stores the maximum element in array after removing subarray of size k ; update minimum difference ; updating the maxprefix and minprefix with current element ; print the minimum difference ; ",
        "context": "",
        "code": "def minimiseDifference(arr, K):\n    N = len(arr)\n    maxSuffix = [0 for i in range(N + 1)]\n    minSuffix = [0 for i in range(N + 1)]\n    maxSuffix[N] = -1e9\n    minSuffix[N] = 1e9\n    maxSuffix[N - 1] = arr[N - 1]\n    minSuffix[N - 1] = arr[N - 1]\n    i = N - 2\n    while (i >= 0):\n        maxSuffix[i] = max(maxSuffix[i + 1], arr[i])\n        minSuffix[i] = min(minSuffix[i + 1], arr[i])\n        i -= 1\n    maxPrefix = arr[0]\n    minPrefix = arr[0]\n    minDiff = maxSuffix[K] - minSuffix[K]\n    for i in range(1, N):\n        if (i + K <= N):\n            maximum = max(maxSuffix[i + K], maxPrefix)\n            minimum = min(minSuffix[i + K], minPrefix)\n            minDiff = min(minDiff, maximum - minimum)\n        maxPrefix = max(maxPrefix, arr[i])\n        minPrefix = min(minPrefix, arr[i])\n    print(minDiff)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 5, 8, 9, 1, 2]\n    K = 2\n    minimiseDifference(arr, K)\n",
        "output": "4\n",
        "fn_call": "minimiseDifference"
    },
    {
        "text": "median of two sorted arrays with different sizes in o ( log ( min ( n , m ) ) ) | python code for median with case of returning double value when even number of elements are present in both array combinely ; def to find max ; def to find minimum ; def to find median of two sorted arrays ; if i = n , it means that elements from a [ ] in the second half is an empty set . and if j = 0 , it means that elements from b [ ] in the first half is an empty set . so it is necessary to check that , because we compare elements from these two groups . searching on right ; if i = 0 , it means that elements from a [ ] in the first half is an empty set and if j = m , it means that elements from b [ ] in the second half is an empty set . so it is necessary to check that , because we compare elements from these two groups . searching on left ; we have found the desired halves . ; this condition happens when we don 't have any elements  in the first half from a[]  so we returning the last  element in b[] from the  first half. ; and this condition happens when we don 't have any  elements in the first half  from b[] so we returning the  last element in a[] from the  first half. ; calculating the median . if number of elements is odd there is one middle element . ; elements from a [ ] in the second half is an empty set . ; elements from b [ ] in the second half is an empty set . ; ",
        "context": "\nmedian = 0\ni = 0\nj = 0\n\n",
        "code": "def maximum(a, b):\n    return a if a > b else b\n\n\ndef minimum(a, b):\n    return a if a < b else b\n\n\ndef findMedianSortedArrays(a, n, b, m):\n    global median, i, j\n    min_index = 0\n    max_index = n\n    while (min_index <= max_index):\n        i = int((min_index + max_index) / 2)\n        j = int(((n + m + 1) / 2) - i)\n        if (i  0 and b[j - 1] > a[i]):\n            min_index = i + 1\n        elif (i > 0 and j < m and b[j] < a[i - 1]):\n            max_index = i - 1\n        else:\n            if (i == 0):\n                median = b[j - 1]\n            elif (j == 0):\n                median = a[i - 1]\n            else:\n                median = maximum(a[i - 1], b[j - 1])\n            break\n    if ((n + m) % 2 == 1):\n        return median\n    if (i == n):\n        return ((median + b[j]) / 2.0)\n    if (j == m):\n        return ((median + a[i]) / 2.0)\n    return ((median + minimum(a[i], b[j])) / 2.0)\n",
        "test": "\na = [900]\nb = [10, 13, 14]\nn = len(a)\nm = len(b)\nif (n < m):\n    print(\"The median is : {}\".format(findMedianSortedArrays(a, n, b, m)))\nelse:\n    echo(\"The median is : {}\".format(findMedianSortedArrays(b, m, a, n)))\n",
        "output": "The median is : 13.5\n",
        "fn_call": "findMedianSortedArrays"
    },
    {
        "text": "count of subsequences whose product is a difference of square of two integers | function to count all the contiguous subsequences whose product is expressed as the square of the difference of two integers ; creating vectors to store the remainders and the subsequences ; iterating through the array ; finding the remainder when the element is divided by 4 ; bringing all the elements in the range [ 0 , 3 ] ; if the remainder is 2 , store the index of the ; if the remainder is 2 , store the index of the ; finding the total number of subsequences ; if there are no numbers which yield the remainder 2 ; iterating through the vector ; if the element is 2 , find the nearest 2 or 0 and find the number of elements between them ; returning the count ; ",
        "context": "",
        "code": "def CntcontSubs(a, n):\n    prod = 1\n    vect = []\n    vect .append((0, 2))\n    two, zero = [], []\n    for i in range(n):\n        a[i] = a[i] % 4\n        if (a[i] < 0):\n            a[i] = a[i] + 4\n        if (a[i] == 2):\n            two .append(i + 1)\n        if (a[i] == 0):\n            zero .append(i + 1)\n        if (a[i] == 0 or a[i] == 2):\n            vect .append((i + 1, a[i]))\n    vect .append((n + 1, 2))\n    total = (n * (n + 1)) // 2\n    if (len(two) == 0):\n        return total\n    else:\n        Sum = 0\n        pos1, pos2, pos3 = -1, -1, -1\n        sz = len(vect)\n        for i in range(1, sz - 1):\n            if (vect[i][1] == 2):\n                Sum += ((vect[i][0] - vect[i - 1][0]) *\n                        (vect[i + 1][0] - vect[i][0]) - 1)\n        return (total - Sum - len(two))\n",
        "test": "\na = [5, 4, 2, 9, 8]\nn = len(a)\nprint(CntcontSubs(a, n))\n",
        "output": "13\n",
        "fn_call": "CntcontSubs"
    },
    {
        "text": "minimum operations of given type to make all elements of a matrix equal | function to return the minimum number of operations required ; create another array to store the elements of matrix ; if not possible ; sort the array to get median ; to count the minimum operations ; if there are even elements , then there are two medians . we consider the best of two as answer . ; return minimum operations required ; ",
        "context": "",
        "code": "def minOperations(n, m, k, matrix):\n    arr = [0] * (n * m)\n    mod = matrix[0][0] % k\n    for i in range(0, n):\n        for j in range(0, m):\n            arr[i * m + j] = matrix[i][j]\n            if matrix[i][j] % k != mod:\n                return -1\n    arr .sort()\n    median = arr[(n * m) // 2]\n    minOperations = 0\n    for i in range(0, n * m):\n        minOperations += abs(arr[i] - median) // k\n    if (n * m) % 2 == 0:\n        median2 = arr[((n * m) // 2) - 1]\n        minOperations2 = 0\n        for i in range(0, n * m):\n            minOperations2 += abs(arr[i] - median2) // k\n        minOperations = min(minOperations, minOperations2)\n    return minOperations\n",
        "test": "\nif __name__ == \"__main__\":\n    matrix = [[2, 4, 6], [8, 10, 12], [14, 16, 18], [20, 22, 24]]\n    n = len(matrix)\n    m = len(matrix[0])\n    k = 2\n    print(minOperations(n, m, k, matrix))\n",
        "output": "36\n",
        "fn_call": "minOperations"
    },
    {
        "text": "pairs from an array that satisfy the given condition | function to return the number of set bits in n ; function to return the count of required pairs ; set bits for first element of the pair ; set bits for second element of the pair ; set bits of the resultant number which is the xor of both the elements of the pair ; if the condition is satisfied ; increment the count ; return the total count ; ",
        "context": "",
        "code": "def setBits(n):\n    count = 0\n    while (n):\n        n = n & (n - 1)\n        count += 1\n    return count\n\n\ndef countPairs(a, n):\n    count = 0\n    for i in range(0, n - 1, 1):\n        setbits_x = setBits(a[i])\n        for j in range(i + 1, n, 1):\n            setbits_y = setBits(a[j])\n            setbits_xor_xy = setBits(a[i] ^ a[j])\n            if (setbits_x + setbits_y == setbits_xor_xy):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    a = [2, 3, 4, 5, 6]\n    n = len(a)\n    print(countPairs(a, n))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "smallest odd number with even sum of digits from the given number n | function to find the smallest odd number whose sum of digits is even from the given string ; converting the given string to a list of digits ; an empty array to store the digits ; for loop to iterate through each digit ; if the given digit is odd then the digit is appended to the array b ; sorting the list of digits ; if the size of the list is greater than 1 then a 2 digit smallest odd number is returned since the sum of two odd digits is always even ; else , - 1 is returned ; ",
        "context": "",
        "code": "def smallest(s):\n    a = list(s)\n    b = []\n    for i in range(len(a)):\n        if (int(a[i]) % 2 != 0):\n            b .append(a[i])\n    b = sorted(b)\n    if (len(b) > 1):\n        return int(b[0]) * 10 + int(b[1])\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    print(smallest(\"15470\"))\n",
        "output": "15\n",
        "fn_call": "smallest"
    },
    {
        "text": "sum of squares of binomial coefficients | return the sum of square of binomial coefficient ; calculate value of binomial coefficient in bottom up manner ; base cases ; calculate value using previously stored values ; finding the sum of square of binomial coefficient . ; ",
        "context": "",
        "code": "def sumofsquare(n):\n    C = [[0 for i in range(n + 1)]for j in range(n + 1)]\n    for i in range(0, n + 1):\n        for j in range(0, min(i, n) + 1):\n            if (j == 0 or j == i):\n                C[i][j] = 1\n            else:\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j])\n    sum = 0\n    for i in range(0, n + 1):\n        sum = sum + (C[n][i] * C[n][i])\n    return sum\n",
        "test": "\nn = 4\nprint(sumofsquare(n), end=\"\")\n",
        "output": "70",
        "fn_call": "sumofsquare"
    },
    {
        "text": "floor square root without using sqrt ( ) function : recursive | function to find the square root of the number n using bs ; if the range is still valid ; find the mid - value of the range ; base case ; condition to check if the left search space is useless ; ",
        "context": "",
        "code": "def sqrtSearch(low, high, N):\n    if (low <= high):\n        mid = (low + high) // 2\n        if ((mid * mid  N)):\n            return mid\n        elif (mid * mid < N):\n            return sqrtSearch(mid + 1, high, N)\n        else:\n            return sqrtSearch(low, mid - 1, N)\n    return low\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 25\n    print(sqrtSearch(0, N, N))\n",
        "output": "5\n",
        "fn_call": "sqrtSearch"
    },
    {
        "text": "length of the largest subarray with contiguous elements | set 1 | utility functions to find minimum and maximum of two elements ; returns length of the longest contiguous subarray ; initialize result ; initialize min and max for all subarrays starting with i ; consider all subarrays starting with i and ending with j ; update min and max in this subarray if needed ; if current subarray has all contiguous elements ; return result ; ",
        "context": "",
        "code": "def min(x, y):\n    return x if (x < y)else y\n\n\ndef max(x, y):\n    return x if (x > y)else y\n\n\ndef findLength(arr, n):\n    max_len = 1\n    for i in range(n - 1):\n        mn = arr[i]\n        mx = arr[i]\n        for j in range(i + 1, n):\n            mn = min(mn, arr[j])\n            mx = max(mx, arr[j])\n            if ((mx - mn) == j - i):\n                max_len = max(max_len, mx - mn + 1)\n    return max_len\n",
        "test": "\narr = [1, 56, 58, 57, 90, 92, 94, 93, 91, 45]\nn = len(arr)\nprint(\"Length of the longest contiguous subarray is \", findLength(arr, n))\n",
        "output": "Length of the longest contiguous subarray is  5\n",
        "fn_call": "findLength"
    },
    {
        "text": "program to calculate volume of ellipsoid | python3 program to volume of ellipsoid ; function to calculate volume ; ",
        "context": "\nimport math\n\n",
        "code": "def volumeOfEllipsoid(r1, r2, r3):\n    return 1.33 * math .pi * r1 * r2 * r3\n",
        "test": "\nr1 = float(2.3)\nr2 = float(3.4)\nr3 = float(5.7)\nprint(\"Volume of ellipsoid is : \", volumeOfEllipsoid(r1, r2, r3))\n",
        "output": "Volume of ellipsoid is :  186.24435675167823\n",
        "fn_call": "volumeOfEllipsoid"
    },
    {
        "text": "check if the large number formed is divisible by 41 or not | check if a number is divisible by 41 or not ; array to store all the digits ; base values ; calculate remaining digits ; calculate answer ; check for divisibility ; ",
        "context": "",
        "code": "def DivisibleBy41(first, second, c, n):\n    digit = [0] * n\n    digit[0] = first\n    digit[1] = second\n    for i in range(2, n):\n        digit[i] = (digit[i - 1] * c + digit[i - 2]) % 10\n    ans = digit[0]\n    for i in range(1, n):\n        ans = (ans * 10 + digit[i]) % 41\n    if (ans % 41 == 0):\n        return True\n    else:\n        return False\n",
        "test": "\nfirst = 1\nsecond = 2\nc = 1\nn = 3\nif (DivisibleBy41(first, second, c, n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "DivisibleBy41"
    },
    {
        "text": "check if n leaves only distinct remainders on division by all values up to k | function to check and return if all remainders are distinct ; stores the remainder ; calculate the remainder ; if remainder already occurred ; insert into the set ; ",
        "context": "",
        "code": "def is_distinct(n, k):\n    s = set()\n    for i in range(1, k + 1):\n        tmp = n % i\n        if (tmp in s):\n            return False\n        s .add(tmp)\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    K = 3\n    if (is_distinct(N, K)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "is_distinct"
    },
    {
        "text": "minimum peak elements from an array by their repeated removal at every iteration of the array | python3 program for the above approach ; function to return the list of minimum peak elements ; length of original list ; initialize resultant list ; traverse each element of list ; length of original list after removing the peak element ; traverse new list after removal of previous min peak element ; update min and index , if first element of list > next element ; update min and index , if last element of list > previous one ; update min and index , if list has single element ; update min and index , if current element > adjacent elements ; remove current min peak element from list ; insert min peak into resultant list ; print resultant list ; ",
        "context": "\nimport sys\n\n",
        "code": "def minPeaks(list1):\n    n = len(list1)\n    result = []\n    for i in range(n):\n        min = sys .maxsize\n        index = -1\n        size = len(list1)\n        for j in range(size):\n            if (j == 0 and j + 1 < size):\n                if (list1[j] > list1[j + 1] and min > list1[j]):\n                    min = list1[j]\n                    index = j\n            elif (j == size - 1 and j - 1 >= 0):\n                if (list1[j] > list1[j - 1] and min > list1[j]):\n                    min = list1[j]\n                    index = j\n            elif (size == 1):\n                min = list1[j]\n                index = j\n            elif (list1[j] > list1[j - 1] and list1[j] > list1[j + 1] and min > list1[j]):\n                min = list1[j]\n                index = j\n        list1 .pop(index)\n        result .append(min)\n    print(result)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 9, 7, 8, 2, 6]\n    minPeaks(arr)\n",
        "output": "[6, 8, 9, 7, 2, 1]\n",
        "fn_call": "minPeaks"
    },
    {
        "text": "program to find number of solutions in quadratic equation | function to check for solutions of equations ; if the expression is greater than 0 , then 2 solutions ; if the expression is equal 0 , then 1 solutions ; else no solutions ; ",
        "context": "",
        "code": "def checkSolution(a, b, c):\n    if ((b * b) - (4 * a * c)) > 0:\n        print(\"2 solutions\")\n    elif ((b * b) - (4 * a * c)) == 0:\n        print(\"1 solution\")\n    else:\n        print(\"No solutions\")\n",
        "test": "\nif __name__ == \"__main__\":\n    a, b, c = 2, 5, 2\n    checkSolution(a, b, c)\n",
        "output": "2 solutions\n",
        "fn_call": "checkSolution"
    },
    {
        "text": "palindrome partitioning | dp | returns the minimum number of cuts needed to partition a string such that every part is a palindrome ; get the length of the string ; create two arrays to build the solution in bottom up manner c [ i ] [ j ] = minimum number of cuts needed for palindrome partitioning of substring str [ i . . j ] p [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false . note that c [ i ] [ j ] is 0 if p [ i ] [ j ] is true ; different looping variables ; every substring of length 1 is a palindrome ; l is substring length . build the solution in bottom - up manner by considering all substrings of length starting from 2 to n . the loop structure is the same as matrix chain multiplication problem ( see https : www . geeksforgeeks . org / matrix - chain - multiplication - dp - 8 / ) ; for substring of length l , set different possible starting indexes ; set ending index ; if l is 2 , then we just need to compare two characters . else need to check two corner characters and value of p [ i + 1 ] [ j - 1 ] ; if str [ i . . j ] is palindrome , then c [ i ] [ j ] is 0 ; make a cut at every possible location starting from i to j , and get the minimum cost cut . ; return the min cut value for complete string . i . e . , str [ 0. . n - 1 ] ; ",
        "context": "",
        "code": "def minPalPartion(str):\n    n = len(str)\n    C = [[0 for i in range(n)]for i in range(n)]\n    P = [[False for i in range(n)]for i in range(n)]\n    j = 0\n    k = 0\n    L = 0\n    for i in range(n):\n        P[i][i] = True\n        C[i][i] = 0\n    for L in range(2, n + 1):\n        for i in range(n - L + 1):\n            j = i + L - 1\n            if L == 2:\n                P[i][j] = (str[i] == str[j])\n            else:\n                P[i][j] = ((str[i] == str[j]) and P[i + 1][j - 1])\n            if P[i][j]:\n                C[i][j] = 0\n            else:\n                C[i][j] = 100000000\n                for k in range(i, j):\n                    C[i][j] = min(C[i][j], C[i][k] + C[k + 1][j] + 1)\n    return C[0][n - 1]\n",
        "test": "\nstr = \"ababbbabbababa\"\nprint('Min cuts needed for Palindrome Partitioning is', minPalPartion(str))\n",
        "output": "Min cuts needed for Palindrome Partitioning is 3\n",
        "fn_call": "minPalPartion"
    },
    {
        "text": "maximum product of a triplet ( subsequence of size 3 ) in array | a o ( n ) python3 program to find maximum product pair in an array . ; function to find a maximum product of a triplet in array of integers of size n ; if size is less than 3 , no triplet exists ; initialize maximum , second maximum and third maximum element ; initialize minimum and second minimum element ; update maximum , second maximum and third maximum element ; update second maximum and third maximum element ; update third maximum element ; update minimum and second minimum element ; update second minimum element ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxProduct(arr, n):\n    if (n < 3):\n        return -1\n    maxA = -sys .maxsize - 1\n    maxB = -sys .maxsize - 1\n    maxC = -sys .maxsize - 1\n    minA = sys .maxsize\n    minB = sys .maxsize\n    for i in range(n):\n        if (arr[i] > maxA):\n            maxC = maxB\n            maxB = maxA\n            maxA = arr[i]\n        elif (arr[i] > maxB):\n            maxC = maxB\n            maxB = arr[i]\n        elif (arr[i] > maxC):\n            maxC = arr[i]\n        if (arr[i] < minA):\n            minB = minA\n            minA = arr[i]\n        elif (arr[i] < minB):\n            minB = arr[i]\n    return max(minA * minB * maxA, maxA * maxB * maxC)\n",
        "test": "\narr = [1, -4, 3, -6, 7, 0]\nn = len(arr)\nMax = maxProduct(arr, n)\nif (Max == -1):\n    print(\"No Triplet Exists\")\nelse:\n    print(\"Maximum product is\", Max)\n",
        "output": "Maximum product is 168\n",
        "fn_call": "maxProduct"
    },
    {
        "text": "largest number by which given 3 numbers should be divided such that they leaves same remainder | __gcd function ; function return number which divides these three number and leaves same remainder . ; we find the differences of all three pairs ; return gcd of three differences . ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef sameRemainder(a, b, c):\n    a1 = (b - a)\n    b1 = (c - b)\n    c1 = (c - a)\n    return gcd(a1, gcd(b1, c1))\n",
        "test": "\na = 62\nb = 132\nc = 237\nprint(sameRemainder(a, b, c))\n",
        "output": "35\n",
        "fn_call": "sameRemainder"
    },
    {
        "text": "find array with k number of merge sort calls | python program to find an array that can be sorted with k merge sort calls . ; we make two recursive calls , so reduce k by 2. ; create an array with values in [ 1 , n ] ; calling unsort function ; ",
        "context": "",
        "code": "def unsort(l, r, a, k):\n    if (k < 1 or l + 1 == r):\n        return\n    k -= 2\n    mid = (l + r) // 2\n    temp = a[mid - 1]\n    a[mid - 1] = a[mid]\n    a[mid] = temp\n    unsort(l, mid, a, k)\n    unsort(mid, r, a, k)\n\n\ndef arrayWithKCalls(n, k):\n    if (k % 2 == 0):\n        print(\"NO SOLUTION\")\n        return\n    a = [0 for i in range(n + 2)]\n    a[0] = 1\n    for i in range(1, n):\n        a[i] = i + 1\n    k -= 1\n    unsort(0, n, a, k)\n    for i in range(n):\n        print(a[i], \" \", end=\"\")\n",
        "test": "\nn = 10\nk = 17\narrayWithKCalls(n, k)\n",
        "output": "3  1  4  6  2  8  5  9  10  7  ",
        "fn_call": "arrayWithKCalls"
    },
    {
        "text": "find sum of all unique elements in the array for k queries | function to find the sum of unique elements after q query ; updating the array after processing each query ; making it to 0 - indexing ; iterating over the array to get the final array ; variable to store the sum ; hash to maintain perviously occured elements ; loop to find the maximum sum ; ",
        "context": "",
        "code": "def uniqueSum(A, R, N, M):\n    for i in range(0, M):\n        l = R[i][0]\n        r = R[i][1] + 1\n        l -= 1\n        r -= 1\n        A[l] += 1\n        if (r < N):\n            A[r] -= 1\n    for i in range(1, N):\n        A[i] += A[i - 1]\n    ans = 0\n    s = {chr}\n    for i in range(0, N):\n        if (A[i]not in s):\n            ans += A[i]\n        s .add(A[i])\n    return ans\n",
        "test": "\nA = [0, 0, 0, 0, 0, 0]\nR = [[1, 3], [4, 6], [3, 4], [3, 3]]\nN = len(A)\nM = len(R)\nprint(uniqueSum(A, R, N, M))\n",
        "output": "6\n",
        "fn_call": "uniqueSum"
    },
    {
        "text": "sum of the series 2 + ( 2 + 4 ) + ( 2 + 4 + 6 ) + ( 2 + 4 + 6 + 8 ) + \u00e2 \u20ac\u00a6 \u00e2 \u20ac\u00a6 + ( 2 + 4 + 6 + 8 + \u00e2 \u20ac\u00a6 . + 2 n ) | function to find the sum of the given series ; sum of 1 st n natural numbers ; sum of squares of 1 st n natural numbers ; required sum ; ",
        "context": "",
        "code": "def sumOfTheSeries(n):\n    sum_n = int((n * (n + 1) / 2))\n    sum_sq_n = int((n * (n + 1) / 2) * (2 * n + 1) / 3)\n    return (sum_n + sum_sq_n)\n",
        "test": "\nn = 5\nans = sumOfTheSeries(n)\nprint(ans)\n",
        "output": "70\n",
        "fn_call": "sumOfTheSeries"
    },
    {
        "text": "length of the longest substring without repeating characters | python3 program to find the length of the longest substring without repeating characters ; result ; note : default values in visited are false ; if current character is visited break the loop ; else update the result if this window is larger , and mark current character as visited . ; remove the first character of previous window ; ",
        "context": "",
        "code": "def longestUniqueSubsttr(str):\n    n = len(str)\n    res = 0\n    for i in range(n):\n        visited = [0] * 256\n        for j in range(i, n):\n            if (visited[ord(str[j])]):\n                break\n            else:\n                res = max(res, j - i + 1)\n                visited[ord(str[j])] = True\n        visited[ord(str[i])] = False\n    return res\n",
        "test": "\nstr = \"geeksforgeeks\"\nprint(\"The input is \", str)\nlen = longestUniqueSubsttr(str)\nprint(\"The length of the longest \" \"non-repeating character substring is \", len)\n",
        "output": "The input is  geeksforgeeks\nThe length of the longest non-repeating character substring is  7\n",
        "fn_call": "longestUniqueSubsttr"
    },
    {
        "text": "find the n | function to calculate nth number made of even digits only ; variable to note how many such numbers have been found till now ; bool variable to check if 1 , 3 , 5 , 7 , 9 is there or not ; checking each digit of the number ; if 1 , 3 , 5 , 7 , 9 is found temp is changed to false ; temp is true it means that it does not have 1 , 3 , 5 , 7 , 9 ; if nth such number is found , return it ; ",
        "context": "",
        "code": "def findNthEvenDigitNumber(n):\n    count = 0\n    i = 0\n    while (True):\n        curr = i\n        isCurrEvenDigit = True\n        while (curr != 0):\n            if (curr %\n                10 == 1 or curr %\n                10 == 3 or curr %\n                10 == 5 or curr %\n                10 == 7 or curr %\n                    10 == 9):\n                isCurrEvenDigit = False\n            curr = curr // 10\n        if (isCurrEvenDigit):\n            count += 1\n        if (count == n):\n            return i\n        i += 1\n",
        "test": "\nprint(findNthEvenDigitNumber(2))\nprint(findNthEvenDigitNumber(10))\n",
        "output": "2\n28\n",
        "fn_call": "findNthEvenDigitNumber"
    },
    {
        "text": "cost required to empty a given array by repeated removal of maximum obtained by given operations | function to find the total cost of removing all array elements ; sort the array in descending order ; stores the total cost ; contribution of i - th greatest element to the cost ; remove the element ; if negative ; add to the final cost ; return the cost ; ",
        "context": "",
        "code": "def findCost(a, n):\n    a .sort(reverse=True)\n    count = 0\n    for j in range(n):\n        p = a[j] - j\n        a[j] = 0\n        if (p < 0):\n            p = 0\n            continue\n        count += p\n    return count\n",
        "test": "\narr = [1, 6, 7, 4, 2, 5, 3]\nN = len(arr)\nprint(findCost(arr, N))\n",
        "output": "16\n",
        "fn_call": "findCost"
    },
    {
        "text": "length of array pair formed where one contains all distinct elements and other all same elements | function to find the max size possible ; counting the maximum frequency ; counting total distinct elements ; find max of both the answer ; ",
        "context": "",
        "code": "def findMaxSize(a, n):\n    frq = [0] * (n + 1)\n    for i in range(n):\n        frq[a[i]] += 1\n    maxfrq = max(frq)\n    dist = n + 1 - frq .count(0)\n    ans1 = min(maxfrq - 1, dist)\n    ans2 = min(maxfrq, dist - 1)\n    ans = max(ans1, ans2)\n    return ans\n",
        "test": "\narr = [4, 2, 4, 1, 4, 3, 4]\nn = len(arr)\nprint(findMaxSize(arr, n))\n",
        "output": "3\n",
        "fn_call": "findMaxSize"
    },
    {
        "text": "minimum time required to transport all the boxes from source to the destination under the given constraints | function that returns true if it is possible to transport all the boxes in the given amount of time ; if all the boxes can be transported in the given time ; if all the boxes can 't be  transported in the given time ; function to return the minimum time required ; sort the two arrays ; stores minimum time in which all the boxes can be transported ; check for the minimum time in which all the boxes can be transported ; if it is possible to transport all the boxes in mid amount of time ; ",
        "context": "",
        "code": "def isPossible(box, truck, n, m, min_time):\n    temp = 0\n    count = 0\n    while (count < m):\n        j = 0\n        while (j = box[temp]):\n            temp += 1\n            j += 2\n        count += 1\n    if (temp == n):\n        return True\n    return False\n\n\ndef minTime(box, truck, n, m):\n    box .sort()\n    truck .sort()\n    l = 0\n    h = 2 * n\n    min_time = 0\n    while (l <= h):\n        mid = (l + h) // 2\n        if (isPossible(box, truck, n, m, mid)):\n            min_time = mid\n            h = mid - 1\n        else:\n            l = mid + 1\n    return min_time\n",
        "test": "\nif __name__ == \"__main__\":\n    box = [10, 2, 16, 19]\n    truck = [29, 25]\n    n = len(box)\n    m = len(truck)\n    print(minTime(box, truck, n, m))\n",
        "output": "3\n",
        "fn_call": "minTime"
    },
    {
        "text": "maximum sum possible for a sub | function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; initialize dp [ 0 ] ; initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; fill remaining positions ; return the maximum sum ; ",
        "context": "",
        "code": "def maxSum(arr, k, n):\n    if (n == 0):\n        return 0\n    if (n == 1):\n        return arr[0]\n    if (n == 2):\n        return max(arr[0], arr[1])\n    dp = [0] * n\n    dp[0] = arr[0]\n    for i in range(1, k + 1):\n        dp[i] = max(arr[i], dp[i - 1])\n    for i in range(k + 1, n):\n        dp[i] = max(arr[i], dp[i - (k + 1)] + arr[i])\n    max_element = max(dp)\n    return max_element\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 7, 1, 3, 8, 2, 4]\n    n = len(arr)\n    k = 2\n    print(maxSum(arr, k, n))\n",
        "output": "15\n",
        "fn_call": "maxSum"
    },
    {
        "text": "pairs with difference less than k | function to count pairs ; ",
        "context": "",
        "code": "def countPairs(a, n, k):\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (abs(a[j] - a[i]) < k):\n                res += 1\n    return res\n",
        "test": "\na = [1, 10, 4, 2]\nk = 3\nn = len(a)\nprint(countPairs(a, n, k), end=\"\")\n",
        "output": "2",
        "fn_call": "countPairs"
    },
    {
        "text": "perfect cube string | python3 program to find if str1ing is a perfect cube or not . ; finding ascii values of each character and finding its sum ; find the cube root of sum ; check if sum is a perfect cube ; ",
        "context": "\nfrom math import ceil\n\n",
        "code": "def isPerfectCubeString(str1):\n    sum = 0\n    for i in range(len(str1)):\n        sum += ord(str1[i])\n    cr = ceil((sum)**(1 / 3))\n    return (cr * cr * cr == sum)\n",
        "test": "\nstr1 = \"ll\"\nif (isPerfectCubeString(str1)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPerfectCubeString"
    },
    {
        "text": "find a partition point in array to maximize its xor sum | function to calculate prefix xor array ; calculating prefix xor ; function to find partition point in array to maximize xor sum ; to store prefix xor ; compute the prefix xor ; to store sum and index ; calculate the maximum sum that can be obtained splitting the array at some index i ; prefixxor [ i ] = xor of all arr elements till i ' th \u2581 index \u2581 prefixxor [ n - 1 ] \u2581 \u2581 ^ \u2581 prefixxor [ i ] \u2581 = \u2581 xor \u2581 of \u2581 all \u2581 elements \u2581 \u2581 from \u2581 i + 1' th index to n - 1 'th index ; return the index ; ",
        "context": "",
        "code": "def ComputePrefixXor(arr, PrefixXor, n):\n    PrefixXor[0] = arr[0]\n    for i in range(1, n):\n        PrefixXor[i] = PrefixXor[i - 1] ^ arr[i]\n\n\ndef Xor_Sum(arr, n):\n    PrefixXor = [0] * n\n    ComputePrefixXor(arr, PrefixXor, n)\n    sum, index = 0, 0\n    for i in range(n):\n        if (PrefixXor[i] + (PrefixXor[n - 1] ^ PrefixXor[i]) > sum):\n            sum = PrefixXor[i] + (PrefixXor[n - 1] ^ PrefixXor[i])\n            index = i\n    return index + 1\n",
        "test": "\narr = [1, 4, 6, 3, 8, 13, 34, 2, 21, 10]\nn = len(arr)\nprint(Xor_Sum(arr, n))\n",
        "output": "2\n",
        "fn_call": "Xor_Sum"
    },
    {
        "text": "maximum primes whose sum is equal to given n | function to find max count of primes ; if n is even n / 2 is required answer if n is odd floor ( n / 2 ) = ( int ) ( n / 2 ) is required answer ; ",
        "context": "",
        "code": "def maxPrmimes(n):\n    return n // 2\n",
        "test": "\nn = 17\nprint(maxPrmimes(n))\n",
        "output": "8\n",
        "fn_call": "maxPrmimes"
    },
    {
        "text": "find k distinct positive odd integers with sum n | function to find k odd positive integers such that their summ is n ; condition to check if there are enough values to check ; ",
        "context": "",
        "code": "def findDistinctOddsumm(n, k):\n    if ((k * k) <= n and (n + k) % 2 == 0):\n        val = 1\n        summ = 0\n        for i in range(1, k):\n            print(val, end=\" \")\n            summ += val\n            val += 2\n        print(n - summ)\n    else:\n        print(\"NO\")\n",
        "test": "\nn = 100\nk = 4\nfindDistinctOddsumm(n, k)\n",
        "output": "1 3 5 91\n",
        "fn_call": "findDistinctOddsumm"
    },
    {
        "text": "length of the largest substring which have character with frequency greater than or equal to half of the substring | python3 implementation of the above approach ; function to return the length of the longest sub string having frequency of a character greater than half of the length of the sub string ; for each of the character ' a ' to 'z ; finding frequency prefix array of the character ; finding the r [ ] and l [ ] arrays . ; for each j from 0 to n ; finding the lower bound of i . ; storing the maximum value of i - j + 1 ; clearing all the vector so that it can be used for other characters . ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxLength(s, n):\n    ans = -(sys .maxsize + 1)\n    A, L, R = [], [], []\n    freq = [0] * (n + 5)\n\n    for i in range(26):\n        count = 0\n        for j in range(n):\n            if (ord(s[j]) - ord('a') == i):\n                count += 1\n            freq[j] = count\n        for j in range(n):\n            L .append((2 * freq[j - 1]) - j)\n            R .append((2 * freq[j]) - j)\n        max_len = -(sys .maxsize + 1)\n        min_val = sys .maxsize\n        for j in range(n):\n            min_val = min(min_val, L[j])\n            A .append(min_val)\n            l = 0\n            r = j\n            while (l <= r):\n                mid = (l + r) >> 1\n                if (A[mid] <= R[j]):\n                    max_len = max(max_len, j - mid + 1)\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        ans = max(ans, max_len)\n        A .clear()\n        R .clear()\n        L .clear()\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"ababbbacbcbcca\"\n    n = len(s)\n    print(maxLength(s, n))\n",
        "output": "13\n",
        "fn_call": "maxLength"
    },
    {
        "text": "find the triplet from given bitwise xor and bitwise and values of all its pairs | function to find the triplet with given bitwise xor and bitwise and values of all possible pairs of the triplet ; stores values of a triplet ; stores a + b ; stores a + c ; stores b + c ; calculate asumb ; calculate asumc ; calculate bsumc ; calculate a ; calculate b ; calculate c ; pra ; prb ; prc ; ",
        "context": "",
        "code": "def findNumbers(aXORb, aANDb, aXORc, aANDc, bXORc, bANDc):\n    a, b, c = 0, 0, 0\n    aSUMb = 0\n    aSUMc = 0\n    bSUMc = 0\n    aSUMb = aXORb + aANDb * 2\n    aSUMc = aXORc + aANDc * 2\n    bSUMc = bXORc + bANDc * 2\n    a = (aSUMb - bSUMc + aSUMc) // 2\n    b = aSUMb - a\n    c = aSUMc - a\n    print(\"a = \", a, end=\"\")\n    print(\", b = \", b, end=\"\")\n    print(\", c = \", c, end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    aXORb = 30\n    aANDb = 0\n    aXORc = 20\n    aANDc = 10\n    bXORc = 10\n    bANDc = 20\n    findNumbers(aXORb, aANDb, aXORc, aANDc, bXORc, bANDc)\n",
        "output": "a =  10, b =  20, c =  30",
        "fn_call": "findNumbers"
    },
    {
        "text": "longest sub | function to find the starting and the ending index of the sub - array with equal number of alphabets and numeric digits ; if its an alphabet ; else its a number ; pick a starting poas i ; consider all sub - arrays starting from i ; if this is a 0 sum sub - array then compare it with maximum size sub - array calculated so far ; if no valid sub - array found ; ",
        "context": "",
        "code": "def findSubArray(arr, n):\n    sum = 0\n    maxsize = -1\n    startindex = 0\n    for i in range(n):\n        if (arr[i].isalpha()):\n            arr[i] = 0\n        else:\n            arr[i] = 1\n    for i in range(n - 1):\n        if arr[i] == '1':\n            sum = 1\n        else:\n            sum = -1\n        for j in range(i + 1, n):\n            if arr[j] == 0:\n                sum -= 1\n            else:\n                sum += 1\n            if (sum == 0 and maxsize < j - i + 1):\n                maxsize = j - i + 1\n                startindex = i\n    if (maxsize == -1):\n        print(maxsize, end=\" \")\n    else:\n        print(startindex, (startindex + maxsize - 1))\n",
        "test": "\narr = ['A', 'B', 'X', '4', '6', 'X', 'a']\nsize = len(arr)\nfindSubArray(arr, size)\n",
        "output": "1 4\n",
        "fn_call": "findSubArray"
    },
    {
        "text": "minimum steps to convert all paths in matrix from top left to bottom right as palindromic paths | python3 implementation to find the minimum number of changes required such that every path from top left to the bottom right are palindromic paths ; function to find the minimum number of the changes required for the every path to be palindromic ; count variable for maintaining total changes . ; left and right variables for keeping distance values from cell ( 0 , 0 ) and ( n - 1 , m - 1 ) respectively . ; iterating over the matrix ; finding minimum number of changes required . ; minimum no . of changes will be the the minimum no . of different values and we will assume to make them equals to value with maximum frequency element ; moving ahead with greater distance ; ",
        "context": "\nM = 3\nN = 3\n\n",
        "code": "def minchanges(mat):\n    count = 0\n    left = 0\n    right = N + M - 2\n    while (left < right):\n        mp = {}\n        totalsize = 0\n        for i in range(N):\n            for j in range(M):\n                if (i + j == left):\n                    mp[mat[i][j]] = mp .get(mat[i][j], 0) + 1\n                    totalsize += 1\n                elif (i + j == right):\n                    mp[mat[i][j]] = mp .get(mat[i][j], 0) + 1\n                    totalsize += 1\n        changes = 0\n        for itr in mp:\n            changes = max(changes, mp[itr])\n        count += totalsize - changes\n        left += 1\n        right -= 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[1, 4, 1], [2, 5, 3], [1, 3, 1]]\n    print(minchanges(mat))\n",
        "output": "2\n",
        "fn_call": "minchanges"
    },
    {
        "text": "split an array into equal length subsequences consisting of equal elements only | python3 program for the above approach ; function to find the gcd of two numbers a and b ; function to check if it is possible to split the array into equal length subsequences such that all elements in the subsequence are equal ; store frequencies of array elements ; traverse the array ; update frequency of arr [ i ] ; store the gcd of frequencies of all array elements ; traverse the map ; update gcd ; if the gcd is greater than 1 , print yes otherwise print no ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef splitArray(arr, N):\n    mp = defaultdict(int)\n    for i in range(N):\n        mp[arr[i]] += 1\n    G = 0\n    for i in mp:\n        G = gcd(G, mp[i])\n    if (G > 1):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 4, 3, 2, 1]\n    n = len(arr)\n    splitArray(arr, n)\n",
        "output": "YES\n",
        "fn_call": "splitArray"
    },
    {
        "text": "number with even sum of digits | function to find kth good number . ; find the last digit of n . ; if last digit is between 0 to 4 then return 2 * n . ; if last digit is between 5 to 9 then return 2 * n + 1. ; ",
        "context": "",
        "code": "def findKthGoodNo(n):\n    lastDig = n % 10\n    if (lastDig >= 0 and lastDig <= 4):\n        return n << 1\n    else:\n        return (n << 1) + 1\n",
        "test": "\nn = 10\nprint(findKthGoodNo(n))\n",
        "output": "20\n",
        "fn_call": "findKthGoodNo"
    },
    {
        "text": "maximum value of ( arr [ i ] * arr [ j ] ) + ( arr [ j ] | function to find the value of the expression a * b + ( b - a ) ; function to find the maximum value of the expression a * b + ( b - a ) possible for any pair ( a , b ) ; sort the vector in ascending order ; stores the maximum value ; update ans by choosing the pair of the minimum and 2 nd minimum ; update ans by choosing the pair of maximum and 2 nd maximum ; return the value of ans ; ",
        "context": "",
        "code": "def calc(a, b):\n    return a * b + (b - a)\n\n\ndef findMaximum(arr, N):\n    arr = sorted(arr)\n    ans = -10 ** 9\n    ans = max(ans, calc(arr[0], arr[1]))\n    ans = max(ans, calc(arr[N - 2], arr[N - 1]))\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, -47, 12]\n    N = len(arr)\n    print(findMaximum(arr, N))\n    arr = [0, -47, 12]\n    N = len(arr)\n    print(findMaximum(arr, N))\n",
        "output": "47\n47\n",
        "fn_call": "findMaximum"
    },
    {
        "text": "minimum swaps required to bring all elements less than or equal to k together | utility function to find minimum swaps required to club all elements less than or equals to k together ; find count of elements which are less than equals to k ; find unwanted elements in current window of size 'count   ; initialize answer with ' bad ' value of current window ; decrement count of previous window ; increment count of current window ; update ans if count of ' bad ' is less in current window ; ",
        "context": "",
        "code": "def minSwap(arr, n, k):\n    count = 0\n    for i in range(0, n):\n        if (arr[i] <= k):\n            count = count + 1\n    bad = 0\n    for i in range(0, count):\n        if (arr[i] > k):\n            bad = bad + 1\n    ans = bad\n    j = count\n    for i in range(0, n):\n        if (j == n):\n            break\n        if (arr[i] > k):\n            bad = bad - 1\n        if (arr[j] > k):\n            bad = bad + 1\n        ans = min(ans, bad)\n        j = j + 1\n    return ans\n",
        "test": "\narr = [2, 1, 5, 6, 3]\nn = len(arr)\nk = 3\nprint(minSwap(arr, n, k))\narr1 = [2, 7, 9, 5, 8, 7, 4]\nn = len(arr1)\nk = 5\nprint(minSwap(arr1, n, k))\n",
        "output": "1\n2\n",
        "fn_call": "minSwap"
    },
    {
        "text": "a product array puzzle | set 2 ( o ( 1 ) space ) | python program for product array puzzle with o ( n ) time and o ( 1 ) space . ; epsilon value to maintain precision ; to hold sum of all values ; output product for each index antilog to find original product value ; ",
        "context": "\nimport math\nEPS = 1e-9\n\n",
        "code": "def productPuzzle(a, n):\n    sum = 0\n    for i in range(n):\n        sum += math .log10(a[i])\n    for i in range(n):\n        print(int((EPS + pow(10.00, sum - math .log10(a[i])))),)\n    return\n",
        "test": "\na = [10, 3, 5, 6, 2]\nn = len(a)\nprint(\"The product array is: \")\nproductPuzzle(a, n)\n",
        "output": "The product array is: \n180\n600\n360\n300\n900\n",
        "fn_call": "productPuzzle"
    },
    {
        "text": "count distinct elements in an array | python3 program to count distinct elements in a given array ; pick all elements one by one ; if not printed earlier , then print it ; ",
        "context": "",
        "code": "def countDistinct(arr, n):\n    res = 1\n    for i in range(1, n):\n        j = 0\n        for j in range(i):\n            if (arr[i] == arr[j]):\n                break\n        if (i == j + 1):\n            res += 1\n    return res\n",
        "test": "\narr = [12, 10, 9, 45, 2, 10, 10, 45]\nn = len(arr)\nprint(countDistinct(arr, n))\n",
        "output": "5\n",
        "fn_call": "countDistinct"
    },
    {
        "text": "delete middle element of a stack | deletes middle of stack of size n . curr is current item number ; if stack is empty or all items are traversed ; remove current item ; remove other items ; put all items back except middle ; ",
        "context": "\nclass Stack:\n    def __init__(self):\n        self .items = []\n\n    def isEmpty(self):\n        return self .items == []\n\n    def push(self, item):\n        self .items .append(item)\n\n    def pop(self):\n        return self .items .pop()\n\n    def peek(self):\n        return self .items[len(self .items) - 1]\n\n    def size(self):\n        return len(self .items)\n\n",
        "code": "def deleteMid(st, n, curr):\n    if (st .isEmpty() or curr == n):\n        return\n    x = st .peek()\n    st .pop()\n    deleteMid(st, n, curr + 1)\n    if (curr != int(n / 2)):\n        st .push(x)\n",
        "test": "\nst = Stack()\nst .push('1')\nst .push('2')\nst .push('3')\nst .push('4')\nst .push('5')\nst .push('6')\nst .push('7')\ndeleteMid(st, st .size(), 0)\nwhile (st .isEmpty() == False):\n    p = st .peek()\n    st .pop()\n    print(str(p) + \" \", end=\"\")\n",
        "output": "7 6 5 3 2 1 ",
        "fn_call": "deleteMid"
    },
    {
        "text": "find the minimum and maximum amount to buy all n candies | python implementation to find the minimum and maximum amount ; function to find the maximum and the minimum cost required ; sort the array ; print the minimum cost ; print the maximum cost ; ",
        "context": "\nfrom math import ceil\n\n",
        "code": "def find(arr, n, k):\n    arr .sort()\n    b = int(ceil(n / k))\n    print(\"minimum \", sum(arr[:b]))\n    print(\"maximum \", sum(arr[-b:]))\n",
        "test": "\narr = [3, 2, 1, 4]\nn = len(arr)\nk = 2\nfind(arr, n, k)\n",
        "output": "minimum  3\nmaximum  7\n",
        "fn_call": "find"
    },
    {
        "text": "check if one string can be converted to other using given operation | function that prints whether is it possible to make a equal to t by performing given operations ; base case , if we put the last character at front of a ; base case , if we put the last character at back of a ; condition if current sequence is matchable ; condition for front move to ( i - 1 ) th character ; condition for back move to ( i - 1 ) th character ; condition if it is possible to make a equal to t ; print final answer ; ",
        "context": "",
        "code": "def twoStringsEquality(s, t):\n    n = len(s)\n    dp = [[0 for i in range(n + 1)]for i in range(n)]\n    if (s[n - 1] == t[0]):\n        dp[n - 1][1] = 1\n    if (s[n - 1] == t[n - 1]):\n        dp[n - 1][0] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(n - i + 1):\n            if (dp[i][j]):\n                if (s[i - 1] == t[j]):\n                    dp[i - 1][j + 1] = 1\n                if (s[i - 1] == t[i + j - 1]):\n                    dp[i - 1][j] = 1\n    ans = False\n    for i in range(n + 1):\n        if (dp[0][i] == 1):\n            ans = True\n            break\n    if (ans):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"abab\"\n    T = \"baab\"\n    twoStringsEquality(S, T)\n",
        "output": "Yes\n",
        "fn_call": "twoStringsEquality"
    },
    {
        "text": "check if the number is even or odd whose digits and base ( radix ) is given | function that returns true if the number represented by arr [ ] is even in base r ; if the base is even , then the last digit is checked ; if base is odd , then the number of odd digits are checked ; to store the count of odd digits ; number is odd ; ",
        "context": "",
        "code": "def isEven(arr, n, r):\n    if (r % 2 == 0):\n        if (arr[n - 1] % 2 == 0):\n            return True\n    else:\n        oddCount = 0\n        for i in range(n):\n            if (arr[i] % 2 != 0):\n                oddCount += 1\n        if (oddCount % 2 == 0):\n            return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 0]\n    n = len(arr)\n    r = 2\n    if (isEven(arr, n, r)):\n        print(\"Even\")\n    else:\n        print(\"Odd\")\n",
        "output": "Even\n",
        "fn_call": "isEven"
    },
    {
        "text": "nicomachus\u00e3\u0192\u00e6 \u2019 \u00e3 \u2020 \u00e2 \u20ac\u2122 \u00e3\u0192\u00e2 \u20ac \u00e3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00e3\u0192\u00e6 \u2019 \u00e3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00e3\u0192\u00e6 \u2019\u00a2 \u00e3\u0192 \u00a2 \u00e3 \u00a2 \u00e2 \u201a\u00ac \u00e5 \u00a1\u00ac \u00e3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac \u00e3\u0192\u00e6 \u2019 \u00e3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00e3\u0192\u00e6 \u2019\u00a2 \u00e3\u0192 \u00a2 \u00e3 \u00a2 \u00e2 \u201a\u00ac \u00e5 \u00a1\u00ac \u00e3\u0192\u00e2 \u20ac\u00a6\u00be\u00a2 s theorem ( sum of k | return the sum of kth group of positive odd integer . ; ",
        "context": "",
        "code": "def kthgroupsum(k):\n    return k * k * k\n",
        "test": "\nk = 3\nprint(kthgroupsum(k))\n",
        "output": "27\n",
        "fn_call": "kthgroupsum"
    },
    {
        "text": "program for area of square after n | function to calculate area of square after given number of folds ; ",
        "context": "",
        "code": "def areaSquare(side, fold):\n    area = side * side\n    ans = area / pow(2, fold)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    side = 4\n    fold = 2\n    print(areaSquare(side, fold))\n",
        "output": "4.0\n",
        "fn_call": "areaSquare"
    },
    {
        "text": "given a large number , check if a subsequence of digits is divisible by 8 | function to calculate any permutation divisible by 8. if such permutation exists , the function will return that permutation else it will return - 1 ; generating all possible permutations and checking if any such permutation is divisible by 8 ; ",
        "context": "",
        "code": "def isSubSeqDivisible(st):\n    l = len(st)\n    arr = [int(ch)for ch in st]\n    for i in range(0, l):\n        for j in range(i, l):\n            for k in range(j, l):\n                if (arr[i] % 8 == 0):\n                    return True\n                elif ((arr[i] * 10 + arr[j]) % 8 == 0 and i != j):\n                    return True\n                elif ((arr[i] * 100 + arr[j] * 10 + arr[k]) % 8 == 0 and i != j and j != k and i != k):\n                    return True\n    return False\n",
        "test": "\nst = \"3144\"\nif (isSubSeqDivisible(st)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isSubSeqDivisible"
    },
    {
        "text": "program to check if n is a pentadecagonal number | python3 program for the above approach ; function to check if n is a pentadecagon number ; condition to check if the number is a pentadecagon number ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isPentadecagon(N):\n    n = (11 + sqrt(104 * N + 121)) / 26\n    return (n - int(n) == 0)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 15\n    if (isPentadecagon(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPentadecagon"
    },
    {
        "text": "count of adjacent vowel consonant pairs | function to count the adjacent pairs of consonant and vowels in the string ; using a set to store the vowels so that checking each character becomes easier ; variable to store number of consonant - vowel pairs ; if the ith character is not found in the set , means it is a consonant and if the ( i + 1 ) th character is found in the set , means it is a vowel we increment the count of such pairs ; ",
        "context": "",
        "code": "def countPairs(s):\n    st = set()\n    st .add('a')\n    st .add('e')\n    st .add('i')\n    st .add('o')\n    st .add('u')\n    count = 0\n    n = len(s)\n    for i in range(n - 1):\n        if (s[i]not in st and s[i + 1] in st):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"geeksforgeeks\"\n    print(countPairs(s))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "count of k | function to to count the number of k - countdowns for multiple queries ; flag which stores the current value of value in the countdown ; count of k - countdowns ; loop to iterate over the elements of the array ; condition check if the elements of the array is equal to k ; condition check if the elements of the array is in continuous order ; condition check if the elements of the array are not in continuous order ; condition check to increment the counter if the there is a k - countdown present in the array ; returning the count of k - countdowns ; ",
        "context": "",
        "code": "def countKCountdown(arr, N, K):\n    flag = -1\n    count = 0\n    for i in range(0, N):\n        if (arr[i] == K):\n            flag = K\n        if (arr[i] == flag):\n            flag -= 1\n        else:\n            flag = -1\n        if (flag == 0):\n            count += 1\n    return count\n",
        "test": "\nN = 8\nK = 3\narr = [4, 3, 2, 1, 5, 3, 2, 1]\nprint(countKCountdown(arr, N, K))\n",
        "output": "2\n",
        "fn_call": "countKCountdown"
    },
    {
        "text": "sequence with sum k and minimum sum of absolute differences between consecutive elements | function to return the minimized sum ; if k is divisible by n then the answer will be 0 ; else the answer will be 1 ; ",
        "context": "",
        "code": "def minimum_sum(n, k):\n    if (k % n == 0):\n        return 0\n    return 1\n",
        "test": "\nn = 3\nk = 56\nprint(minimum_sum(n, k))\n",
        "output": "1\n",
        "fn_call": "minimum_sum"
    },
    {
        "text": "palindrome partitioning | dp | python code for implementation of naive recursive approach ; ",
        "context": "",
        "code": "def isPalindrome(x):\n    return x == x[::-1]\n\n\ndef minPalPartion(string, i, j):\n    if i >= j or isPalindrome(string[i:j + 1]):\n        return 0\n    ans = float('inf')\n    for k in range(i, j):\n        count = (\n            1 +\n            minPalPartion(\n                string,\n                i,\n                k) +\n            minPalPartion(\n                string,\n                k +\n                1,\n                j))\n        ans = min(ans, count)\n    return ans\n\n\ndef main():\n    string = \"ababbbabbababa\"\n    print(\"Min cuts needed for Palindrome Partitioning is \",\n          minPalPartion(string, 0, len(string) - 1),)\n",
        "test": "\nif __name__ == \"__main__\":\n    main()\n",
        "output": "Min cuts needed for Palindrome Partitioning is  3\n",
        "fn_call": "main"
    },
    {
        "text": "geometric mean ( two methods ) | program to calculate the geometric mean of the given array elements . ; function to calculate geometric mean and return float value . ; declare sum variable and initialize it to 1. ; compute the sum of all the elements in the array . ; compute geometric mean through formula antilog ( ( ( log ( 1 ) + log ( 2 ) + . . ... + log ( n ) ) / n ) and return the value to main function . ; ",
        "context": "\nimport math\n\n",
        "code": "def geometricMean(arr, n):\n    sum = 0\n    for i in range(n):\n        sum = sum + math .log(arr[i])\n    sum = sum / n\n    return math .exp(sum)\n",
        "test": "\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nn = len(arr)\nprint(geometricMean(arr, n))\n",
        "output": "3.764350599503129\n",
        "fn_call": "geometricMean"
    },
    {
        "text": "program to find sum of 1 + x / 2 ! + x ^ 2 / 3 ! + ... + x ^ n / ( n + 1 ) ! | method to find the factorial of a number ; method to compute the sum ; iterate the loop till n and compute the formula ; ",
        "context": "",
        "code": "def fact(n):\n    if n == 1:\n        return 1\n    else:\n        return n * fact(n - 1)\n\n\ndef sum(x, n):\n    total = 1.0\n    for i in range(1, n + 1, 1):\n        total = total + (pow(x, i) / fact(i + 1))\n    return total\n",
        "test": "\nif __name__ == '__main__':\n    x = 5\n    n = 4\n    print(\"Sum is: {0:.4f}\".format(sum(x, n)))\n",
        "output": "Sum is: 18.0833\n",
        "fn_call": "sum"
    },
    {
        "text": "longest common anagram subsequence | python 3 implementation to find the length of the longest common anagram subsequence ; function to find the length of the longest common anagram subsequence ; list for storing frequencies of each character ; calculate frequency of each character of 'str1[] ; calculate frequency of each character of 'str2[] ; for each character add its minimum frequency out of the two strings in 'len ; required length ; ",
        "context": "\n\nSIZE = 26\n\n",
        "code": "def longCommonAnagramSubseq(str1, str2,\n                            n1, n2):\n    freq1 = [0] * SIZE\n    freq2 = [0] * SIZE\n\n    l = 0\n    for i in range(n1):\n        freq1[ord(str1[i]) -\n              ord('a')] += 1\n    for i in range(n2):\n        freq2[ord(str2[i]) -\n              ord('a')] += 1\n    for i in range(SIZE):\n        l += min(freq1[i], freq2[i])\n    return l\n",
        "test": "\nif __name__ == \"__main__\":\n\n    str1 = \"abdacp\"\n    str2 = \"ckamb\"\n    n1 = len(str1)\n    n2 = len(str2)\n    print(\"Length = \",\n          longCommonAnagramSubseq(str1, str2,\n                                  n1, n2))\n",
        "output": "Length =  3\n",
        "fn_call": "longCommonAnagramSubseq"
    },
    {
        "text": "maximum average sum partition of an array | python3 program for maximum average sum partition ; storing prefix sums ; for each i to n storing averages ; ",
        "context": "",
        "code": "def largestSumOfAverages(A, K):\n    n = len(A)\n    pre_sum = [0] * (n + 1)\n    pre_sum[0] = 0\n    for i in range(n):\n        pre_sum[i + 1] = pre_sum[i] + A[i]\n    dp = [0] * n\n    sum = 0\n    for i in range(n):\n        dp[i] = (pre_sum[n] - pre_sum[i]) / (n - i)\n    for k in range(K - 1):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i] = max(dp[i], (pre_sum[j] - pre_sum[i]) / (j - i) + dp[j])\n    return int(dp[0])\n",
        "test": "\nA = [9, 1, 2, 3, 9]\nK = 3\nprint(largestSumOfAverages(A, K))\n",
        "output": "20\n",
        "fn_call": "largestSumOfAverages"
    },
    {
        "text": "elements to be added so that all elements of a range are present in array | function to count numbers to be added ; make a hash of elements and store minimum and maximum element ; traverse all elements from minimum to maximum and count if it is not in the hash ; ",
        "context": "",
        "code": "def countNum(arr, n):\n    s = dict()\n    count, maxm, minm = 0, -10 ** 9, 10 ** 9\n    for i in range(n):\n        s[arr[i]] = 1\n        if (arr[i] < minm):\n            minm = arr[i]\n        if (arr[i] > maxm):\n            maxm = arr[i]\n    for i in range(minm, maxm + 1):\n        if i not in s .keys():\n            count += 1\n    return count\n",
        "test": "\narr = [3, 5, 8, 6]\nn = len(arr)\nprint(countNum(arr, n))\n",
        "output": "2\n",
        "fn_call": "countNum"
    },
    {
        "text": "segregate even and odd numbers | set 3 | function to segregate even odd numbers ; swapping even and odd numbers ; printing segregated array ; ",
        "context": "",
        "code": "def arrayEvenAndOdd(arr, n):\n    i = -1\n    j = 0\n    while (j != n):\n        if (arr[j] % 2 == 0):\n            i = i + 1\n            arr[i], arr[j] = arr[j], arr[i]\n        j = j + 1\n    for i in arr:\n        print(str(i) + \" \", end='')\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 2, 4, 7, 6, 9, 10]\n    n = len(arr)\n    arrayEvenAndOdd(arr, n)\n",
        "output": "2 4 6 10 7 1 9 3 ",
        "fn_call": "arrayEvenAndOdd"
    },
    {
        "text": "largest subset whose all elements are fibonacci numbers | prints largest subset of an array whose all elements are fibonacci numbers ; find maximum element in arr [ ] ; generate all fibonacci numbers till max and store them in hash . ; npw iterate through all numbers and quickly check for fibonacci using hash . ; ",
        "context": "",
        "code": "def findFibSubset(arr, n):\n    m = max(arr)\n    a = 0\n    b = 1\n    hash = []\n    hash .append(a)\n    hash .append(b)\n    while (b < m):\n        c = a + b\n        a = b\n        b = c\n        hash .append(b)\n    for i in range(n):\n        if arr[i] in hash:\n            print(arr[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 2, 8, 5, 20, 1, 40, 13, 23]\n    n = len(arr)\n    findFibSubset(arr, n)\n",
        "output": "2 8 5 1 13 ",
        "fn_call": "findFibSubset"
    },
    {
        "text": "find if a point lies inside , outside or on the circumcircle of three points a , b , c | function to find the line given two points ; function which converts the input line to its perpendicular bisector . it also inputs the points whose mid - lies o on the bisector ; find the mid point ; x coordinates ; y coordinates ; c = - bx + ay ; assign the coefficient of a and b ; returns the intersection of two lines ; find determinant ; returns the intersection of two lines ; find determinant ; function to find the point lies inside , outside or on the circle ; store the coordinates radius of circumcircle ; line pq is represented as ax + by = c ; line qr is represented as ex + fy = g ; converting lines pq and qr to perpendicular bisectors . after this , l = ax + by = c m = ex + fy = g ; the of intersection of l and m gives r as the circumcenter ; length of radius ; distance between radius and the given d ; condition for lies inside circumcircle ; condition for lies on circumcircle ; condition for lies outside circumcircle ; ",
        "context": "",
        "code": "def lineFromPoints(P, Q, a, b, c):\n    a = Q[1] - P[1]\n    b = P[0] - Q[0]\n    c = a * (P[0]) + b * (P[1])\n    return a, b, c\n\n\ndef perpenBisectorFromLine(P, Q, a, b, c):\n    mid_point = [0, 0]\n    mid_point[0] = (P[0] + Q[0]) / 2\n    mid_point[1] = (P[1] + Q[1]) / 2\n    c = (-b * (mid_point[0]) + a * (mid_point[1]))\n    temp = a\n    a = -b\n    b = temp\n    return a, b, c\n\n\ndef LineInterX(a1, b1, c1, a2, b2, c2):\n    determ = a1 * b2 - a2 * b1\n    x = (b2 * c1 - b1 * c2)\n    x /= determ\n    return x\n\n\ndef LineInterY(a1, b1, c1, a2, b2, c2):\n    determ = a1 * b2 - a2 * b1\n    y = (a1 * c2 - a2 * c1)\n    print(y)\n    y /= determ\n    return y\n\n\ndef findPosition(P, Q, R, D):\n    r = [0, 0]\n    a, b, c = lineFromPoints(P, Q, 0, 0, 0)\n    e, f, g = lineFromPoints(Q, R, 0, 0, 0)\n    a, b, c = perpenBisectorFromLine(P, Q, a, b, c)\n    e, f, g = perpenBisectorFromLine(Q, R, e, f, g)\n    r[0] = LineInterX(a, b, c, e, f, g)\n    r[1] = LineInterY(a, b, c, e, f, g)\n    q = ((r[0] - P[0]) * (r[0] - P[0]) + (r[1] - P[1]) * (r[1] - P[1]))\n    dis = ((r[0] - D[0]) * (r[0] - D[0]) + (r[1] - D[1]) * (r[1] - D[1]))\n    if (dis < q):\n        print(\"Point (\", D[0], \",\", D[1], \") is inside the circumcircle\")\n    elif (dis == q):\n        print(\"Point (\", D[0], \",\", D[1], \") lies on the circumcircle\")\n    else:\n        print(\"Point (\", D[0], \",\", D[1], \") lies outside the circumcircle\")\n",
        "test": "\nif __name__ == '__main__':\n    A = [2, 8]\n    B = [2, 1]\n    C = [4, 5]\n    D = [3, 0]\n    findPosition(A, B, C, D)\n",
        "output": "63.0\nPoint ( 3 , 0 ) lies outside the circumcircle\n",
        "fn_call": "findPosition"
    },
    {
        "text": "how to validate indian driving license number using regular expression | python program to validate indian driving license number using regular expression ; function to validate indian driving license number . ; regex to check valid indian driving license number ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidLicenseNo(str):\n    regex = (\n        \"^(([A-Z]{2}[0-9]{2})\" +\n        \"( )|([A-Z]{2}-[0-9]\" +\n        \"{2}))((19 20)[0-9]\" +\n        \"[0-9])[0-9]{7}$\")\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"HR-0619850034761\"\nprint(isValidLicenseNo(str1))\nstr2 = \"UP14 20160034761\"\nprint(isValidLicenseNo(str2))\nstr3 = \"12HR-37200602347\"\nprint(isValidLicenseNo(str3))\nstr4 = \"MH27 30123476102\"\nprint(isValidLicenseNo(str4))\nstr5 = \"GJ-2420180\"\nprint(isValidLicenseNo(str5))\n",
        "output": "False\nFalse\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidLicenseNo"
    },
    {
        "text": "minimum increment / decrement operations required on array to satisfy given conditions | function to find minimum number of operations to get desired array ; for odd ' i ' , sum of elements till ' i ' is positive ; if i is even and sum is positive , make it negative by subtracting 1 + | s | from a [ i ] ; if i is odd and sum is negative , make it positive by adding 1 + | s | into a [ i ] ; for odd ' i ' , sum of elements till ' i ' is negative ; check if ' i ' is odd and sum is positive , make it negative by subtracting 1 + | s | from a [ i ] ; check if ' i ' is even and sum is negative , make it positive by adding 1 + | s | into a [ i ] ; return the minimum of the two ; ",
        "context": "",
        "code": "def minOperations(a, N):\n    num_of_ops1 = num_of_ops2 = sum = 0\n    for i in range(N):\n        sum += a[i]\n        if (i % 2 == 0 and sum >= 0):\n            num_of_ops1 += (1 + abs(sum))\n            sum = -1\n        elif (i % 2 == 1 and sum <= 0):\n            num_of_ops1 += (1 + abs(sum))\n            sum = 1\n    sum = 0\n    for i in range(N):\n        sum += a[i]\n        if (i % 2 == 1 and sum >= 0):\n            num_of_ops2 += (1 + abs(sum))\n            sum = -1\n        elif (i % 2 == 0 and sum <= 0):\n            num_of_ops2 += (1 + abs(sum))\n            sum = 1\n    return min(num_of_ops1, num_of_ops2)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, -4, 5, 0, 1]\n    N = len(arr)\n    print(minOperations(arr, N))\n",
        "output": "6\n",
        "fn_call": "minOperations"
    },
    {
        "text": "nth term of a recurrence relation generated by two given arrays | python3 program for the above approach ; declare t [ ] [ ] as global matrix ; result matrix ; function to multiply two matrices ; create an auxiliary matrix to store elements of the multiplication matrix ; iterate over range [ 0 , k ] ; update temp [ i ] [ j ] ; update the final matrix ; function to multiply two matrices ; create an auxiliary matrix to store elements of the multiplication matrix ; iterate over range [ 0 , k ] ; update temp [ i ] [ j ] ; update the final matrix ; function to calculate matrix ^ n using binary exponentaion ; initialize result matrix and unity matrix ; function to calculate nth term of general recurrence ; fill t [ ] [ ] with appropriate value ; function call to calculate t ^ n ; calculate nth term as first element of f * ( t ^ n ) ; print the result ; ",
        "context": "\nmod = 1e9 + 7\nT = [[0 for x in range(2000)]for y in range(2000)]\nresult = [[0 for x in range(2000)]for y in range(2000)]\n\n",
        "code": "def mul_2(K):\n    temp = [[0 for x in range(K + 1)]for y in range(K + 1)]\n    for i in range(1, K + 1):\n        for j in range(1, K + 1):\n            for k in range(1, K + 1):\n                temp[i][j] = ((temp[i][j] + (T[i][k] * T[k][j]) % mod) % mod)\n    for i in range(1, K + 1):\n        for j in range(1, K + 1):\n            T[i][j] = temp[i][j]\n\n\ndef mul_1(K):\n    temp = [[0 for x in range(K + 1)]for y in range(K + 1)]\n    for i in range(1, K + 1):\n        for j in range(1, K + 1):\n            for k in range(1, K + 1):\n                temp[i][j] = (\n                    (temp[i][j] + (result[i][k] * T[k][j]) % mod) % mod)\n    for i in range(1, K + 1):\n        for j in range(1, K + 1):\n            result[i][j] = temp[i][j]\n\n\ndef matrix_pow(K, n):\n    for i in range(1, K + 1):\n        for j in range(1, K + 1):\n            if (i == j):\n                result[i][j] = 1\n    while (n > 0):\n        if (n % 2 == 1):\n            mul_1(K)\n        mul_2(K)\n        n //= 2\n\n\ndef NthTerm(F, C, K, n):\n    for i in range(1, K + 1):\n        T[i][K] = C[K - i]\n    for i in range(1, K + 1):\n        T[i + 1][i] = 1\n    matrix_pow(K, n)\n    answer = 0\n    for i in range(1, K + 1):\n        answer += F[i - 1] * result[i][1]\n    print(int(answer))\n",
        "test": "\nif __name__ == \"__main__\":\n    F = [1, 2, 3]\n    C = [1, 1, 1]\n    K = 3\n    N = 10\n    NthTerm(F, C, K, N)\n",
        "output": "423\n",
        "fn_call": "NthTerm"
    },
    {
        "text": "find the minimum value of the given expression over all pairs of the array | python3 program to find the minimum value of the given expression over all pairs of the array ; function to find the minimum value of the expression ; iterate over all the pairs and find the minimum value ; ",
        "context": "\nimport sys\n\n",
        "code": "def MinimumValue(a, n):\n    answer = sys .maxsize\n    for i in range(n):\n        for j in range(i + 1, n, 1):\n            answer = min(answer, ((a[i] & a[j]) ^ (a[i] | a[j])))\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    N = 6\n    A = [12, 3, 14, 5, 9, 8]\n    print(MinimumValue(A, N))\n",
        "output": "1\n",
        "fn_call": "MinimumValue"
    },
    {
        "text": "check if a number starts with another number or not | function to check if b is a prefix of a or not ; convert numbers into strings ; find the length of s1 and s2 ; base case ; traverse the string s1 and s2 ; if at any index characters are unequal then return false ; return true ; ",
        "context": "",
        "code": "def checkprefix(A, B):\n    s1 = str(A)\n    s2 = str(B)\n    n1 = len(s1)\n    n2 = len(s2)\n    if n1 < n2:\n        return False\n    for i in range(0, n2):\n        if s1[i] != s2[i]:\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    A = 12345\n    B = 12\n    result = checkprefix(A, B)\n    if result:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkprefix"
    },
    {
        "text": "Number of ways to color boundary of each block of M * N table | Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Number of rows ; Number of columns",
        "context": "",
        "code": "def CountWays(N, M):\n    count = 1\n    count = pow(3, M + N)\n    count *= pow(2, M * N)\n    return count\n",
        "test": "\nN = 3\nM = 2\nprint(CountWays(N, M))\n",
        "output": "15552\n",
        "fn_call": "CountWays"
    },
    {
        "text": "maximum number of people that can be killed with strength p | python3 implementation of the approach ; function to return the maximum number of people that can be killed ; storing the sum beforehand so that it can be used in each query ; lower_bound returns an iterator pointing to the first element greater than or equal to your val ; previous value ; returns the index in array upto which killing is possible with strength p ; ",
        "context": "\nkN = 1000000\n\n",
        "code": "def lower_bound(a, low, high, element):\n    while (low < high):\n        middle = int(low + (high - low) / 2)\n        if (element > a[middle]):\n            low = middle + 1\n        else:\n            high = middle\n    return low\n\n\ndef maxPeople(p):\n    sums = [0] * kN\n    sums[0] = 0\n    for i in range(1, kN):\n        sums[i] = (i * i) + sums[i - 1]\n    it = lower_bound(sums, 0, kN, p)\n    if (it > p):\n        it -= 1\n    return it\n",
        "test": "\nif __name__ == '__main__':\n    p = 14\n    print(maxPeople(p))\n",
        "output": "3\n",
        "fn_call": "maxPeople"
    },
    {
        "text": "Program to find Sum of the series 1 * 3 + 3 * 5 + ... . | Python program to find sum of first n terms ; Sn = n * ( 4 * n * n + 6 * n - 1 ) / 3 ; number of terms to be included in the sum ; find the Sn",
        "context": "",
        "code": "def calculateSum(n):\n    return (n * (4 * n * n + 6 * n - 1) / 3)\n",
        "test": "\nn = 4\nprint(\"Sum =\", calculateSum(n))\n",
        "output": "Sum = 116.0\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "smallest integer with digit sum m and multiple of n | python 3 implementation of the above approach ; function to return digit sum ; function to find out the smallest integer ; start of the iterator ( smallest multiple of n ) ; ",
        "context": "\nfrom math import floor, pow\nimport sys\n\n",
        "code": "def digitSum(n):\n    ans = 0\n    while (n):\n        ans += n % 10\n        n = int(n / 10)\n    return ans\n\n\ndef findInt(n, m):\n    minDigit = floor(m / 9)\n    start = (int(pow(10, minDigit)) - int(pow(10, minDigit)) % n)\n    while (start < sys .maxsize):\n        if (digitSum(start) == m):\n            return start\n        else:\n            start += n\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    n = 13\n    m = 32\n    print(findInt(n, m))\n",
        "output": "8879\n",
        "fn_call": "findInt"
    },
    {
        "text": "count of n | function to return the count of such numbers ; for 1 - digit numbers , the count is 10 irrespective of k ; dp [ j ] stores the number of such i - digit numbers ending with j ; stores the results of length i ; initialize count for 1 - digit numbers ; compute values for count of digits greater than 1 ; find the range of allowed numbers if last digit is j ; perform range update ; prefix sum to find actual count of i - digit numbers ending with j ; update dp [ ] ; stores the final answer ; return the final answer ; ",
        "context": "",
        "code": "def getCount(n, K):\n    if (n == 1):\n        return 10\n    dp = [0] * 11\n    next = [0] * 11\n    for i in range(1, 9 + 1):\n        dp[i] = 1\n    for i in range(2, n + 1):\n        for j in range(9 + 1):\n            l = max(0, j - k)\n            r = min(9, j + k)\n            next[l] += dp[j]\n            next[r + 1] -= dp[j]\n        for j in range(1, 9 + 1):\n            next[j] += next[j - 1]\n        for j in range(10):\n            dp[j] = next[j]\n            next[j] = 0\n    count = 0\n    for i in range(9 + 1):\n        count += dp[i]\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    k = 1\n    print(getCount(n, k))\n",
        "output": "26\n",
        "fn_call": "getCount"
    },
    {
        "text": "minimize difference between the largest and smallest array elements by k replacements | python3 program for above approach ; function to find minimum difference between the largest and smallest element after k replacements ; create a maxheap ; create a minheap ; update maxheap and minheap with highest and smallest k elements respectively ; insert current element into the maxheap ; if maxheap size exceeds k + 1 ; remove top element ; insert current element into the maxheap ; if maxheap size exceeds k + 1 ; remove top element ; store all max element from maxheap ; store all min element from minheap ; generating all k + 1 possibilities ; return answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def minDiff(A, K):\n    if (len(A) <= K + 1):\n        return 0\n    maxHeap = []\n    minHeap = []\n    for n in A:\n        maxHeap .append(n)\n        maxHeap .sort()\n        if (len(maxHeap) > K + 1):\n            del maxHeap[0]\n        minHeap .append(n)\n        minHeap .sort()\n        minHeap .reverse()\n        if (len(minHeap) > K + 1):\n            del minHeap[0]\n    maxList = []\n    while (len(maxHeap) > 0):\n        maxList .append(maxHeap[0])\n        del maxHeap[0]\n    minList = []\n    while (len(minHeap) > 0):\n        minList .append(minHeap[0])\n        del minHeap[0]\n    mindiff = sys .maxsize\n    for i in range(K):\n        mindiff = min(mindiff, maxList[i] - minList[K - i])\n    return mindiff\n",
        "test": "\nA = [-1, 3, -1, 8, 5, 4]\nK = 3\nprint(minDiff(A, K))\n",
        "output": "2\n",
        "fn_call": "minDiff"
    },
    {
        "text": "find out the correct position of the ball after shuffling | python3 implementation of the above approach ; function to generate the index of the glass containing the ball ; change the index ; change the index ; print the index ; ",
        "context": "\nM = 3\nN = 2\n\n",
        "code": "def getIndex(n, shuffle):\n    for i in range(3):\n        if (shuffle[i][0] == n):\n            n = shuffle[i][1]\n        elif (shuffle[i][1] == n):\n            n = shuffle[i][0]\n    print(n)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    shuffle = [[3, 1], [2, 1], [1, 2]]\n    getIndex(n, shuffle)\n",
        "output": "1\n",
        "fn_call": "getIndex"
    },
    {
        "text": "maximum number of overlapping rectangles with at least one common point | function to find the maximum number of overlapping rectangles ; stores the maximum count of overlapping rectangles ; stores the x and y coordinates ; iterate over all pairs of xs and ys ; store the count for the current x and y ; update the maximum count of rectangles ; returns the total count ; ",
        "context": "",
        "code": "def maxOverlappingRectangles(x1, y1, x2, y2, N):\n    max_rectangles = 0\n    X = []\n    Y = []\n    for i in range(0, N):\n        X .append(x1[i])\n        X .append(x2[i] - 1)\n        Y .append(y1[i])\n        Y .append(y2[i] - 1)\n    for i in range(0, len(X)):\n        for j in range(0, len(Y)):\n            cnt = 0\n            for k in range(0, N):\n                if (X[i] >= x1[k] and X[i] + 1 <= x2[k]\n                        and Y[j] >= y1[k] and Y[j] + 1 <= y2[k]):\n                    cnt += 1\n            max_rectangles = max(max_rectangles, cnt)\n    print(max_rectangles)\n",
        "test": "\nif __name__ == \"__main__\":\n    x1 = [0, 50]\n    y1 = [0, 50]\n    x2 = [100, 60]\n    y2 = [100, 60]\n    N = len(x1)\n    maxOverlappingRectangles(x1, y1, x2, y2, N)\n",
        "output": "2\n",
        "fn_call": "maxOverlappingRectangles"
    },
    {
        "text": "count rectangles generated in a given rectangle by lines drawn parallel to x and y axis from a given set of points | function to get the count of ractangles ; store distinct horizontal lines ; store distinct vertical lines ; insert horizontal line passing through 0 ; insert vertical line passing through 0. ; insert horizontal line passing through rectangle [ 3 ] [ 0 ] ; insert vertical line passing through rectangle [ 3 ] [ 1 ] ; insert all horizontal and vertical lines passing through the given array ; insert all horizontal lines ; insert all vertical lines ; ",
        "context": "",
        "code": "def cntRect(points, N, rectangle):\n    cntHor = set([])\n    cntVer = set([])\n    cntHor .add(0)\n    cntVer .add(0)\n    cntHor .add(rectangle[3][0])\n    cntVer .add(rectangle[3][1])\n    for i in range(N):\n        cntHor .add(points[i][0])\n        cntVer .add(points[i][1])\n    return ((len(cntHor) - 1) * (len(cntVer) - 1))\n",
        "test": "\nif __name__ == \"__main__\":\n    rectangle = [[0, 0], [0, 5], [5, 0], [5, 5]]\n    points = [[1, 2], [3, 4]]\n    N = len(points)\n    print(cntRect(points, N, rectangle))\n",
        "output": "9\n",
        "fn_call": "cntRect"
    },
    {
        "text": "partition a set into two subsets such that difference between max of one and min of other is minimized | function to split the array ; sort the array in increasing order ; calculating the max difference between consecutive elements ; return the final minimum difference ; ",
        "context": "",
        "code": "def splitArray(arr, N):\n    arr = sorted(arr)\n    result = 10 ** 9\n    for i in range(1, N):\n        result = min(result, arr[i] - arr[i - 1])\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 1, 2, 6, 4]\n    N = len(arr)\n    print(splitArray(arr, N))\n",
        "output": "1\n",
        "fn_call": "splitArray"
    },
    {
        "text": "count array elements whose count of divisors is a prime number | function to count the array elements whose count of divisors is prime ; stores the maximum element ; find the maximum element ; store if i - th element is prime ( 0 ) or non - prime ( 1 ) ; base case ; if i is a prime number ; mark all multiples of i as non - prime ; stores the count of divisors ; base case ; iterate to count factors ; stores the count of array elements whose count of divisors is a prime number ; traverse the array arr [ ] ; if count of divisors is prime ; return the resultant count ; ",
        "context": "",
        "code": "def primeDivisors(arr, N):\n    K = arr[0]\n    for i in range(1, N):\n        K = max(K, arr[i])\n    prime = [0] * (K + 1)\n    prime[0] = 1\n    prime[1] = 1\n    for i in range(2, K + 1):\n        if (not prime[i]):\n            for j in range(2 * i, K + 1, i):\n                prime[j] = 1\n    factor = [0] * (K + 1)\n    factor[0] = 0\n    factor[1] = 1\n    for i in range(2, K + 1):\n        factor[i] += 1\n        for j in range(i, K + 1, i):\n            factor[j] += 1\n    count = 0\n    for i in range(N):\n        if (prime[factor[arr[i]]] == 0):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 13, 17, 25]\n    N = len(arr)\n    print(primeDivisors(arr, N))\n",
        "output": "3\n",
        "fn_call": "primeDivisors"
    },
    {
        "text": "program to check if n is a icositrigonal number | python3 implementation to check that a number is a icositrigonal number or not ; function to check that the number is a icositrigonal number ; condition to check if the number is a icositrigonal number ; ",
        "context": "\nimport math\n\n",
        "code": "def isicositrigonal(N):\n    n = (19 + math .sqrt(168 * N + 361)) / 42\n    return (n - int(n)) == 0\n",
        "test": "\ni = 23\nif (isicositrigonal(i)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isicositrigonal"
    },
    {
        "text": "group multiple occurrence of array elements ordered by first occurrence | a hashing based method to group all occurrences of individual elements ; creates an empty hashmap ; traverse the array elements , and store count for every element in hashmap ; increment count of elements in hashmap ; traverse array again ; check if this is first occurrence ; if yes , then print the element ' count ' times ; and remove the element from hashmap . ; ",
        "context": "",
        "code": "def orderedGroup(arr):\n    hM = {}\n    for i in range(0, len(arr)):\n        hM[arr[i]] = hM .get(arr[i], 0) + 1\n    for i in range(0, len(arr)):\n        count = hM .get(arr[i], None)\n        if count is not None:\n            for j in range(0, count):\n                print(arr[i], end=\" \")\n            del hM[arr[i]]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 5, 3, 10, 10, 4, 1, 3]\n    orderedGroup(arr)\n",
        "output": "10 10 10 5 3 3 4 1 ",
        "fn_call": "orderedGroup"
    },
    {
        "text": "check if a non | utility function to check whether a subsequence same as the given subarray exists or not ; check if first element of the subarray is also present before ; check if last element of the subarray is also present later ; if above two conditions are not satisfied , then no such subsequence exists ; function to check and prif a subsequence which is same as the given subarray is present or not ; ",
        "context": "",
        "code": "def checkSubsequenceUtil(arr, L, R, N):\n    for i in range(L):\n        if (arr[i] == arr[L]):\n            return True\n    for i in range(R + 1, N, 1):\n        if (arr[i] == arr[R]):\n            return True\n    return False\n\n\ndef checkSubsequence(arr, L, R, N):\n    if (checkSubsequenceUtil(arr, L, R, N)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\narr = [1, 7, 12, 1, 7, 5, 10, 11, 42]\nN = len(arr)\nL = 3\nR = 6\ncheckSubsequence(arr, L, R, N)\n",
        "output": "YES\n",
        "fn_call": "checkSubsequence"
    },
    {
        "text": "create a graph by connecting divisors from n to m and find shortest path | python3 program for the above approach ; function to check the number is prime or not ; base cases ; iterate till [ 5 , sqrt ( n ) ] to detect primarility of numbers ; function to print the shortest path ; use vector to store the factor of m and n ; use map to check if largest common factor previously present or not ; first store m ; check whether m is prime or not ; largest common factor of m ; if m is divisible by i ; store the largest common factor ; for number n ; check whether n is prime ; largest common factor of n ; store the largest common factor ; print the path print factors from m ; to avoid duplicate printing of same element ; print the factors from n ; ",
        "context": "\nimport math\n\n",
        "code": "def isprm(n):\n    if (n <= 1):\n        return 0\n    if (n <= 3):\n        return 1\n    if (n % 2 == 0 or n % 3 == 0):\n        return 0\n    i = 5\n    while i * i <= n:\n        if (n % i == 0 or n % (i + 2) == 0):\n            return 0\n        i += 6\n    return 1\n\n\ndef shortestpath(m, n):\n    mfactor = []\n    nfactor = []\n    fre = dict .fromkeys(range(n + 1), 0)\n    mfactor .append(m)\n    fre[m] = 1\n    while (m != 1):\n        if (isprm(m)):\n            mfactor .append(1)\n            fre[1] = 1\n            m = 1\n        else:\n            sqt = (int)(math .sqrt(m))\n            for i in range(2, sqt + 1):\n                if (m % i == 0):\n                    mfactor .append(m // i)\n                    fre[m // i] = 1\n                    m = (m // i)\n                    break\n    nfactor .append(n)\n    while (fre[n] != 1):\n        if (isprm(n)):\n            nfactor .append(1)\n            n = 1\n        else:\n            sqt = (int)(math .sqrt(n))\n            for i in range(2, sqt + 1):\n                if (n % i == 0):\n                    nfactor .append(n // i)\n                    n = (n // i)\n                    break\n    for i in range(len(mfactor)):\n        if (mfactor[i] == n):\n            break\n        print(mfactor[i], end=\"  \")\n    for i in range(len(nfactor) - 1, -1, -1):\n        if (i == 0):\n            print(nfactor[i], end=\"\")\n        else:\n            print(nfactor[i], end=\"  \")\n",
        "test": "\nif __name__ == \"__main__\":\n    m = 18\n    n = 19\n    shortestpath(m, n)\n",
        "output": "18  9  3  1  19",
        "fn_call": "shortestpath"
    },
    {
        "text": "number of unique rectangles formed using n unit squares | python3 program to count rotationally equivalent rectangles with n unit squares ; height >= length is maintained ; ",
        "context": "\nimport math\n\n",
        "code": "def countRect(n):\n    ans = 0\n    for length in range(1, int(math .sqrt(n)) + 1):\n        height = length\n        while (height * length <= n):\n            ans += 1\n            height += 1\n    return ans\n",
        "test": "\nn = 5\nprint(countRect(n))\n",
        "output": "6\n",
        "fn_call": "countRect"
    },
    {
        "text": "count of 0 s to be flipped to make any two adjacent 1 s at least k 0 s apart | function to find the count of 0 s to be flipped ; loop traversal to mark k adjacent positions to the right of already existing 1 s . ; loop traversal to mark k adjacent positions to the left of already existing 1 s . ; loop to count the maximum number of 0 s that will be replaced by 1 s ; ",
        "context": "",
        "code": "def count(k, s):\n    ar = [0] * len(s)\n    end = 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            for j in range(i, len(s)):\n                if (j <= i + k):\n                    ar[j] = -1\n                    end = j\n            i = end\n    end = 0\n    for i in range(len(s) - 1, -1, -1):\n        if (s[i] == '1'):\n            for j in range(i, -1, -1):\n                if (j >= i - k):\n                    ar[j] = -1\n                    end = j\n            i = end\n    ans = 0\n    end = 0\n    for j in range(len(s)):\n        if (ar[j] == 0):\n            ans += 1\n            for g in range(j, len(s)):\n                if (g <= j + k):\n                    ar[g] = -1\n                    end = g\n            j = end - 1\n    return ans\n",
        "test": "\nK = 2\ns = \"000000\"\nprint(count(K, s))\n",
        "output": "2\n",
        "fn_call": "count"
    },
    {
        "text": "split the given array into k sub | function to check if mid can be maximum sub - arrays sum ; if individual element is greater maximum possible sum ; increase sum of current sub - array ; if the sum is greater than mid increase count ; check condition ; function to find maximum subarray sum which is minimum ; start = max ( array ) max subarray sum , considering subarray of length 1 ; answer stores possible maximum sub array sum ; if mid is possible solution put answer = mid ; ; ",
        "context": "",
        "code": "def check(mid, array, n, K):\n    count = 0\n    sum = 0\n    for i in range(n):\n        if (array[i] > mid):\n            return False\n        sum += array[i]\n        if (sum > mid):\n            count += 1\n            sum = array[i]\n    count += 1\n    if (count <= K):\n        return True\n    return False\n\n\ndef solve(array, n, K):\n\n    start = max(array)\n    end = 0\n\n    for i in range(n):\n        end += array[i]\n    answer = 0\n    while (start <= end):\n        mid = (start + end) // 2\n        if (check(mid, array, n, K)):\n            answer = mid\n            end = mid - 1\n        else:\n            start = mid + 1\n\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    array = [1, 2, 3, 4]\n    n = len(array)\n    K = 3\n    print(solve(array, n, K))\n",
        "output": "4\n",
        "fn_call": "solve"
    },
    {
        "text": "check whether a given number is even or odd | returns true if n is even , else odd ; ",
        "context": "",
        "code": "def isEven(n):\n    return (n % 2 == 0)\n",
        "test": "\nn = 101\nprint(\"Even\"if isEven(n)else \"Odd\")\n",
        "output": "Odd\n",
        "fn_call": "isEven"
    },
    {
        "text": "count prime numbers up to n that can be represented as a sum of two prime numbers | function to store all prime numbers up to n using sieve of eratosthenes ; set 0 and 1 as non - prime ; if p is prime ; set all multiples of p as non - prime ; function to count prime numbers up to n that can be represented as the sum of two prime numbers ; stores all the prime numbers ; update the prime array ; create a dp array of size n + 1 ; update dp [ 1 ] = 0 ; iterate over the range [ 2 , n ] ; add the previous count value ; increment dp [ i ] by 1 if i and ( i - 2 ) are both prime ; print the result ; ",
        "context": "",
        "code": "def SieveOfEratosthenes(n, prime):\n    prime[0] = 0\n    prime[1] = 0\n    p = 2\n    while p * p <= n:\n        if (prime[p]):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n\n\ndef countPrime(n):\n    prime = [True] * (n + 1)\n    SieveOfEratosthenes(n, prime)\n    dp = [0] * (n + 1)\n    dp[1] = 0\n    for i in range(2, n + 1):\n        dp[i] += dp[i - 1]\n        if (prime[i] == 1 and prime[i - 2] == 1):\n            dp[i] += 1\n    print(dp[n])\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    countPrime(N)\n",
        "output": "1\n",
        "fn_call": "countPrime"
    },
    {
        "text": "remove duplicates from a given string | python3 program to remove duplicate character from character array and prin sorted order ; used as index in the modified string ; traverse through all characters ; check if str [ i ] is present before it ; if not present , then add it to result . ; ",
        "context": "",
        "code": "def removeDuplicate(str, n):\n    index = 0\n    for i in range(0, n):\n        for j in range(0, i + 1):\n            if (str[i] == str[j]):\n                break\n        if (j == i):\n            str[index] = str[i]\n            index += 1\n    return \"\".join(str[:index])\n",
        "test": "\nstr = \"geeksforgeeks\"\nn = len(str)\nprint(removeDuplicate(list(str), n))\n",
        "output": "geksfor\n",
        "fn_call": "removeDuplicate"
    },
    {
        "text": "next word that does not contain a palindrome and has characters from first k | function to return lexicographically next word ; we made m as m + 97 that means our required string contains not more than m + 97 ( as per ascii value ) in it . ; increment last alphabet to make next lexicographically next word . ; if i - th alphabet not in first k letters then make it as \" a \" and then increase ( i - 1 ) th letter ; to check whether formed string palindrome or not . ; increment i . ; if i less than or equals to one that means we not formed such word . ; ",
        "context": "",
        "code": "def findNextWord(s, m):\n    m += 97\n    n = len(s)\n    i = len(s) - 1\n    s[i] = chr(ord(s[i]) + 1)\n    while i >= 0 and i <= n - 1:\n        if ord(s[i]) >= m:\n            s[i] = 'a'\n            i -= 1\n            s[i] = chr(ord(s[i]) + 1)\n        elif s[i] == s[i - 1] or s[i] == s[i - 2]:\n            s[i] = chr(ord(s[i]) + 1)\n        else:\n            i += 1\n    if i <= -1:\n        print(\"-1\")\n    else:\n        print(''.join(s))\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"abcd\"\n    k = 4\n    findNextWord(list(string), k)\n",
        "output": "abda\n",
        "fn_call": "findNextWord"
    },
    {
        "text": "perfect cube | function to check if a number is a perfect cube using inbuilt function ; if cube of cube_root is equals to n , then print yes else print no ; ",
        "context": "",
        "code": "def perfectCube(N):\n    cube_root = round(N ** (1 / 3))\n    if cube_root * cube_root * cube_root == N:\n        print(\"Yes\")\n        return\n    else:\n        print(\"NO\")\n        return\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 125\n    perfectCube(N)\n",
        "output": "Yes\n",
        "fn_call": "perfectCube"
    },
    {
        "text": "largest subtree sum for each vertex of given n | python3 program for the above approach ; function to perform the dfs traversal on the given tree ; to check if v is leaf vertex ; initialize answer for vertex v ; traverse adjacency list of v ; update maximum subtree sum ; if v is leaf ; function to calculate maximum subtree sum for each vertex ; add edegs to the list ; calculate answer ; prthe result ; ",
        "context": "\nV = 3\nM = 2\n\n",
        "code": "def dfs(v, p):\n    isLeaf = 1\n    ans[v] = -10 ** 9\n    for u in adj[v]:\n        if (u == p):\n            continue\n        isLeaf = 0\n        dfs(u, v)\n        ans[v] = max(ans[u] + vals[v], max(ans[u], vals[u]))\n    if (isLeaf):\n        ans[v] = vals[v]\n\n\ndef printAnswer(n, edges, vals):\n    for i in range(n - 1):\n        u = edges[i][0] - 1\n        v = edges[i][1] - 1\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0, -1)\n    for x in ans:\n        print(x, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    edges = [[1, 2], [1, 3], [3, 4]]\n    adj = [[]for i in range(N)]\n    ans = [0 for i in range(N)]\n    vals = [1, -1, 0, 1]\n    printAnswer(N, edges, vals)\n",
        "output": "2 -1 1 1 ",
        "fn_call": "printAnswer"
    },
    {
        "text": "count numbers formed by given two digit with sum having given digits | python 3 program to count the number of numbers formed by digits a and b exactly of a length n such that the sum of the digits of the number thus formed is of digits a and b . ; function to check if sum of digits is made of a and b ; sum of digits is 0 ; if any of digits in sum is other than a and b ; calculate the modinverse v of a number in o ( log n ) ; q is quotient ; m is remainder now , process same as euclid 's algo ; update y and x ; make x positive ; function to pregenerate factorials ; function to pre calculate the modinverse of factorials ; calculates the modinverse of the last factorial ; precalculates the modinverse of all factorials by formulae ; function that returns the value of nci ; function that returns the count of numbers ; function call to pre - calculate the factorials and modinverse of factorials ; if a and b are same ; ",
        "context": "\nmod = 1000000007\nN = 1000005\nfact = [0] * N\ninvfact = [0] * N\n\n",
        "code": "def check(x, a, b):\n    if (x == 0):\n        return 0\n    while (x):\n        if (x % 10 != a and x % 10 != b):\n            return 0\n        x //= 10\n    return 1\n\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if (m == 1):\n        return 0\n    while (a > 1):\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if (x < 0):\n        x += m0\n    return x\n\n\ndef pregenFact():\n    fact[0] = fact[1] = 1\n    for i in range(1, 1000001):\n        fact[i] = fact[i - 1] * i % mod\n\n\ndef pregenInverse():\n    invfact[0] = invfact[1] = 1\n    invfact[1000000] = modInverse(fact[1000000], mod)\n    for i in range(999999, 0, -1):\n        invfact[i] = ((invfact[i + 1] * (i + 1)) % mod)\n\n\ndef comb(big, small):\n    return (fact[big] * invfact[small] % mod * invfact[big - small] % mod)\n\n\ndef count(a, b, n):\n    pregenFact()\n    pregenInverse()\n    if (a == b):\n        return (check(a * n, a, b))\n    ans = 0\n    for i in range(n + 1):\n        if (check(i * a + (n - i) * b, a, b)):\n            ans = (ans + comb(n, i)) % mod\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 3\n    b = 4\n    n = 11028\n    print(count(a, b, n))\n",
        "output": "461668105\n",
        "fn_call": "count"
    },
    {
        "text": "count pairs from two sorted arrays whose sum is equal to a given value x | function to search ' value ' in the given array ' arr [ ] ' it uses binary search technique as ' arr [ ] ' is sorted ; value found ; value not found ; function to count all pairs from both the sorted arrays whose sum is equal to a given value ; for each arr1 [ i ] ; check if the ' value ' is present in 'arr2[]   ; required count of pairs ; ",
        "context": "",
        "code": "def isPresent(arr, low, high, value):\n    while (low <= high):\n        mid = (low + high) // 2\n        if (arr[mid] == value):\n            return True\n        elif (arr[mid] > value):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return False\n\n\ndef countPairs(arr1, arr2, m, n, x):\n    count = 0\n    for i in range(m):\n        value = x - arr1[i]\n        if (isPresent(arr2, 0, n - 1, value)):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 3, 5, 8]\n    m = len(arr1)\n    n = len(arr2)\n    x = 10\n    print(\"Count = \", countPairs(arr1, arr2, m, n, x))\n",
        "output": "Count =  2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "length of all prefixes that are also the suffixes of given string | function to find the length of all prefixes of the given that are also suffixes of the same string ; stores the prefix string ; traverse the s ; add the current character to the prefix string ; store the suffix string ; check if both the strings are equal or not ; ",
        "context": "",
        "code": "def countSamePrefixSuffix(s, n):\n    prefix = \"\"\n    for i in range(n - 1):\n        prefix += s[i]\n        suffix = s[n - 1 - i:2 * n - 2 - i]\n        if (prefix == suffix):\n            print(len(prefix), end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"ababababab\"\n    N = len(S)\n    countSamePrefixSuffix(S, N)\n",
        "output": "2 4 6 8 ",
        "fn_call": "countSamePrefixSuffix"
    },
    {
        "text": "find number of edges that can be broken in a tree such that bitwise or of resulting two trees are equal | python3 implementation of the approach ; function to perform simple dfs ; finding the number of times each bit is set in all the values of a subtree rooted at v ; checking for each bit whether the numbers with that particular bit as set are either zero in both the resulting trees or greater than zero in both the resulting trees ; ",
        "context": "\nm, x = [0] * 1000, [0] * 22\na = [[0 for i in range(22)]for j in range(1000)]\nans = 0\n\n",
        "code": "def dfs(u, p):\n    global ans\n    for i in range(0, len(g[u])):\n        v = g[u][i]\n        if v != p:\n            dfs(v, u)\n            for i in range(0, 22):\n                a[u][i] += a[v][i]\n    pp = 0\n    for i in range(0, 22):\n        if (not ((a[u][i] > 0 and x[i] - a[u][i] > 0)\n                 or (a[u][i] == 0 and x[i] == 0))):\n            pp = 1\n            break\n    if pp == 0:\n        ans += 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    g = [[]for i in range(n + 1)]\n    m[1] = 1\n    m[2] = 3\n    m[3] = 2\n    m[4] = 3\n    for i in range(1, n + 1):\n        y, k = m[i], 0\n        while y != 0:\n            p = y % 2\n            if p == 1:\n                x[k] += 1\n                a[i][k] += 1\n            y = y // 2\n            k += 1\n    g[1].append(2)\n    g[2].append(1)\n    g[1].append(3)\n    g[3].append(1)\n    g[1].append(4)\n    g[4].append(1)\n    dfs(1, 0)\n    print(ans)\n",
        "output": "2\n",
        "fn_call": "dfs"
    },
    {
        "text": "minimum removals to make array sum odd | function to find minimum removals ; count odd numbers ; if the counter is odd return 0 otherwise return 1 ; ",
        "context": "",
        "code": "def findCount(arr, n):\n    countOdd = 0\n    for i in range(n):\n        if (arr[i] % 2 == 1):\n            countOdd += 1\n    if (countOdd % 2 == 0):\n        return 1\n    else:\n        return 0\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 5, 1]\n    n = len(arr)\n    print(findCount(arr, n))\n",
        "output": "1\n",
        "fn_call": "findCount"
    },
    {
        "text": "count even and odd bitwise xors of consecutive numbers in a range [ l , r ] starting from l | prcount of even and odd numbers of xor value from l to r ; store the number of elements between l and r ; count of even xor values ; if l is odd and range % 4 = 3 ; increment even by 1 ; if l is even and range % 4 != 0 ; increment even by 1 ; prthe answer ; ",
        "context": "",
        "code": "def countEvenOdd(L, R):\n    range = R - L + 1\n    even = (range // 4) * 2\n    if ((L & 1) != 0 and (range % 4 == 3)):\n        even += 1\n    elif ((L & 1) == 0 and (range % 4 != 0)):\n        even += 1\n    print(\"Even = \", even, \", Odd = \", (range - even))\n",
        "test": "\nif __name__ == '__main__':\n    L = 2\n    R = 7\n    countEvenOdd(L, R)\n",
        "output": "Even =  3 , Odd =  3\n",
        "fn_call": "countEvenOdd"
    },
    {
        "text": "last digit of product of two large or small numbers ( a * b ) | function to print the last digit of product a * b ; ",
        "context": "",
        "code": "def lastDigit(a, b):\n    lastDig = ((int(a[len(a) - 1]) - int('0'))\n               * (int(b[len(b) - 1]) - int('0')))\n    print(lastDig % 10)\n",
        "test": "\nif __name__ == '__main__':\n    a, b = \"1234567891233\", \"1234567891233156\"\n    lastDigit(a, b)\n",
        "output": "8\n",
        "fn_call": "lastDigit"
    },
    {
        "text": "maximum sum of all elements of array after performing given operations | python3 program to find the maximum sum after given operations ; function to calculate maximum subarray sum or kadane 's algorithm ; function to find the maximum sum after given operations ; to store sum of all elements ; maximum sum of a subarray ; calculate the sum of all elements ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxSubArraySum(a, size):\n    max_so_far = -(sys .maxsize - 1)\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        if (max_ending_here < 0):\n            max_ending_here = 0\n    return max_so_far\n\n\ndef maxSum(a, n):\n    S = 0\n    S1 = maxSubArraySum(a, n)\n    for i in range(n):\n        S += a[i]\n    return (2 * S1 - S)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [-35, 32, -24, 0, 27, -10, 0, -19]\n    n = len(a)\n    print(maxSum(a, n))\n",
        "output": "99\n",
        "fn_call": "maxSum"
    },
    {
        "text": "find the kth number which is not divisible by n | python3 implementation for above approach ; function to find the kth not divisible by n ; lowest possible value ; highest possible value ; to store the kth non divisible number of n ; using binary search ; calculating mid value ; sol would have the value by subtracting all multiples of n till mid ; check if sol is greater than k ; h should be reduced to find minimum possible value ; check if sol is less than k then l will be mid + 1 ; check if sol is equal to k ; ans will be mid ; h would be reduced to find any more possible value ; print the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def kthNonDivisible(N, K):\n    L = 1\n    H = sys .maxsize\n    ans = 0\n    while (L <= H):\n        mid = (L + H) // 2\n        sol = mid - mid // N\n        if (sol > K):\n            H = mid - 1\n        elif (sol < K):\n            L = mid + 1\n        else:\n            ans = mid\n            H = mid - 1\n    print(ans)\n",
        "test": "\nN = 3\nK = 7\nkthNonDivisible(N, K)\n",
        "output": "10\n",
        "fn_call": "kthNonDivisible"
    },
    {
        "text": "maximum games played by winner | method returns maximum games a winner needs to play in n - player tournament ; for 0 games , 1 player is needed for 1 game , 2 players are required ; loop until i - th fibonacci number is less than or equal to n ; result is ( i - 1 ) because i will be incremented one extra in while loop and we want the last value which is smaller than n , so ; ",
        "context": "",
        "code": "def maxGameByWinner(N):\n    dp = [0 for i in range(N)]\n    dp[0] = 1\n    dp[1] = 2\n    i = 1\n    while dp[i] <= N:\n        i = i + 1\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return (i - 1)\n",
        "test": "\nN = 10\nprint(maxGameByWinner(N))\n",
        "output": "4\n",
        "fn_call": "maxGameByWinner"
    },
    {
        "text": "count pair of strings whose concatenation has every vowel | function to return the count of all concatenated string with each vowel at least once ; concatenating all possible pairs of string ; creating an array which checks , the presence of each vowel ; checking for each vowel by traversing the concatenated string ; checking if all the elements are set in vowel [ ] ; check if all vowels are present or not ; return the final count ; ",
        "context": "",
        "code": "def good_pair(st, N):\n    countStr = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            res = st[i] + st[j]\n            vowel = [0] * 5\n            for k in range(len(res)):\n                if (res[k] == 'a'):\n                    vowel[0] = 1\n                elif (res[k] == 'e'):\n                    vowel[1] = 1\n                elif (res[k] == 'i'):\n                    vowel[2] = 1\n                elif (res[k] == 'o'):\n                    vowel[3] = 1\n                elif (res[k] == 'u'):\n                    vowel[4] = 1\n            temp = 0\n            for ind in range(5):\n                if (vowel[ind] == 1):\n                    temp += 1\n            if (temp == 5):\n                countStr += 1\n    return countStr\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"aaweiolkju\", \"oxdfgujkmi\"]\n    N = len(arr)\n    print(good_pair(arr, N))\n",
        "output": "1\n",
        "fn_call": "good_pair"
    },
    {
        "text": "program to find nth term of series 0 , 7 , 18 , 33 , 51 , 75 , 102 , 133 , ... . . | calculate nth term of series ; ",
        "context": "",
        "code": "def nthTerm(n):\n    return 2 * pow(n, 2) + n - 3\n",
        "test": "\nN = 4\nprint(nthTerm(N))\n",
        "output": "33\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "number of n length sequences whose product is m | function to calculate the value of ncr effectively ; initializing the result ; multiply and divide simultaneously to avoid overflow ; return the answer ; function to return the number of sequences of length n such that their product is m ; hashmap to store the prime factors of m ; calculate the prime factors of m ; if i divides m it means it is a factor divide m by i till it could be divided to store the exponent ; increase the exponent count ; if the number is a prime number greater than sqrt ( m ) ; initializing the ans ; multiply the answer for every prime factor ; it . second represents the exponent of every prime factor ; return the result ; ",
        "context": "",
        "code": "def ncr(n, r):\n    res = 1\n    for i in range(1, r + 1):\n        res *= (n - r + i)\n        res //= i\n    return res\n\n\ndef NoofSequences(N, M):\n    prime = {}\n    for i in range(2, int(M ** (.5)) + 1):\n        while (M % i == 0):\n            prime[i] = prime .get(i, 0) + 1\n            M //= i\n    if (M > 1):\n        prime[M] = prime .get(M, 0) + 1\n    ans = 1\n    for it in prime:\n        ans *= (ncr(N + prime[it] - 1, N - 1))\n    return ans\n",
        "test": "\nN = 2\nM = 6\nprint(NoofSequences(N, M))\n",
        "output": "4\n",
        "fn_call": "NoofSequences"
    },
    {
        "text": "program for worst fit algorithm in memory management | function to allocate memory to blocks as per worst fit algorithm ; initially no block is assigned to any process ; pick each process and find suitable blocks according to its size ad assign to it ; find the best fit block for current process ; if we could find a block for current process ; allocate block j to p [ i ] process ; reduce available memory in this block . ; ",
        "context": "",
        "code": "def worstFit(blockSize, m, processSize, n):\n    allocation = [-1] * n\n    for i in range(n):\n        wstIdx = -1\n        for j in range(m):\n            if blockSize[j] >= processSize[i]:\n                if wstIdx == -1:\n                    wstIdx = j\n                elif blockSize[wstIdx] < blockSize[j]:\n                    wstIdx = j\n        if wstIdx != -1:\n            allocation[i] = wstIdx\n            blockSize[wstIdx] -= processSize[i]\n    print(\"Process No. Process Size Block no.\")\n    for i in range(n):\n        print(i + 1, \" \", processSize[i], end=\" \")\n        if allocation[i] != -1:\n            print(allocation[i] + 1)\n        else:\n            print(\"Not Allocated\")\n",
        "test": "\nif __name__ == '__main__':\n    blockSize = [100, 500, 200, 300, 600]\n    processSize = [212, 417, 112, 426]\n    m = len(blockSize)\n    n = len(processSize)\n    worstFit(blockSize, m, processSize, n)\n",
        "output": "Process No. Process Size Block no.\n1   212 5\n2   417 2\n3   112 5\n4   426 Not Allocated\n",
        "fn_call": "worstFit"
    },
    {
        "text": "print ' k ' th least significant bit of a number | function returns 1 if set , 0 if not ; ",
        "context": "",
        "code": "def LSB(num, K):\n    return bool(num & (1 << (K - 1)))\n",
        "test": "\nnum, k = 10, 4\nres = LSB(num, k)\nif res:\n    print(1)\nelse:\n    print(0)\n",
        "output": "1\n",
        "fn_call": "LSB"
    },
    {
        "text": "generate all binary strings of length n with sub | utility function to print the given binary string ; this function will be called recursively to generate the next bit for given binary string according to its current state ; base - case : if the generated binary string meets the required length and the pattern \"01\" appears twice ; nextbit needs to be 0 because each time we call the function recursively , we call 2 times for 2 cases : next bit is 0 or 1 the is to assure that the binary string is printed one time only ; generate the next bit for str and call recursive ; assign first bit ; the next generated bit will either be 0 or 1 ; if pattern \"01\" occurrence is < 2 ; set next bit ; if pattern \"01\" appears then increase the occurrence of pattern ; else pattern \"01\" occurrence equals 2 ; if previous bit is 0 then next bit cannot be 1 ; otherwise ; ",
        "context": "",
        "code": "def printBinStr(string, length):\n    for i in range(0, length):\n        print(string[i], end=\"\")\n    print()\n\n\ndef generateBinStr(string, length, currlen, occur, nextbit):\n    if currlen == length:\n        if occur == 2 and nextbit == 0:\n            printBinStr(string, length)\n        return\n    if currlen == 0:\n        string[0] = nextbit\n        generateBinStr(string, length, currlen + 1, occur, 0)\n        generateBinStr(string, length, currlen + 1, occur, 1)\n    else:\n        if occur < 2:\n            string[currlen] = nextbit\n            if string[currlen - 1] == 0 and nextbit == 1:\n                occur += 1\n            generateBinStr(string, length, currlen + 1, occur, 0)\n            generateBinStr(string, length, currlen + 1, occur, 1)\n        else:\n            if string[currlen - 1] == 0 and nextbit == 1:\n                return\n            else:\n                string[currlen] = nextbit\n                generateBinStr(string, length, currlen + 1, occur, 0)\n                generateBinStr(string, length, currlen + 1, occur, 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    if n < 4:\n        print(-1)\n    else:\n        string = [None] * n\n        generateBinStr(string, n, 0, 0, 0)\n        generateBinStr(string, n, 0, 0, 1)\n",
        "output": "00101\n01001\n01010\n01011\n01101\n10101\n",
        "fn_call": "generateBinStr"
    },
    {
        "text": "find the nth term of the series 0 , 8 , 64 , 216 , 512 , . . . | function to return the nth term of the given series ; common difference ; first term ; nth term ; nth term of the given series ; ",
        "context": "",
        "code": "def term(n):\n    d = 2\n    a1 = 0\n    An = a1 + (n - 1) * d\n    An = An ** 3\n    return An\n",
        "test": "\nn = 5\nprint(term(n))\n",
        "output": "512\n",
        "fn_call": "term"
    },
    {
        "text": "How to validate an IP address using ReGex | Python3 program to validate IP address using Regex ; Function for Validating IP ; Regex expression for validating IPv4 ; Regex expression for validating IPv6 ; Checking if it is a valid IPv4 addresses ; Checking if it is a valid IPv6 addresses ; Return Invalid ; IP addresses to validate",
        "context": "\nimport re\n\n",
        "code": "def Validate_It(IP):\n    regex = \"(([0-9] [1-9][0-9] 1[0-9][0-9] 2[0-4][0-9] 25[0-5])\\.){3}\" \"([0-9] [1-9][0-9] 1[0-9][0-9] 2[0-4][0-9] 25[0-5])\"\n    regex1 = \"((([0-9a-fA-F]){1,4})\\:){7}\"\n    p = re .compile(regex)\n    p1 = re .compile(regex1)\n    if (re .search(p, IP)):\n        return \"Valid IPv4\"\n    elif (re .search(p1, IP)):\n        return \"Valid IPv6\"\n    return \"Invalid IP\"\n",
        "test": "\nIP = \"203.120.223.13\"\nprint(Validate_It(IP))\nIP = \"fffe:3465:efab:23fe:2235:6565:aaab:0001\"\nprint(Validate_It(IP))\nIP = \"2F33:12a0:3Ea0:0302\"\nprint(Validate_It(IP))\n",
        "output": "Invalid IP\nValid IPv6\nInvalid IP\n",
        "fn_call": "Validate_It"
    },
    {
        "text": "modular exponentiation ( recursive ) | recursive python program to compute modular power ; base cases ; if b is even ; if b is odd ; ",
        "context": "",
        "code": "def exponentMod(A, B, C):\n    if (A == 0):\n        return 0\n    if (B == 0):\n        return 1\n    y = 0\n    if (B % 2 == 0):\n        y = exponentMod(A, B / 2, C)\n        y = (y * y) % C\n    else:\n        y = A % C\n        y = (y * exponentMod(A, B - 1, C) % C) % C\n    return ((y + C) % C)\n",
        "test": "\nA = 2\nB = 5\nC = 13\nprint(\"Power is\", exponentMod(A, B, C))\n",
        "output": "Power is 6\n",
        "fn_call": "exponentMod"
    },
    {
        "text": "program for next fit algorithm in memory management | function to allocate memory to blocks as per next fit algorithm ; initially no block is assigned to any process ; pick each process and find suitable blocks according to its size ad assign to it ; do not start from beginning ; allocate block j to p [ i ] process ; reduce available memory in this block . ; mod m will help in traversing the blocks from starting block after we reach the end . ; ",
        "context": "",
        "code": "def NextFit(blockSize, m, processSize, n):\n    allocation = [-1] * n\n    j = 0\n    for i in range(n):\n        while j < m:\n            if blockSize[j] >= processSize[i]:\n                allocation[i] = j\n                blockSize[j] -= processSize[i]\n                break\n            j = (j + 1) % m\n    print(\"Process No. Process Size Block no.\")\n    for i in range(n):\n        print(i + 1, \" \", processSize[i], end=\" \")\n        if allocation[i] != -1:\n            print(allocation[i] + 1)\n        else:\n            print(\"Not Allocated\")\n",
        "test": "\nif __name__ == '__main__':\n    blockSize = [5, 10, 20]\n    processSize = [10, 20, 5]\n    m = len(blockSize)\n    n = len(processSize)\n    NextFit(blockSize, m, processSize, n)\n",
        "output": "Process No. Process Size Block no.\n1   10 2\n2   20 3\n3   5 1\n",
        "fn_call": "NextFit"
    },
    {
        "text": "lexicographically smallest string formed repeatedly deleting character from substring 10 | function to find smallest lexicogra - phically smallest string ; stores the index of last occuring 0 ; stores the lexicographically smallest string ; traverse the s ; if str [ i ] is 0 ; assign i to lastze ; traverse the str ; if i is less than or equal to lastze and str [ i ] is 0 ; if i is greater than lastze ; return ans ; ",
        "context": "",
        "code": "def lexicographicallySmallestString(S, N):\n    LastZe = -1\n    ans = \"\"\n    for i in range(N - 1, -1, -1):\n        if (S[i] == '0'):\n            LastZe = i\n            break\n    for i in range(N):\n        if (i <= LastZe and S[i] == '0'):\n            ans += S[i]\n        elif (i > LastZe):\n            ans += S[i]\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    S = \"11001101\"\n    N = len(S)\n    print(lexicographicallySmallestString(S, N))\n",
        "output": "0001\n",
        "fn_call": "lexicographicallySmallestString"
    },
    {
        "text": "find a number in minimum steps | python3 program to find a number in minimum steps ; steps sequence ; current sum ; sign of the number ; basic steps required to get sum >= required value . ; if we have reached ahead to destination . ; if the last step was an odd number , then it has following mechanism for negating a particular number and decreasing the sum to required number also note that it may require 1 more step in order to reach the sum . ; if the current time instance is even and sum is odd than it takes 2 more steps and few negations in previous elements to reach there . ; ",
        "context": "",
        "code": "def find(n):\n    ans = []\n    Sum = 0\n    i = 0\n    sign = 0\n    if (n >= 0):\n        sign = 1\n    else:\n        sign = -1\n    n = abs(n)\n    i = 1\n    while (Sum < n):\n        ans .append(sign * i)\n        Sum += i\n        i += 1\n    if (Sum > sign * n):\n        if (i % 2 != 0):\n            Sum -= n\n            if (Sum % 2 != 0):\n                ans .append(sign * i)\n                Sum += i\n                i += 1\n            ans[int(Sum / 2) - 1] *= -1\n        else:\n            Sum -= n\n            if (Sum % 2 != 0):\n                Sum -= 1\n                ans .append(sign * i)\n                ans .append(sign * -1 * (i + 1))\n            ans[int((sum / 2)) - 1] *= -1\n    return ans\n",
        "test": "\nn = 20\nif (n == 0):\n    print(\"MinimumnumberofSteps:0Stepsequence:0\")\nelse:\n    a = find(n)\n    print(\"Minimum number of Steps:\", len(a))\n    print(\"Step sequence:\")\n    print(*a, sep=\" \")\n",
        "output": "Minimum number of Steps: 7\nStep sequence:\n1 2 3 -4 5 6 7\n",
        "fn_call": "find"
    },
    {
        "text": "Sum of all Perfect numbers lying in the range [ L , R ] | Python3 implementation to find the sum of all perfect numbers lying in the range [ L , R ] ; Array to store the sum ; Function to check if a number is a perfect number or not ; Iterating till the square root of the number and checking if the sum of divisors is equal to the number or not ; If it is a perfect number , then return the number ; Else , return 0 ; Function to precompute the sum of perfect squares and store then in an array",
        "context": "\nfrom math import sqrt\npref = [0] * 10000\n\n",
        "code": "def isPerfect(n):\n    sum = 1\n    for i in range(2, int(sqrt(n)) + 1):\n        if (n % i == 0):\n            if (i * i != n):\n                sum = sum + i + n // i\n            else:\n                sum = sum + i\n    if (sum == n and n != 1):\n        return n\n    return 0\n\n\ndef precomputation():\n    for i in range(1, 10000):\n        pref[i] = pref[i - 1] + isPerfect(i)\n",
        "test": "\nif __name__ == \"__main__\":\n    L = 6\n    R = 28\n    precomputation()\n    print(pref[R] - pref[L - 1])\n",
        "output": "34\n",
        "fn_call": "precomputation"
    },
    {
        "text": "reverse the given string in the range [ l , r ] | function to return the string after reversing characters in the range [ l , r ] ; invalid range ; while there are characters to swap ; swap ( str [ l ] , str [ r ] ) ; ",
        "context": "",
        "code": "def reverse(string, length, l, r):\n    if (l = length or l > r):\n        return string\n    string = list(string)\n    while (l < r):\n        c = string[l]\n        string[l] = string[r]\n        string[r] = c\n        l += 1\n        r -= 1\n    return \"\".join(string)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    length = len(string)\n    l = 5\n    r = 7\n    print(reverse(string, length, l, r))\n",
        "output": "geeksrofgeeks\n",
        "fn_call": "reverse"
    },
    {
        "text": "maximum difference between node and its ancestor in a directed acyclic graph ( dag ) | python3 program for the above approach ; function to perform dfs traversal on the given graph ; update the value of ans ; update the currentmin and currentmax ; traverse the adjacency list of the node src ; recursively call for the child node ; function to calculate maximum absolute difference between a node and its ancestor ; stores the adjacency list of graph ; create adjacency list ; add a directed edge ; perform dfs traversal ; print the maximum absolute difference ; ",
        "context": "\nans = 0\n\n",
        "code": "def DFS(src, Adj, arr, currentMin, currentMax):\n    global ans\n    ans = max(ans,\n              max(abs(currentMax - arr[src - 1]),\n                  abs(currentMin - arr[src - 1])))\n    currentMin = min(currentMin, arr[src - 1])\n    currentMax = min(currentMax, arr[src - 1])\n    for child in Adj[src]:\n        DFS(child, Adj, arr, currentMin, currentMax)\n\n\ndef getMaximumDifference(Edges, arr, N, M):\n    global ans\n    Adj = [[]for i in range(N + 1)]\n    for i in range(M):\n        u = Edges[i][0]\n        v = Edges[i][1]\n        Adj[u].append(v)\n    DFS(1, Adj, arr, arr[0], arr[0])\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    M = 4\n    Edges = [[1, 2], [2, 3], [4, 5], [1, 3]]\n    arr = [13, 8, 3, 15, 18]\n    getMaximumDifference(Edges, arr, N, M)\n",
        "output": "10\n",
        "fn_call": "getMaximumDifference"
    },
    {
        "text": "minimum removals required to make any interval equal to the union of the given set | function to count minimum number of removals required to make an interval equal to the union of the given set ; stores the minimum number of removals ; traverse the set ; left boundary ; right boundary ; stores count of intervals lying within current interval ; traverse over all remaining intervals ; check if interval lies within the current interval ; increase count ; update minimum removals required ; ",
        "context": "",
        "code": "def findMinDeletions(v, n):\n    minDel = 10 ** 18\n    for i in range(n):\n        L = v[i][0]\n        R = v[i][1]\n        Count = 0\n        for j in range(n):\n            if (v[j][1] >= L and v[j][0] <= R):\n                Count += 1\n        minDel = min(minDel, n - Count)\n    return minDel\n",
        "test": "\nif __name__ == '__main__':\n    v = []\n    v .append([1, 3])\n    v .append([4, 12])\n    v .append([5, 8])\n    v .append([13, 2])\n    N = len(v)\n    print(findMinDeletions(v, N))\n",
        "output": "2\n",
        "fn_call": "findMinDeletions"
    },
    {
        "text": "print all safe primes below n | python 3 implementation of the approach ; function to print first n safe primes ; initialize all entries of integer array as 1. a value in prime [ i ] will finally be 0 if i is not a prime , else 1 ; 0 and 1 are not primes ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; if i is prime ; 2 p + 1 ; if 2 p + 1 is also a prime then set prime [ 2 p + 1 ] = 2 ; i is a safe prime ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def printSafePrimes(n):\n    prime = [0 for i in range(n + 1)]\n    for i in range(2, n + 1):\n        prime[i] = 1\n    prime[0] = prime[1] = 0\n    for p in range(2, int(sqrt(n)) + 1, 1):\n        if (prime[p] == 1):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = 0\n    for i in range(2, n + 1, 1):\n        if (prime[i] != 0):\n            temp = (2 * i) + 1\n            if (temp <= n and prime[temp] != 0):\n                prime[temp] = 2\n    for i in range(5, n + 1):\n        if (prime[i] == 2):\n            print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    n = 20\n    printSafePrimes(n)\n",
        "output": "5 7 11 ",
        "fn_call": "printSafePrimes"
    },
    {
        "text": "find maximum gcd value from root to leaf in a binary tree | initialise to update the maximum gcd value from all the path ; node structure ; initialize constructor ; function to find gcd of a and b ; function to find the gcd of a path ; function to find the maximum value of gcd from root to leaf in a binary tree ; check if root is not null ; find the maximum gcd of path value and store in global maxm variable ; traverse left of binary tree ; traverse right of the binary tree ; ",
        "context": "\nglobal maxm\nmaxm = 0\n\n\nclass Node:\n    def __init__(self, x):\n        self .val = x\n        self .left = None\n        self .right = None\n\n",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef find_gcd(arr):\n    if (len(arr) == 1):\n        return arr[0]\n    g = arr[0]\n    for i in range(1, len(arr)):\n        g = gcd(g, arr[i])\n    return g\n\n\ndef maxm_gcd(root, ans):\n    global maxm\n    if (not root):\n        return\n    if (root .left is None and root .right is None):\n        ans .append(root .val)\n        maxm = max(find_gcd(ans), maxm)\n        return\n    ans .append(root .val)\n    maxm_gcd(root .left, ans)\n    maxm_gcd(root .right, ans)\n",
        "test": "\nif __name__ == '__main__':\n    root = Node(15)\n    root .left = Node(3)\n    root .right = Node(7)\n    root .left .left = Node(15)\n    root .left .right = Node(1)\n    root .right .left = Node(31)\n    root .right .right = Node(9)\n    maxm_gcd(root, [])\n    print(maxm)\n",
        "output": "3\n",
        "fn_call": "maxm_gcd"
    },
    {
        "text": "minimize remaining array element by removing pairs and replacing them by their absolute difference | function to find the smallest element left in the array by the given operations ; base case ; if this subproblem has occurred previously ; including i - th array element into the first subset ; if i - th array element is not selected ; update dp [ i ] [ sum ] ; utility function to find smallest element left in the array by the given operations ; stores sum of the array elements ; traverse the array ; update total ; stores overlapping subproblems ; ",
        "context": "",
        "code": "def smallestLeft(arr, total, sum, i, dp):\n    if (i == 0):\n        return abs(total - 2 * sum)\n    if (dp[i][sum] != -1):\n        return dp[i][sum]\n    X = smallestLeft(arr, total, sum + arr[i - 1], i - 1, dp)\n    Y = smallestLeft(arr, total, sum, i - 1, dp)\n    dp[i][sum] = min(X, Y)\n    return dp[i][sum]\n\n\ndef UtilSmallestElement(arr, N):\n    total = 0\n    for i in range(0, N):\n        total += arr[i]\n    dp = [[-1 for y in range(total)]for x in range(N + 1)]\n    print(smallestLeft(arr, total, 0, N, dp))\n",
        "test": "\narr = [2, 7, 4, 1, 8, 1]\nN = len(arr)\nUtilSmallestElement(arr, N)\n",
        "output": "1\n",
        "fn_call": "UtilSmallestElement"
    },
    {
        "text": "minimum count of elements required to obtain the given array by repeated mirror operations | function to find minimum number of elements required to form a [ ] by performing mirroring operation ; initialize k ; odd length array cannot be formed by mirror operation ; check if prefix of length k is palindrome ; check if not a palindrome ; if found to be palindrome ; otherwise ; return the final answer ; ",
        "context": "",
        "code": "def minimumrequired(A, N):\n    K = N\n    while (K > 0):\n        if (K % 2) == 1:\n            ans = K\n            break\n        ispalindrome = 1\n        for i in range(0, K // 2):\n            if (A[i] != A[K - 1 - i]):\n                ispalindrome = 0\n        if (ispalindrome == 1):\n            ans = K // 2\n            K = K // 2\n        else:\n            ans = K\n            break\n    return ans\n",
        "test": "\nA = [1, 2, 2, 1, 1, 2, 2, 1]\nN = len(A)\nprint(minimumrequired(A, N))\n",
        "output": "2\n",
        "fn_call": "minimumrequired"
    },
    {
        "text": "return maximum occurring character in an input string | python program to return the maximum occurring character in the input string ; create array to keep the count of individual characters initialize the count array to zero ; construct character count array from the input string . ; initialize max count ; initialize result ; traversing through the string and maintaining the count of each character ; ",
        "context": "\nASCII_SIZE = 256\n\n",
        "code": "def getMaxOccuringChar(str):\n    count = [0] * ASCII_SIZE\n    for i in str:\n        count[ord(i)] += 1\n    max = -1\n    c = ''\n    for i in str:\n        if max < count[ord(i)]:\n            max = count[ord(i)]\n            c = i\n    return c\n",
        "test": "\nstr = \"sample string\"\nprint(\"Max occurring character is \" + getMaxOccuringChar(str))\n",
        "output": "Max occurring character is s\n",
        "fn_call": "getMaxOccuringChar"
    },
    {
        "text": "Program for Tower of Hanoi | Recursive Python function to solve tower of hanoi ; Number of disks ; A , C , B are the name of rods",
        "context": "",
        "code": "def TowerOfHanoi(n, from_rod, to_rod, aux_rod):\n    if n == 1:\n        print(\"Move disk 1 from rod\", from_rod, \"to rod\", to_rod)\n        return\n    TowerOfHanoi(n - 1, from_rod, aux_rod, to_rod)\n    print(\"Move disk\", n, \"from rod\", from_rod, \"to rod\", to_rod)\n    TowerOfHanoi(n - 1, aux_rod, to_rod, from_rod)\n",
        "test": "\nn = 4\nTowerOfHanoi(n, 'A', 'C', 'B')\n",
        "output": "Move disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\n",
        "fn_call": "TowerOfHanoi"
    },
    {
        "text": "check whether two convex regular polygon have same center or not | function to check whether two convex polygons have the same center or not ; ",
        "context": "",
        "code": "def check(n, m):\n    if (m % n == 0):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nn = 5\nm = 10\ncheck(n, m)\n",
        "output": "YES\n",
        "fn_call": "check"
    },
    {
        "text": "minimum number of swaps required to make the string k periodic | python3 code to find the minimum number of swaps required to make the string k periodic ; mark all allowed characters as true ; initialize the freq array to 0 ; increase the frequency of each character ; total number of periods of size k in the string ; check if the current character is present in allowed and whether the current frequency is greater than all previous frequencies for this position ; update the answer by subtracting the maxfrequency from total positions if there exist extra character at the end of the string apart from the n / k characters then add 1. ; ",
        "context": "",
        "code": "def minFlip(s, n, k, a, p):\n    allowed = [0] * 26\n    for i in range(p):\n        allowed[ord(a[i]) - ord('a')] = True\n    freq = [[0 for x in range(26)]for y in range(k)]\n    for i in range(k):\n        for j in range(26):\n            freq[i][j] = 0\n    for i in range(n):\n        freq[i % k][ord(s[i]) - ord('a')] += 1\n    ans = 0\n    totalpositions = n // k\n    for i in range(k):\n        maxfrequency = 0\n        for j in range(26):\n            if (freq[i][j] > maxfrequency and allowed[j]):\n                maxfrequency = freq[i][j]\n        ans += (totalpositions - maxfrequency)\n        if (i % k < n % k):\n            ans += 1\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"nihsiakyt\"\n    n = len(S)\n    K = 3\n    A = ['n', 'i', 'p', 's', 'q']\n    p = len(A)\n    minFlip(S, n, K, A, p)\n",
        "output": "6\n",
        "fn_call": "minFlip"
    },
    {
        "text": "check whether the product of every subsequence is a perfect square or not | python 3 program for the above approach ; function to check if the product of every subsequence of the array is a perfect square or not ; traverse the given array ; if arr [ i ] is a perfect square or not ; return \" yes \" ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def perfectSquare(arr, N):\n    for i in range(N):\n        p = sqrt(arr[i])\n        if (p * p != arr[i]):\n            return \"No\"\n    return \"Yes\"\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 4, 100]\n    N = len(arr)\n    print(perfectSquare(arr, N))\n",
        "output": "Yes\n",
        "fn_call": "perfectSquare"
    },
    {
        "text": "find the number which contain the digit d | returns true if d is present as digit in number x . ; breal loop if d is present as digit ; if loop broke ; function to display the values ; check all numbers one by one ; checking for digit ; ",
        "context": "",
        "code": "def isDigitPresent(x, d):\n    while (x > 0):\n        if (x % 10 == d):\n            break\n        x = x / 10\n    return (x > 0)\n\n\ndef printNumbers(n, d):\n    for i in range(0, n + 1):\n        if (i == d or isDigitPresent(i, d)):\n            print(i, end=\" \")\n",
        "test": "\nn = 47\nd = 7\nprint(\"The number of values are\")\nprintNumbers(n, d)\n",
        "output": "The number of values are\n7 17 27 37 47 ",
        "fn_call": "printNumbers"
    },
    {
        "text": "count of multiples of a , b or c less than or equal to n | function to return the gcd of a and b ; function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c ; calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\n\ndef divTermCount(a, b, c, num):\n    return (num // a + num // b + num // c - num // lcm(a, b) - num //\n            lcm(c, b) - num // lcm(a, c) + num // (lcm(lcm(a, b), c)))\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 7\n    b = 3\n    c = 5\n    n = 100\n    print(divTermCount(a, b, c, n))\n",
        "output": "55\n",
        "fn_call": "divTermCount"
    },
    {
        "text": "count primes that can be expressed as sum of two consecutive primes and 1 | python3 implementation of the approach ; to check if a number is prime or not ; to store possible numbers ; function to return all prime numbers ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; function to count all possible prime numbers that can be expressed as the sum of two consecutive primes and one ; all possible prime numbers below n ; ",
        "context": "\nfrom math import sqrt\nN = 100005\nisprime = [True] * N\ncan = [False] * N\n\n",
        "code": "def SieveOfEratosthenes():\n    for p in range(2, int(sqrt(N)) + 1):\n        if (isprime[p]):\n            for i in range(p * p, N, p):\n                isprime[i] = False\n    primes = []\n    for i in range(2, N):\n        if (isprime[i]):\n            primes .append(i)\n    return primes\n\n\ndef Prime_Numbers(n):\n    primes = SieveOfEratosthenes()\n    for i in range(len(primes) - 1):\n        if (primes[i] + primes[i + 1] + 1 < N):\n            can[primes[i] + primes[i + 1] + 1] = True\n    ans = 0\n    for i in range(2, n + 1):\n        if (can[i] and isprime[i]):\n            ans += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 50\n    print(Prime_Numbers(n))\n",
        "output": "5\n",
        "fn_call": "Prime_Numbers"
    },
    {
        "text": "maximum manhattan distance between a distinct pair from n coordinates | function to calculate the maximum manhattan distance ; list to store maximum and minimum of all the four forms ; sorting both the vectors ; ",
        "context": "",
        "code": "def MaxDist(A, N):\n    V = [0 for i in range(N)]\n    V1 = [0 for i in range(N)]\n    for i in range(N):\n        V[i] = A[i][0] + A[i][1]\n        V1[i] = A[i][0] - A[i][1]\n    V .sort()\n    V1 .sort()\n    maximum = max(V[-1] - V[0], V1[-1] - V1[0])\n    print(maximum)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    A = [[1, 2], [2, 3], [3, 4]]\n    MaxDist(A, N)\n",
        "output": "4\n",
        "fn_call": "MaxDist"
    },
    {
        "text": "decode a string recursively encoded as count followed by substring | returns decoded string for ' str ' ; traversing the string ; if number , convert it into number and push it into integerstack . ; if closing bracket ' ] ' , pop elemment until ' [ ' opening bracket is not found in the character stack . ; repeating the popped string ' temo ' count number of times . ; push it in the character stack . ; if ' [ ' opening bracket , push it into character stack . ; pop all the elmenet , make a string and return . ; ",
        "context": "",
        "code": "def decode(Str):\n    integerstack = []\n    stringstack = []\n    temp = \"\"\n    result = \"\"\n    i = 0\n    while i < len(Str):\n        count = 0\n        if (Str[i] >= '0' and Str[i] <= '9'):\n            while (Str[i] >= '0' and Str[i] <= '9'):\n                count = count * 10 + ord(Str[i]) - ord('0')\n                i += 1\n            i -= 1\n            integerstack .append(count)\n        elif (Str[i] == ']'):\n            temp = \"\"\n            count = 0\n            if (len(integerstack) != 0):\n                count = integerstack[-1]\n                integerstack .pop()\n            while (len(stringstack) != 0 and stringstack[-1] != '['):\n                temp = stringstack[-1] + temp\n                stringstack .pop()\n            if (len(stringstack) != 0 and stringstack[-1] == '['):\n                stringstack .pop()\n            for j in range(count):\n                result = result + temp\n            for j in range(len(result)):\n                stringstack .append(result[j])\n            result = \"\"\n        elif (Str[i] == '['):\n            if (Str[i - 1] >= '0' and Str[i - 1] <= '9'):\n                stringstack .append(Str[i])\n            else:\n                stringstack .append(Str[i])\n                integerstack .append(1)\n        else:\n            stringstack .append(Str[i])\n        i += 1\n    while len(stringstack) != 0:\n        result = stringstack[-1] + result\n        stringstack .pop()\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    Str = \"3[b2[ca]]\"\n    print(decode(Str))\n",
        "output": "bcacabcacabcaca\n",
        "fn_call": "decode"
    },
    {
        "text": "sum of multiples of array elements within a given range [ l , r ] | function to find the sum of all multiples of n up to k ; calculate the sum ; return the sum ; function to find the total sum ; if l is divisible by a [ i ] ; otherwise ; return the final sum ; ",
        "context": "",
        "code": "def calcSum(k, n):\n    value = (k * n * (n + 1)) // 2\n    return value\n\n\ndef findSum(a, n, L, R):\n    sum = 0\n    for i in range(n):\n        if (L % a[i] == 0 and L != 0):\n            sum += (calcSum(a[i], R // a[i]) - calcSum(a[i], (L - 1) // a[i]))\n        else:\n            sum += (calcSum(a[i], R // a[i]) - calcSum(a[i], L // a[i]))\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 7, 3, 8]\n    N = len(arr)\n    L = 7\n    R = 20\n    print(findSum(arr, N, L, R))\n",
        "output": "197\n",
        "fn_call": "findSum"
    },
    {
        "text": "find two numbers with difference and division both same as n | function to find two numbers with difference and division both as n ; condition if the answer is not possible ; calculate a and b ; print the values ; ",
        "context": "",
        "code": "def findAandB(N):\n    if (N == 1):\n        print(\"No\")\n        return\n    a = N * N / (N - 1)\n    b = a / N\n    print(\"a = \", a)\n    print(\"b = \", b)\n",
        "test": "\nN = 6\nfindAandB(N)\n",
        "output": "a =  7.2\nb =  1.2\n",
        "fn_call": "findAandB"
    },
    {
        "text": "total number of subsets of size at most k | function to compute the value of binomial coefficient c ( n , k ) ; calculate value of binomial coefficient in bottom up manner ; base cases ; calculate value using previously stored values ; function to calculate sum of ncj from j = 1 to k ; calling the ncr function for each value of j ; ",
        "context": "",
        "code": "def binomialCoeff(n, k):\n    C = [[0 for i in range(k + 1)]for j in range(n + 1)]\n    i, j = 0, 0\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n            if (j == 0 or j == i):\n                C[i][j] = 1\n            else:\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j]\n    return C[n][k]\n\n\ndef count(n, k):\n    sum = 0\n    for j in range(1, k + 1):\n        sum = sum + binomialCoeff(n, j)\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    k = 2\n    print(count(n, k), end=\"\")\n    n1 = 5\n    k1 = 2\n    print(count(n1, k1))\n",
        "output": "615\n",
        "fn_call": "count"
    },
    {
        "text": "find n numbers such that a number and its reverse are divisible by sum of its digits | function to calculate the sum of digits ; loop to iterate through every digit of the number ; returning the sum of digits ; function to calculate the reverse of a number ; loop to calculate the reverse of the number ; return the reverse of the number ; function to print the first n numbers such that every number and the reverse of the number is divisible by its sum of digits ; loop to continuously check and generate number until there are n outputs ; variable to hold the sum of the digit of the number ; computing the reverse of the number ; checking if the condition satisfies . increment the count and print the number if it satisfies . ; ",
        "context": "",
        "code": "def digit_sum(n):\n    sum = 0\n    while (n > 0):\n        m = n % 10\n        sum = sum + m\n        n = n // 10\n    return (sum)\n\n\ndef reverse(n):\n    r = 0\n    while (n != 0):\n        r = r * 10\n        r = r + n % 10\n        n = n // 10\n    return (r)\n\n\ndef operation(n):\n    i = 1\n    count = 0\n    while (count < n):\n        a = digit_sum(i)\n        r = reverse(i)\n        if (i % a == 0 and r % a == 0):\n            print(i, end=\" \")\n            count += 1\n            i += 1\n        else:\n            i += 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 10\n    operation(n)\n",
        "output": "1 2 3 4 5 6 7 8 9 10 ",
        "fn_call": "operation"
    },
    {
        "text": "occurrences of a pattern in binary representation of a number | function to return the count of occurrence of pat in binary representation of n ; to store decimal value of the pattern ; to store a number that has all ones in its binary representation and length of ones equal to length of the pattern ; find values of pattern_int and all_ones ; if the pattern occurs in the last digits of n ; right shift n by 1 bit ; ",
        "context": "",
        "code": "def countPattern(n, pat):\n    pattern_int = 0\n    power_two = 1\n    all_ones = 0\n    i = len(pat) - 1\n    while (i >= 0):\n        current_bit = ord(pat[i]) - ord('0')\n        pattern_int += (power_two * current_bit)\n        all_ones = all_ones + power_two\n        power_two = power_two * 2\n        i -= 1\n    count = 0\n    while (n != 0 and n >= pattern_int):\n        if ((n & all_ones) == pattern_int):\n            count += 1\n        n = n >> 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 500\n    pat = \"10\"\n    print(countPattern(n, pat))\n",
        "output": "2\n",
        "fn_call": "countPattern"
    },
    {
        "text": "check if possible to move from given coordinate to desired coordinate | python program to check if it is possible to reach ( a , b ) from ( x , y ) . returns gcd of i and j ; returns true if it is possible to go to ( a , b ) from ( x , y ) ; find absolute values of all as sign doesn 't  matter. ; if gcd is equal then it is possible to reach . else not possible . ; ",
        "context": "",
        "code": "def gcd(i, j):\n    if (i == j):\n        return i\n    if (i > j):\n        return gcd(i - j, j)\n    return gcd(i, j - i)\n\n\ndef ispossible(x, y, a, b):\n    x, y, a, b = abs(x), abs(y), abs(a), abs(b)\n    return (gcd(x, y) == gcd(a, b))\n",
        "test": "\nx, y = 35, 15\na, b = 20, 25\nif (ispossible(x, y, a, b)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "ispossible"
    },
    {
        "text": "triangular numbers | returns true if ' num ' is triangular , else false ; base case ; a triangular number must be sum of first n natural numbers ; ",
        "context": "",
        "code": "def isTriangular(num):\n    if (num < 0):\n        return False\n    sum, n = 0, 1\n    while (sum <= num):\n        sum = sum + n\n        if (sum == num):\n            return True\n        n += 1\n    return False\n",
        "test": "\nn = 55\nif (isTriangular(n)):\n    print(\"The number is a triangular number\")\nelse:\n    print(\"The number is NOT a triangular number\")\n",
        "output": "The number is a triangular number\n",
        "fn_call": "isTriangular"
    },
    {
        "text": "minimum inversions required so that no two adjacent elements are same | function to return the minimum inversions required so that no two adjacent elements are same ; to store the inversions required to make the array { 1 , 0 , 1 , 0 , 1 , 0 , 1 , ... } and { 0 , 1 , 0 , 1 , 0 , 1 , 0 , ... } respectively ; find all the changes required ; return the required answer ; ",
        "context": "",
        "code": "def min_changes(a, n):\n    ans_a = 0\n    ans_b = 0\n    for i in range(n):\n        if (i % 2 == 0):\n            if (a[i] == 0):\n                ans_a += 1\n            else:\n                ans_b += 1\n        else:\n            if (a[i] == 0):\n                ans_b += 1\n            else:\n                ans_a += 1\n    return min(ans_a, ans_b)\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 0, 0, 1, 0, 0, 1, 0]\n    n = len(a)\n    print(min_changes(a, n))\n",
        "output": "3\n",
        "fn_call": "min_changes"
    },
    {
        "text": "alternate primes till n | function for checking number is prime or not ; if flag = 0 then number is prime and return 1 otherwise return 0 ; function for printing alternate prime number ; counter is initialize with 0 ; looping through 2 to n - 1 ; function calling along with if condition ; if counter is multiple of 2 then only print prime number ; ",
        "context": "",
        "code": "def prime(num):\n    flag = 0\n    for i in range(2, num // 2 + 1):\n        if num % i == 0:\n            flag = 1\n            break\n    if flag == 0:\n        return 1\n    else:\n        return 0\n\n\ndef print_alternate_prime(n):\n    counter = 0\n    for num in range(2, n):\n        if prime(num) == 1:\n            if counter % 2 == 0:\n                print(num, end=\" \")\n            counter += 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 15\n    print(\"Following are the alternate prime\" +\n          \"number smaller than or equal to\", n)\n    print_alternate_prime(n)\n",
        "output": "Following are the alternate primenumber smaller than or equal to 15\n2 5 11 ",
        "fn_call": "print_alternate_prime"
    },
    {
        "text": "heptagonal number | function to find nth heptagonal number ; ",
        "context": "",
        "code": "def heptagonalNumber(n):\n    return ((5 * n * n) - (3 * n)) // 2\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    print(heptagonalNumber(n))\n    n = 15\n    print(heptagonalNumber(n))\n",
        "output": "7\n540\n",
        "fn_call": "heptagonalNumber"
    },
    {
        "text": "count of substrings of a given binary string with all characters same | function to count number of sub - strings of a given binary string that contains only 1 ; iterate untill l and r cross each other ; check if reached the end of string ; check if encountered '1' then extend window ; check if encountered '0' then add number of strings of current window and change the values for both l and r ; return the answer ; function to flip the bits of string ; function to count number of sub - strings of a given binary string that contains only 0 s & 1 s ; count of substring which contains only 1 s ; flip the character of string s 0 to 1 and 1 to 0 to count the substring with consecutive 0 s ; count of substring which contains only 0 s ; ",
        "context": "",
        "code": "def countSubAllOnes(s):\n    l, r, ans = 0, 0, 0\n    while (l <= r):\n        if (r == len(s)):\n            ans += ((r - l) * (r - l + 1)) // 2\n            break\n        if (s[r] == '1'):\n            r += 1\n        else:\n            ans += ((r - l) * (r - l + 1)) // 2\n            l = r + 1\n            r += 1\n    return ans\n\n\ndef flip(s):\n    arr = list(s)\n    for i in range(len(s)):\n        if (arr[i] == '1'):\n            arr[i] = '0'\n        else:\n            arr[i] = '1'\n    s = ''.join(arr)\n    return s\n\n\ndef countSubAllZerosOnes(s):\n    only_1s = countSubAllOnes(s)\n    s = flip(s)\n    only_0s = countSubAllOnes(s)\n    return only_0s + only_1s\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"011\"\n    print(countSubAllZerosOnes(s))\n",
        "output": "4\n",
        "fn_call": "countSubAllZerosOnes"
    },
    {
        "text": "count triangles required to form a house of cards of height n | function to find required number of triangles ; ",
        "context": "",
        "code": "def noOfTriangles(n):\n    return n * (n + 2) * (2 * n + 1) // 8\n",
        "test": "\nn = 3\nprint(noOfTriangles(n))\n",
        "output": "13\n",
        "fn_call": "noOfTriangles"
    },
    {
        "text": "multiply large numbers represented as strings | multiplies str1 and str2 , and prints result . ; will keep the result number in vector in reverse order ; below two indexes are used to find positions in result . ; go from right to left in num1 ; to shift position to left after every multiplication of a digit in num2 ; go from right to left in num2 ; take current digit of second number ; multiply with current digit of first number and add result to previously stored result at current position . ; carry for next iteration ; store result ; store carry in next cell ; to shift position to left after every multiplication of a digit in num1 . ; ignore '0' s from the right ; if all were '0' s - means either both or one of num1 or num2 were '0 ; generate the result string ; ",
        "context": "",
        "code": "def multiply(num1, num2):\n    len1 = len(num1)\n    len2 = len(num2)\n    if len1 == 0 or len2 == 0:\n        return \"0\"\n    result = [0] * (len1 + len2)\n    i_n1 = 0\n    i_n2 = 0\n    for i in range(len1 - 1, -1, -1):\n        carry = 0\n        n1 = ord(num1[i]) - 48\n        i_n2 = 0\n        for j in range(len2 - 1, -1, -1):\n            n2 = ord(num2[j]) - 48\n            summ = n1 * n2 + result[i_n1 + i_n2] + carry\n            carry = summ // 10\n            result[i_n1 + i_n2] = summ % 10\n            i_n2 += 1\n        if (carry > 0):\n            result[i_n1 + i_n2] += carry\n        i_n1 += 1\n    i = len(result) - 1\n    while (i >= 0 and result[i] == 0):\n        i -= 1\n\n    if (i == -1):\n        return \"0\"\n    s = \"\"\n    while (i >= 0):\n        s += chr(result[i] + 48)\n        i -= 1\n    return s\n",
        "test": "\nstr1 = \"1235421415454545454545454544\"\nstr2 = \"1714546546546545454544548544544545\"\nif ((str1[0] == '-' or str2[0] == '-') and (str1[0] != '-' or str2[0] != '-')):\n    print(\"-\", end='')\nif (str1[0] == '-' and str2[0] != '-'):\n    str1 = str1[1:]\nelif (str1[0] != '-' and str2[0] == '-'):\n    str2 = str2[1:]\nelif (str1[0] == '-' and str2[0] == '-'):\n    str1 = str1[1:]\n    str2 = str2[1:]\nprint(multiply(str1, str2))\n",
        "output": "2118187521397235888154583183918321221520083884298838480662480\n",
        "fn_call": "multiply"
    },
    {
        "text": "minimum number of operations required to delete all elements of the array | python 3 implementation of the above approach ; function to find minimum operations ; sort array ; prepare hash of array ; ",
        "context": "\nMAX = 10000\nhashTable = [0] * MAX\n\n",
        "code": "def minOperations(arr, n):\n    arr .sort()\n    for i in range(n):\n        hashTable[arr[i]] += 1\n    res = 0\n    for i in range(n):\n        if (hashTable[arr[i]]):\n            for j in range(i, n):\n                if (arr[j] % arr[i] == 0):\n                    hashTable[arr[j]] = 0\n            res += 1\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 6, 2, 8, 7, 21, 24, 49, 44]\n    n = len(arr)\n    print(minOperations(arr, n))\n",
        "output": "2\n",
        "fn_call": "minOperations"
    },
    {
        "text": "find unit digit of x raised to power y | returns unit digit of x raised to power y ; initialize result as 1 to handle case when y is 0. ; one by one multiply with x mod 10 to avoid overflow . ; ",
        "context": "",
        "code": "def unitDigitXRaisedY(x, y):\n    res = 1\n    for i in range(y):\n        res = (res * x) % 10\n    return res\n",
        "test": "\nprint(unitDigitXRaisedY(4, 2))\n",
        "output": "6\n",
        "fn_call": "unitDigitXRaisedY"
    },
    {
        "text": "elements to be added so that all elements of a range are present in array | function to count numbers to be added ; sort the array ; check if elements are consecutive or not . if not , update count ; ",
        "context": "",
        "code": "def countNum(arr, n):\n    count = 0\n    arr .sort()\n    for i in range(0, n - 1):\n        if (arr[i] != arr[i + 1] and arr[i] != arr[i + 1] - 1):\n            count += arr[i + 1] - arr[i] - 1\n    return count\n",
        "test": "\narr = [3, 5, 8, 6]\nn = len(arr)\nprint(countNum(arr, n))\n",
        "output": "2\n",
        "fn_call": "countNum"
    },
    {
        "text": "level order traversal line by line | set 3 ( using one queue ) | python3 program to print levels line by line ; a binary tree node ; function to do level order traversal line by line ; create an empty queue for level order traversal ; pushing root node into the queue . ; pushing delimiter into the queue . ; condition to check occurrence of next level . ; pushing left child of current node . ; pushing left child current node ; pushing right child of current node . ; ",
        "context": "\nfrom collections import deque as queue\n\n\nclass Node:\n    def __init__(self, key):\n        self .data = key\n        self .left = None\n        self .right = None\n\n",
        "code": "def levelOrder(root):\n    if (root is None):\n        return\n    q = queue()\n    q .append(root)\n    q .append(None)\n    while (len(q) > 1):\n        curr = q .popleft()\n        if (curr is None):\n            q .append(None)\n            print()\n        else:\n            if (curr .left):\n                q .append(curr .left)\n            if (curr .right):\n                q .append(curr .right)\n            print(curr .data, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    root = Node(1)\n    root .left = Node(2)\n    root .right = Node(3)\n    root .left .left = Node(4)\n    root .left .right = Node(5)\n    root .right .right = Node(6)\n    levelOrder(root)\n",
        "output": "1 \n2 3 \n4 5 6 ",
        "fn_call": "levelOrder"
    },
    {
        "text": "check if a number exists with x divisors out of which y are composite | python3 program to check if a number exists having exactly x positive divisors out of which y are composite divisors ; count the number of times 2 divides n ; check for all possible numbers that can divide it ; if n at the end is a prime number . ; function to check if any such number exists ; ",
        "context": "\nimport math\n\n",
        "code": "def factorize(N):\n    count = 0\n    cnt = 0\n    while ((N % 2) == 0):\n        N = N // 2\n        count += 1\n    cnt = cnt + count\n    sq = int(math .sqrt(N))\n    for i in range(3, sq, 2):\n        count = 0\n        while (N % i == 0):\n            count += 1\n            N = N // i\n        cnt = cnt + count\n    if (N > 2):\n        cnt = cnt + 1\n    return cnt\n\n\ndef ifNumberExists(X, Y):\n    C = X - Y - 1\n    dsum = factorize(X)\n    if (dsum >= C):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 6\n    Y = 4\n    ifNumberExists(X, Y)\n",
        "output": "YES\n",
        "fn_call": "ifNumberExists"
    },
    {
        "text": "minimum moves required to type a word in qwerty based keyboard | function that calculates the moves required to prthe current string ; row1 has qwertyuiop , row2 has asdfghjkl , and row3 has zxcvbnm store the row number of each character ; string length ; initialise move to 1 ; traverse the string ; if current row number is not equal to previous row then increment the moves ; return the moves ; ",
        "context": "",
        "code": "def numberMoves(s):\n    row = [2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2,\n           3, 3, 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3]\n    n = len(s)\n    move = 1\n    for i in range(1, n):\n        if (row[ord(s[i]) - ord('a')] != row[ord(s[i - 1]) - ord('a')]):\n            move += 1\n    return move\n",
        "test": "\nif __name__ == '__main__':\n    str = \"geeksforgeeks\"\n    print(numberMoves(str))\n",
        "output": "7\n",
        "fn_call": "numberMoves"
    },
    {
        "text": "maximum number of partitions that can be sorted individually to make sorted | function to find maximum partitions . ; find maximum in prefix arr [ 0. . i ] ; if maximum so far is equal to index , we can make a new partition ending at index i . ; ",
        "context": "",
        "code": "def maxPartitions(arr, n):\n    ans = 0\n    max_so_far = 0\n    for i in range(0, n):\n        max_so_far = max(max_so_far, arr[i])\n        if (max_so_far == i):\n            ans += 1\n    return ans\n",
        "test": "\narr = [1, 0, 2, 3, 4]\nn = len(arr)\nprint(maxPartitions(arr, n))\n",
        "output": "4\n",
        "fn_call": "maxPartitions"
    },
    {
        "text": "sort the strings based on the numbers of matchsticks required to represent them | stick [ ] stores the count of sticks required to represent the alphabets ; number [ ] stores the count of sticks required to represent the numerals ; function that return the count of sticks required to represent the given string str ; loop to iterate over every character of the string ; add the count of sticks required to represent the current character ; function to sort the array according to the number of sticks required to represent it ; vector to store the number of sticks required with respective strings ; inserting number of sticks with respective strings ; sort the vector ; print the sorted vector ; ",
        "context": "\nsticks = [6, 7, 4, 6, 5, 4, 6, 5, 2, 4, 4, 3,\n          6, 6, 6, 5, 7, 6, 5, 3, 5, 4, 6, 4, 3, 4]\nnumber = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n\n",
        "code": "def countSticks(st):\n    cnt = 0\n    for i in range(len(st)):\n        ch = st[i]\n        if (ch >= 'A' and ch <= 'Z'):\n            cnt += sticks[ord(ch) - ord('A')]\n        else:\n            cnt += number[ord(ch) - ord('0')]\n    return cnt\n\n\ndef sortArr(arr, n):\n    vp = []\n    for i in range(n):\n        vp .append([countSticks(arr[i]), arr[i]])\n    vp .sort()\n    for i in range(len(vp)):\n        print(vp[i][1], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"GEEKS\", \"FOR\", \"GEEKSFORGEEKS\"]\n    n = len(arr)\n    sortArr(arr, n)\n",
        "output": "FOR GEEKS GEEKSFORGEEKS ",
        "fn_call": "sortArr"
    },
    {
        "text": "numbers less than n which are product of exactly two distinct prime numbers | python 3 program to find numbers that are product of exactly two distinct prime numbers ; function to check whether a number is a perfectsquare or not ; function to check if a number is a product of exactly two distinct primes ; function to find numbers that are product of exactly two distinct prime numbers . ; vector to store such numbers ; insert in the vector ; print all numbers till n from the vector ; ",
        "context": "\nimport math\n\n",
        "code": "def isPerfectSquare(x):\n    sr = math .sqrt(x)\n    return ((sr - math .floor(sr)) == 0)\n\n\ndef isProduct(num):\n    cnt = 0\n    i = 2\n    while cnt < 2 and i * i <= num:\n        while (num % i == 0):\n            num //= i\n            cnt += 1\n        i += 1\n    if (num > 1):\n        cnt += 1\n    return cnt == 2\n\n\ndef findNumbers(N):\n    vec = []\n    for i in range(1, N + 1):\n        if (isProduct(i) and not isPerfectSquare(i)):\n            vec .append(i)\n    for i in range(len(vec)):\n        print(vec[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 30\n    findNumbers(N)\n",
        "output": "6 10 14 15 21 22 26 ",
        "fn_call": "findNumbers"
    },
    {
        "text": "count balanced binary trees of height h | python3 program to count number of balanced binary trees of height h . ; base cases ; ",
        "context": "",
        "code": "def countBT(h):\n    MOD = 1000000007\n    dp = [0 for i in range(h + 1)]\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, h + 1):\n        dp[i] = (dp[i - 1] * ((2 * dp[i - 2]) % MOD + dp[i - 1]) % MOD) % MOD\n    return dp[h]\n",
        "test": "\nh = 3\nprint(\"No. of balanced binary trees of height \" +\n      str(h) + \" is: \" + str(countBT(h)))\n",
        "output": "No. of balanced binary trees of height 3 is: 15\n",
        "fn_call": "countBT"
    },
    {
        "text": "find if array can be sorted by swaps limited to multiples of k | checksort function to check if array can be sorted ; sortarr is sorted array of arr ; if k = 1 then ( always possible to sort ) swapping can easily give sorted array ; comparing sortarray with array ; element at index j must be in j = i + l * k form where i = 0 , 1 , 2 , 3. . . where l = 0 , 1 , 2 , 3 , . . n - 1 ; if element is present then swapped ; if element of sorted array does not found in its sequence then flag remain zero that means arr can not be sort after swapping ; if flag is 0 not possible else possible ; ",
        "context": "",
        "code": "def CheckSort(arr, k, n):\n    sortarr = sorted(arr)\n    if (k == 1):\n        print(\"yes\")\n    else:\n        for i in range(0, n):\n            flag = 0\n            for j in range(i, n, k):\n                if (sortarr[i] == arr[j]):\n                    arr[i], arr[j] = arr[j], arr[i]\n                    flag = 1\n                    break\n                if (j + k >= n):\n                    break\n            if (flag == 0):\n                break\n        if (flag == 0):\n            print(\"Not possible to sort\")\n        else:\n            print(\"Possible to sort\")\n",
        "test": "\nif __name__ == \"__main__\":\n    k = 3\n    arr = [1, 5, 6, 9, 2, 3, 5, 9]\n    n = len(arr)\n    CheckSort(arr, k, n)\n",
        "output": "Possible to sort\n",
        "fn_call": "CheckSort"
    },
    {
        "text": "check whether count of odd and even factors of a number are equal | function to check condition ; ",
        "context": "",
        "code": "def isEqualFactors(N):\n    if ((N % 2 == 0) and (N % 4 != 0)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nN = 10\nisEqualFactors(N)\nN = 125\nisEqualFactors(N)\n",
        "output": "YES\nNO\n",
        "fn_call": "isEqualFactors"
    },
    {
        "text": "lcs ( longest common subsequence ) of three strings | python3 program to find lcs of three strings ; returns length of lcs for x [ 0. . m - 1 ] , y [ 0. . n - 1 ] and z [ 0. . o - 1 ] ; ",
        "context": "\nX = \"AGGT12\"\nY = \"12TXAYB\"\nZ = \"12XBA\"\ndp = [[[-1 for i in range(100)]for j in range(100)]for k in range(100)]\n\n",
        "code": "def lcsOf3(i, j, k):\n    if (i == -1 or j == -1 or k == -1):\n        return 0\n    if (dp[i][j][k] != -1):\n        return dp[i][j][k]\n    if (X[i] == Y[j] and Y[j] == Z[k]):\n        dp[i][j][k] = 1 + lcsOf3(i - 1, j - 1, k - 1)\n        return dp[i][j][k]\n    else:\n        dp[i][j][k] = max(\n            max(lcsOf3(i - 1, j, k), lcsOf3(i, j - 1, k)), lcsOf3(i, j, k - 1))\n        return dp[i][j][k]\n",
        "test": "\nif __name__ == \"__main__\":\n    m = len(X)\n    n = len(Y)\n    o = len(Z)\n    print(\"Length of LCS is\", lcsOf3(m - 1, n - 1, o - 1))\n",
        "output": "Length of LCS is 2\n",
        "fn_call": "lcsOf3"
    },
    {
        "text": "jaro and jaro | python3 implementation of above approach ; function to calculate the jaro similarity of two strings ; if the strings are equal ; length of two strings ; maximum distance upto which matching is allowed ; count of matches ; hash for matches ; traverse through the first string ; check if there is any matches ; if there is a match ; if there is no match ; number of transpositions ; count number of occurrences where two characters match but there is a third matched character in between the indices ; find the next matched character in second string ; return the jaro similarity ; jaro winkler similarity ; if the jaro similarity is above a threshold ; find the length of common prefix ; if the characters match ; else break ; maximum of 4 characters are allowed in prefix ; calculate jaro winkler similarity ; ",
        "context": "\nfrom math import floor\n\n",
        "code": "def jaro_distance(s1, s2):\n    if (s1 == s2):\n        return 1.0\n    len1 = len(s1)\n    len2 = len(s2)\n    if (len1 == 0 or len2 == 0):\n        return 0.0\n    max_dist = (max(len(s1), len(s2)) // 2) - 1\n    match = 0\n    hash_s1 = [0] * len(s1)\n    hash_s2 = [0] * len(s2)\n    for i in range(len1):\n        for j in range(max(0, i - max_dist), min(len2, i + max_dist + 1)):\n            if (s1[i] == s2[j] and hash_s2[j] == 0):\n                hash_s1[i] = 1\n                hash_s2[j] = 1\n                match += 1\n                break\n    if (match == 0):\n        return 0.0\n    t = 0\n    point = 0\n    for i in range(len1):\n        if (hash_s1[i]):\n            while (hash_s2[point] == 0):\n                point += 1\n            if (s1[i] != s2[point]):\n                point += 1\n                t += 1\n            else:\n                point += 1\n        t /= 2\n    return ((match / len1 + match / len2 + (match - t) / match) / 3.0)\n\n\ndef jaro_Winkler(s1, s2):\n    jaro_dist = jaro_distance(s1, s2)\n    if (jaro_dist > 0.7):\n        prefix = 0\n        for i in range(min(len(s1), len(s2))):\n            if (s1[i] == s2[i]):\n                prefix += 1\n            else:\n                break\n        prefix = min(4, prefix)\n        jaro_dist += 0.1 * prefix * (1 - jaro_dist)\n    return jaro_dist\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"TRATE\"\n    s2 = \"TRACE\"\n    print(\"Jaro-Winkler Similarity =\", jaro_Winkler(s1, s2))\n",
        "output": "Jaro-Winkler Similarity = 0.9066666666666667\n",
        "fn_call": "jaro_Winkler"
    },
    {
        "text": "count ways to split array into three non | function to count ways to split array into three subarrays with equal bitwise xor ; stores the xor value of arr [ ] ; update the value of arr_xor ; stores the xor value of prefix and suffix array respectively ; stores the ending points of all the required prefix arrays ; stores the count of suffix arrays whose xor value is equal to the total xor value at each index ; find all prefix arrays with xor value equal to arr_xor ; update pref_xor ; fill the values of suff_inds [ ] ; update suff_xor ; update suff_inds [ i ] ; stores the total number of ways ; count total number of ways ; return the final count ; ",
        "context": "",
        "code": "def countWays(arr, N):\n    arr_xor = 0\n    for i in range(N):\n        arr_xor ^= arr[i]\n    pref_xor, suff_xor = 0, 0\n    pref_ind = []\n    suff_inds = [0] * (N + 1)\n    for i in range(N):\n        pref_xor ^= arr[i]\n        if (pref_xor == arr_xor):\n            pref_ind .append(i)\n    for i in range(N - 1, -1, -1):\n        suff_xor ^= arr[i]\n        suff_inds[i] += suff_inds[i + 1]\n        if (suff_xor == arr_xor):\n            suff_inds[i] += 1\n    tot_ways = 0\n    for idx in pref_ind:\n        if (idx < N - 1):\n            tot_ways += suff_inds[idx + 2]\n    return tot_ways\n",
        "test": "\nif __name__ == '__main__':\n    arr = [7, 0, 5, 2, 7]\n    N = len(arr)\n    print(countWays(arr, N))\n",
        "output": "2\n",
        "fn_call": "countWays"
    },
    {
        "text": "find n | return n - th number in series made of 4 and 7 ; create an array of size ( n + 1 ) ; if i is odd ; ",
        "context": "",
        "code": "def printNthElement(n):\n    arr = [0] * (n + 1)\n    arr[1] = 4\n    arr[2] = 7\n    for i in range(3, n + 1):\n        if (i % 2 != 0):\n            arr[i] = arr[i // 2] * 10 + 4\n        else:\n            arr[i] = arr[(i // 2) - 1] * 10 + 7\n    return arr[n]\n",
        "test": "\nn = 6\nprint(printNthElement(n))\n",
        "output": "77\n",
        "fn_call": "printNthElement"
    },
    {
        "text": "construct an array from its pair | python3 implementation of the approach ; utility function to print the array ; function to generate the original array from the pair - product array ; first element of the resulting array ; find all the other elements ; print the elements of the generated array ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end=\" \")\n\n\ndef constructArr(pair, n):\n    size = int((1 + sqrt(1 + 8 * n)) // 2)\n    arr = [0] * (size)\n    arr[0] = int(sqrt((pair[0] * pair[1]) / pair[size - 1]))\n    for i in range(1, size):\n        arr[i] = pair[i - 1] // arr[0]\n    printArr(arr, size)\n",
        "test": "\nif __name__ == \"__main__\":\n    pair = [48, 18, 24, 24, 32, 12]\n    n = len(pair)\n    constructArr(pair, n)\n",
        "output": "6 8 3 4 ",
        "fn_call": "constructArr"
    },
    {
        "text": "delete edge to minimize subtree sum difference | dfs method to traverse through edges , calculating subtree sum at each node and updating the difference between subtrees ; loop for all neighbors except parent and aggregate sum over all subtrees ; store sum in current node 's  subtree index ; at one side subtree sum is ' sum ' and other side subtree sum is ' totalsum \u2581 - \u2581 sum ' so their difference will be totalsum - 2 * sum , by which we 'll update res ; method returns minimum subtree sum difference ; calculating total sum of tree and initializing subtree sum 's  by vertex values ; filling edge data structure ; calling dfs method at node 0 , with parent as - 1 ; ",
        "context": "",
        "code": "def dfs(u, parent, totalSum, edge, subtree, res):\n    Sum = subtree[u]\n    for i in range(len(edge[u])):\n        v = edge[u][i]\n        if (v != parent):\n            dfs(v, u, totalSum, edge, subtree, res)\n            Sum += subtree[v]\n    subtree[u] = Sum\n    if (u != 0 and abs(totalSum - 2 * Sum) < res[0]):\n        res[0] = abs(totalSum - 2 * Sum)\n\n\ndef getMinSubtreeSumDifference(vertex, edges, N):\n    totalSum = 0\n    subtree = [None] * N\n    for i in range(N):\n        subtree[i] = vertex[i]\n        totalSum += vertex[i]\n    edge = [[]for i in range(N)]\n    for i in range(N - 1):\n        edge[edges[i][0]].append(edges[i][1])\n        edge[edges[i][1]].append(edges[i][0])\n    res = [999999999999]\n    dfs(0, -1, totalSum, edge, subtree, res)\n    return res[0]\n",
        "test": "\nif __name__ == '__main__':\n    vertex = [4, 2, 1, 6, 3, 5, 2]\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4], [2, 5], [3, 6]]\n    N = len(vertex)\n    print(getMinSubtreeSumDifference(vertex, edges, N))\n",
        "output": "5\n",
        "fn_call": "getMinSubtreeSumDifference"
    },
    {
        "text": "number of subsequences in a string divisible by n | returns count of subsequences of str divisible by n . ; division by n can leave only n remainder [ 0. . n - 1 ] . dp [ i ] [ j ] indicates number of subsequences in string [ 0. . i ] which leaves remainder j after division by n . ; filling value for first digit in str ; start a new subsequence with index i ; exclude i 'th character from all the  current subsequences of string [0...i-1] ; include i 'th character in all the current  subsequences of string [0...i-1] ; ",
        "context": "",
        "code": "def countDivisibleSubseq(str, n):\n    l = len(str)\n    dp = [[0 for x in range(l)]for y in range(n)]\n    dp[0][(ord(str[0]) - ord('0')) % n] += 1\n    for i in range(1, l):\n        dp[i][(ord(str[i]) - ord('0')) % n] += 1\n        for j in range(n):\n            dp[i][j] += dp[i - 1][j]\n            dp[i][(j * 10 + (ord(str[i]) - ord('0'))) % n] += dp[i - 1][j]\n    return dp[l - 1][0]\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"1234\"\n    n = 4\n    print(countDivisibleSubseq(str, n))\n",
        "output": "4\n",
        "fn_call": "countDivisibleSubseq"
    },
    {
        "text": "find n geometric means between a and b | python3 program to find n geometric means between a and b ; prints n geometric means between a and b . ; calculate common ratio ( r ) ; for finding n the geometric mean between a and b ; ",
        "context": "\nimport math\n\n",
        "code": "def printGMeans(A, B, N):\n    R = (math .pow((B / A), 1.0 / (N + 1)))\n    for i in range(1, N + 1):\n        print(int(A * math .pow(R, i)), end=\" \")\n",
        "test": "\nA = 3\nB = 81\nN = 2\nprintGMeans(A, B, N)\n",
        "output": "9 27 ",
        "fn_call": "printGMeans"
    },
    {
        "text": "count of pairs of integers up to x and y that generates equal quotient and remainder | python 3 program for the above approach ; function to calculate the number of pairs satisfying ( m / n = m % n ) ; iterate from 1 to sqrt ( x ) ; combining the conditions - 1 ) n > k 2 ) n <= y 3 ) n <= ( x / k - 1 ) ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def countOfPairs(x, y):\n    count = 0\n    for k in range(1, int(sqrt(x)) + 1, 1):\n        count += max(0, min(y, x / k - 1) - k)\n    print(int(count))\n",
        "test": "\nif __name__ == '__main__':\n    x = 4\n    y = 5\n    countOfPairs(x, y)\n",
        "output": "2\n",
        "fn_call": "countOfPairs"
    },
    {
        "text": "rearrange array to maximize count of local minima | function to rearrange array elements to maximize count of local minima in the array ; sort the array in ascending order ; stores index of left pointer ; stores index of right pointer ; traverse the array elements ; if right is less than n ; print array element ; update right ; print array element ; update left ; ",
        "context": "",
        "code": "def rearrangeArrMaxcntMinima(arr, N):\n    arr .sort()\n    left = 0\n    right = N // 2\n    while (left < N // 2 or right < N):\n        if (right < N):\n            print(arr[right], end=\" \")\n            right += 1\n        if (left < N // 2):\n            print(arr[left], end=\" \")\n            left += 1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    N = len(arr)\n    rearrangeArrMaxcntMinima(arr, N)\n",
        "output": "3 1 4 2 5 ",
        "fn_call": "rearrangeArrMaxcntMinima"
    },
    {
        "text": "sum of all subsequences of length k | function to find ncr ; function that returns factorial of n ; function for finding sum of all k length subsequences ; calculate the sum of array ; calculate nck ; return the final result ; ",
        "context": "",
        "code": "def nCr(n, r):\n    return fact(n) / (fact(r) * fact(n - r))\n\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef sumSubsequences(arr, n, k):\n    sum = 0\n    for i in range(0, n):\n        sum = sum + arr[i]\n    kLengthSubSequence = nCr(n, k)\n    ans = sum * ((k * kLengthSubSequence) / n)\n    return ans\n",
        "test": "\narr = [7, 8, 9, 2]\nk = 2\nn = len(arr)\nprint(sumSubsequences(arr, n, k))\n",
        "output": "78.0\n",
        "fn_call": "sumSubsequences"
    },
    {
        "text": "remove all the prime numbers from the given array | python3 implementation of the approach ; function for sieve of eratosthenes ; function to pr the elements of the array ; function to remove all the prime numbers ; generate primes ; traverse the array ; if the current element is prime ; shift all the elements on the right of it to the left ; decrease the loop counter by 1 to check the shifted element ; decrease the length ; pr the updated array ; ",
        "context": "\nsz = 10 ** 5\nisPrime = [True for i in range(sz + 1)]\n\n",
        "code": "def sieve():\n    isPrime[0] = isPrime[1] = False\n    i = 2\n    while i * i < sz:\n        if (isPrime[i]):\n            for j in range(i * i, sz, i):\n                isPrime[j] = False\n        i += 1\n\n\ndef prArray(arr, lenn):\n    for i in range(lenn):\n        print(arr[i], end=\" \")\n\n\ndef removePrimes(arr, lenn):\n    sieve()\n    i = 0\n    while i < lenn:\n        if (isPrime[arr[i]]):\n            for j in range(i, lenn - 1):\n                arr[j] = arr[j + 1]\n            i -= 1\n            lenn -= 1\n        i += 1\n    prArray(arr, lenn)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 6, 5, 3, 8, 7, 10, 11, 14, 15]\n    lenn = len(arr)\n    removePrimes(arr, lenn)\n",
        "output": "4 6 8 10 14 15 ",
        "fn_call": "removePrimes"
    },
    {
        "text": "find subfactorial of a number | function to find the subfactorial of the number ; initialize variables ; iterating over range n ; fact variable store factorial of the i ; if count is even ; increase the value of count by 1 ; ",
        "context": "",
        "code": "def subfactorial(N):\n    res = 0\n    fact = 1\n    count = 0\n    for i in range(1, N + 1):\n        fact = fact * i\n        if (count % 2 == 0):\n            res = res - (1 / fact)\n        else:\n            res = res + (1 / fact)\n        count += 1\n    return fact * (1 + res)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    print(subfactorial(N))\n",
        "output": "9.0\n",
        "fn_call": "subfactorial"
    },
    {
        "text": "check whether given circle resides in boundary maintained by two other circles | python3 program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if ",
        "context": "\nimport math\n\n",
        "code": "def fitOrNotFit(R, r, x, y, rad):\n    val = math .sqrt(math .pow(x, 2) + math .pow(y, 2))\n    if (val + rad = R - r):\n        print(\"Fits\")\n    else:\n        print(\"Doesn't Fit\")\n",
        "test": "\nR = 8\nr = 4\nx = 5\ny = 3\nrad = 3\nfitOrNotFit(R, r, x, y, rad)\n",
        "output": "Doesn't Fit\n",
        "fn_call": "fitOrNotFit"
    },
    {
        "text": "count of integers up to n which represent a binary number | python3 program to count the number of integers upto n which are of the form of binary representations ; function to return the count ; if the current last digit is 1 ; add 2 ^ ( ctr - 1 ) possible integers to the answer ; if the current digit exceeds 1 ; set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def countBinaries(N):\n    ctr = 1\n    ans = 0\n    while (N > 0):\n        if (N % 10 == 1):\n            ans += pow(2, ctr - 1)\n        elif (N % 10 > 1):\n            ans = pow(2, ctr) - 1\n        ctr += 1\n        N //= 10\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 20\n    print(int(countBinaries(N)))\n",
        "output": "3\n",
        "fn_call": "countBinaries"
    },
    {
        "text": "count of substrings of a binary string containing only 1 s | function to find the total number of substring having only ones ; ",
        "context": "",
        "code": "def countOfSubstringWithOnlyOnes(s):\n    count = 0\n    res = 0\n    for i in range(0, len(s)):\n        if s[i] == '1':\n            count = count + 1\n        else:\n            count = 0\n        res = res + count\n    return res\n",
        "test": "\ns = \"0110111\"\nprint(countOfSubstringWithOnlyOnes(s))\n",
        "output": "9\n",
        "fn_call": "countOfSubstringWithOnlyOnes"
    },
    {
        "text": "generate all rotations of a number | function to return the count of digit of n ; function to print the left shift numbers ; formula to calculate left shift from previous number ; update the original number ; ",
        "context": "",
        "code": "def numberofDigits(n):\n    cnt = 0\n    while n > 0:\n        cnt += 1\n        n //= 10\n    return cnt\n\n\ndef cal(num):\n    digit = numberofDigits(num)\n    powTen = pow(10, digit - 1)\n    for i in range(digit - 1):\n        firstDigit = num // powTen\n        left = (num * 10 + firstDigit - (firstDigit * powTen * 10))\n        print(left, end=\" \")\n        num = left\n",
        "test": "\nnum = 1445\ncal(num)\n",
        "output": "4451 4514 5144 ",
        "fn_call": "cal"
    },
    {
        "text": "find the missing number | getmissingno takes list as argument ; ",
        "context": "",
        "code": "def getMissingNo(A):\n    n = len(A)\n    total = (n + 1) * (n + 2) / 2\n    sum_of_A = sum(A)\n    return total - sum_of_A\n",
        "test": "\nA = [1, 2, 4, 5, 6]\nmiss = getMissingNo(A)\nprint(miss)\n",
        "output": "3.0\n",
        "fn_call": "getMissingNo"
    },
    {
        "text": "count rotations which are divisible by 10 | function to return the count of all rotations which are divisible by 10. ; loop to iterate through the number ; if the last digit is 0 , then increment the count ; ",
        "context": "",
        "code": "def countRotation(n):\n    count = 0\n    while n > 0:\n        digit = n % 10\n        if (digit % 2 == 0):\n            count = count + 1\n        n = int(n / 10)\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10203\n    print(countRotation(n))\n",
        "output": "3\n",
        "fn_call": "countRotation"
    },
    {
        "text": "find a common element in all rows of a given row | specify number of rows and columns ; returns common element in all rows of mat [ m ] [ n ] . if there is no common element , then - 1 is returned ; an array to store indexes of current last column ; initialize min_row as first row ; keep finding min_row in current last column , till either all elements of last column become same or we hit first column . ; find minimum in current last column ; eq_count is count of elements equal to minimum in current last column . ; traverse current last column elements again to update it ; decrease last column index of a row whose value is more than minimum . ; reduce last column index by 1 ; if equal count becomes m , return the value ; ",
        "context": "\nM = 4\nN = 5\n\n",
        "code": "def findCommon(mat):\n    column = [N - 1] * M\n    min_row = 0\n    while (column[min_row] >= 0):\n        for i in range(M):\n            if (mat[i][column[i]] < mat[min_row][column[min_row]]):\n                min_row = i\n        eq_count = 0\n        for i in range(M):\n            if (mat[i][column[i]] > mat[min_row][column[min_row]]):\n                if (column[i] == 0):\n                    return -1\n                column[i] -= 1\n            else:\n                eq_count += 1\n        if (eq_count == M):\n            return mat[min_row][column[min_row]]\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3, 4, 5], [2, 4, 5, 8, 10],\n           [3, 5, 7, 9, 11], [1, 3, 5, 7, 9]]\n    result = findCommon(mat)\n    if (result == -1):\n        print(\"No common element\")\n    else:\n        print(\"Common element is\", result)\n",
        "output": "Common element is 5\n",
        "fn_call": "findCommon"
    },
    {
        "text": "print all root to leaf paths of an n | ''structure of an n ary tree node ; ''function to print the root to leaf path of the given n-ary tree ; '' print elements in the vector ; ''utility function to print all root to leaf paths of an nary tree ; '' if root is null ; ' ' \u2581 insert \u2581 current \u2581 node ' s data into the vector ; '' if current node is a leaf node ; '' print the path ; '' pop the leaf node  and return ; '' recur for all children of  the current node ; '' recursive function call ; ''function to print root to leaf path ; '' if root is null, return ; '' utility function call ; ''",
        "context": "\nclass Node:\n    def __init__(self, x):\n        self .data = x\n        self .child = []\n\n",
        "code": "def printPath(vec):\n    for ele in vec:\n        print(ele, end=\" \")\n    print()\n\n\ndef printAllRootToLeafPaths(root):\n    global vec\n    if (not root):\n        return\n    vec .append(root .data)\n    if (len(root .child) == 0):\n        printPath(vec)\n        vec .pop()\n        return\n    for i in range(len(root .child)):\n        printAllRootToLeafPaths(root .child[i])\n    vec .pop()\n\n\ndef printRootToLeafPaths(root):\n    global vec\n    if (not root):\n        return\n    printAllRootToLeafPaths(root)\n",
        "test": "\nif __name__ == '__main__':\n    vec = []\n    root = Node(1)\n    root .child .append(Node(2))\n    root .child .append(Node(3))\n    root .child[0].child .append(Node(4))\n    root .child[1].child .append(Node(5))\n    root .child[1].child .append(Node(6))\n    root .child[1].child[1].child .append(Node(7))\n    root .child[1].child[1].child .append(Node(8))\n    printRootToLeafPaths(root)\n",
        "output": "1 2 4 \n1 3 5 \n1 3 6 7 \n1 3 6 8 \n",
        "fn_call": "printRootToLeafPaths"
    },
    {
        "text": "count all triplets whose sum is equal to a perfect cube | python 3 program to calculate all triplets whose sum is perfect cube . ; function to calculate all occurrence of a number in a given range ; if i == 0 assign 1 to present state ; else add + 1 to current state with previous state ; function to calculate triplets whose sum is equal to the perfect cube ; initialize answer ; count all occurrence of third triplet in range from j + 1 to n ; ",
        "context": "\ndp = [[0 for i in range(15001)]for j in range(1001)]\n\n",
        "code": "def computeDpArray(arr, n):\n    for i in range(n):\n        for j in range(1, 15001, 1):\n            if (i == 0):\n                dp[i][j] = (j == arr[i])\n            else:\n                dp[i][j] = dp[i - 1][j] + (arr[i] == j)\n\n\ndef countTripletSum(arr, n):\n    computeDpArray(arr, n)\n    ans = 0\n    for i in range(0, n - 2, 1):\n        for j in range(i + 1, n - 1, 1):\n            for k in range(1, 25, 1):\n                cube = k * k * k\n                rem = cube - (arr[i] + arr[j])\n                if (rem > 0):\n                    ans += dp[n - 1][rem] - dp[j][rem]\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 5, 1, 20, 6]\n    n = len(arr)\n    print(countTripletSum(arr, n))\n",
        "output": "3\n",
        "fn_call": "countTripletSum"
    },
    {
        "text": "find i 'th index character in a binary string obtained after n iterations | function to store binary representation ; function to find ith character ; function to change decimal to binary ; assign s1 string in s string ; ",
        "context": "",
        "code": "def binary_conversion(s, m):\n    while (m):\n        temp = m % 2\n        s += str(temp)\n        m = m // 2\n    return s[::-1]\n\n\ndef find_character(n, m, i):\n    s = \"\"\n    s = binary_conversion(s, m)\n    s1 = \"\"\n    for x in range(n):\n        for j in range(len(s)):\n            if s[j] == \"1\":\n                s1 += \"10\"\n            else:\n                s1 += \"01\"\n        s = s1\n        s1 = \"\"\n    e = ord(s[i])\n    r = ord('0')\n    return e - r\n",
        "test": "\nm, n, i = 5, 2, 8\nprint(find_character(n, m, i))\n",
        "output": "1\n",
        "fn_call": "find_character"
    },
    {
        "text": "check if roots of a quadratic equation are numerically equal but opposite in sign or not | function to find the required answer ; ",
        "context": "",
        "code": "def checkSolution(a, b, c):\n    if b == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\na = 2\nb = 0\nc = 2\ncheckSolution(a, b, c)\n",
        "output": "Yes\n",
        "fn_call": "checkSolution"
    },
    {
        "text": "maximum product cutting | dp | the main function that returns the max possible product ; n equals to 2 or 3 must be handled explicitly ; keep removing parts of size 3 while n is greater than 4 ; keep multiplying 3 to res ; the last part multiplied by previous parts ; ",
        "context": "",
        "code": "def maxProd(n):\n    if (n == 2 or n == 3):\n        return (n - 1)\n    res = 1\n    while (n > 4):\n        n -= 3\n        res *= 3\n    return (n * res)\n",
        "test": "\nprint(\"Maximum Product is \", maxProd(10))\n",
        "output": "Maximum Product is  36\n",
        "fn_call": "maxProd"
    },
    {
        "text": "check given matrix is magic square or not | python3 program to check whether a given matrix is magic matrix or not ; returns true if mat [ ] [ ] is magic square , else returns false . ; calculate the sum of the prime diagonal ; the secondary diagonal ; for sums of rows ; check if every row sum is equal to prime diagonal sum ; for sums of columns ; check if every column sum is equal to prime diagonal sum ; ",
        "context": "\nN = 3\n\n",
        "code": "def isMagicSquare(mat):\n    s = 0\n    for i in range(0, N):\n        s = s + mat[i][i]\n    s2 = 0\n    for i in range(0, N):\n        s2 = s2 + mat[i][N - i - 1]\n    if (s != s2):\n        return False\n    for i in range(0, N):\n        rowSum = 0\n        for j in range(0, N):\n            rowSum += mat[i][j]\n        if (rowSum != s):\n            return False\n    for i in range(0, N):\n        colSum = 0\n        for j in range(0, N):\n            colSum += mat[j][i]\n        if (s != colSum):\n            return False\n    return True\n",
        "test": "\nmat = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\nif (isMagicSquare(mat)):\n    print(\"Magic Square\")\nelse:\n    print(\"Not a magic Square\")\n",
        "output": "Magic Square\n",
        "fn_call": "isMagicSquare"
    },
    {
        "text": "lcm of given array elements | recursive function to return gcd of a and b ; recursive implementation ; lcm ( a , b ) = ( a * b / gcd ( a , b ) ) ; ",
        "context": "",
        "code": "def __gcd(a, b):\n    if (a == 0):\n        return b\n    return __gcd(b % a, a)\n\n\ndef LcmOfArray(arr, idx):\n    if (idx == len(arr) - 1):\n        return arr[idx]\n    a = arr[idx]\n    b = LcmOfArray(arr, idx + 1)\n    return int(a * b / __gcd(a, b))\n",
        "test": "\narr = [1, 2, 8, 3]\nprint(LcmOfArray(arr, 0))\narr = [2, 7, 3, 9, 4]\nprint(LcmOfArray(arr, 0))\n",
        "output": "24\n252\n",
        "fn_call": "LcmOfArray"
    },
    {
        "text": "probability of reaching a point with 2 or 3 steps at a time | returns probability to reach n ; ",
        "context": "",
        "code": "def find_prob(N, P):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 0\n    dp[2] = P\n    dp[3] = 1 - P\n    for i in range(4, N + 1):\n        dp[i] = (P) * dp[i - 2] + (1 - P) * dp[i - 3]\n    return dp[N]\n",
        "test": "\nn = 5\np = 0.2\nprint(round(find_prob(n, p), 2))\n",
        "output": "0.32\n",
        "fn_call": "find_prob"
    },
    {
        "text": "quickselect ( a simple iterative implementation ) | standard lomuto partition function ; implementation of quickselect ; partition a [ left . . right ] around a pivot and find the position of the pivot ; if pivot itself is the k - th smallest element ; if there are more than k - 1 elements on left of pivot , then k - th smallest must be on left side . ; else k - th smallest is on right side . ; ",
        "context": "",
        "code": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = (low - 1)\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return (i + 1)\n\n\ndef kthSmallest(a, left, right, k):\n    while left <= right:\n        pivotIndex = partition(a, left, right)\n        if pivotIndex == k - 1:\n            return a[pivotIndex]\n        elif pivotIndex > k - 1:\n            right = pivotIndex - 1\n        else:\n            left = pivotIndex + 1\n    return -1\n",
        "test": "\narr = [10, 4, 5, 8, 11, 6, 26]\nn = len(arr)\nk = 5\nprint(\"K-th smallest element is\", kthSmallest(arr, 0, n - 1, k))\n",
        "output": "K-th smallest element is 10\n",
        "fn_call": "kthSmallest"
    },
    {
        "text": "remove a character from a string to make it a palindrome | utility method to check if substring from low to high is palindrome or not . ; this method returns - 1 if it is not possible to make string a palindrome . it returns - 2 if string is already a palindrome . otherwise it returns index of character whose removal can make the whole string palindrome . ; initialize low and right by both the ends of the string ; loop until low and high cross each other ; if both characters are equal then move both pointer towards end ; if removing str [ low ] makes the whole string palindrome . we basically check if substring str [ low + 1. . high ] is palindrome or not . ; if removing str [ high ] makes the whole string palindrome we basically check if substring str [ low + 1. . high ] is palindrome or not ; we reach here when complete string will be palindrome if complete string is palindrome then return mid character ; ",
        "context": "",
        "code": "def isPalindrome(string: str, low: int, high: int) -> bool:\n    while low < high:\n        if string[low] != string[high]:\n            return False\n        low += 1\n        high -= 1\n    return True\n\n\ndef possiblepalinByRemovingOneChar(string: str) -> int:\n    low = 0\n    high = len(string) - 1\n    while low < high:\n        if string[low] == string[high]:\n            low += 1\n            high -= 1\n        else:\n            if isPalindrome(string, low + 1, high):\n                return low\n            if isPalindrome(string, low, high - 1):\n                return high\n            return -1\n    return -2\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"abecbea\"\n    idx = possiblepalinByRemovingOneChar(string)\n    if idx == -1:\n        print(\"Not possible\")\n    elif idx == -2:\n        print(\"Possible without removing any character\")\n    else:\n        print(\"Possible by removing character at index\", idx)\n",
        "output": "Not possible\n",
        "fn_call": "possiblepalinByRemovingOneChar"
    },
    {
        "text": "count substrings with same first and last characters | assuming lower case only ; calculating frequency of each character in the string . ; computing result using counts ; ",
        "context": "\nMAX_CHAR = 26\n\n",
        "code": "def countSubstringWithEqualEnds(s):\n    result = 0\n    n = len(s)\n    count = [0] * MAX_CHAR\n    for i in range(n):\n        count[ord(s[i]) - ord('a')] += 1\n    for i in range(MAX_CHAR):\n        result += (count[i] * (count[i] + 1) / 2)\n    return result\n",
        "test": "\ns = \"abcab\"\nprint(countSubstringWithEqualEnds(s))\n",
        "output": "7.0\n",
        "fn_call": "countSubstringWithEqualEnds"
    },
    {
        "text": "subarray permutation that satisfies the given condition | function that returns true if the required subarray exists in the given array ; map to store the positions of each integer in the original permutation ; to store the address of each entry in arr [ n ] but with 1 - based indexing ; to track minimum position sumcur for sum of a positions ti this position ; summing up addresses ; tracking minimum address encountered ti now ; the sum of the addresses if it forms the required subarray ; if current sum of address is equal to val ; ",
        "context": "",
        "code": "def subArray(arr, n, m):\n    i = 0\n    mp = dict()\n    for i in range(n):\n        mp[arr[i]] = i + 1\n    sumcur = 0\n    p = 10 ** 9\n    ans = []\n    for i in range(1, m + 1):\n        sumcur += mp[i]\n        p = min(p, mp[i])\n        val = p * i - i + (i * (i + 1)) / 2\n        if (i == m):\n            if (val == sumcur):\n                return True\n            else:\n                return False\n",
        "test": "\narr = [4, 5, 1, 3, 2, 6]\nn = len(arr)\nm = 3\nif (subArray(arr, n, m)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "subArray"
    },
    {
        "text": "product of all subsets of a set formed by first n natural numbers | function to find the product of all elements in all subsets in natural numbers from 1 to n ; ",
        "context": "",
        "code": "def product(N):\n    ans = 1\n    val = 2 ** (N - 1)\n    for i in range(1, N + 1):\n        ans *= (i ** val)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 2\n    print(product(N))\n",
        "output": "4\n",
        "fn_call": "product"
    },
    {
        "text": "minimum cost to convert m to n by repeated addition of its even divisors | python3 program for the above approach ; function to find the value of minimum steps to convert m to n ; base case ; if n exceeds m ; iterate through all possible even divisors of m ; if m is divisible by i , then find the minimum cost ; add the cost to convert m to m + i and recursively call next state ; return min_cost ; ",
        "context": "\ninf = 1000000008\n\n",
        "code": "def minSteps(m, n):\n    if (n == m):\n        return 0\n    if (m > n):\n        return inf\n    min_cost = inf\n    for i in range(2, m, 2):\n        if (m % i == 0):\n            min_cost = min(min_cost, m / i + minSteps(m + i, n))\n    return min_cost\n",
        "test": "\nif __name__ == '__main__':\n    M = 6\n    N = 24\n    minimum_cost = minSteps(M, N)\n    if minimum_cost == inf:\n        minimum_cost = -1\n    print(minimum_cost)\n",
        "output": "10.0\n",
        "fn_call": "minSteps"
    },
    {
        "text": "Check whether Bishop can take down Pawn or not | Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Bishop 's Position ; Pawn 's Position",
        "context": "",
        "code": "def canTakeDown(bishopX, bishopY, pawnX, pawnY):\n    if (pawnX - bishopX == pawnY - bishopY):\n        return True\n    elif (-pawnX + bishopX == pawnY - bishopY):\n        return True\n    else:\n        return False\n",
        "test": "\nbishopX = 5\nbishopY = 5\npawnX = 1\npawnY = 1\nif (canTakeDown(bishopX, bishopY, pawnX, pawnY)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canTakeDown"
    },
    {
        "text": "multiply a number by 15 without using * and / operators | function to perform multiplication ; prod = 8 * n ; add ( 4 * n ) ; add ( 2 * n ) ; add n ; ( 8 * n ) + ( 4 * n ) + ( 2 * n ) + n = ( 15 * n ) ; ",
        "context": "",
        "code": "def multiplyByFifteen(n):\n    prod = (n << 3)\n    prod += (n << 2)\n    prod += (n << 1)\n    prod += n\n    return prod\n",
        "test": "\nn = 7\nprint(multiplyByFifteen(n))\n",
        "output": "105\n",
        "fn_call": "multiplyByFifteen"
    },
    {
        "text": "sum of first n natural numbers with alternate signs | function to find the sum of first n natural numbers with alternate signs ; stores sum of alternate sign of first n natural numbers ; if n is an even number ; update alternatesum ; if n is an odd number ; update alternatesum ; ",
        "context": "",
        "code": "def alternatingSumOfFirst_N(N):\n    alternateSum = 0\n    if (N % 2 == 0):\n        alternateSum = (-N) // 2\n    else:\n        alternateSum = (N + 1) // 2\n    return alternateSum\n",
        "test": "\nif __name__ == '__main__':\n    N = 6\n    print(alternatingSumOfFirst_N(N))\n",
        "output": "-3\n",
        "fn_call": "alternatingSumOfFirst_N"
    },
    {
        "text": "winner in the rock | function to return the winner of the game ; both the players chose to play the same move ; player a wins the game ; function to perform the queries ; ",
        "context": "",
        "code": "def winner(moves):\n    data = dict()\n    data['R'] = 0\n    data['P'] = 1\n    data['S'] = 2\n    if (moves[0] == moves[1]):\n        return \"Draw\"\n    if (((data[moves[0]] | 1 << (2)) - (data[moves[1]] | 0 << (2))) % 3):\n        return \"A\"\n    return \"B\"\n\n\ndef performQueries(arr, n):\n    for i in range(n):\n        print(winner(arr[i]))\n",
        "test": "\narr = [\"RS\", \"SR\", \"SP\", \"PP\"]\nn = len(arr)\nperformQueries(arr, n)\n",
        "output": "A\nB\nA\nDraw\n",
        "fn_call": "performQueries"
    },
    {
        "text": "maximum score possible after performing given operations on an array | function to calculate maximum score recursively ; base case ; sum of array in range ( l , r ) ; if the operation is even - numbered the score is decremented ; exploring all paths , by removing leftmost and rightmost element and selecting the maximum value ; function to find the max score ; prefix sum array ; calculating prefix_sum ; ",
        "context": "",
        "code": "def maxScore(l, r, prefix_sum, num):\n    if (l > r):\n        return 0\n    if ((l - 1) >= 0):\n        current_sum = (prefix_sum[r] - prefix_sum[l - 1])\n    else:\n        current_sum = prefix_sum[r] - 0\n    if (num % 2 == 0):\n        current_sum *= -1\n    return current_sum + max(maxScore(l + 1, r, prefix_sum,\n                             num + 1), maxScore(l, r - 1, prefix_sum, num + 1))\n\n\ndef findMaxScore(a, n):\n    prefix_sum = [0] * n\n    prefix_sum[0] = a[0]\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i]\n    return maxScore(0, n - 1, prefix_sum, 1)\n",
        "test": "\nn = 6\nA = [1, 2, 3, 4, 2, 6]\nans = findMaxScore(A, n)\nprint(ans)\n",
        "output": "13\n",
        "fn_call": "findMaxScore"
    },
    {
        "text": "longest subarray having average greater than or equal to x | function to find index in presum list of tuples upto which all prefix sum values are less than or equal to val . ; starting and ending index of search space . ; to store required index value ; if middle value is less than or equal to val then index can lie in mid + 1. . n else it lies in 0. . mid - 1 ; function to find longest subarray having average greater than or equal to x . ; update array by subtracting x from each element ; length of longest subarray . ; list to store pair of prefix sum and corresponding ending index value . ; to store current value of prefix sum . ; to store minimum index value in range 0. . i of presum vector . ; insert values in presum vector ; update minind array . ; if sum is greater than or equal to 0 , then answer is i + 1 ; if sum is less than 0 , then find if there is a prefix array having sum that needs to be added to current sum to make its value greater than or equal to 0. if yes , then compare length of updated subarray with maximum length found so far ; ",
        "context": "",
        "code": "def findInd(preSum, n, val):\n    l = 0\n    h = n - 1\n    ans = -1\n    while (l <= h):\n        mid = (l + h) // 2\n        if preSum[mid][0] <= val:\n            ans = mid\n            l = mid + 1\n        else:\n            h = mid - 1\n    return ans\n\n\ndef LongestSub(arr, n, x):\n    for i in range(n):\n        arr[i] -= x\n    maxlen = 0\n    preSum = []\n    total = 0\n    minInd = [None] * n\n    for i in range(n):\n        total += arr[i]\n        preSum .append((total, i))\n    preSum = sorted(preSum)\n    minInd[0] = preSum[0][1]\n    for i in range(1, n):\n        minInd[i] = min(minInd[i - 1], preSum[i][1])\n    total = 0\n    for i in range(n):\n        total += arr[i]\n        if total >= 0:\n            maxlen = i + 1\n        else:\n            ind = findInd(preSum, n, total)\n            if (ind != -1) & (minInd[ind] < i):\n                maxlen = max(maxlen, i - minInd[ind])\n    return maxlen\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-2, 1, 6, -3]\n    n = len(arr)\n    x = 3\n    print(LongestSub(arr, n, x))\n",
        "output": "2\n",
        "fn_call": "LongestSub"
    },
    {
        "text": "check if a number n can be expressed as the sum of powers of x or not | function to check if the number n can be expressed as the sum of different powers of x or not ; while n is a positive number ; find the remainder ; if rem is at least 2 , then representation is impossible ; divide the value of n by x ; ",
        "context": "",
        "code": "def ToCheckPowerofX(n, x):\n    while (n > 0):\n        rem = n % x\n        if (rem >= 2):\n            return False\n        n = n // x\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    X = 3\n    if (ToCheckPowerofX(N, X)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "ToCheckPowerofX"
    },
    {
        "text": "count of index pairs with equal elements in an array | return the number of pairs with equal values . ; for each index i and j ; finding the index with same value but different index . ; ",
        "context": "",
        "code": "def countPairs(arr, n):\n    ans = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (arr[i] == arr[j]):\n                ans += 1\n    return ans\n",
        "test": "\narr = [1, 1, 2]\nn = len(arr)\nprint(countPairs(arr, n))\n",
        "output": "1\n",
        "fn_call": "countPairs"
    },
    {
        "text": "find nth smallest number that is divisible by 100 exactly k times | function to find the nth smallest number ; if n is divisible by 100 then we multiply n + 1 otherwise , it will be divisible by 100 more than k times ; convert integer to string ; if n is not divisible by 100 ; convert integer to string ; add 2 * k 0 's at the end to be divisible  by 100 exactly k times ; ",
        "context": "",
        "code": "def find_number(N, K):\n    r = \"\"\n    if (N % 100 == 0):\n        N += 1\n        r = str(N)\n    else:\n        r = str(N)\n    for i in range(1, K + 1):\n        r += \"00\"\n    return r\n",
        "test": "\nN = 1000\nK = 2\nans = find_number(N, K)\nprint(ans)\n",
        "output": "10010000\n",
        "fn_call": "find_number"
    },
    {
        "text": "check whether two strings contain same characters in same order | python3 implementation of the approach ; string class has a constructor that allows us to specify the size of string as first parameter and character to be filled in given size as the second parameter . ; function that returns true if the given strings contain same characters in same order ; get the first character of both strings ; now if there are adjacent similar character remove that character from s1 ; now if there are adjacent similar character remove that character from s2 ; if both the strings are equal then return true ; ",
        "context": "",
        "code": "def getString(x):\n    return x\n\n\ndef solve(s1, s2):\n    a = getString(s1[0])\n    b = getString(s2[0])\n    for i in range(1, len(s1)):\n        if s1[i] != s1[i - 1]:\n            a += getString(s1[i])\n    for i in range(1, len(s2)):\n        if s2[i] != s2[i - 1]:\n            b += getString(s2[i])\n    if a == b:\n        return True\n    return False\n",
        "test": "\ns1 = \"Geeks\"\ns2 = \"Geks\"\nif solve(s1, s2):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "solve"
    },
    {
        "text": "check whether product of digits at even places is divisible by sum of digits at odd place of a number | below function checks whether product of digits at even places is divisible by sum of digits at odd places ; converting integer to string ; traveersing the string ; ",
        "context": "",
        "code": "def productSumDivisible(n):\n    sum = 0\n    product = 1\n    num = str(n)\n    for i in range(len(num)):\n        if (i % 2 != 0):\n            product = product * int(num[i])\n        else:\n            sum = sum + int(num[i])\n    if (product % sum == 0):\n        return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 1234\n    if (productSumDivisible(n)):\n        print(\"TRUE\")\n    else:\n        print(\"FALSE\")\n",
        "output": "TRUE\n",
        "fn_call": "productSumDivisible"
    },
    {
        "text": "split an array into minimum number of non | function to split the array into minimum count of subarrays such that each subarray is either non - increasing or non - decreasing ; initialize variable to keep track of current sequence ; stores the required result ; traverse the array , arr [ ] ; if current sequence is neither non - increasing nor non - decreasing ; if previous element is greater ; update current ; if previous element is equal to the current element ; update current ; otherwise ; update current ; if current sequence is in non - decreasing ; i f previous element is less than or equal to the current element ; otherwise ; update current as n and increment answer by 1 ; if current sequence is non - increasing ; if previous element is greater or equal to the current element ; otherwise ; update current as n and increment answer by 1 ; print the answer ; ",
        "context": "",
        "code": "def minimumSubarrays(arr, n):\n    current = 'N'\n    answer = 1\n    for i in range(1, n):\n        if (current == 'N'):\n            if (arr[i] < arr[i - 1]):\n                current = 'D'\n            elif (arr[i] == arr[i - 1]):\n                current = 'N'\n            else:\n                current = 'I'\n        elif (current == 'I'):\n            if (arr[i] >= arr[i - 1]):\n                current = 'I'\n            else:\n                current = 'N'\n                answer += 1\n        else:\n            if (arr[i] <= arr[i - 1]):\n                current = 'D'\n            else:\n                current = 'N'\n                answer += 1\n    print(answer)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 9, 5, 4, 6, 8]\n    n = len(arr)\n    minimumSubarrays(arr, n)\n",
        "output": "3\n",
        "fn_call": "minimumSubarrays"
    },
    {
        "text": "check if a right | function to check if right - angled triangle can be formed by the given coordinates ; calculate the sides ; check pythagoras formula ; ",
        "context": "",
        "code": "def checkRightAngled(X1, Y1, X2, Y2, X3, Y3):\n    A = (int(pow((X2 - X1), 2)) + int(pow((Y2 - Y1), 2)))\n    B = (int(pow((X3 - X2), 2)) + int(pow((Y3 - Y2), 2)))\n    C = (int(pow((X3 - X1), 2)) + int(pow((Y3 - Y1), 2)))\n    if ((A > 0 and B > 0 and C > 0) and (\n            A == (B + C) or B == (A + C) or C == (A + B))):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    X1 = 0\n    X2 = 0\n    X3 = 9\n    Y1 = 2\n    Y2 = 14\n    Y3 = 2\n    checkRightAngled(X1, Y1, X2, Y2, X3, Y3)\n",
        "output": "Yes\n",
        "fn_call": "checkRightAngled"
    },
    {
        "text": "count numbers which can be constructed using two numbers | returns count of numbers from 1 to n that can be formed using x and y . ; create an auxiliary array and initialize it as false . an entry arr [ i ] = true is going to mean that i can be formed using x and y ; x and y can be formed using x and y . ; initialize result ; traverse all numbers and increment result if a number can be formed using x and y . ; if i can be formed using x and y ; then i + x and i + y can also be formed using x and y . ; increment result ; ",
        "context": "",
        "code": "def countNums(n, x, y):\n    arr = [False for i in range(n + 2)]\n    if (x <= n):\n        arr[x] = True\n    if (y <= n):\n        arr[y] = True\n    result = 0\n    for i in range(min(x, y), n + 1):\n        if (arr[i]):\n            if (i + x <= n):\n                arr[i + x] = True\n            if (i + y <= n):\n                arr[i + y] = True\n            result = result + 1\n    return result\n",
        "test": "\nn = 15\nx = 5\ny = 7\nprint(countNums(n, x, y))\n",
        "output": "6\n",
        "fn_call": "countNums"
    },
    {
        "text": "print all longest dividing subsequence in an array | function to print lds [ i ] element ; traverse the max [ ] ; function to construct and print longest dividing subsequence ; 2d vector for storing sequences ; push the first element to lds [ ] [ ] ; interate over all element ; loop for every index till i ; if current elements divides arr [ i ] and length is greater than the previous index , then insert the current element to the sequences lds [ i ] ; l [ i ] ends with arr [ i ] ; lds stores the sequences till each element of arr [ ] traverse the lds [ ] [ ] to find the maximum length ; print all lds with maximum length ; find size ; if size = maxlength ; print lds ; ",
        "context": "",
        "code": "def printLDS(Max):\n    for it in Max:\n        print(it, end=\" \")\n\n\ndef LongestDividingSeq(arr, N):\n    LDS = [[]for i in range(N)]\n    LDS[0].append(arr[0])\n    for i in range(1, N):\n        for j in range(i):\n            if ((arr[i] % arr[j] == 0) and (len(LDS[i]) < len(LDS[j]) + 1)):\n                LDS[i] = LDS[j].copy()\n        LDS[i].append(arr[i])\n    maxLength = 0\n    for i in range(N):\n        x = len(LDS[i])\n        maxLength = max(maxLength, x)\n    for i in range(N):\n        size = len(LDS[i])\n        if (size == maxLength):\n            printLDS(LDS[i])\n            print()\n",
        "test": "\narr = [2, 11, 16, 12, 36, 60, 71]\nN = len(arr)\nLongestDividingSeq(arr, N)\n",
        "output": "2 12 36 \n2 12 60 \n",
        "fn_call": "LongestDividingSeq"
    },
    {
        "text": "count of distinct gcds among all the non | python 3 program for the above approach ; function to calculate the number of distinct gcds among all non - empty subsequences of an array ; variables to store the largest element in array and the required count ; map to store whether a number is present in a ; calculate largest number in a and mapping a to mp ; iterate over all possible values of gcd ; variable to check current gcd ; iterate over all multiples of i ; if j is present in a ; calculate gcd of all encountered multiples of i ; current gcd is possible ; return answer ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def distinctGCDs(arr, N):\n    M = -1\n    ans = 0\n    Mp = {}\n    for i in range(N):\n        M = max(M, arr[i])\n        Mp[arr[i]] = 1\n    for i in range(1, M + 1, 1):\n        currGcd = 0\n        for j in range(i, M + 1, i):\n            if (j in Mp):\n                currGcd = gcd(currGcd, j)\n                if (currGcd == i):\n                    ans += 1\n                    break\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 11, 14, 6, 12]\n    N = len(arr)\n    print(distinctGCDs(arr, N))\n",
        "output": "7\n",
        "fn_call": "distinctGCDs"
    },
    {
        "text": "program to implement collatz conjecture | function to find if n reaches to 1 or not . ; return true if n is positive ; ",
        "context": "",
        "code": "def isToOne(n):\n    return (n > 0)\n",
        "test": "\nn = 5\nif isToOne(n):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isToOne"
    },
    {
        "text": "check if a subarray exists with sum greater than the given array | function to check whether there exists a subarray whose sum is greater than or equal to sum of given array elements ; initialize sum with 0 ; checking possible prefix subarrays . if sum of them is less than or equal to zero , then return 1 ; again reset sum to zero ; checking possible suffix subarrays . if sum of them is less than or equal to zero , then return 1 ; otherwise return 0 ; ",
        "context": "",
        "code": "def subarrayPossible(arr, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n        if (sum <= 0):\n            return True\n    sum = 0\n    for i in range(n - 1, -1, -1):\n        sum += arr[i]\n        if (sum <= 0):\n            return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 5, -12, 7, -10, 20, 30, -10, 50, 60]\n    size = len(arr)\n    if (subarrayPossible(arr, size)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "subarrayPossible"
    },
    {
        "text": "find two numbers with the given lcm and minimum possible difference | python3 implementation of the approach ; function to return the lcm of a and b ; function to find and print the two numbers ; to find the factors ; to check if i is a factor of x and the minimum possible number satisfying the given conditions ; ",
        "context": "\nfrom math import gcd as __gcd, sqrt, ceil\n\n",
        "code": "def lcm(a, b):\n    return (a // __gcd(a, b) * b)\n\n\ndef findNums(x):\n    ans = 0\n    for i in range(1, ceil(sqrt(x))):\n        if (x % i == 0 and lcm(i, x // i) == x):\n            ans = i\n    print(ans, (x // ans))\n",
        "test": "\nx = 12\nfindNums(x)\n",
        "output": "3 4\n",
        "fn_call": "findNums"
    },
    {
        "text": "coordinates of rectangle with given points lie inside | function to print coordinate of smallest rectangle ; find xmax and xmin ; find ymax and ymin ; print all four coordinates ; ",
        "context": "",
        "code": "def printRect(X, Y, n):\n    Xmax = max(X)\n    Xmin = min(X)\n    Ymax = max(Y)\n    Ymin = min(Y)\n    print(\"{\", Xmin, \", \", Ymin, \"}\", sep=\"\")\n    print(\"{\", Xmin, \", \", Ymax, \"}\", sep=\"\")\n    print(\"{\", Xmax, \", \", Ymax, \"}\", sep=\"\")\n    print(\"{\", Xmax, \", \", Ymin, \"}\", sep=\"\")\n",
        "test": "\nX = [4, 3, 6, 1, -1, 12]\nY = [4, 1, 10, 3, 7, -1]\nn = len(X)\nprintRect(X, Y, n)\n",
        "output": "{-1, -1}\n{-1, 10}\n{12, 10}\n{12, -1}\n",
        "fn_call": "printRect"
    },
    {
        "text": "minimum value among and of elements of every subset of an array | python program for the above approach ; find and of whole array ; print the answer ; ",
        "context": "",
        "code": "def minAND(arr, n):\n    s = arr[0]\n    for i in range(1, n):\n        s = s & arr[i]\n    print(s)\n",
        "test": "\narr = [1, 2, 3]\nn = len(arr)\nminAND(arr, n)\n",
        "output": "0\n",
        "fn_call": "minAND"
    },
    {
        "text": "form n | function returns the minimum cost to form a n - copy string here , x -> cost to add / remove a single character ' g ' and y -> cost to append the string to itself ; base case : ro form a 1 - copy string we need tp perform an operation of type 1 ( i , e add ) ; case1 . perform a add operation on ( i - 1 ) copy string case2 . perform a type 2 operation on ( ( i + 1 ) / 2 ) - copy string ; case1 . perform a add operation on ( i - 1 ) - copy string case2 . perform a type operation on ( i / 2 ) - copy string ; ",
        "context": "",
        "code": "def findMinimumCost(n, x, y):\n    dp = [0 for i in range(n + 1)]\n    dp[1] = x\n    for i in range(2, n + 1):\n        if i & 1:\n            dp[i] = min(dp[i - 1] + x, dp[(i + 1) // 2] + y + x)\n        else:\n            dp[i] = min(dp[i - 1] + x, dp[i // 2] + y)\n    return dp[n]\n",
        "test": "\nn, x, y = 4, 2, 1\nprint(findMinimumCost(n, x, y))\n",
        "output": "4\n",
        "fn_call": "findMinimumCost"
    },
    {
        "text": "modify given array to make sum of odd and even indexed elements same | function to modify array to make sum of odd and even indexed elements equal ; stores the count of 0 s , 1 s ; stores sum of odd and even indexed elements respectively ; count 0 s ; count 1 s ; calculate odd_sum and even_sum ; if both are equal ; print the original array ; otherwise ; print all the 0 s ; for checking even or odd ; update total count of 1 s ; print all 1 s ; ",
        "context": "",
        "code": "def makeArraySumEqual(a, N):\n    count_0 = 0\n    count_1 = 0\n    odd_sum = 0\n    even_sum = 0\n    for i in range(N):\n        if (a[i] == 0):\n            count_0 += 1\n        else:\n            count_1 += 1\n        if ((i + 1) % 2 == 0):\n            even_sum += a[i]\n        elif ((i + 1) % 2 > 0):\n            odd_sum += a[i]\n    if (odd_sum == even_sum):\n        for i in range(N):\n            print(a[i], end=\" \")\n    else:\n        if (count_0 >= N / 2):\n            for i in range(count_0):\n                print(\"0\", end=\" \")\n        else:\n            is_Odd = count_1 % 2\n            count_1 -= is_Odd\n            for i in range(count_1):\n                print(\"1\", end=\" \")\n",
        "test": "\narr = [1, 1, 1, 0]\nN = len(arr)\nmakeArraySumEqual(arr, N)\n",
        "output": "1 1 ",
        "fn_call": "makeArraySumEqual"
    },
    {
        "text": "count of alphabets whose ascii values can be formed with the digits of n | python3 implementation of the approach ; function that returns true if num can be formed with the digits in digits [ ] array ; copy of the digits array ; get last digit ; if digit array doesn 't contain  current digit ; one occurrence is used ; remove the last digit ; function to return the count of required alphabets ; to store the occurrences of digits ( 0 - 9 ) ; get last digit ; update the occurrence of the digit ; remove the last digit ; if any lowercase character can be picked from the current digits ; if any uppercase character can be picked from the current digits ; return the required count of alphabets ; ",
        "context": "\nimport math\n\n",
        "code": "def canBePicked(digits, num):\n    copyDigits = []\n    for i in range(len(digits)):\n        copyDigits .append(digits[i])\n    while (num > 0):\n        digit = num % 10\n        if (copyDigits[digit] == 0):\n            return False\n        else:\n            copyDigits[digit] -= 1\n        num = math .floor(num / 10)\n    return True\n\n\ndef countAlphabets(n):\n    count = 0\n    digits = [0] * 10\n    while (n > 0):\n        digit = n % 10\n        digits[digit] += 1\n        n = math .floor(n / 10)\n    for i in range(ord('a'), ord('z') + 1):\n        if (canBePicked(digits, i)):\n            count += 1\n    for i in range(ord('A'), ord('Z') + 1):\n        if (canBePicked(digits, i)):\n            count += 1\n    return count\n",
        "test": "\nn = 1623455078\nprint(countAlphabets(n))\n",
        "output": "27\n",
        "fn_call": "countAlphabets"
    },
    {
        "text": "queries to update array elements in a range [ l , r ] to satisfy given conditions | function to prthe array ; function to perform the query in range [ l , r ] such that arr [ i ] += i - l + 1 ; initialize array ; traverse the query array ; stores range in 1 - based index ; update arr1 [ l ] ; update arr1 [ r + 1 ] ; update arr2 [ r + 1 ] ; calculate prefix sum ; traverse the array , arr2 [ ] ; copy arr2 [ ] into arr [ ] ; ",
        "context": "",
        "code": "def printArray(arr, N):\n    print(*arr)\n\n\ndef modifyArray(arr, N, Q, cntQuery):\n    arr1 = [0 for i in range(N + 2)]\n    arr2 = [0 for i in range(N + 2)]\n    for i in range(cntQuery):\n        L = Q[i][0] + 1\n        R = Q[i][1] + 1\n        arr1[L] += 1\n        arr1[R + 1] -= 1\n        arr2[R + 1] -= R - L + 1\n    for i in range(1, N + 1):\n        arr1[i] += arr1[i - 1]\n    for i in range(1, N + 1):\n        arr2[i] += arr2[i - 1] + arr1[i]\n    for i in range(1, N + 1):\n        arr[i - 1] = arr2[i]\n    printArray(arr, N)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 0, 0, 0]\n    N = len(arr)\n    Q = [[1, 3], [0, 1]]\n    cntQuery = len(Q)\n    modifyArray(arr, N, Q, cntQuery)\n",
        "output": "1 3 2 3\n",
        "fn_call": "modifyArray"
    },
    {
        "text": "count natural numbers whose factorials are divisible by x but not y | gcd function to compute the greatest divisor among a and b ; returns first number whose factorial is divisible by x . ; result ; remove common factors ; we found first i . ; count of natural numbers whose factorials are divisible by x but not y . ; return difference between first natural number whose factorial is divisible by y and first natural number whose factorial is divisible by x . ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if ((a % b) == 0):\n        return b\n    return gcd(b, a % b)\n\n\ndef firstFactorialDivisibleNumber(x):\n    i = 1\n    new_x = x\n    for i in range(1, x):\n        new_x /= gcd(i, new_x)\n        if (new_x == 1):\n            break\n    return i\n\n\ndef countFactorialXNotY(x, y):\n    return (firstFactorialDivisibleNumber(\n        y) - firstFactorialDivisibleNumber(x))\n",
        "test": "\nx = 15\ny = 25\nprint(countFactorialXNotY(x, y))\n",
        "output": "5\n",
        "fn_call": "countFactorialXNotY"
    },
    {
        "text": "find all possible values of k such that the sum of first n numbers starting from k is g | python 3 program for the above approach ; function to find the count the value of k such that sum of the first n numbers from k is g ; stores the total count of k ; iterate till square root of g ; if the number is factor of g ; if the second factor is not equal to first factor ; check if two factors are odd or not ; if second factor is the same as the first factor then check if the first factor is odd or not ; print the resultant count ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def findValuesOfK(g):\n    count = 0\n    for i in range(1, int(sqrt(g)) + 1, 1):\n        if (g % i == 0):\n            if (i != g // i):\n                if (i & 1):\n                    count += 1\n                if ((g // i) & 1):\n                    count += 1\n            elif (i & 1):\n                count += 1\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    G = 125\n    findValuesOfK(G)\n",
        "output": "4\n",
        "fn_call": "findValuesOfK"
    },
    {
        "text": "remaining array element after repeated removal of last element and subtraction of each element from next adjacent element | function to find the last remaining array element after performing the given operations repeatedly ; stores the resultant sum ; traverse the array ; increment sum by arr [ i ] * coefficient of i - th term in ( x - y ) ^ ( n - 1 ) ; update multiplier ; return the resultant sum ; ",
        "context": "",
        "code": "def lastElement(arr, n):\n    sum = 0\n    if n % 2 == 0:\n        multiplier = -1\n    else:\n        multiplier = 1\n    for i in range(n):\n        sum += arr[i] * multiplier\n        multiplier = multiplier * (n - 1 - i) / (i + 1) * (-1)\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 4, 2, 1]\n    N = len(arr)\n    print(int(lastElement(arr, N)))\n",
        "output": "4\n",
        "fn_call": "lastElement"
    },
    {
        "text": "check if 2 * k + 1 non | function to check if the s can be obtained by ( k + 1 ) non - empty substrings whose concatenation and concatenation of the reverse of these k strings ; stores the size of the string ; if n is less than 2 * k + 1 ; stores the first k characters ; stores the last k characters ; reverse the string ; if both the strings are equal ; ",
        "context": "",
        "code": "def checkString(s, k):\n    n = len(s)\n    if (2 * k + 1 > n):\n        print(\"No\")\n        return\n    a = s[0:k]\n    b = s[n - k:n]\n    b = b[::-1]\n    if (a == b):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    S = \"qwqwq\"\n    K = 1\n    checkString(S, K)\n",
        "output": "Yes\n",
        "fn_call": "checkString"
    },
    {
        "text": "tower of hanoi | set 2 | python program for the above approach ; function to print order of movement of n disks across three rods to place all disks on the third rod from the first - rod using binary representation ; iterate over the range [ 0 , 2 ^ n - 1 ] ; print the movement of the current rod ; ",
        "context": "\nimport math\n\n",
        "code": "def TowerOfHanoi(N):\n    for x in range(1, int(math .pow(2, N))):\n        print(\"Move from Rod \", ((x & x - 1) % 3 + 1),\n              \" to Rod \", (((x | x - 1) + 1) % 3 + 1))\n",
        "test": "\nN = 3\nTowerOfHanoi(N)\n",
        "output": "Move from Rod  1  to Rod  3\nMove from Rod  1  to Rod  2\nMove from Rod  3  to Rod  2\nMove from Rod  1  to Rod  3\nMove from Rod  2  to Rod  1\nMove from Rod  2  to Rod  3\nMove from Rod  1  to Rod  3\n",
        "fn_call": "TowerOfHanoi"
    },
    {
        "text": "check if a given pair of numbers are betrothed numbers or not | python3 program for the above approach ; function to check whether n is perfect square or not ; find sqrt ; function to check whether the given pairs of numbers is betrothed numbers or not ; for finding the sum of all the divisors of first number n ; for finding the sum of all the divisors of second number m ; ",
        "context": "\nfrom math import sqrt, floor\n\n",
        "code": "def isPerfectSquare(N):\n    sr = sqrt(N)\n    return (sr - floor(sr)) == 0\n\n\ndef BetrothedNumbers(n, m):\n    Sum1 = 1\n    Sum2 = 1\n    for i in range(2, int(sqrt(n)) + 1, 1):\n        if (n % i == 0):\n            if (isPerfectSquare(n)):\n                Sum1 += i\n            else:\n                Sum1 += i + n / i\n    for i in range(2, int(sqrt(m)) + 1, 1):\n        if (m % i == 0):\n            if (isPerfectSquare(m)):\n                Sum2 += i\n            else:\n                Sum2 += i + (m / i)\n    if ((n + 1 == Sum2) and (m + 1 == Sum1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 9504\n    M = 20734\n    BetrothedNumbers(N, M)\n",
        "output": "NO\n",
        "fn_call": "BetrothedNumbers"
    },
    {
        "text": "check whether a + b = c or not after removing all zeroes from a , b and c | function to remove zeroes ; initialize result to zero holds the result after removing zeroes from no ; initialize variable d to 1 that holds digits of no ; loop while n is greater then zero ; check if n mod 10 is not equal to zero ; store the result by removing zeroes and increment d by 10 ; go to the next digit ; return the result ; function to check if sum is true after removing all zeroes . ; call removezero ( ) for both sides and check whether they are equal after removing zeroes . ; ",
        "context": "",
        "code": "def removeZero(n):\n    res = 0\n    d = 1\n    while (n > 0):\n        if (n % 10 != 0):\n            res += (n % 10) * d\n            d *= 10\n        n //= 10\n    return res\n\n\ndef isEqual(a, b):\n    if (removeZero(a) + removeZero(b) == removeZero(a + b)):\n        return True\n    return False\n",
        "test": "\na = 105\nb = 106\nif (isEqual(a, b)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isEqual"
    },
    {
        "text": "bitwise xor of all unordered pairs from a given array | function to get bitwise xor of all possible pairs of the given array ; stores bitwise xor of all possible pairs ; generate all possible pairs and calculate bitwise xor of all possible pairs ; calculate bitwise xor of each pair ; ",
        "context": "",
        "code": "def TotalXorPair(arr, N):\n    totalXOR = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            totalXOR ^= arr[i] ^ arr[j]\n    return totalXOR\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    N = len(arr)\n    print(TotalXorPair(arr, N))\n",
        "output": "4\n",
        "fn_call": "TotalXorPair"
    },
    {
        "text": "count of subarrays whose maximum element is greater than k | return number of subarrays whose maximum element is less than or equal to k . ; to store count of subarrays with all elements less than or equal to k . ; traversing the array . ; if element is greater than k , ignore . ; counting the subarray length whose each element is less than equal to k . ; suming number of subarray whose maximum element is less than equal to k . ; ",
        "context": "",
        "code": "def countSubarray(arr, n, k):\n    s = 0\n    i = 0\n    while (i < n):\n        if (arr[i] > k):\n            i = i + 1\n            continue\n        count = 0\n        while (i < n and arr[i] <= k):\n            i = i + 1\n            count = count + 1\n        s = s + ((count * (count + 1)) // 2)\n    return (n * (n + 1) // 2 - s)\n",
        "test": "\narr = [1, 2, 3]\nk = 2\nn = len(arr)\nprint(countSubarray(arr, n, k))\n",
        "output": "3\n",
        "fn_call": "countSubarray"
    },
    {
        "text": "find if a string starts and ends with another given string | python program to find if a given corner string is present at corners . ; if length of corner string is more , it cannot be present at corners . ; return true if corner string is present at both corners of given string . ; ",
        "context": "",
        "code": "def isCornerPresent(str, corner):\n    n = len(str)\n    cl = len(corner)\n    if (n < cl):\n        return False\n    return ((str[:cl] == corner) and (str[n - cl:] == corner))\n",
        "test": "\nstr = \"geeksforgeeks\"\ncorner = \"geeks\"\nif (isCornerPresent(str, corner)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isCornerPresent"
    },
    {
        "text": "find instances at end of time frame after auto scaling | python program for the above approach ; function to find the number of instances after completion ; traverse the array , arr [ ] ; if current element is less than 25 ; divide instances by 2 ; if the current element is greater than 60 ; double the instances ; print the instances at the end of the traversal ; ",
        "context": "\nfrom math import ceil\n\n",
        "code": "def finalInstances(instances, arr):\n    i = 0\n    while i < len(arr):\n        if arr[i]  1:\n            instances = ceil(instances / 2)\n            i += 10\n        elif arr[i] > 60 and instances <= 10 ** 8:\n            instances *= 2\n            i += 10\n        i += 1\n    print(instances)\n",
        "test": "\ninstances = 2\narr = [25, 23, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 76, 80]\nfinalInstances(instances, arr)\n",
        "output": "2\n",
        "fn_call": "finalInstances"
    },
    {
        "text": "digit | function to produce and print digit product sequence ; array which store sequence ; temporary variable to store product ; ",
        "context": "",
        "code": "def digit_product_Sum(N):\n    a = [0] * (N + 1)\n    product = 1\n    a[0] = 1\n    for i in range(1, N + 1):\n        product = int(a[i - 1] / 10)\n        if (product == 0):\n            product = 1\n        else:\n            product = a[i - 1] % 10\n        val = int(a[i - 1] / 10)\n        if (val == 0):\n            val = a[i - 1]\n        a[i] = a[i - 1] + (val * product)\n    for i in range(N):\n        print(a[i], end=\" \")\n",
        "test": "\nN = 10\ndigit_product_Sum(N)\n",
        "output": "1 2 4 8 16 22 26 38 62 74 ",
        "fn_call": "digit_product_Sum"
    },
    {
        "text": "count all subarrays whose sum can be split as difference of squares of two integers | function to count all the non - contiguous subarrays whose sum can be split as the difference of the squares ; loop to iterate over all the possible subsequences of the array ; finding the sum of all the possible subsequences ; condition to check whether the number can be split as difference of squares ; ",
        "context": "",
        "code": "def Solve(arr, n):\n    temp = 0\n    count = 0\n    for i in range(0, n):\n        temp = 0\n        for j in range(i, n):\n            temp = temp + arr[j]\n            if ((temp + 2) % 4 != 0):\n                count += 1\n    return count\n",
        "test": "\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nN = len(arr)\nprint(Solve(arr, N))\n",
        "output": "40\n",
        "fn_call": "Solve"
    },
    {
        "text": "count of numbers between range having only non | function to return the count of required numbers from 0 to num ; last position ; if this result is already computed simply return it ; maximum limit upto which we can place digit . if tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; if the current digit is zero and nonz is 1 , we can 't place it ; function to convert x into its digit vector and uses count ( ) function to return the required count ; initialize dp ; ",
        "context": "",
        "code": "def count(pos, Sum, rem, tight, nonz, num):\n    if pos == len(num):\n        if rem == 0 and Sum == n:\n            return 1\n        return 0\n    if dp[pos][Sum][rem][tight] != -1:\n        return dp[pos][Sum][rem][tight]\n    ans = 0\n    if tight:\n        limit = 9\n    else:\n        limit = num[pos]\n    for d in range(0, limit + 1):\n        if d == 0 and nonz:\n            continue\n        currSum = Sum + d\n        currRem = (rem * 10 + d) % m\n        currF = int(tight or (d < num[pos]))\n        ans += count(pos + 1, currSum, currRem, currF, nonz or d, num)\n    dp[pos][Sum][rem][tight] = ans\n    return ans\n\n\ndef solve(x):\n    num = []\n    global dp\n    while x > 0:\n        num .append(x % 10)\n        x //= 10\n    num .reverse()\n    dp = [[[[-1, -1]for i in range(M)]for j in range(165)]for k in range(M)]\n    return count(0, 0, 0, 0, 0, num)\n",
        "test": "\nif __name__ == \"__main__\":\n    L, R = 1, 100\n    n, m, M = 8, 2, 20\n    dp = []\n    print(solve(R) - solve(L))\n",
        "output": "4\n",
        "fn_call": "solve"
    },
    {
        "text": "make a lexicographically smallest palindrome with minimal changes | function to create a palindrome ; count the occurrences of every character in the string ; create a string of characters with odd occurrences ; change the created string upto middle element and update count to make sure that only one odd character exists . ; decrease the count of character updated ; create three strings to make first half second half and middle one . ; characters with even occurrences ; fill the first half . ; character with odd occurrence ; fill the first half with half of occurrence except one ; for middle element ; create the second half by reversing the first half . ; ",
        "context": "",
        "code": "def palindrome(s: str, n: int) -> int:\n    cnt = dict()\n    R = []\n    for i in range(n):\n        a = s[i]\n        if a in cnt:\n            cnt[a] += 1\n        else:\n            cnt[a] = 1\n    i = 'a'\n    while i <= 'z':\n        if i in cnt and cnt[i] % 2 != 0:\n            R += i\n        i = chr(ord(i) + 1)\n    l = len(R)\n    j = 0\n    for i in range(l - 1, (l // 2) - 1, -1):\n        if R[i] in cnt:\n            cnt[R[i]] -= 1\n        else:\n            cnt[R[i]] = -1\n        R[i] = R[j]\n        if R[j] in cnt:\n            cnt[R[j]] += 1\n        else:\n            cnt[R[j]] = 1\n        j += 1\n    first, middle, second = \"\", \"\", \"\"\n    i = 'a'\n    while i <= 'z':\n        if i in cnt:\n            if cnt[i] % 2 == 0:\n                j = 0\n                while j < cnt[i] // 2:\n                    first += i\n                    j += 1\n            else:\n                j = 0\n                while j < (cnt[i] - 1) // 2:\n                    first += i\n                    j += 1\n                middle += i\n        i = chr(ord(i) + 1)\n    second = first\n    second = ''.join(reversed(second))\n    resultant = first + middle + second\n    print(resultant)\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"geeksforgeeks\"\n    n = len(S)\n    palindrome(S, n)\n",
        "output": "eefgksoskgfee\n",
        "fn_call": "palindrome"
    },
    {
        "text": "maximum length substring having all same characters after k changes | function to find the maximum length of substring having character ch ; traverse the whole string ; if character is not same as ch increase count ; while count > k traverse the string again until count becomes less than k and decrease the count when characters are not same ; length of substring will be rightindex - leftindex + 1. compare this with the maximum length and return maximum length ; function which returns maximum length of substring ; ",
        "context": "",
        "code": "def findLen(A, n, k, ch):\n    maxlen = 1\n    cnt = 0\n    l = 0\n    r = 0\n    while r < n:\n        if A[r] != ch:\n            cnt += 1\n        while cnt > k:\n            if A[l] != ch:\n                cnt -= 1\n            l += 1\n        maxlen = max(maxlen, r - l + 1)\n        r += 1\n    return maxlen\n\n\ndef answer(A, n, k):\n    maxlen = 1\n    for i in range(26):\n        maxlen = max(maxlen, findLen(A, n, k, chr(i + ord('A'))))\n        maxlen = max(maxlen, findLen(A, n, k, chr(i + ord('a'))))\n    return maxlen\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    k = 2\n    A = \"ABABA\"\n    print(\"Maximum length =\", answer(A, n, k))\n    n = 6\n    k = 4\n    B = \"HHHHHH\"\n    print(\"Maximum length =\", answer(B, n, k))\n",
        "output": "Maximum length = 5\nMaximum length = 6\n",
        "fn_call": "answer"
    },
    {
        "text": "count all distinct pairs with difference equal to k | returns count of pairs with difference k in arr [ ] of size n . ; sort array elements ; arr [ r ] - arr [ l ] < sum ; ",
        "context": "",
        "code": "def countPairsWithDiffK(arr, n, k):\n    count = 0\n    arr .sort()\n    l = 0\n    r = 0\n    while r < n:\n        if arr[r] - arr[l] == k:\n            count += 1\n            l += 1\n            r += 1\n        elif arr[r] - arr[l] > k:\n            l += 1\n        else:\n            r += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 5, 3, 4, 2]\n    n = len(arr)\n    k = 3\n    print(\"Count of pairs with given diff is \", countPairsWithDiffK(arr, n, k))\n",
        "output": "Count of pairs with given diff is  2\n",
        "fn_call": "countPairsWithDiffK"
    },
    {
        "text": "lexicographically smallest and largest substring of size k | python 3 program to find lexicographically largest and smallest substrings of size k . ; initialize min and max as first substring of size k ; consider all remaining substrings . we consider every substring ending with index i . ; print result . ; ",
        "context": "",
        "code": "def getSmallestAndLargest(s, k):\n    currStr = s[:k]\n    lexMin = currStr\n    lexMax = currStr\n    for i in range(k, len(s)):\n        currStr = currStr[1:k] + s[i]\n        if (lexMax < currStr):\n            lexMax = currStr\n        if (lexMin > currStr):\n            lexMin = currStr\n    print(lexMin)\n    print(lexMax)\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"GeeksForGeeks\"\n    k = 3\n    getSmallestAndLargest(str1, k)\n",
        "output": "For\nsFo\n",
        "fn_call": "getSmallestAndLargest"
    },
    {
        "text": "source to destination in 2 | function that returns true if it is possible to move from source to the destination with the given moves ; ",
        "context": "",
        "code": "def isPossible(Sx, Sy, Dx, Dy, x, y):\n    if (abs(Sx - Dx) %\n        x == 0 and abs(Sy - Dy) %\n        y == 0 and (abs(Sx - Dx) / x) %\n        2 == (abs(Sy - Dy) / y) %\n            2):\n        return True\n    return False\n",
        "test": "\nSx = 0\nSy = 0\nDx = 0\nDy = 0\nx = 3\ny = 4\nif (isPossible(Sx, Sy, Dx, Dy, x, y)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "smallest string without any multiplication sign that represents the product of two given numbers | python3 program for the above approach ; function to find the string which evaluates to the product of a and b ; stores the result ; 2 ^ logg  b ; update res to res += a x 2 ^ logg ; update res to res += a x 2 ^ 0 ; find the remainder ; if remainder is not equal to 0 ; return the resultant string ; function to find the minimum length representation of a * b ; find representation of form a << k1 + a << k2 + ... + a << kn ; find representation of form b << k1 + b << k2 + ... + b << kn ; compare the length of the representations ; ",
        "context": "\nfrom math import log\n\n",
        "code": "def lenn(A, B):\n    res = \"\"\n    logg = 0\n    while True:\n        logg = log(B) // log(2)\n        if (logg != 0):\n            res += (str(A) + \"<<\" + str(int(logg)))\n        else:\n            res += A\n            break\n        B = B - pow(2, logg)\n        if (B != 0):\n            res += \"+\"\n        else:\n            break\n        if logg == 0:\n            break\n    return res\n\n\ndef minimumString(A, B):\n    res1 = lenn(A, B)\n    res2 = lenn(B, A)\n    if (len(res1) > len(res2)):\n        print(res2)\n    else:\n        print(res1)\n",
        "test": "\nif __name__ == '__main__':\n    A = 6\n    B = 10\n    minimumString(A, B)\n",
        "output": "6<<3+6<<1\n",
        "fn_call": "minimumString"
    },
    {
        "text": "find all palindrome numbers of given digits | function to return the reverse of num ; function that returns true if num is palindrome ; if the number is equal to the reverse of it then it is a palindrome ; function to prall the d - digit palindrome numbers ; smallest and the largest d - digit numbers ; starting from the smallest d - digit number till the largest ; if the current number is palindrome ; ",
        "context": "",
        "code": "def reverse(num):\n    rev = 0\n    while (num > 0):\n        rev = rev * 10 + num % 10\n        num = num // 10\n    return rev\n\n\ndef isPalindrome(num):\n    if (num == reverse(num)):\n        return True\n    return False\n\n\ndef printPalindromes(d):\n    if (d <= 0):\n        return\n    smallest = pow(10, d - 1)\n    largest = pow(10, d) - 1\n    for i in range(smallest, largest + 1):\n        if (isPalindrome(i)):\n            print(i, end=\" \")\n",
        "test": "\nd = 2\nprintPalindromes(d)\n",
        "output": "11 22 33 44 55 66 77 88 99 ",
        "fn_call": "printPalindromes"
    },
    {
        "text": "program to find the side of the octagon inscribed within the square | python 3 program to find the side of the octagon which can be inscribed within the square ; function to find the side of the octagon ; side cannot be negative ; side of the octagon ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def octaside(a):\n    if a < 0:\n        return -1\n    s = a / (sqrt(2) + 1)\n    return s\n",
        "test": "\nif __name__ == '__main__':\n    a = 4\n    print(\"{0:.6}\".format(octaside(a)))\n",
        "output": "1.65685\n",
        "fn_call": "octaside"
    },
    {
        "text": "maximum element in an array such that its previous and next element product is maximum | function to return the largest element such that its previous and next element product is maximum ; calculate the product of the previous and the next element for the current element ; update the maximum product ; if current product is equal to the current maximum product then choose the maximum element ; ",
        "context": "",
        "code": "def maxElement(a, n):\n    if n < 3:\n        return -1\n    maxElement = a[0]\n    maxProd = a[n - 1] * a[1]\n    for i in range(1, n):\n        currprod = a[i - 1] * a[(i + 1) % n]\n        if currprod > maxProd:\n            maxProd = currprod\n            maxElement = a[i]\n        elif currprod == maxProd:\n            maxElement = max(maxElement, a[i])\n    return maxElement\n",
        "test": "\na = [5, 6, 4, 3, 2]\nn = len(a)\nprint(maxElement(a, n))\n",
        "output": "6\n",
        "fn_call": "maxElement"
    },
    {
        "text": "maximum sum subarray of size range [ l , r ] | python3 program to find maximum sum subarray of size between l and r . ; function to find maximum sum subarray of size between l and r ; calculating prefix sum ; maintain 0 for initial values of i upto r once i = r , then we need to erase that 0 from our multiset as our first index of subarray cannot be 0 anymore . ; we maintain flag to counter if that initial 0 was erased from set or not . ; erase 0 from multiset once i = b ; insert pre [ i - l ] ; find minimum value in multiset . ; erase pre [ i - r ] ; ",
        "context": "\nimport sys\n\n",
        "code": "def max_sum_subarray(arr, L, R):\n    n = len(arr)\n    pre = n * [0]\n    pre[0] = arr[0]\n    for i in range(1, n):\n        pre[i] = pre[i - 1] + arr[i]\n    s1 = []\n    s1 .append(0)\n    ans = -sys .maxsize - 1\n    ans = max(ans, pre[L - 1])\n    flag = 0\n    for i in range(L, n):\n        if (i - R >= 0):\n            if (flag == 0):\n                s1 .remove(0)\n                flag = 1\n        if (i - L >= 0):\n            s1 .append(pre[i - L])\n        ans = max(ans, pre[i] - s1[0])\n        if (i - R >= 0):\n            s1 .remove(pre[i - R])\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    L = 1\n    R = 3\n    arr = [1, 2, 2, 1]\n    max_sum_subarray(arr, L, R)\n",
        "output": "5\n",
        "fn_call": "max_sum_subarray"
    },
    {
        "text": "count subsequences having average of its elements equal to k | stores the dp states ; function to find the count of subsequences having average k ; base condition ; three loops for three states ; recurrence relation ; stores the sum of dp [ n ] [ j ] [ k * j ] all possible values of j with average k and sum k * j ; iterate over the range [ 1 , n ] ; return the final count ; ",
        "context": "\ndp = [[[0 for i in range(1001)]for i in range(101)]for i in range(101)]\n\n",
        "code": "def countAverage(n, K, arr):\n    global dp\n    dp[0][0][0] = 1\n    for i in range(n):\n        for k in range(n):\n            for s in range(100):\n                dp[i + 1][k + 1][s + arr[i]] += dp[i][k][s]\n                dp[i + 1][k][s] += dp[i][k][s]\n    cnt = 0\n    for j in range(1, n + 1):\n        cnt += dp[n][j][K * j]\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    arr = [9, 7, 8, 9]\n    K = 8\n    N = len(arr)\n    print(countAverage(N, K, arr))\n",
        "output": "5\n",
        "fn_call": "countAverage"
    },
    {
        "text": "smallest alphabet greater than a given character | returns the smallest character from the given set of letters that is greater than k ; take the first element as l and the rightmost element as r ; if this while condition does not satisfy simply return the first element . ; return the smallest element ; ",
        "context": "",
        "code": "def nextGreatestAlphabet(alphabets, K):\n    n = len(alphabets)\n    if (K >= alphabets[n - 1]):\n        return alphabets[0]\n    l = 0\n    r = len(alphabets) - 1\n    ans = -1\n    while (l <= r):\n        mid = int((l + r) / 2)\n        if (alphabets[mid] > K):\n            r = mid - 1\n            ans = mid\n        else:\n            l = mid + 1\n    if (alphabets[ans] < K):\n        return alphabets[0]\n    else:\n        return alphabets[ans]\n",
        "test": "\nletters = ['A', 'r', 'z']\nK = 'z'\nresult = nextGreatestAlphabet(letters, K)\nprint(result)\n",
        "output": "A\n",
        "fn_call": "nextGreatestAlphabet"
    },
    {
        "text": "find a number x such that sum of x and its digits is equal to given n . | utility function for digit sum ; function for finding x ; iterate from 1 to n . for every no . check if its digit sum with it isequal to n . ; if no such i found return - 1 ; ",
        "context": "",
        "code": "def digSum(n):\n    sum = 0\n    rem = 0\n    while (n):\n        rem = n % 10\n        sum = sum + rem\n        n = int(n / 10)\n    return sum\n\n\ndef findX(n):\n    for i in range(n + 1):\n        if (i + digSum(i) == n):\n            return i\n    return -1\n",
        "test": "\nn = 43\nprint(\"x = \", findX(n))\n",
        "output": "x =  35\n",
        "fn_call": "findX"
    },
    {
        "text": "time taken per hour for stoppage of car | python3 implementation of the approach ; function to return the time taken per hour for stoppage ; ",
        "context": "\nimport math\n\n",
        "code": "def numberOfMinutes(S, S1):\n    Min = 0\n    Min = ((S - S1) / math .floor(S)) * 60\n    return int(Min)\n",
        "test": "\nif __name__ == '__main__':\n    S, S1 = 30, 10\n    print(numberOfMinutes(S, S1), \"min\")\n",
        "output": "40 min\n",
        "fn_call": "numberOfMinutes"
    },
    {
        "text": "Find the number of spectators standing in the stadium at time t | Python program to find number of spectators standing at a time ; If the time is less than k then we can print directly t time . ; If the time is n then k spectators are standing . ; Otherwise we calculate the spectators standing . ; Stores the value of n , k and t t is time n & k is the number of specators",
        "context": "",
        "code": "def result(n, k, t):\n    if (t <= k):\n        print(t)\n    elif (t <= n):\n        print(k)\n    else:\n        temp = t - n\n        temp = k - temp\n        print(temp)\n",
        "test": "\nn = 10\nk = 5\nt = 12\nresult(n, k, t)\n",
        "output": "3\n",
        "fn_call": "result"
    },
    {
        "text": "number of times an array can be partitioned repetitively into two subarrays with equal sum | recursion function to calculate the possible splitting ; if there are less than two elements , we cannot partition the sub - array . ; iterate from the start to end - 1. ; recursive call to the left and the right sub - array . ; if there is no such partition , then return 0 ; function to find the total splitting ; prefix array to store the prefix - sum using 1 based indexing ; store the prefix - sum ; function call to count the number of splitting ; ",
        "context": "",
        "code": "def splitArray(start, end, arr, prefix_sum):\n    if (start >= end):\n        return 0\n    for k in range(start, end):\n        if ((prefix_sum[k] - prefix_sum[start - 1])\n                == (prefix_sum[end] - prefix_sum[k])):\n            return (\n                1 +\n                splitArray(\n                    start,\n                    k,\n                    arr,\n                    prefix_sum) +\n                splitArray(\n                    k +\n                    1,\n                    end,\n                    arr,\n                    prefix_sum))\n    return 0\n\n\ndef solve(arr, n):\n    prefix_sum = [0] * (n + 1)\n    prefix_sum[0] = 0\n    for i in range(1, n + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + arr[i - 1])\n    print(splitArray(1, n, arr, prefix_sum))\n",
        "test": "\narr = [12, 3, 3, 0, 3, 3]\nN = len(arr)\nsolve(arr, N)\n",
        "output": "4\n",
        "fn_call": "solve"
    },
    {
        "text": "find maximum xor of k elements in an array | python implementation of the approach ; function to return the maximum xor for a subset of size j from the given array ; if the subset is complete then return the xor value of the selected elements ; return if already calculated for some mask and j at the i 'th index ; initialize answer to 0 ; if we can still include elements in our subset include the i 'th element ; exclude the i 'th element  ans store the max of both operations ; ",
        "context": "\nMAX = 10000\nMAX_ELEMENT = 50\ndp = [[[-1 for i in range(MAX)]for j in range(MAX_ELEMENT)]\n      for k in range(MAX_ELEMENT)]\n\n",
        "code": "def Max_Xor(arr, i, j, mask, n):\n    if (i >= n):\n        if (j == 0):\n            return mask\n        else:\n            return 0\n    if (dp[i][j][mask] != -1):\n        return dp[i][j][mask]\n    ans = 0\n    if (j > 0):\n        ans = Max_Xor(arr, i + 1, j - 1, mask ^ arr[i], n)\n    ans = max(ans, Max_Xor(arr, i + 1, j, mask, n))\n    dp[i][j][mask] = ans\n    return ans\n",
        "test": "\narr = [2, 5, 4, 1, 3, 7, 6, 8]\nn = len(arr)\nk = 3\nprint(Max_Xor(arr, 0, k, 0, n))\n",
        "output": "15\n",
        "fn_call": "Max_Xor"
    },
    {
        "text": "count number of pairs ( i , j ) such that arr [ i ] * arr [ j ] = arr [ i ] + arr [ j ] | function to return the count of pairs ( i , j ) such that arr [ i ] * arr [ j ] = arr [ i ] + arr [ j ] ; count number of 0 ' s \u2581 and \u2581 2' s in the array ; total pairs due to occurrence of 0 's  ; total pairs due to occurrence of 2 's  ; return count of all pairs ; ",
        "context": "",
        "code": "def countPairs(arr, n):\n    countZero = 0\n    countTwo = 0\n    for i in range(n):\n        if (arr[i] == 0):\n            countZero += 1\n        elif (arr[i] == 2):\n            countTwo += 1\n    pair0 = (countZero * (countZero - 1)) // 2\n    pair2 = (countTwo * (countTwo - 1)) // 2\n    return pair0 + pair2\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 0, 3, 2, 0]\n    n = len(arr)\n    print(countPairs(arr, n))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "friends pairing problem | python3 program for solution of friends pairing problem using recursion ; returns count of ways n people can remain single or paired up . ; ",
        "context": "\ndp = [-1] * 1000\n\n",
        "code": "def countFriendsPairings(n):\n    global dp\n    if (dp[n] != -1):\n        return dp[n]\n    if (n > 2):\n        dp[n] = (countFriendsPairings(n - 1) + (n - 1)\n                 * countFriendsPairings(n - 2))\n        return dp[n]\n    else:\n        dp[n] = n\n        return dp[n]\n",
        "test": "\nn = 4\nprint(countFriendsPairings(n))\n",
        "output": "10\n",
        "fn_call": "countFriendsPairings"
    },
    {
        "text": "Program for N | Python 3 Program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; starting number ; Common difference ; N th term to be find ; Display the output",
        "context": "",
        "code": "def Nth_of_AP(a, d, N):\n    return (a + (N - 1) * d)\n",
        "test": "\na = 2\nd = 1\nN = 5\nprint(\"The \", N, \"th term of the series is : \", Nth_of_AP(a, d, N))\n",
        "output": "The  5 th term of the series is :  6\n",
        "fn_call": "Nth_of_AP"
    },
    {
        "text": "maximum number of overlapping string | function to find the maximum overlapping strings ; get the current character ; condition to check if the current character is the first character of the string t then increment the overlapping count ; condition to check previous character is also occurred ; update count of previous and current character ; condition to check the current character is the last character of the string t ; condition to check the every subsequence is a valid string t ; ",
        "context": "",
        "code": "def maxOverlap(S, T):\n    str = T\n    count = [0 for i in range(len(T))]\n    overlap = 0\n    max_overlap = 0\n    for i in range(0, len(S)):\n        index = str .find(S[i])\n        if (index == 0):\n            overlap += 1\n            if (overlap >= 2):\n                max_overlap = max(overlap, max_overlap)\n            count[index] += 1\n        else:\n            if (count[index - 1] <= 0):\n                return -1\n            count[index] += 1\n            count[index - 1] -= 1\n        if (index == 4):\n            overlap -= 1\n    if (overlap == 0):\n        return max_overlap\n    else:\n        return -1\n",
        "test": "\nS = \"chcirphirp\"\nT = \"chirp\"\nprint(maxOverlap(S, T))\n",
        "output": "2\n",
        "fn_call": "maxOverlap"
    },
    {
        "text": "transform string str1 into str2 by taking characters from string str3 | function to check whether str1 can be transformed to str2 ; to store the frequency of characters of string str3 ; declare two pointers & flag ; traverse both the string and check whether it can be transformed ; if both pointers point to same characters increment them ; if the letters don 't match check  if we can find it in string c ; if the letter is available in string str3 , decrement it 's  frequency & increment the ptr2 ; if letter isn 't present in str3[]  set the flag to false and break ; if the flag is true and both pointers points to their end of respective strings then it is possible to transformed str1 into str2 , otherwise not . ; ",
        "context": "",
        "code": "def convertString(str1, str2, str3):\n    freq = {}\n    for i in range(len(str3)):\n        if (freq .get(str3[i]) is None):\n            freq[str3[i]] = 1\n        else:\n            freq .get(str3[i], 1)\n    ptr1 = 0\n    ptr2 = 0\n    flag = True\n    while (ptr1 < len(str1) and ptr2 < len(str2)):\n        if (str1[ptr1] == str2[ptr2]):\n            ptr1 += 1\n            ptr2 += 1\n        else:\n            if (freq[str3[ptr2]] > 0):\n                freq[str3[ptr2]] -= 1\n                ptr2 += 1\n            else:\n                flag = False\n                break\n    if (flag and ptr1 == len(str1) and ptr2 == len(str2)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"abyzfe\"\n    str2 = \"abcdeyzf\"\n    str3 = \"popode\"\n    convertString(str1, str2, str3)\n",
        "output": "NO\n",
        "fn_call": "convertString"
    },
    {
        "text": "minimize difference between maximum and minimum of array by at most k replacements | function to find minimum difference between the maximum and the minimum elements arr [ ] by at most k replacements ; check if turns are more than or equal to n - 1 then simply return zero ; sort the array ; set difference as the maximum possible difference ; iterate over the array to track the minimum difference in k turns ; return the answer ; ",
        "context": "",
        "code": "def maxMinDifference(arr, n, k):\n    if (k >= n - 1):\n        return 0\n    arr .sort()\n    ans = arr[n - 1] - arr[0]\n    i = k\n    j = n - 1\n    while i >= 0:\n        ans = min(arr[j] - arr[i], ans)\n        i -= 1\n        j -= 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 4, 6, 11, 15]\n    N = len(arr)\n    K = 3\n    print(maxMinDifference(arr, N, K))\n",
        "output": "2\n",
        "fn_call": "maxMinDifference"
    },
    {
        "text": "minimum changes required such that the string satisfies the given condition | function to return the minimum changes required ; to store the count of minimum changes , number of ones and the number of zeroes ; first character has to be '1 ; if condition fails changes need to be made ; return the required count ; ",
        "context": "",
        "code": "def minChanges(str, n):\n    count, zeros, ones = 0, 0, 0\n    if (ord(str[0]) != ord('1')):\n        count += 1\n        ones += 1\n\n    for i in range(1, n):\n        if (ord(str[i]) == ord('0')):\n            zeros += 1\n        else:\n            ones += 1\n        if (zeros > ones):\n            zeros -= 1\n            ones += 1\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    str = \"0000\"\n    n = len(str)\n    print(minChanges(str, n))\n",
        "output": "2\n",
        "fn_call": "minChanges"
    },
    {
        "text": "find a string which matches all the patterns in the given array | function to find a common string which matches all the pattern ; for storing prefix till first most * without conflicts ; for storing suffix till last most * without conflicts ; for storing all middle characters between first and last * ; loop to iterate over every pattern of the array ; index of the first \" * \" ; index of last \" * \" ; iterate over the first \" * \" ; prefix till first most * without conflicts ; iterate till last most * from last ; make suffix till last most * without conflicts ; take all middle characters in between first and last most * ; ",
        "context": "",
        "code": "def find(S, N):\n    pref = \"\"\n    suff = \"\"\n    mid = \"\"\n\n    for i in range(N):\n        first = int(S[i].index(\"*\"))\n        last = int(S[i].rindex(\"*\"))\n        for z in range(len(pref)):\n            if (z < first):\n                if (pref[z] != S[i][z]):\n                    return \"*\"\n        for z in range(len(pref), first):\n            pref += S[i][z]\n        for z in range(len(suff)):\n            if (len(S[i]) - 1 - z > last):\n                if (suff[z] != S[i][len(S[i]) - 1 - z]):\n                    return \"*\"\n        for z in range(len(suff),\n                       len(S[i]) - 1 - last):\n            suff += S[i][len(S[i]) - 1 - z]\n        for z in range(first, last + 1):\n            if (S[i][z] != '*'):\n                mid += S[i][z]\n\n    suff = suff[:: -1]\n    return pref + mid + suff\n",
        "test": "\nN = 3\ns = [\"\" for i in range(N)]\ns[0] = \"pq*du*q\"\ns[1] = \"pq*abc*q\"\ns[2] = \"p*d*q\"\nprint(find(s, N))\n",
        "output": "pqduabcdq\n",
        "fn_call": "find"
    },
    {
        "text": "maximize sum of array by repeatedly removing an element from pairs whose concatenation is a multiple of 3 | function to calculate sum of digits of an integer ; function to calculate maximum sum of array after removing pairs whose concatenation is divisible by 3 ; stores the sum of digits of array element ; find the sum of digits ; if i is divisible by 3 ; otherwise , if i modulo 3 is 1 ; otherwise , if i modulo 3 is 2 ; return the resultant sum of array elements ; ",
        "context": "",
        "code": "def getSum(n):\n    ans = 0\n    for i in str(n):\n        ans += int(i)\n    return ans\n\n\ndef getMax(arr):\n    maxRem0 = 0\n    rem1 = 0\n    rem2 = 0\n    for i in arr:\n        digitSum = getSum(i)\n        if digitSum % 3 == 0:\n            maxRem0 = max(maxRem0, i)\n        elif digitSum % 3 == 1:\n            rem1 += i\n        else:\n            rem2 += i\n    print(maxRem0 + max(rem1, rem2))\n",
        "test": "\narr = [23, 12, 43, 3, 56]\ngetMax(arr)\n",
        "output": "91\n",
        "fn_call": "getMax"
    },
    {
        "text": "encoding a word into pig latin | python program to encode a word to a pig latin . ; the index of the first vowel is stored . ; pig latin is possible only if vowels is present ; take all characters after index ( including index ) . append all characters which are before index . finally append \" ay \" ; ",
        "context": "",
        "code": "def isVowel(c):\n    return (c == 'A' or c == 'E' or c == 'I' or\n            c == 'O' or c == 'U' or c == 'a' or\n            c == 'e' or c == 'i' or c == 'o' or\n            c == 'u')\n\n\ndef pigLatin(s):\n    length = len(s)\n    index = -1\n    for i in range(length):\n        if (isVowel(s[i])):\n            index = i\n            break\n    if (index == -1):\n        return \"-1\"\n    return s[index:] + s[0:index] + \"ay\"\n",
        "test": "\nstr = pigLatin(\"graphic\")\nif (str == \"-1\"):\n    print(\"No vowels found. Pig Latin not possible\")\nelse:\n    print(str)\n",
        "output": "aphicgray\n",
        "fn_call": "pigLatin"
    },
    {
        "text": "generate an n | python3 program for above approach ; function to print target array ; sort the given array ; seeking for index of elements with minimum diff . ; seeking for index ; to store target array ; copying element ; copying remaining element ; printing target array ; ",
        "context": "\nimport sys\n\n",
        "code": "def printArr(arr, n):\n    arr .sort()\n    minDifference = sys .maxsize\n    minIndex = -1\n    for i in range(1, n, 1):\n        if (minDifference > abs(arr[i] - arr[i - 1])):\n            minDifference = abs(arr[i] - arr[i - 1])\n            minIndex = i - 1\n    Arr = [0 for i in range(n)]\n    Arr[0] = arr[minIndex]\n    Arr[n - 1] = arr[minIndex + 1]\n    pos = 1\n    for i in range(minIndex + 2, n, 1):\n        Arr[pos] = arr[i]\n        pos += 1\n    for i in range(minIndex):\n        Arr[pos] = arr[i]\n        pos += 1\n    for i in range(n):\n        print(Arr[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 8\n    arr = [4, 6, 2, 6, 8, 2, 6, 4]\n    printArr(arr, N)\n",
        "output": "2 4 4 6 6 6 8 2 ",
        "fn_call": "printArr"
    },
    {
        "text": "find nth positive number whose digital root is x | function to find the n - th number with digital root as x ; ",
        "context": "",
        "code": "def findAnswer(X, N):\n    return (N - 1) * 9 + X\n",
        "test": "\nX = 7\nN = 43\nprint(findAnswer(X, N))\n",
        "output": "385\n",
        "fn_call": "findAnswer"
    },
    {
        "text": "program to print matrix in z form | python3 program to pra square matrix in z form ; ",
        "context": "",
        "code": "def diag(arr, n):\n    for i in range(n):\n        for j in range(n):\n            if (i == 0):\n                print(arr[i][j], end=\" \")\n            elif (i == j):\n                print(arr[i][j], end=\" \")\n            elif (i == n - 1):\n                print(arr[i][j], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    a = [[4, 5, 6, 8], [1, 2, 3, 1], [7, 8, 9, 4], [1, 8, 7, 5]]\n    diag(a, 4)\n",
        "output": "4 5 6 8 2 9 1 8 7 5 ",
        "fn_call": "diag"
    },
    {
        "text": "minimize the maximum difference between adjacent elements in an array | python3 implementation to find the minimum of the maximum difference of the adjacent elements after removing k elements from the array ; function to find the minimum different in the subarrays of size k in the array ; create a double ended queue , qi that will store indexes of array elements , queue will store indexes of useful elements in every window ; process first k ( or first window ) elements of array ; for every element , the previous smaller elements are useless so remove them from qi ; add new element at rear of queue ; process rest of the elements , i . e . , from arr [ k ] to arr [ n - 1 ] ; the element at the front of the queue is the largest element of previous window ; remove the elements which are out of this window ; remove all elements smaller than the currently being added element ( remove useless elements ) ; add current element at the rear of qi ; compare the maximum element of last window ; function to find the minimum of the maximum difference of the adjacent elements after removing k elements from the array ; create the difference array ; find minimum of all maximum of subarray sizes n - k - 1 ; ",
        "context": "\nimport sys\n\n",
        "code": "def findKMin(arr, n, k):\n    Qi = []\n    i = 0\n\n    for j in range(k):\n        while ((len(Qi) != 0) and\n               arr[i] >= arr[Qi[-1]]):\n            Qi.pop()\n        Qi.append(i)\n        i += 1\n\n    minDiff = sys.maxsize\n    for j in range(i, n):\n        minDiff = min(minDiff, arr[Qi[0]])\n        while ((len(Qi) != 0) and\n               Qi[0] <= i - k):\n            Qi.pop(0)\n        while ((len(Qi) != 0) and\n               arr[i] >= arr[Qi[-1]]):\n            Qi.pop()\n        Qi.append(i)\n        i += 1\n    minDiff = min(minDiff, arr[Qi[0]])\n\n    return minDiff\n\n\ndef minimumAdjacentDifference(a, n, k):\n    diff = [0 for i in range(n - 1)]\n\n    for i in range(n - 1):\n        diff[i] = a[i + 1] - a[i]\n    answer = findKMin(diff, n - 1,\n                      n - k - 1)\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    k = 2\n    a = [3, 7, 8, 10, 14]\n    print(minimumAdjacentDifference(a, n, k))\n",
        "output": "2\n",
        "fn_call": "minimumAdjacentDifference"
    },
    {
        "text": "number of cycles formed by joining vertices of n sided polygon at the center | function to calculate number of cycles ; biginteger is used here if n = 10 ^ 9 then multiply will result into value greater than 10 ^ 18 ; biginteger multiply function ; return the final result ; ",
        "context": "",
        "code": "def findCycles(N):\n    res = 0\n    finalResult = 0\n    val = 2 * N - 1\n    s = val\n    res = (N - 1) * (N - 2)\n    finalResult = res + s\n    return finalResult\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    print(findCycles(N))\n",
        "output": "21\n",
        "fn_call": "findCycles"
    },
    {
        "text": "find the equation of plane which passes through two points and parallel to a given axis | python3 implementation to find the equation of plane which passes through two points and parallel to a given axis ; find direction vector of points ( x1 , y1 , z1 ) and ( x2 , y2 , z2 ) ; values that are calculated and simplified from the cross product ; print the equation of plane ; ",
        "context": "",
        "code": "def findEquation(x1, y1, z1, x2, y2, z2, d, e, f):\n    a = x2 - x1\n    b = y2 - y1\n    c = z2 - z1\n    A = (b * f - c * e)\n    B = (a * f - c * d)\n    C = (a * e - b * d)\n    D = -(A * d - B * e + C * f)\n    print(A, \"x + \", B, \"y + \", C, \"z + \", D, \"= 0\")\n",
        "test": "\nif __name__ == \"__main__\":\n    x1 = 2\n    y1 = 3\n    z1 = 5\n    x2 = 6\n    y2 = 7\n    z2 = 8\n    a = 11\n    b = 23\n    c = 10\n    findEquation(x1, y1, z1, x2, y2, z2, a, b, c)\n",
        "output": "-29 x +  7 y +  48 z +  0 = 0\n",
        "fn_call": "findEquation"
    },
    {
        "text": "check whether two strings can be made equal by increasing prefixes | check whether the first string can be converted to the second string by increasing the ascii value of prefix string of first string ; length of two strings ; if lengths are not equal ; store the difference of ascii values ; difference of first element ; traverse through the string ; the ascii value of the second string should be greater than or equal to first string , if it is violated return false . ; store the difference of ascii values ; the difference of ascii values should be in descending order ; if the difference array is not in descending order ; if all the ascii values of characters of first string is less than or equal to the second string and the difference array is in descending order , return true ; ",
        "context": "",
        "code": "def find(s1, s2):\n    len__ = len(s1)\n    len_1 = len(s2)\n    if (len__ != len_1):\n        return False\n    d = [0 for i in range(len__)]\n    d[0] = ord(s2[0]) - ord(s1[0])\n    for i in range(1, len__, 1):\n        if (s1[i] > s2[i]):\n            return False\n        else:\n            d[i] = ord(s2[i]) - ord(s1[i])\n    for i in range(len__ - 1):\n        if (d[i] < d[i + 1]):\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    s1 = \"abcd\"\n    s2 = \"bcdd\"\n    if (find(s1, s2)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "find"
    },
    {
        "text": "maximum sum of any submatrix of a matrix which is sorted row | function that finds the maximum sub - matrix sum ; number of rows in the matrix ; number of columns in the matrix ; dp [ ] [ ] matrix to store the results of each iteration ; base case - the largest element in the matrix ; to stores the final result ; find the max sub matrix sum for the last row ; check whether the current sub - array yields maximum sum ; calculate the max sub matrix sum for the last column ; check whether the current sub - array yields maximum sum ; build the dp [ ] [ ] matrix from bottom to the top row ; update sum at each cell in dp [ ] [ ] ; update the maximum sum ; return the maximum sum ; ",
        "context": "",
        "code": "def maxSubMatSum(mat):\n    n = len(mat)\n    m = len(mat[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[n - 1][m - 1] = mat[n - 1][m - 1]\n    res = dp[n - 1][m - 1]\n    for i in range(m - 2, -1, -1):\n        dp[n - 1][i] = (mat[n - 1][i] + dp[n - 1][i + 1])\n        res = max(res, dp[n - 1][i])\n    for i in range(n - 2, -1, -1):\n        dp[i][m - 1] = (mat[i][m - 1] + dp[i + 1][m - 1])\n        res = max(res, dp[i][m - 1])\n    for i in range(n - 2, -1, -1):\n        for j in range(m - 2, -1, -1):\n            dp[i][j] = (mat[i][j] + dp[i][j + 1] +\n                        dp[i + 1][j] - dp[i + 1][j + 1])\n            res = max(res, dp[i][j])\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[-6, -4, -1], [-3, 2, 4], [2, 5, 8]]\n    print(maxSubMatSum(mat))\n",
        "output": "19\n",
        "fn_call": "maxSubMatSum"
    },
    {
        "text": "count swaps required to sort an array using insertion sort | stores the sorted array elements ; function to count the number of swaps required to merge two sorted subarray in a sorted form ; stores the count of swaps ; function to count the total number of swaps required to sort the array ; stores the total count of swaps required ; find the middle index splitting the two halves ; count the number of swaps required to sort the left subarray ; count the number of swaps required to sort the right subarray ; count the number of swaps required to sort the two sorted subarrays ; ",
        "context": "\ntemp = [0] * 100000\n\n",
        "code": "def merge(A, left, mid, right):\n    swaps = 0\n    i, j, k = left, mid, left\n    while (i < mid and j <= right):\n        if (A[i] <= A[j]):\n            temp[k] = A[i]\n            k, i = k + 1, i + 1\n        else:\n            temp[k] = A[j]\n            k, j = k + 1, j + 1\n            swaps += mid - i\n    while (i < mid):\n        temp[k] = A[i]\n        k, i = k + 1, i + 1\n    while (j <= right):\n        temp[k] = A[j]\n        k, j = k + 1, j + 1\n    while (left <= right):\n        A[left] = temp[left]\n        left += 1\n    return swaps\n\n\ndef mergeInsertionSwap(A, left, right):\n    swaps = 0\n    if (left < right):\n        mid = left + (right - left) // 2\n        swaps += mergeInsertionSwap(A, left, mid)\n        swaps += mergeInsertionSwap(A, mid + 1, right)\n        swaps += merge(A, left, mid + 1, right)\n    return swaps\n",
        "test": "\nif __name__ == '__main__':\n    A = [2, 1, 3, 1, 2]\n    N = len(A)\n    print(mergeInsertionSwap(A, 0, N - 1))\n",
        "output": "4\n",
        "fn_call": "mergeInsertionSwap"
    },
    {
        "text": "number of ones in the smallest repunit | function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; ",
        "context": "",
        "code": "def countOnes(n):\n    count = 1\n    rem = 1\n    while (rem != 0):\n        rem = (rem * 10 + 1) % n\n        count = count + 1\n    return count\n",
        "test": "\nn = 13\nprint(countOnes(n))\n",
        "output": "6\n",
        "fn_call": "countOnes"
    },
    {
        "text": "how to validate indian passport number using regular expression | python3 program to validate passport number of india using regular expression ; function to validate the pin code of india . ; regex to check valid pin code of india . ; compile the regex ; if the string is empty return false ; pattern class contains matcher ( ) method to find matching between given string and regular expression . ; return true if the string matched the regex else false ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidPassportNo(string):\n    regex = \"^[A-PR-WYa-pr-wy][1-9]\\d\" + \"\\s?\\d{4}[1-9]$\"\n    p = re.compile(regex)\n    if (string == ''):\n        return False\n    m = re.match(p, string)\n    if m is None:\n        return False\n    else:\n        return True\n",
        "test": "\nif __name__ == \"__main__\":\n    str1 = \"A21 90457\"\n    print(isValidPassportNo(str1))\n    str2 = \"A0296457\"\n    print(isValidPassportNo(str2))\n    str3 = \"Q2096453\"\n    print(isValidPassportNo(str3))\n    str4 = \"12096457\"\n    print(isValidPassportNo(str4))\n    str5 = \"A209645704\"\n    print(isValidPassportNo(str5))\n",
        "output": "True\nFalse\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidPassportNo"
    },
    {
        "text": "next greater integer having one more number of set bits | python3 implementation to find the next greater integer with one more number of set bits ; function to find the position of rightmost set bit . returns - 1 if there are no set bits ; function to find the next greater integer ; position of rightmost unset bit of n by passing ~ n as argument ; if n consists of unset bits , then set the rightmost unset bit ; n does not consists of unset bits ; ",
        "context": "\nimport math\n\n",
        "code": "def getFirstSetBitPos(n):\n    return ((int)(math .log(n & -n) / math .log(2)) + 1) - 1\n\n\ndef nextGreaterWithOneMoreSetBit(n):\n    pos = getFirstSetBitPos(~n)\n    if (pos > -1):\n        return (1 << pos) | n\n    return ((n << 1) + 1)\n",
        "test": "\nn = 10\nprint(\"Next greater integer = \", nextGreaterWithOneMoreSetBit(n))\n",
        "output": "Next greater integer =  11\n",
        "fn_call": "nextGreaterWithOneMoreSetBit"
    },
    {
        "text": "non | function to find count of prime ; find maximum value in the array ; find and store all prime numbers up to max_val using sieve create a boolean array \" prime [ 0 . . n ] \" . a value in prime [ i ] will finally be false if i is not a prime , else true . ; remaining part of sieve ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; function to print non - repeating primes ; precompute primes using sieve ; create hashmap to store frequency of prime numbers ; traverse through array elements and count frequencies of all primes ; traverse through map and print non repeating primes ; ",
        "context": "",
        "code": "def findPrimes(arr, n):\n    max_val = max(arr)\n    prime = [True for i in range(max_val + 1)]\n    prime[0] = False\n    prime[1] = False\n    p = 2\n    while (p * p <= max_val):\n        if (prime[p]):\n            for i in range(p * 2, max_val + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\ndef nonRepeatingPrimes(arr, n):\n    prime = findPrimes(arr, n)\n    mp = dict()\n    for i in range(n):\n        if (prime[arr[i]]):\n            if (arr[i] in mp):\n                mp[arr[i]] += 1\n            else:\n                mp[arr[i]] = 1\n    for entry in mp .keys():\n        if (mp[entry] == 1):\n            print(entry)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 4, 6, 7, 9, 7, 23, 21, 3]\n    n = len(arr)\n    nonRepeatingPrimes(arr, n)\n",
        "output": "2\n23\n",
        "fn_call": "nonRepeatingPrimes"
    },
    {
        "text": "newman\u00e2 \u20ac\u201c shanks\u00e2 \u20ac\u201c williams prime | return nth newmanashanksawilliams prime ; base case ; recursive step ; ",
        "context": "",
        "code": "def nswp(n):\n    if n == 0 or n == 1:\n        return 1\n    return 2 * nswp(n - 1) + nswp(n - 2)\n",
        "test": "\nn = 3\nprint(nswp(n))\n",
        "output": "7\n",
        "fn_call": "nswp"
    },
    {
        "text": "m coloring problem | backtracking | python3 program for the above approach ; a node class which stores the color and the edges connected to the node ; create a visited array of n nodes , initialized to zero ; maxcolors used till now are 1 as all nodes are painted color 1 ; do a full bfs traversal from all unvisited starting points ; if the starting point is unvisited , mark it visited and push it in queue ; bfs travel starts here ; checking all adjacent nodes to \" top \" edge in our queue ; important : if the color of the adjacent node is same , increase it by 1 ; if number of colors used shoots m , return 0 ; if the adjacent node is not visited , mark it visited and push it in queue ; ",
        "context": "\nfrom queue import Queue\n\n\nclass node:\n    color = 1\n    edges = set()\n\n",
        "code": "def canPaint(nodes, n, m):\n    visited = [0 for _ in range(n + 1)]\n    maxColors = 1\n    for _ in range(1, n + 1):\n        if visited[_]:\n            continue\n        visited[_] = 1\n        q = Queue()\n        q .put(_)\n        while not q .empty():\n            top = q .get()\n            for _ in nodes[top].edges:\n                if nodes[top].color == nodes[_].color:\n                    nodes[_].color += 1\n                maxColors = max(\n                    maxColors, max(\n                        nodes[top].color, nodes[_].color))\n                if maxColors > m:\n                    print(maxColors)\n                    return 0\n                if not visited[_]:\n                    visited[_] = 1\n                    q .put(_)\n    return 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    graph = [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]\n    m = 3\n    nodes = []\n    for _ in range(n + 1):\n        nodes .append(node())\n    for _ in range(n):\n        for __ in range(n):\n            if graph[_][__]:\n                nodes[_].edges .add(_)\n                nodes[__].edges .add(__)\n    print(canPaint(nodes, n, m))\n",
        "output": "1\n",
        "fn_call": "canPaint"
    },
    {
        "text": "check if number is palindrome or not in octal | python3 program to check if octal representation of a number is prime ; function to check no is in octal or not ; function to check no is palindrome or not ; if number is already in octal , we traverse digits using repeated division with 10. else we traverse digits using repeated division with 8 ; to store individual digits ; traversing all digits ; checking if octal no is palindrome ; ",
        "context": "\nMAX_DIGITS = 20\n\n",
        "code": "def isOctal(n):\n    while (n):\n        if ((n % 10) >= 8):\n            return False\n        else:\n            n = int(n / 10)\n    return True\n\n\ndef isPalindrome(n):\n    divide = 8 if (isOctal(n) == False)else 10\n    octal = []\n    while (n != 0):\n        octal .append(n % divide)\n        n = int(n / divide)\n    j = len(octal) - 1\n    k = 0\n    while (k <= j):\n        if (octal[j] != octal[k]):\n            return False\n        j -= 1\n        k += 1\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    n = 97\n    if (isPalindrome(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPalindrome"
    },
    {
        "text": "number formed by adding product of its max and min digit k times | function to find the formed number ; k -= 1 m ( 1 ) = n ; check if minimum digit is 0 ; function that returns the product of maximum and minimum digit of n number . ; find the last digit . ; moves to next digit ; ",
        "context": "",
        "code": "def prod_of_max_min(n):\n    largest = 0\n    smallest = 10\n    while (n != 0):\n        r = n % 10\n        largest = max(r, largest)\n        smallest = min(r, smallest)\n        n = n // 10\n    return largest * smallest\n\n\ndef formed_no(N, K):\n    if (K == 1):\n        return N\n    answer = N\n    while (K != 0):\n        a_current = prod_of_max_min(answer)\n        if (a_current == 0):\n            break\n        answer += a_current\n        K -= 1\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 487\n    K = 100000000\n    print(formed_no(N, K))\n",
        "output": "950\n",
        "fn_call": "formed_no"
    },
    {
        "text": "digital root of a given large integer using recursion | function to convert given sum into string ; loop to extract digit one by one from the given sum and concatenate into the string ; type casting for concatenation ; return converted string ; function to get individual digit sum from string ; loop to get individual digit sum ; function call to convert sum into string ; function to calculate the digital root of a very large number ; base condition ; function call to get individual digit sum ; recursive function to get digital root of a very large number ; ",
        "context": "",
        "code": "def convertToString(sum):\n    str1 = \"\"\n    while (sum):\n        str1 = str1 + chr((sum % 10) + ord('0'))\n        sum = sum // 10\n    return str1\n\n\ndef GetIndividulaDigitSum(str1, len1):\n    sum = 0\n    for i in range(len1):\n        sum = sum + ord(str1[i]) - ord('0')\n    return convertToString(sum)\n\n\ndef GetDigitalRoot(str1):\n    if (len(str1) == 1):\n        return ord(str1[0]) - ord('0')\n    str1 = GetIndividulaDigitSum(str1, len(str1))\n    return GetDigitalRoot(str1)\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"675987890789756545689070986776987\"\n    print(GetDigitalRoot(str1))\n",
        "output": "5\n",
        "fn_call": "GetDigitalRoot"
    },
    {
        "text": "number obtained by reducing sum of digits of 2 n into a single digit | function to find the number obtained by reducing sum of digits of 2 ^ n into a single digit ; stores answers for different values of n ; ",
        "context": "",
        "code": "def findNumber(N):\n    ans = [1, 2, 4, 8, 7, 5]\n    return ans[N % 6]\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    print(findNumber(N))\n",
        "output": "1\n",
        "fn_call": "findNumber"
    },
    {
        "text": "count all n digit numbers whose digits are multiple of x | function to calculate x ^ n using binary - exponentiation ; stores the resultant power ; stores the value of x ^ ( n / 2 ) ; function to count an - digit numbers whose digits are multiples of x ; count adigits which are multiples of x ; check if current number is a multiple of x ; increase count of multiples ; check if it 's a 1 digit number ; count the total numbers ; return the total numbers ; ",
        "context": "",
        "code": "def power(x, n):\n    temp = []\n    if (n == 0):\n        return 1\n    temp = power(x, n // 2)\n    if (n % 2 == 0):\n        return temp * temp\n    else:\n        return x * temp * temp\n\n\ndef count_Total_Numbers(n, x):\n    total, multiples = 0, 0\n    for i in range(10):\n        if (i % x == 0):\n            multiples += 1\n    if (n == 1):\n        return multiples\n    total = ((multiples - 1) * power(multiples, n - 1))\n    return total\n",
        "test": "\nif __name__ == '__main__':\n    N = 1\n    X = 3\n    print(count_Total_Numbers(N, X))\n",
        "output": "4\n",
        "fn_call": "count_Total_Numbers"
    },
    {
        "text": "sum of matrix in which each element is absolute difference of its row and column numbers | return the sum of matrix in which each element is absolute difference of its corresponding row and column number row ; generate matrix ; compute sum ; ",
        "context": "",
        "code": "def findSum(n):\n    arr = [[0 for x in range(n)]for y in range(n)]\n    for i in range(n):\n        for j in range(n):\n            arr[i][j] = abs(i - j)\n    sum = 0\n    for i in range(n):\n        for j in range(n):\n            sum += arr[i][j]\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    print(findSum(n))\n",
        "output": "8\n",
        "fn_call": "findSum"
    },
    {
        "text": "maximum sum subsequence | function to print the maximum non - emepty subsequence sum ; stores the maximum non - emepty subsequence sum in an array ; stores the largest element in the array ; traverse the array ; if a [ i ] is greater than 0 ; update sum ; ",
        "context": "",
        "code": "def MaxNonEmpSubSeq(a, n):\n    sum = 0\n    maxm = max(a)\n    if (maxm <= 0):\n        return maxm\n    for i in range(n):\n        if (a[i] > 0):\n            sum += a[i]\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-2, 11, -4, 2, -3, -10]\n    N = len(arr)\n    print(MaxNonEmpSubSeq(arr, N))\n",
        "output": "13\n",
        "fn_call": "MaxNonEmpSubSeq"
    },
    {
        "text": "difference between sum of k maximum even and odd array elements | function to find the absolute difference between sum of first k maximum even and odd numbers ; stores index from where odd number starts ; segregate even and odd number ; if current element is even ; sort in decreasing order even part ; sort in decreasing order odd part ; calculate sum of k maximum even number ; calculate sum of k maximum odd number ; print the absolute difference ; ",
        "context": "",
        "code": "def evenOddDiff(a, n, k):\n    j = -1\n    even = []\n    odd = []\n    for i in range(n):\n        if (a[i] % 2 == 0):\n            even .append(a[i])\n        else:\n            odd .append(a[i])\n    j += 1\n    even .sort()\n    even .reverse()\n    odd .sort()\n    odd .reverse()\n    evenSum, oddSum = 0, 0\n    for i in range(k):\n        evenSum += even[i]\n    for i in range(k):\n        oddSum += odd[i]\n    print(abs(evenSum - oddSum))\n",
        "test": "\narr = [1, 8, 3, 4, 5]\nN = len(arr)\nK = 2\nevenOddDiff(arr, N, K)\n",
        "output": "4\n",
        "fn_call": "evenOddDiff"
    },
    {
        "text": "check if suffix and prefix of a string are palindromes | function to check whether the string is a palindrome ; reverse the string and assign it to new variable for comparison ; check if both are same ; function to check whether the string has prefix and suffix substrings of length greater than 1 which are palindromes . ; check all prefix substrings ; check if the prefix substring is a palindrome ; if we did not find any palindrome prefix of length greater than 1. ; check all suffix substrings , as the string is reversed now ; check if the suffix substring is a palindrome ; if we did not find a suffix ; ",
        "context": "",
        "code": "def isPalindrome(r):\n    p = r[::-1]\n    return r == p\n\n\ndef CheckStr(s):\n    l = len(s)\n    i = 0\n    for i in range(2, l + 1):\n        if isPalindrome(s[0:i]):\n            break\n    if i == (l + 1):\n        return False\n    for i in range(2, l + 1):\n        if isPalindrome(s[l - i:l]):\n            return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abccbarfgdbd\"\n    if CheckStr(s):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "CheckStr"
    },
    {
        "text": "subarray / substring vs subsequence and programs to generate them | prints all subarrays in arr [ 0. . n - 1 ] ; pick starting point ; pick ending point ; print subarray between current starting and ending points ; ",
        "context": "",
        "code": "def subArray(arr, n):\n    for i in range(0, n):\n        for j in range(i, n):\n            for k in range(i, j + 1):\n                print(arr[k], end=\" \")\n            print(\"\", end=\"\")\n",
        "test": "\narr = [1, 2, 3, 4]\nn = len(arr)\nprint(\"All Non-empty Subarrays\")\nsubArray(arr, n)\n",
        "output": "All Non-empty Subarrays\n1 1 2 1 2 3 1 2 3 4 2 2 3 2 3 4 3 3 4 4 ",
        "fn_call": "subArray"
    },
    {
        "text": "maximum score after flipping a binary matrix atmost k times | python3 program to find the maximum score after flipping a binary matrix atmost k times ; function to find maximum score of matrix ; find value of rows having first column value equal to zero ; update those rows which lead to maximum score after toggle ; calculating answer ; check if k > 0 we can toggle if necessary . ; return max answer possible ; ",
        "context": "\nn = 3\nm = 4\n\n",
        "code": "def maxMatrixScore(A, K):\n    update = {}\n    for i in range(0, n):\n        if A[i][0] == 0:\n            ans = 0\n            for j in range(1, m):\n                ans = ans + A[i][j] * 2 ** (m - j - 1)\n            update[ans] = i\n    for idx in update .values():\n        for j in range(0, m):\n            A[idx][j] = (A[idx][j] + 1) % 2\n        K -= 1\n        if K <= 0:\n            break\n    ans = 0\n    for j in range(0, m):\n        zero, one = 0, 0\n        for i in range(0, n):\n            if A[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if K > 0 and zero > one:\n            ans += zero * 2 ** (m - j - 1)\n            K -= 1\n        else:\n            ans += one * 2 ** (m - j - 1)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [[0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]]\n    K = 2\n    print(maxMatrixScore(A, K))\n",
        "output": "36\n",
        "fn_call": "maxMatrixScore"
    },
    {
        "text": "modular exponentiation ( power in modular arithmetic ) | iterative function to calculate ( x ^ y ) in o ( log y ) ; ",
        "context": "\n",
        "code": "def power(x, y, p):\n\n    res = 1\n\n    while (y > 0):\n\n        if ((y & 1) != 0):\n            res = res * x\n        y = y >> 1\n        x = x * x\n\n    return res % p\n",
        "test": "\nx = 2\ny = 5\np = 13\nprint(\"Power is \", power(x, y, p))\n",
        "output": "Power is  6\n",
        "fn_call": "power"
    },
    {
        "text": "minimum deletions in array to make difference of adjacent elements non | function for finding minimum deletions so that the array becomes non decreasing and the difference between adjacent elements also becomes non decreasing ; initialize answer to a large value ; generating all subsets ; checking the first condition ; checking the second condition ; if both conditions are satisfied consider the answer for minimum ; ",
        "context": "",
        "code": "def minimumDeletions(A, N):\n    ans = 10 ** 8\n    for i in range(1, (1 << N)):\n        temp = []\n        for j in range(N):\n            if ((i & (1 << j)) != 0):\n                temp .append(A[j])\n        flag = 0\n        for j in range(1, len(temp)):\n            if (temp[j] < temp[j - 1]):\n                flag = 1\n        for j in range(1, len(temp) - 1):\n            if (temp[j] - temp[j - 1] > temp[j + 1] - temp[j]):\n                flag = 1\n        if (flag == 0):\n            ans = min(ans, N - len(temp))\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 4, 5, 7, 20, 21]\n    N = len(A)\n    print(minimumDeletions(A, N))\n",
        "output": "2\n",
        "fn_call": "minimumDeletions"
    },
    {
        "text": "count of subsets not containing adjacent elements | function to return the count of possible subsets ; total possible subsets of n sized array is ( 2 ^ n - 1 ) ; to store the required count of subsets ; run from i 000. .0 to 111. .1 ; if current subset has consecutive elements from the array ; ",
        "context": "",
        "code": "def cntSubsets(arr, n):\n    max = pow(2, n)\n    result = 0\n    for i in range(max):\n        counter = i\n        if (counter & (counter >> 1)):\n            continue\n        result += 1\n    return result\n",
        "test": "\narr = [3, 5, 7]\nn = len(arr)\nprint(cntSubsets(arr, n))\n",
        "output": "5\n",
        "fn_call": "cntSubsets"
    },
    {
        "text": "count of subarrays whose sum is a perfect square | python3 code for the above approach . ; function to find count of subarrays whose sum is a perfect square . ; to search for index with ( current prefix sum - j * j ) ; storing the prefix sum ; used to track the minimum value in prefixsum ; calculating the prefixsum and tracking the prefixmin ; below statement is used if array contains negative numbers ; counts the no of subarrays with perfect square sum ; as 0 is a perfect square , so we initialize 0 th index - key with value 1 ; here we count the perfect square subarray sum by searching if there is a prefix with sum = ( current prefixsum - ( sq * sq ) ) ; increasing our subarray count ; increasing the current prefixsum index value in map by 1 to count the other perfect squares while traversing further ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def countSubarrays(arr, n):\n    mp = defaultdict(lambda: 0)\n    prefixSum = [0] * n\n    prefixMin = 0\n    prefixSum[0] = arr[0]\n    prefixMin = min(prefixMin, prefixSum[0])\n    for i in range(1, n):\n        prefixSum[i] = prefixSum[i - 1] + arr[i]\n        prefixMin = min(prefixMin, prefixSum[i])\n    countSubs = 0\n    mp[0] = 1\n    for i in range(n):\n        j = 0\n        while prefixSum[i] - j * j >= prefixMin:\n            if prefixSum[i] - j * j in mp:\n                countSubs += mp[prefixSum[i] - j * j]\n            j += 1\n        mp[prefixSum[i]] += 1\n    return countSubs\n",
        "test": "\narr = [2, 3, -5, 6, -7, 4]\nn = len(arr)\nans = countSubarrays(arr, n)\nprint(ans)\n",
        "output": "5\n",
        "fn_call": "countSubarrays"
    },
    {
        "text": "search in an array of strings where non | compare two string equals are not ; main function to find string location ; move mid to the middle ; if mid is empty , find closest non - empty string ; if mid is empty , search in both sides of mid and find the closest non - empty string , and set mid accordingly . ; if str is found at mid ; if str is greater than mid ; if str is smaller than mid ; ",
        "context": "",
        "code": "def compareStrings(str1, str2):\n    i = 0\n    while i < len(str1) - 1 and str1[i] == str2[i]:\n        i += 1\n    if str1[i] > str2[i]:\n        return -1\n    return str1[i] < str2[i]\n\n\ndef searchStr(arr, string, first, last):\n    if first > last:\n        return -1\n    mid = (last + first) // 2\n    if len(arr[mid]) == 0:\n        left, right = mid - 1, mid + 1\n        while True:\n            if left  last:\n                return -1\n            if right <= last and len(arr[right]) != 0:\n                mid = right\n                break\n            if left >= first and len(arr[left]) != 0:\n                mid = left\n                break\n            right += 1\n            left -= 1\n    if compareStrings(string, arr[mid]) == 0:\n        return mid\n    if compareStrings(string, arr[mid]) < 0:\n        return searchStr(arr, string, mid + 1, last)\n    return searchStr(arr, string, first, mid - 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\n        \"for\",\n        \"\",\n        \"\",\n        \"\",\n        \"geeks\",\n        \"ide\",\n        \"\",\n        \"practice\",\n        \"\",\n        \"\",\n        \"quiz\",\n        \"\",\n        \"\"]\n    string = \"quiz\"\n    n = len(arr)\n    print(searchStr(arr, string, 0, n - 1))\n",
        "output": "10\n",
        "fn_call": "searchStr"
    },
    {
        "text": "find area of triangle if two vectors of two adjacent sides are given | python code to calculate area of triangle if vectors of 2 adjacent sides are given ; function to calculate area of triangle ; ",
        "context": "\nimport math\n\n",
        "code": "def area(x1, y1, z1, x2, y2, z2):\n    area = math .sqrt((y1 * z2 - y2 * z1)**2 + (x1 * z2 -\n                      x2 * z1)**2 + (x1 * y2 - x2 * y1)**2)\n    area = area / 2\n    return area\n\n\ndef main():\n    x1 = -2\n    y1 = 0\n    z1 = -5\n    x2 = 1\n    y2 = -2\n    z2 = -1\n    a = area(x1, y1, z1, x2, y2, z2)\n    print(\"Area = \", a)\n",
        "test": "\nif __name__ == \"__main__\":\n    main()\n",
        "output": "Area =  6.422616289332565\n",
        "fn_call": "main"
    },
    {
        "text": "given a sorted and rotated array , find if there is a pair with a given sum | this function returns count of number of pairs with sum equals to x . ; find the pivot element . pivot element is largest element of array . ; l is index of smallest element . ; r is index of largest element . ; variable to store count of number of pairs . ; find sum of pair formed by arr [ l ] and arr [ r ] and update l , r and cnt accordingly . ; if we find a pair with sum x , then increment cnt , move l and r to next element . ; this condition is required to be checked , otherwise l and r will cross each other and loop will never terminate . ; if current pair sum is less , move to the higher sum side . ; if current pair sum is greater , move to the lower sum side . ; ",
        "context": "",
        "code": "def pairsInSortedRotated(arr, n, x):\n    for i in range(n):\n        if arr[i] > arr[i + 1]:\n            break\n    l = (i + 1) % n\n    r = i\n    cnt = 0\n    while (l != r):\n        if arr[l] + arr[r] == x:\n            cnt += 1\n            if l == (r - 1 + n) % n:\n                return cnt\n            l = (l + 1) % n\n            r = (r - 1 + n) % n\n        elif arr[l] + arr[r] < x:\n            l = (l + 1) % n\n        else:\n            r = (n + r - 1) % n\n    return cnt\n",
        "test": "\narr = [11, 15, 6, 7, 9, 10]\ns = 16\nprint(pairsInSortedRotated(arr, 6, s))\n",
        "output": "2\n",
        "fn_call": "pairsInSortedRotated"
    },
    {
        "text": "prime triplet | function to detect prime number using sieve method https : www . geeksforgeeks . org / sieve - of - eratosthenes / to detect prime number ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; function to print prime triplets ; finding all primes from 1 to n ; triplets of form ( p , p + 2 , p + 6 ) ; triplets of form ( p , p + 4 , p + 6 ) ; ",
        "context": "",
        "code": "def sieve(n, prime):\n    p = 2\n    while (p * p <= n):\n        if (prime[p]):\n            i = p * 2\n            while (i <= n):\n                prime[i] = False\n                i = i + p\n        p = p + 1\n\n\ndef printPrimeTriplets(n):\n    prime = [True] * (n + 1)\n    sieve(n, prime)\n    print(\"The prime triplets from 1 to \", n, \"are :\")\n    for i in range(2, n - 6 + 1):\n        if (prime[i] and prime[i + 2] and prime[i + 6]):\n            print(i, (i + 2), (i + 6))\n        elif (prime[i] and prime[i + 4] and prime[i + 6]):\n            print(i, (i + 4), (i + 6))\n",
        "test": "\nn = 25\nprintPrimeTriplets(n)\n",
        "output": "The prime triplets from 1 to  25 are :\n5 7 11\n7 11 13\n11 13 17\n13 17 19\n17 19 23\n",
        "fn_call": "printPrimeTriplets"
    },
    {
        "text": "find sum in range l to r in given sequence of integers | function to find the sum within the given range ; generating array from ",
        "context": "",
        "code": "def findSum(L, R):\n    arr = []\n    i = 0\n    x = 2\n    k = 0\n    while (i <= R):\n        arr .insert(k, i + x)\n        k += 1\n        if (i + 1 <= R):\n            arr .insert(k, i + 1 + x)\n        k += 1\n        x *= -1\n        i += 2\n    sum = 0\n    for i in range(L, R + 1):\n        sum += arr[i]\n    return sum\n",
        "test": "\nL = 0\nR = 5\nprint(findSum(L, R))\n",
        "output": "19\n",
        "fn_call": "findSum"
    },
    {
        "text": "modify a numeric string to a balanced parentheses by replacements | function to check if the given string can be converted to a balanced bracket sequence or not ; check if the first and last characters are equal ; initialize two variables to store the count of open and closed brackets ; if the current character is same as the first character ; if the current character is same as the last character ; if count of open brackets becomes less than 0 ; print the new string ; if the current character is same as the first character ; if bracket sequence is not balanced ; check for unbalanced bracket sequence ; print the sequence ; ",
        "context": "",
        "code": "def balBracketSequence(str):\n    n = len(str)\n    if (str[0] == str[n - 1]):\n        print(\"No\", end=\"\")\n    else:\n        cntForOpen = 0\n        cntForClose = 0\n        check = 1\n        for i in range(n):\n            if (str[i] == str[0]):\n                cntForOpen += 1\n            elif str[i] == str[n - 1]:\n                cntForOpen -= 1\n            else:\n                cntForOpen += 1\n            if (cntForOpen < 0):\n                check = 0\n                break\n        if (check and cntForOpen == 0):\n            print(\"Yes, \", end=\"\")\n            for i in range(n):\n                if (str[i] == str[n - 1]):\n                    print(')', end=\"\")\n                else:\n                    print('(', end=\"\")\n            return\n        else:\n            for i in range(n):\n                if (str[i] == str[0]):\n                    cntForClose += 1\n                else:\n                    cntForClose -= 1\n                if (cntForClose < 0):\n                    check = 0\n                    break\n            if (check and cntForClose == 0):\n                print(\"Yes, \", end=\"\")\n                for i in range(n):\n                    if (str[i] == str[0]):\n                        print('(', end=\"\")\n                    else:\n                        print(')', end=\"\")\n                return\n        print(\"NO\", end=\"\")\n",
        "test": "\nstr = \"123122\"\nbalBracketSequence(str)\n",
        "output": "Yes, ()(())",
        "fn_call": "balBracketSequence"
    },
    {
        "text": "maximum possible gcd for a pair of integers with sum n | function to find the required gcd value ; if i is a factor of n ; return the largest factor possible ; if n is a prime number ; ",
        "context": "",
        "code": "def maxGCD(N):\n    i = 2\n    while (i * i <= N):\n        if (N % i == 0):\n            return N // i\n        i += 1\n    return 1\n",
        "test": "\nN = 33\nprint(\"Maximum Possible GCD value is : \", maxGCD(N))\n",
        "output": "Maximum Possible GCD value is :  11\n",
        "fn_call": "maxGCD"
    },
    {
        "text": "minimum absolute difference between n and a power of 2 | python3 implementation of the above approach ; function to return the minimum difference between n and a power of 2 ; power of 2 closest to n on its left ; power of 2 closest to n on its right ; return the minimum abs difference ; ",
        "context": "\nimport math\n\n",
        "code": "def minAbsDiff(n):\n    left = 1 << (int)(math .floor(math .log2(n)))\n    right = left * 2\n    return min((n - left), (right - n))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 15\n    print(minAbsDiff(n))\n",
        "output": "1\n",
        "fn_call": "minAbsDiff"
    },
    {
        "text": "arrange n elements in circular fashion such that all elements are strictly less than sum of adjacent elements | function to print the arrangement that satisifes the given condition ; sort the array initially ; array that stores the arrangement ; once the array is sorted re - fill the array again in the mentioned way in the approach ; iterate in the array and check if the arrangement made satisfies the given condition or not ; for the first element the adjacents will be a [ 1 ] and a [ n - 1 ] ; for the last element the adjacents will be a [ 0 ] and a [ n - 2 ] ; if we reach this position then the arrangement is possible ; ",
        "context": "",
        "code": "def printArrangement(a, n):\n    a = sorted(a)\n    b = [0 for i in range(n)]\n    low = 0\n    high = n - 1\n    for i in range(n):\n        if (i % 2 == 0):\n            b[low] = a[i]\n            low += 1\n        else:\n            b[high] = a[i]\n            high -= 1\n    for i in range(n):\n        if (i == 0):\n            if (b[n - 1] + b[1] <= b[i]):\n                print(\"-1\")\n                return\n        elif (i == (n - 1)):\n            if (b[n - 2] + b[0] <= b[i]):\n                print(\"-1\")\n                return\n        else:\n            if (b[i - 1] + b[i + 1] <= b[i]):\n                print(\"-1\")\n                return\n    for i in range(n):\n        print(b[i], end=\" \")\n",
        "test": "\na = [1, 4, 4, 3, 2]\nn = len(a)\nprintArrangement(a, n)\n",
        "output": "1 3 4 4 2 ",
        "fn_call": "printArrangement"
    },
    {
        "text": "check if a string can be converted to another string by replacing vowels and consonants | function to check if the character is vowel or not ; function that checks if a string can be converted to another string ; find length of string ; if length is not same ; iterate for every character ; if both vowel ; both are consonants ; ",
        "context": "",
        "code": "def isVowel(c):\n    if (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u'):\n        return True\n    return False\n\n\ndef checkPossibility(s1, s2):\n    l1 = len(s1)\n    l2 = len(s2)\n    if (l1 != l2):\n        return False\n    for i in range(l1):\n        if (isVowel(s1[i]) and isVowel(s2[i])):\n            continue\n        elif ((isVowel(s1[i])) == False and (isVowel(s2[i]) == False)):\n            continue\n        else:\n            return False\n    return True\n",
        "test": "\nS1, S2 = \"abcgle\", \"ezggli\"\nif (checkPossibility(S1, S2)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkPossibility"
    },
    {
        "text": "program to find slope of a line | python3 program to find slope ; function to find the slope of a straight line ; ",
        "context": "\nimport sys\n\n",
        "code": "def slope(x1, y1, x2, y2):\n    if x1 == x2:\n        return (sys .maxsize)\n    return ((y2 - y1) / (x2 - x1))\n",
        "test": "\nx1 = 4\ny1 = 2\nx2 = 2\ny2 = 5\nprint(\"Slope is :\", slope(4, 2, 2, 5))\n",
        "output": "Slope is : -1.5\n",
        "fn_call": "slope"
    },
    {
        "text": "bitonic string | function to check if the given string is bitonic ; check for increasing sequence ; if end of string has been reached ; check for decreasing sequence ; if the end of string hasn 't  been reached ; return true if bitonic ; ",
        "context": "",
        "code": "def checkBitonic(s):\n    i = 0\n    j = 0\n    for i in range(1, len(s)):\n        if (s[i] > s[i - 1]):\n            continue\n        if (s[i] <= s[i - 1]):\n            break\n    if (i == (len(s) - 1)):\n        return True\n    for j in range(i + 1, len(s)):\n        if (s[j] < s[j - 1]):\n            continue\n        if (s[j] >= s[j - 1]):\n            break\n    i = j\n    if (i != len(s) - 1):\n        return False\n    return True\n",
        "test": "\ns = \"abcdfgcba\"\nif (checkBitonic(s)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "checkBitonic"
    },
    {
        "text": "minimize sum of an array by at most k reductions | function to obtain the minimum possible sum from the array by k reductions ;  ; insert elements into the maxheap ; remove the maximum ; insert maximum / 2 ; stores the sum of remaining elements ; ",
        "context": "",
        "code": "def minSum(a, n, k):\n\n    q = []\n    for i in range(n):\n        q.append(a[i])\n\n    q = sorted(q)\n\n    while (len(q) > 0 and k > 0):\n        top = q[-1] // 2\n        del q[-1]\n\n        q.append(top)\n        k -= 1\n        q = sorted(q)\n\n    sum = 0\n    while (len(q) > 0):\n        sum += q[-1]\n        del q[-1]\n\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n\n    n = 4\n    k = 3\n\n    a = [20, 7, 5, 4]\n\n    print(minSum(a, n, k))\n",
        "output": "17\n",
        "fn_call": "minSum"
    },
    {
        "text": "merging two unsorted arrays in sorted order | function to merge array in sorted order ; sorting a [ ] and b [ ] ; merge two sorted arrays into res [ ] ; merging remaining elements of a [ ] ( if any ) ; merging remaining elements of b [ ] ( if any ) ; ",
        "context": "",
        "code": "def sortedMerge(a, b, res, n, m):\n    a .sort()\n    b .sort()\n    i, j, k = 0, 0, 0\n    while (i < n and j < m):\n        if (a[i] <= b[j]):\n            res[k] = a[i]\n            i += 1\n            k += 1\n        else:\n            res[k] = b[j]\n            j += 1\n            k += 1\n    while (i < n):\n        res[k] = a[i]\n        i += 1\n        k += 1\n    while (j < m):\n        res[k] = b[j]\n        j += 1\n        k += 1\n",
        "test": "\na = [10, 5, 15]\nb = [20, 3, 2, 12]\nn = len(a)\nm = len(b)\nres = [0 for i in range(n + m)]\nsortedMerge(a, b, res, n, m)\nprint(\"Sorted merged list :\")\nfor i in range(n + m):\n    print(res[i],)\n",
        "output": "Sorted merged list :\n2\n3\n5\n10\n12\n15\n20\n",
        "fn_call": "sortedMerge"
    },
    {
        "text": "arithmetic mean | prints n arithmetic means between a and b . ; calculate common difference ( d ) ; for finding n the arithmetic mean between a and b ; ",
        "context": "",
        "code": "def printAMeans(A, B, N):\n    d = (B - A) / (N + 1)\n    for i in range(1, N + 1):\n        print(int(A + i * d), end=\" \")\n",
        "test": "\nA = 20\nB = 32\nN = 5\nprintAMeans(A, B, N)\n",
        "output": "22 24 26 28 30 ",
        "fn_call": "printAMeans"
    },
    {
        "text": "smallest positive number made up of non | function to find smallest positive number made up of non - repeating digits whose sum of its digits is equal to n ; no such number exists ; stores the required answer ; store the digit at unit 's place ; iterate until n > digit ; push digit at the start of res ; decrement n by digit ; decrement digit by 1 ; push the remaining number as the starting digit ; print the required number ; ",
        "context": "",
        "code": "def result(n):\n    if (n > 45):\n        print(-1, end=\"\")\n        return\n    res = \"\"\n    digit = 9\n    while (n > digit):\n        res = str(digit) + res\n        n -= digit\n        digit -= 1\n    if (n > 0):\n        res = str(n) + res\n    print(res)\n",
        "test": "\nif __name__ == '__main__':\n    N = 19\n    result(N)\n",
        "output": "289\n",
        "fn_call": "result"
    },
    {
        "text": "product of maximum in first array and minimum in second | function to calculate the product ; initialize max of first array ; initialize min of second array ; to find the maximum element in first array ; to find the minimum element in second array ; process remaining elements ; ",
        "context": "",
        "code": "def minMaxProduct(arr1, arr2, n1, n2):\n    max = arr1[0]\n    min = arr2[0]\n    i = 1\n    while (i < n1 and i < n2):\n        if (arr1[i] > max):\n            max = arr1[i]\n        if (arr2[i] < min):\n            min = arr2[i]\n        i += 1\n    while (i < n1):\n        if (arr1[i] > max):\n            max = arr1[i]\n            i += 1\n    while (i < n2):\n        if (arr2[i] < min):\n            min = arr2[i]\n            i += 1\n    return max * min\n",
        "test": "\narr1 = [10, 2, 3, 6, 4, 1]\narr2 = [5, 1, 4, 2, 6, 9]\nn1 = len(arr1)\nn2 = len(arr1)\nprint(minMaxProduct(arr1, arr2, n1, n2))\n",
        "output": "10\n",
        "fn_call": "minMaxProduct"
    },
    {
        "text": "larger of a ^ b or b ^ a ( a raised to power b or b raised to power a ) | python 3 code for finding greater between the a ^ b and b ^ a ; function to find the greater value ; ",
        "context": "\nimport math\n\n",
        "code": "def findGreater(a, b):\n    x = a * (math .log(b))\n    y = b * (math .log(a))\n    if (y > x):\n        print(\"a^b is greater\")\n    elif (y < x):\n        print(\"b^a is greater\")\n    else:\n        print(\"Both are equal\")\n",
        "test": "\na = 3\nb = 5\nc = 2\nd = 4\nfindGreater(a, b)\nfindGreater(c, d)\n",
        "output": "a^b is greater\nBoth are equal\n",
        "fn_call": "findGreater"
    },
    {
        "text": "rat in a maze | backtracking | maze size ; a utility function to print solution matrix sol ; a utility function to check if x , y is valid index for n * n maze ; if ( x , y outside maze ) return false ; this function solves the maze problem using backtracking . it mainly uses solvemazeutil ( ) to solve the problem . it returns false if no path is possible , otherwise return true and prints the path in the form of 1 s . please note that there may be more than one solutions , this function prints one of the feasable solutions . ; a recursive utility function to solve maze problem ; if ( x , y is goal ) return true ; check if maze [ x ] [ y ] is valid ; check if the current block is already part of solution path . ; mark x , y as part of solution path ; move forward in x direction ; if moving in x direction doesn 't give solution  then move down in y direction ; if moving in y direction doesn 't give solution then  move back in x direction ; if moving in backwards in x direction doesn 't give solution  then move upwards in y direction ; if none of the above movements work then backtrack : unmark x , y as part of solution path ; ",
        "context": "\nN = 4\n\n",
        "code": "def printSolution(sol):\n    for i in sol:\n        for j in i:\n            print(str(j) + \" \", end=\"\")\n        print(\"\")\n\n\ndef isSafe(maze, x, y):\n    if x >= 0 and x = 0 and y < N and maze[x][y] == 1:\n        return True\n    return False\n\n\ndef solveMazeUtil(maze, x, y, sol):\n    if x == N - 1 and y == N - 1 and maze[x][y] == 1:\n        sol[x][y] = 1\n        return True\n    if isSafe(maze, x, y):\n        if sol[x][y] == 1:\n            return False\n        sol[x][y] = 1\n        if solveMazeUtil(maze, x + 1, y, sol):\n            return True\n        if solveMazeUtil(maze, x, y + 1, sol):\n            return True\n        if solveMazeUtil(maze, x - 1, y, sol):\n            return True\n        if solveMazeUtil(maze, x, y - 1, sol):\n            return True\n        sol[x][y] = 0\n        return False\n\n\ndef solveMaze(maze):\n    sol = [[0 for j in range(4)]for i in range(4)]\n    if solveMazeUtil(maze, 0, 0, sol) == False:\n        print(\"Solution doesn't exist\")\n        return False\n    printSolution(sol)\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    maze = [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1]]\n    solveMaze(maze)\n",
        "output": "1 0 0 0 \n1 1 0 0 \n0 1 0 0 \n0 1 1 1 \n",
        "fn_call": "solveMaze"
    },
    {
        "text": "count total set bits in all numbers from range l to r | function that counts the set bits from 0 to n ; to store sum of set bits from 0 - n ; until n >= to 2 ^ i ; this k will get flipped after 2 ^ i iterations ; change is iterator from 2 ^ i to 1 ; this will loop from 0 to n for every bit position ; when change = 1 flip the bit ; again set change to 2 ^ i ; increment the position ; function that counts the set bit in the range ( l , r ) ; return the count ; ",
        "context": "",
        "code": "def countSetBit(n):\n    i = 0\n    ans = 0\n    while ((1 << i) <= n):\n        k = True\n        change = 1 << i\n        for j in range(n + 1):\n            ans += 0 if k else 1\n            if (change == 1):\n                k = False if k else True\n                change = 1 << i\n            else:\n                change -= 1\n        i += 1\n    return ans\n\n\ndef countSetBits(L, R):\n    return abs(countSetBit(R) - countSetBit(L - 1))\n",
        "test": "\nif __name__ == '__main__':\n    L = 3\n    R = 5\n    print(\"Total set bit count is \", countSetBits(L, R))\n",
        "output": "Total set bit count is  5\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "minimum elements to be inserted in array to make adjacent differences equal | function to find gcd of two numbers ; function to calculate minimum numbers to be inserted to make equal differences between two consecutive elements ; check if there is only one element in the array then answer will be 0 ; calculate difference between first and second element of array ; if there is only two elements in the array then gcd of differences of consecutive elements of array will be equal to difference of first and second element of the array ; loop to calculate the gcd of the differences between consecutive elements of the array ; loop to calculate the elements to be inserted ; return the answer ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef minimum_elements(n, arr):\n    if (n < 3):\n        return 0\n    ans = 0\n    diff = arr[1] - arr[0]\n    g = diff\n    for i in range(2, n):\n        diff = arr[i] - arr[i - 1]\n        g = gcd(g, diff)\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        cnt = diff // g\n        ans += (cnt - 1)\n    return ans\n",
        "test": "\narr = [1, 5, 8, 10, 12, 16]\nn = len(arr)\nprint(minimum_elements(n, arr))\n",
        "output": "10\n",
        "fn_call": "minimum_elements"
    },
    {
        "text": "check if two nodes are cousins in a binary tree | a binary tree node ; recursive function to check if two nodes are siblings ; base case ; recursive function to find level of node ' ptr ' in a binary tree ; base case ; return level if node is present in left subtree ; else search in right subtree ; returns 1 if a and b are cousins , otherwise 0 ; 1. the two nodes should be on the same level in the binary tree the two nodes should not be siblings ( means that they should not have the smae parent node ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def isSibling(root, a, b):\n    if root is None:\n        return 0\n    return (\n        (\n            root .left == a and root .right == b) or (\n            root .left == b and root .right == a) or isSibling(\n                root .left,\n                a,\n                b) or isSibling(\n                    root .right,\n                    a,\n            b))\n\n\ndef level(root, ptr, lev):\n    if root is None:\n        return 0\n    if root == ptr:\n        return lev\n    l = level(root .left, ptr, lev + 1)\n    if l != 0:\n        return l\n    return level(root .right, ptr, lev + 1)\n\n\ndef isCousin(root, a, b):\n    if ((level(root, a, 1) == level(root, b, 1))\n            and not (isSibling(root, a, b))):\n        return 1\n    else:\n        return 0\n",
        "test": "\n\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nroot .left .left = Node(4)\nroot .left .right = Node(5)\nroot .left .right .right = Node(15)\nroot .right .left = Node(6)\nroot .right .right = Node(7)\nroot .right .left .right = Node(8)\nnode1 = root .left .right\nnode2 = root .right .right\nprint(\"Yes\")if isCousin(root, node1, node2) == 1 else print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isCousin"
    },
    {
        "text": "count of longest possible subarrays with sum not divisible by k | function to find the count of longest subarrays with sum not divisible by k ; sum of all elements in an array ; if overall sum is not divisible then return 1 , as only one subarray of size n is possible ; index of the first number not divisible by k ; index of the last number not divisible by k ; subarray doesn 't exist ; sum of the window ; calculate the sum of rest of the windows of size len ; ",
        "context": "",
        "code": "def CountLongestSubarrays(arr, n, k):\n    s = 0\n    for i in range(n):\n        s += arr[i]\n    if (s % k):\n        return 1\n    else:\n        ini = 0\n        while (ini < n and arr[ini] % k == 0):\n            ini += 1\n        final = n - 1\n        while (final >= 0 and arr[final] % k == 0):\n            final -= 1\n        sum, count = 0, 0\n        if (ini == n):\n            return -1\n        else:\n            length = max(n - 1 - ini, final)\n        for i in range(length):\n            sum += arr[i]\n        if (sum % k != 0):\n            count += 1\n        for i in range(length, n):\n            sum = sum + arr[i]\n            sum = sum + arr[i - length]\n            if (sum % k != 0):\n                count += 1\n        return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 2, 2, 2, 3]\n    n = len(arr)\n    k = 3\n    print(CountLongestSubarrays(arr, n, k))\n",
        "output": "2\n",
        "fn_call": "CountLongestSubarrays"
    },
    {
        "text": "right | generate all prime numbers less than n . ; initialize all entries of boolean array as true . a value in isprime [ i ] will finally be false if i is not a prime , else true bool isprime [ n + 1 ] ; ; if isprime [ p ] is not changed , then it is a prime ; update all multiples of p ; returns true if n is right - truncatable , else false ; generating primes using sieve ; checking whether the number remains prime when the last ( \" right \" ) digit is successively removed ; ",
        "context": "",
        "code": "def sieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while (p * p <= n):\n        if (isPrime[p]):\n            i = p * 2\n            while (i <= n):\n                isPrime[i] = False\n                i = i + p\n        p = p + 1\n\n\ndef rightTruPrime(n):\n    isPrime = [None] * (n + 1)\n    sieveOfEratosthenes(n, isPrime)\n    while (n != 0):\n        if (isPrime[n]):\n            n = n // 10\n        else:\n            return False\n    return True\n",
        "test": "\nn = 59399\nif (rightTruPrime(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "rightTruPrime"
    },
    {
        "text": "Jump in rank of a student after updating marks | Function to print the name of student who stood first after updation in rank ; Array of students ; Store the name of the student ; Update the marks of the student ; Store the current rank of the student ; Print the name and jump in rank ; Names of the students ; Marks of the students ; Updates that are to be done ; Number of students",
        "context": "",
        "code": "def nameRank(names, marks, updates, n):\n    x = [[0 for j in range(3)]for i in range(n)]\n    for i in range(n):\n        x[i][0] = names[i]\n        x[i][1] = marks[i] + updates[i]\n        x[i][2] = i + 1\n    highest = x[0]\n    for j in range(1, n):\n        if (x[j][1] >= highest[1]):\n            highest = x[j]\n    print(\"Name: \", highest[0], \", Jump: \", abs(highest[2] - 1), sep=\"\")\n",
        "test": "\nnames = [\"sam\", \"ram\", \"geek\"]\nmarks = [80, 79, 75]\nupdates = [0, 5, -9]\nn = len(marks)\nnameRank(names, marks, updates, n)\n",
        "output": "Name: ram, Jump: 1\n",
        "fn_call": "nameRank"
    },
    {
        "text": "how to check if two given sets are disjoint ? | this function prints all distinct elements ; creates an empty hashset ; traverse the first set and store its elements in hash ; traverse the second set and check if any element of it is already in hash or not . ; ",
        "context": "",
        "code": "def areDisjoint(set1, set2, n1, n2):\n    myset = set([])\n    for i in range(n1):\n        myset .add(set1[i])\n    for i in range(n2):\n        if (set2[i] in myset):\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    set1 = [10, 5, 3, 4, 6]\n    set2 = [8, 7, 9, 3]\n    n1 = len(set1)\n    n2 = len(set2)\n    if (areDisjoint(set1, set2, n1, n2)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "areDisjoint"
    },
    {
        "text": "toggle first and last bits of a number | returns a number which has same bit count as n and has only first and last bits as set . ; set all the bit of the number ; adding one to n now unsets all bits and moves msb to one place . now we shift the number by 1 and add 1. ; if number is 1 ; take xor with first and last set bit number ; ",
        "context": "",
        "code": "def takeLandFsetbits(n):\n    n = n | n >> 1\n    n = n | n >> 2\n    n = n | n >> 4\n    n = n | n >> 8\n    n = n | n >> 16\n    return ((n + 1) >> 1) + 1\n\n\ndef toggleFandLbits(n):\n    if (n == 1):\n        return 0\n    return n ^ takeLandFsetbits(n)\n",
        "test": "\nn = 10\nprint(toggleFandLbits(n))\n",
        "output": "3\n",
        "fn_call": "toggleFandLbits"
    },
    {
        "text": "longest common subarray in the given two arrays | function to find the maximum length of equal subarray ; auxiliary dp [ ] [ ] array ; updating the dp [ ] [ ] table in bottom up approach ; if a [ i ] is equal to b [ i ] then dp [ j ] [ i ] = dp [ j + 1 ] [ i + 1 ] + 1 ; find maximum of all the values in dp [ ] [ ] array to get the maximum length ; update the length ; return the maximum length ; ",
        "context": "",
        "code": "def FindMaxLength(A, B):\n    n = len(A)\n    m = len(B)\n    dp = [[0 for i in range(n + 1)]for i in range(m + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if A[i] == B[j]:\n                dp[j][i] = dp[j + 1][i + 1] + 1\n    maxm = 0\n    for i in dp:\n        for j in i:\n            maxm = max(maxm, j)\n    return maxm\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 8, 2, 1]\n    B = [8, 2, 1, 4, 7]\n    print(FindMaxLength(A, B))\n",
        "output": "3\n",
        "fn_call": "FindMaxLength"
    },
    {
        "text": "perfect cube factors of a number | function that returns the count of factors that are perfect cube ; to store the count of number of times a prime number divides n ; to store the count of factors that are perfect cube ; count number of 2 's that divides n ; calculate ans according to above formula ; check for all possible numbers that can divide it ; loop to check the number of times prime number i divides it ; calculate ans according to above formula ;  ; ",
        "context": "",
        "code": "def noofFactors(N):\n    if N == 1:\n        return 1\n    count = 0\n    ans = 1\n    while (N % 2 == 0):\n        count += 1\n        N //= 2\n    ans *= ((count // 3) + 1)\n    i = 3\n    while ((i * i) <= N):\n        count = 0\n        while (N % i == 0):\n            count += 1\n            N //= i\n        ans *= ((count // 3) + 1)\n        i += 2\n    return ans\n",
        "test": "\nN = 216\nprint(noofFactors(N))\n",
        "output": "4\n",
        "fn_call": "noofFactors"
    },
    {
        "text": "deletions of \"01\" or \"10\" in binary string to make it free from \"01\" or \"10\" | function to return the count of deletions of sub - strings \"01\" or \"10\" ; to store the count of 0 s and 1 s ; ",
        "context": "",
        "code": "def substrDeletion(string, length):\n    count0 = 0\n    count1 = 0\n    for i in range(length):\n        if (string[i] == '0'):\n            count0 += 1\n        else:\n            count1 += 1\n    return min(count0, count1)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"010\"\n    length = len(string)\n    print(substrDeletion(string, length))\n",
        "output": "1\n",
        "fn_call": "substrDeletion"
    },
    {
        "text": "generate an array of size n according to the given rules | function to search the most recent location of element n if not present in the array it will return - 1 ; function to generate an array of size n by following the given rules ; loop to fill the array as per the given rules ; check for the occurrence of arr [ i - 1 ] ; ",
        "context": "",
        "code": "def search(a, k, x):\n    for j in range(k - 1, -1, -1):\n        if (a[j] == x):\n            return j\n    return -1\n\n\ndef genArray(arr, N):\n    for i in range(0, N - 1, 1):\n        if (search(arr, i, arr[i]) == -1):\n            arr[i + 1] = 0\n        else:\n            arr[i + 1] = (i - search(arr, i, arr[i]))\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    size = N + 1\n    a = [0] * N\n    genArray(a, N)\n    print(a)\n",
        "output": "[0, 0, 1, 0, 2]\n",
        "fn_call": "genArray"
    },
    {
        "text": "number of digits in a ^ b | python program to calculate no . of digits in a ^ b ; function to calculate number of digits in a ^ b ; ",
        "context": "\nimport math\n\n",
        "code": "def no_of_digit(a, b):\n    return ((int)(b * math .log10(a)) + 1)\n",
        "test": "\na = 2\nb = 100\nprint(\"no of digits = \", no_of_digit(a, b))\n",
        "output": "no of digits =  31\n",
        "fn_call": "no_of_digit"
    },
    {
        "text": "check if given array can be rearranged such that mean is equal to median | function to return true or false if size of array is odd ; to prevent overflow ; if element is greater than mid , then it can only be present in right subarray ; if element is smaller than mid , then it can only be present in left subarray ; else the element is present at the middle then return 1 ; when element is not present in array then return 0 ; function to return true or false if size of array is even ; calculating candidate median ; if candidate median if greater than mean then decrement j ; if candidate median if less than mean then increment i ; if candidate median if equal to mean then return 1 ; when no candidate found for mean ; function to return true if mean can be equal to any candidate median otherwise return false ; calculating mean ; if n is odd ; if n is even ; ",
        "context": "",
        "code": "def binarySearch(arr, size, key):\n    low = 0\n    high = size - 1\n    while (low <= high):\n        mid = low + (high - low) // 2\n        if (key > arr[mid]):\n            low = mid + 1\n        elif (key < arr[mid]):\n            high = mid - 1\n        else:\n            return 1\n    return 0\n\n\ndef twoPointers(arr, N, mean):\n    i = 0\n    j = N - 1\n    while (i < j):\n        temp = (arr[i] + arr[j]) / 2\n        if (temp > mean):\n            j = j - 1\n        elif (temp < mean):\n            i = i + 1\n        else:\n            return 1\n    return 0\n\n\ndef checkArray(arr, N):\n    sum = 0\n    for i in range(0, N):\n        sum += arr[i]\n    mean = sum / N\n    if (N & 1):\n        return binarySearch(arr, N, mean)\n    else:\n        return twoPointers(arr, N, mean)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1.0, 3.0, 6.0, 9.0, 12.0, 32.0]\n    N = len(arr)\n    if (checkArray(arr, N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkArray"
    },
    {
        "text": "minimum length of the subarray required to be replaced to make frequency of array elements equal to n / m | function to find the minimum length of the subarray to be changed . ; stores the frequencies of array elements ; stores the number of array elements that are present more than n / m times ; iterate over the range ; increment the frequency ; if the frequency of all array elements are already n / m ; stores the resultant length of the subarray ; the left and right pointers ; iterate over the range ; if the current element is ; if the value of c is 0 , then find the possible answer ; iterate over the range ; if the element at left is making it extra ; update the left pointer ; update the right pointer ; return the resultant length ; ",
        "context": "",
        "code": "def minimumSubarray(arr, n, m):\n    mapu = [0 for i in range(m + 1)]\n    c = 0\n    for i in range(n):\n        mapu[arr[i]] += 1\n        if (mapu[arr[i]] == (n // m) + 1):\n            c += 1\n    if (c == 0):\n        return 0\n    ans = n\n    l = 0\n    r = 0\n    while (r < n):\n        mapu[arr[r]] -= 1\n        if (mapu[arr[r]] == (n // m)):\n            c -= 1\n        if (c == 0):\n            while (l <= r and c == 0):\n                ans = min(ans, r - l + 1)\n                mapu[arr[l]] += 1\n                if (mapu[arr[l]] > (n // m)):\n                    c += 1\n                l += 1\n        r += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 2, 1, 1, 2]\n    M = 2\n    N = len(arr)\n    print(minimumSubarray(arr, N, M))\n",
        "output": "1\n",
        "fn_call": "minimumSubarray"
    },
    {
        "text": "check if a number is a perfect square having all its digits as a perfect square | python3 program for the above approach ; function to check if digits of n is a perfect square or not ; iterate over the digits ; extract the digit ; check if digit is a perfect square or not ; divide n by 10 ; return true ; function to check if n is a perfect square or not ; if floor and ceil of n is not same ; function to check if n satisfies the required conditions or not ; if both the conditions are satisfied ; ",
        "context": "\nimport math\n\n",
        "code": "def check_digits(N):\n    while (N > 0):\n        n = N % 10\n        if ((n != 0) and (n != 1) and (n != 4) and (n != 9)):\n            return 0\n        N = N // 10\n    return 1\n\n\ndef is_perfect(N):\n    n = math .sqrt(N)\n    if (math .floor(n) != math .ceil(n)):\n        return 0\n    return 1\n\n\ndef isFullSquare(N):\n    if (is_perfect(N) and check_digits(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nN = 144\nisFullSquare(N)\n",
        "output": "Yes\n",
        "fn_call": "isFullSquare"
    },
    {
        "text": "count unordered pairs ( i , j ) such that product of a [ i ] and a [ j ] is power of two | function to check if x is power of 2 ; first x in the below expression is for the case when x is 0 ; function to count unordered pairs ; is a number can be expressed as power of two ; count total number of unordered pairs ; ",
        "context": "",
        "code": "def isPowerOfTwo(x):\n    return (x and (not (x & (x - 1))))\n\n\ndef Count_pairs(a, n):\n    count = 0\n    for i in range(n):\n        if isPowerOfTwo(a[i]):\n            count += 1\n    ans = (count * (count - 1)) / 2\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 5, 8, 16, 128]\n    n = len(a)\n    Count_pairs(a, n)\n",
        "output": "6.0\n",
        "fn_call": "Count_pairs"
    },
    {
        "text": "zuckerman numbers | function to get product of digits ; function to check if n is an zuckerman number ; ",
        "context": "",
        "code": "def getProduct(n):\n    product = 1\n    while (n > 0):\n        product = product * (n % 10)\n        n = n // 10\n    return product\n\n\ndef isZuckerman(n):\n    return n % getProduct(n) == 0\n",
        "test": "\nN = 115\nif (isZuckerman(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isZuckerman"
    },
    {
        "text": "philaland coin | tcs mockvita 2020 | python3 implementation to find the minimum number of denominations required for any number ; function to find the minimum number of denomminations required ; ",
        "context": "\nfrom math import log2, floor\n\n",
        "code": "def findMinDenomin(n):\n    return log2(n) + 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 10\n    print(floor(findMinDenomin(n)))\n",
        "output": "4\n",
        "fn_call": "findMinDenomin"
    },
    {
        "text": "given a sorted and rotated array , find if there is a pair with a given sum | this function returns true if arr [ 0. . n - 1 ] has a pair with sum equals to x . ; find the pivot element ; l is now index of smallest element ; r is now index of largest element ; keep moving either l or r till they meet ; if we find a pair with sum x , we return true ; if current pair sum is less , move to the higher sum ; move to the lower sum side ; ",
        "context": "",
        "code": "def pairInSortedRotated(arr, n, x):\n    for i in range(0, n - 1):\n        if (arr[i] > arr[i + 1]):\n            break\n    l = (i + 1) % n\n    r = i\n    while (l != r):\n        if (arr[l] + arr[r] == x):\n            return True\n        if (arr[l] + arr[r] < x):\n            l = (l + 1) % n\n        else:\n            r = (n + r - 1) % n\n    return False\n",
        "test": "\narr = [11, 15, 6, 8, 9, 10]\nsum = 16\nn = len(arr)\nif (pairInSortedRotated(arr, n, sum)):\n    print(\"Array has two elements with sum 16\")\nelse:\n    print(\"Array doesn't have two elements with sum 16 \")\n",
        "output": "Array has two elements with sum 16\n",
        "fn_call": "pairInSortedRotated"
    },
    {
        "text": "make array elements equal by replacing adjacent elements with their xor | function to check if it is possible to make all the array elements equal using the given operation ; stores the xor of all elements of array a [ ] ; case 1 , check if the xor of the array a [ ] is 0 ; maintains the xor till the current element ; iterate over the array ; if the current xor is equal to the total xor increment the count and initialize current xor as 0 ; print answer ; ",
        "context": "",
        "code": "def possibleEqualArray(A, N):\n    tot_XOR = 0\n    for i in range(N):\n        tot_XOR ^= A[i]\n    if (tot_XOR == 0):\n        print(\"YES\")\n        return\n    cur_XOR = 0\n    cnt = 0\n    for i in range(N):\n        cur_XOR ^= A[i]\n        if (cur_XOR == tot_XOR):\n            cnt += 1\n            cur_XOR = 0\n    if (cnt > 2):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == '__main__':\n    A = [0, 2, 2]\n    N = len(A)\n    possibleEqualArray(A, N)\n",
        "output": "YES\n",
        "fn_call": "possibleEqualArray"
    },
    {
        "text": "minimize replacement of characters to its nearest alphabet to make a string palindromic | function to find the minimum number of operations required to convert th given string into palindrome ; iterate till half of the string ; find the absolute difference between the characters ; adding the minimum difference of the two result ; return the result ; ",
        "context": "",
        "code": "def minOperations(s):\n    length = len(s)\n    result = 0\n    for i in range(length // 2):\n        D1 = (ord(max(s[i], s[length - 1 - i])) -\n              ord(min(s[i], s[length - 1 - i])))\n        D2 = 26 - D1\n        result += min(D1, D2)\n    return result\n",
        "test": "\ns = \"abccdb\"\nprint(minOperations(s))\n",
        "output": "3\n",
        "fn_call": "minOperations"
    },
    {
        "text": "minimize the cost of buying the objects | function that will calculate the price ; calculate the number of items we can get for free ; calculate the number of items we will have to pay the price for ; calculate the price ; ",
        "context": "",
        "code": "def totalPay(totalItems, priceOfOneItem, N, M):\n    freeItems = 0\n    actual = 0\n    freeItems = totalItems // (N + M)\n    actual = totalItems - freeItems\n    amount = actual * priceOfOneItem\n    return amount\n",
        "test": "\nT = 12\nP = 8\nN = 2\nM = 1\nprint(\"Amount = \", totalPay(T, P, N, M))\n",
        "output": "Amount =  64\n",
        "fn_call": "totalPay"
    },
    {
        "text": "print leftmost and rightmost nodes of a binary tree | python3 program to print corner node at each level of binary tree ; a binary tree node has key , pointer to left child and a pointer to right child ; function to print corner node at each level ; if the root is null then simply return ; star node is for keeping track of levels ; pushing root node and star node ; do level order traversal using a single queue ; n denotes the size of the current level in the queue ; if it is leftmost corner value or rightmost corner value then print it ; push the left and right children of the temp node ; ",
        "context": "\nfrom collections import deque\n\n\nclass Node:\n    def __init__(self, key):\n        self .key = key\n        self .left = None\n        self .right = None\n\n",
        "code": "def printCorner(root: Node):\n    if root is None:\n        return\n    q = deque()\n    q .append(root)\n    while q:\n        n = len(q)\n        for i in range(n):\n            temp = q[0]\n            q .popleft()\n            if i == 0 or i == n - 1:\n                print(temp .key, end=\" \")\n            if temp .left:\n                q .append(temp .left)\n            if temp .right:\n                q .append(temp .right)\n",
        "test": "\nif __name__ == \"__main__\":\n    root = Node(15)\n    root .left = Node(10)\n    root .right = Node(20)\n    root .left .left = Node(8)\n    root .left .right = Node(12)\n    root .right .left = Node(16)\n    root .right .right = Node(25)\n    printCorner(root)\n",
        "output": "15 10 20 8 25 ",
        "fn_call": "printCorner"
    },
    {
        "text": "number of subarrays consisting only of pronic numbers | function to check if a number is pronic number or not ; iterate over the range [ 1 , sqrt ( n ) ] ; return true if n is pronic ; otherwise , return false ; function to count the number of subarrays consisting of pronic numbers ; stores the count of subarrays ; stores the number of consecutive array elements which are pronic ; traverse the array ; if i is pronic ; return the total count ; ",
        "context": "",
        "code": "def isPronic(n):\n    for i in range(int(n ** (1 / 2)) + 1):\n        if i * (i + 1) == n:\n            return True\n    return False\n\n\ndef countSub(arr):\n    ans = 0\n    ispro = 0\n    for i in arr:\n        if isPronic(i):\n            ispro += 1\n        else:\n            ispro = 0\n        ans += ispro\n    return ans\n",
        "test": "\narr = [5, 6, 12, 3, 4]\nprint(countSub(arr))\n",
        "output": "3\n",
        "fn_call": "countSub"
    },
    {
        "text": "smallest and largest n | python3 implementation of the approach ; function to print the largest and the smallest n - digit perfect squares ; smallest n - digit perfect square ; largest n - digit perfect square ; ",
        "context": "\nimport math\n\n",
        "code": "def nDigitPerfectSquares(n):\n    print(pow(math .ceil(math .sqrt(pow(10, n - 1))), 2), end=\" \")\n    print(pow(math .ceil(math .sqrt(pow(10, n))) - 1, 2))\n",
        "test": "\nn = 4\nnDigitPerfectSquares(n)\n",
        "output": "1024 9801\n",
        "fn_call": "nDigitPerfectSquares"
    },
    {
        "text": "two player game in which a player can remove all occurrences of a number | python3 implementation for two player game in which a player can remove all occurrences of a number ; function that print whether player1 can wins or loses ; storing the number of occurrence of elements in unordered map ; variable to check if the occurrence of repeated elements is >= 4 and multiple of 2 or not ; count elements which occur more than once ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def game(v, n):\n    m = defaultdict(int)\n    for i in range(n):\n        if (v[i]not in m):\n            m[v[i]] = 1\n        else:\n            m[v[i]] += 1\n    count = 0\n    check = 0\n    for i in m .values():\n        if (i > 1):\n            if (i >= 4 and i % 2 == 0):\n                check += 1\n            count += 1\n    if (check % 2 != 0):\n        flag = False\n    if (check % 2 != 0):\n        print(\"Yes\")\n    elif (n % 2 == 0 and count % 2 == 0):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 2, 2, 3, 3, 5]\n    size = len(arr)\n    game(arr, size)\n",
        "output": "No\n",
        "fn_call": "game"
    },
    {
        "text": "maximum sum subarray after altering the array | python3 implementation of the approach ; function to return the maximum subarray sum ; function to reverse the subarray arr [ 0. . . i ] ; function to return the maximum subarray sum after performing the given operation at most once ; to store the result ; when no operation is performed ; find the maximum subarray sum after reversing the subarray arr [ 0. . . i ] for all possible values of i ; the complete array is reversed so that the subarray can be processed as arr [ 0. . . i ] instead of arr [ i ... n - 1 ] ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxSumSubarray(arr, size):\n    max_so_far = -sys .maxsize - 1\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here = max_ending_here + arr[i]\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        if (max_ending_here < 0):\n            max_ending_here = 0\n    return max_so_far\n\n\ndef getUpdatedArray(arr, copy, i):\n    for j in range((i // 2) + 1):\n        copy[j] = arr[i - j]\n        copy[i - j] = arr[j]\n    return\n\n\ndef maxSum(arr, size):\n    resSum = -sys .maxsize - 1\n    resSum = max(resSum, maxSumSubarray(arr, size))\n    copyArr = []\n    copyArr = arr\n    for i in range(1, size, 1):\n        getUpdatedArray(arr, copyArr, i)\n        resSum = max(resSum, maxSumSubarray(copyArr, size))\n    arr = arr[::-1]\n    copyArr = arr\n    for i in range(1, size, 1):\n        getUpdatedArray(arr, copyArr, i)\n        resSum = max(resSum, maxSumSubarray(copyArr, size))\n    resSum += 6\n    return resSum\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-9, 21, 24, 24, -51, -6, 17, -42, -39, 33]\n    size = len(arr)\n    print(maxSum(arr, size))\n",
        "output": "102\n",
        "fn_call": "maxSum"
    },
    {
        "text": "program to check if n is a heptagonal number | python3 program for the above approach ; function to check if n is a heptagonal number ; condition to check if the number is a heptagonal number ; ",
        "context": "\nimport math\n\n",
        "code": "def isheptagonal(N):\n    n = (3 + math .sqrt(40 * N + 9)) / 10\n    return (n - int(n)) == 0\n",
        "test": "\nN = 7\nif (isheptagonal(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isheptagonal"
    },
    {
        "text": "zigzag ( or diagonal ) traversal of matrix |  ; we will use a 2d vector to store the diagonals of our array the 2d vector will have ( n + m - 1 ) rows that is equal to the number of diagnols ; ",
        "context": "\nR = 5\nC = 5\n\n",
        "code": "def diagonalOrder(arr, n, m):\n    ans = [[]for i in range(n + m - 1)]\n    for i in range(m):\n        for j in range(n):\n            ans[i + j].append(arr[j][i])\n    for i in range(len(ans)):\n        for j in range(len(ans[i])):\n            print(ans[i][j], end=\" \")\n        print()\n",
        "test": "\nn = 5\nm = 4\narr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\n       [13, 14, 15, 16], [17, 18, 19, 20]]\ndiagonalOrder(arr, n, m)\n",
        "output": "1 \n5 2 \n9 6 3 \n13 10 7 4 \n17 14 11 8 \n18 15 12 \n19 16 \n20 \n",
        "fn_call": "diagonalOrder"
    },
    {
        "text": "count of words whose i | return the count of words . ; if word contain single letter , return 1. ; checking for first letter . ; traversing the string and multiplying for combinations . ; if all three letters are same . ; if two letter are distinct . ; if all three letter are distinct . ; checking for last letter . ; ",
        "context": "",
        "code": "def countWords(str, l):\n    count = 1\n    if (l == 1):\n        return count\n    if (str[0] == str[1]):\n        count *= 1\n    else:\n        count *= 2\n    for j in range(1, l - 1):\n        if (str[j] == str[j - 1] and str[j] == str[j + 1]):\n            count *= 1\n        elif (str[j] == str[j - 1] or str[j] == str[j + 1] or str[j - 1] == str[j + 1]):\n            count *= 2\n        else:\n            count *= 3\n    if (str[l - 1] == str[l - 2]):\n        count *= 1\n    else:\n        count *= 2\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"abc\"\n    l = len(str)\n    print(countWords(str, l))\n",
        "output": "12\n",
        "fn_call": "countWords"
    },
    {
        "text": "number of indices pair such that element pair sum from first array is greater than second array | python 3 program to find the number of indices pair such that pair sum from first array is greater than second array ; function to get the number of pairs of indices { i , j } in the given two arrays a and b such that a [ i ] + a [ j ] > b [ i ] + b [ j ] ; intitializing the difference array d ; computing the difference between the elements at every index and storing it in the array d ; sort the array d ; variable to store the total number of pairs that satisfy the given condition ; loop to iterate through the difference array d and find the total number of pairs of indices that follow the given condition ; if the value at the index i is positive , then it remains positive for any pairs with j such that j > i . ; if the value at that index is negative then we need to find the index of the value just greater than - d [ i ] ; ",
        "context": "\nimport bisect\n\n",
        "code": "def getPairs(A, B, n):\n    D = [0] * (n)\n    for i in range(n):\n        D[i] = A[i] - B[i]\n    D .sort()\n    total = 0\n    for i in range(n - 1, -1, -1):\n        if (D[i] > 0):\n            total += n - i - 1\n        else:\n            k = bisect .bisect_right(D, -D[i], 0, len(D))\n            total += n - k\n    return total\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    A = []\n    B = []\n    A .append(4)\n    A .append(8)\n    A .append(2)\n    A .append(6)\n    A .append(2)\n    B .append(4)\n    B .append(5)\n    B .append(4)\n    B .append(1)\n    B .append(3)\n    print(getPairs(A, B, n))\n",
        "output": "7\n",
        "fn_call": "getPairs"
    },
    {
        "text": "maximize ropes of consecutive length possible by connecting given ropes | function to find maximized count of ropes of consecutive length ; stores the maximum count of ropes of consecutive length ; sort the ropes by their length ; traverse the array ; if size of the current rope is less than or equal to current maximum possible size + 1 , update the range to cursize + ropes [ i ] ; if a rope of size ( cursize + 1 ) cannot be obtained ; ",
        "context": "",
        "code": "def maxConsecutiveRopes(ropes, N):\n    curSize = 0\n    ropes = sorted(ropes)\n    for i in range(N):\n        if (ropes[i] <= curSize + 1):\n            curSize = curSize + ropes[i]\n        else:\n            break\n    return curSize\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    ropes = [1, 2, 7, 1, 1]\n    print(maxConsecutiveRopes(ropes, N))\n",
        "output": "5\n",
        "fn_call": "maxConsecutiveRopes"
    },
    {
        "text": "minimum cost to make two strings identical | returns length of lcs for x [ 0. . m - 1 ] , y [ 0. . n - 1 ] ; following steps build l [ m + 1 ] [ n + 1 ] in bottom up fashion . note that l [ i ] [ j ] contains length of lcs of x [ 0. . i - 1 ] and y [ 0. . j - 1 ] ; l [ m ] [ n ] contains length of lcs for x [ 0. . n - 1 ] and y [ 0. . m - 1 ] ; returns cost of making x [ ] and y [ ] identical . costx is cost of removing a character from x [ ] and costy is cost of removing a character from y [ ] ; find lcs of x [ ] and y [ ] ; cost of making two strings identical is sum of following two 1 ) cost of removing extra characters from first string 2 ) cost of removing extra characters from second string ; ",
        "context": "",
        "code": "def lcs(X, Y, m, n):\n    L = [[0 for i in range(n + 1)]for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    return L[m][n]\n\n\ndef findMinCost(X, Y, costX, costY):\n    m = len(X)\n    n = len(Y)\n    len_LCS = lcs(X, Y, m, n)\n    return (costX * (m - len_LCS) + costY * (n - len_LCS))\n",
        "test": "\nX = \"ef\"\nY = \"gh\"\nprint('Minimum Cost to make two strings ', end='')\nprint('identical is = ', findMinCost(X, Y, 10, 20))\n",
        "output": "Minimum Cost to make two strings identical is =  60\n",
        "fn_call": "findMinCost"
    },
    {
        "text": "sum of all the numbers present at given level in pascal 's triangle | function to find sum of numbers at lth level in pascals triangle ; ",
        "context": "",
        "code": "def summ(h):\n    return pow(2, h - 1)\n",
        "test": "\nL = 3\nprint(summ(L))\n",
        "output": "4\n",
        "fn_call": "summ"
    },
    {
        "text": "append digits to the end of duplicate strings to make all strings in an array unique | function to replace duplicate strings by alphanumeric strings to make all strings in the array unique ; store the frequency of strings ; iterate over the array ; for the first occurrence , update the frequency count ; otherwise ; append frequency count to end of the string ; print the modified array ; ",
        "context": "",
        "code": "def replaceDuplicates(names):\n    hash = {}\n    for i in range(0, len(names)):\n        if names[i]not in hash:\n            hash[names[i]] = 1\n        else:\n            count = hash[names[i]]\n            hash[names[i]] += 1\n            names[i] += str(count)\n    for i in range(0, len(names)):\n        print(names[i], end=' ')\n",
        "test": "\nif __name__ == '__main__':\n    str1 = [\"aa\", \"bb\", \"cc\", \"bb\", \"aa\", \"aa\", \"aa\"]\n    replaceDuplicates(str1)\n",
        "output": "aa bb cc bb1 aa1 aa2 aa3 ",
        "fn_call": "replaceDuplicates"
    },
    {
        "text": "check if a binary string can be converted to another by reversing substrings consisting of even number of 1 s | function to check if string a can be transformed to string b by reversing substrings of a having even number of 1 s ; store the size of string a ; store the size of string b ; store the count of 1 s in a and b ; stores cnta for string a and cntb for string b ; traverse the string a ; if current character is 1 ; increment 1 s count ; otherwise , update odd1a or even1a depending whether count1a is odd or even ; traverse the string b ; if current character is 1 ; increment 1 s count ; otherwise , update odd1b or even1b depending whether count1b is odd or even ; if the condition is satisfied ; if true , pryes ; otherwise , prno ; ",
        "context": "",
        "code": "def canTransformStrings(A, B):\n    n1 = len(A)\n    n2 = len(B)\n    count1A = 0\n    count1B = 0\n    odd1A = 0\n    odd1B = 0\n    even1A = 0\n    even1B = 0\n    for i in range(n1):\n        if (A[i] == '1'):\n            count1A += 1\n        else:\n            if ((count1A & 1) == 1):\n                odd1A += 1\n            else:\n                even1A += 1\n    for i in range(n2):\n        if (B[i] == '1'):\n            count1B += 1\n        else:\n            if ((count1B & 1) == 1):\n                odd1B += 1\n            else:\n                even1B += 1\n    if (count1A == count1B and odd1A == odd1B and even1A == even1B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == '__main__':\n    A = \"10011\"\n    B = \"11100\"\n    canTransformStrings(A, B)\n",
        "output": "Yes\n",
        "fn_call": "canTransformStrings"
    },
    {
        "text": "possibility of a word from a given set of characters | python 3 program to check if a query string is present is given set . ; count occurrences of all characters in s . ; check if number of occurrences of every character in q is less than or equal to that in s . ; ",
        "context": "\nMAX_CHAR = 256\n\n",
        "code": "def isPresent(s, q):\n    freq = [0] * MAX_CHAR\n    for i in range(0, len(s)):\n        freq[ord(s[i])] += 1\n    for i in range(0, len(q)):\n        freq[ord(q[i])] -= 1\n        if (freq[ord(q[i])] < 0):\n            return False\n    return True\n",
        "test": "\ns = \"abctd\"\nq = \"cat\"\nif (isPresent(s, q)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPresent"
    },
    {
        "text": "count numbers from 1 to n that have 4 as a digit | python3 program to count numbers having 4 as a digit ; function to count numbers from 1 to n that have 4 as a digit ; base case ; d = number of digits minus one in n . for 328 , d is 2 ; computing count of numbers from 1 to 10 ^ d - 1 , d = 0 a [ 0 ] = 0 d = 1 a [ 1 ] = count of numbers from 0 to 9 = 1 d = 2 a [ 2 ] = count of numbers from 0 to 99 = a [ 1 ] * 9 + 10 = 19 d = 3 a [ 3 ] = count of numbers from 0 to 999 = a [ 2 ] * 19 + 100 = 171 ; computing 10 ^ d ; most significant digit ( msd ) of n , for 328 , msd is 3 which can be obtained using 328 / 100 ; if msd is 4. for example if n = 428 , then count of numbers is sum of following . 1 ) count of numbers from 1 to 399 2 ) count of numbers from 400 to 428 which is 29. ; if msd > 4. for example if n is 728 , then count of numbers is sum of following . 1 ) count of numbers from 1 to 399 and count of numbers from 500 to 699 , i . e . , \" a [ 2 ] \u2581 * \u2581 6\" 2 ) count of numbers from 400 to 499 , i . e . 100 3 ) count of numbers from 700 to 728 , recur for 28 ; if msd < 4. for example if n is 328 , then count of numbers is sum of following . 1 ) count of numbers from 1 to 299 a 2 ) count of numbers from 300 to 328 , recur for 28 ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def countNumbersWith4(n):\n    if (n < 4):\n        return 0\n    d = int(mt .log10(n))\n    a = [1 for i in range(d + 1)]\n    a[0] = 0\n    if len(a) > 1:\n        a[1] = 1\n    for i in range(2, d + 1):\n        a[i] = a[i - 1] * 9 + mt .ceil(pow(10, i - 1))\n    p = mt .ceil(pow(10, d))\n    msd = n // p\n    if (msd == 4):\n        return (msd) * a[d] + (n % p) + 1\n    if (msd > 4):\n        return ((msd - 1) * a[d] + p + countNumbersWith4(n % p))\n    return (msd) * a[d] + countNumbersWith4(n % p)\n",
        "test": "\nn = 328\nprint(\n    \"Count of numbers from 1 to\",\n    n,\n    \"that have 4 as a digit is\",\n    countNumbersWith4(n))\n",
        "output": "Count of numbers from 1 to 328 that have 4 as a digit is 60\n",
        "fn_call": "countNumbersWith4"
    },
    {
        "text": "check if characters of a given string can be rearranged to form a palindrome | python3 implementation to check if characters of a given string can be rearranged to form a palindrome ; function to check whether characters of a string can form a palindrome ; create a count array and initialize all values as 0 ; for each character in input strings , increment count in the corresponding count array ; count odd occurring characters ; return true if odd count is 0 or 1 , ; ",
        "context": "\nNO_OF_CHARS = 256\n\n",
        "code": "def canFormPalindrome(st):\n    count = [0] * (NO_OF_CHARS)\n    for i in range(0, len(st)):\n        count[ord(st[i])] = count[ord(st[i])] + 1\n    odd = 0\n    for i in range(0, NO_OF_CHARS):\n        if (count[i] & 1):\n            odd = odd + 1\n        if (odd > 1):\n            return False\n    return True\n",
        "test": "\nif (canFormPalindrome(\"geeksforgeeks\")):\n    print(\"Yes\")\nelse:\n    print(\"No\")\nif (canFormPalindrome(\"geeksogeeks\")):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\nYes\n",
        "fn_call": "canFormPalindrome"
    },
    {
        "text": "largest even and odd n | function to print the largest n - digit even and odd numbers ; ",
        "context": "",
        "code": "def findNumbers(n):\n    odd = pow(10, n) - 1\n    even = odd - 1\n    print(\"Even = \", even)\n    print(\"Odd = \", odd)\n",
        "test": "\nn = 4\nfindNumbers(n)\n",
        "output": "Even =  9998\nOdd =  9999\n",
        "fn_call": "findNumbers"
    },
    {
        "text": "find any permutation of binary string of given size not present in array | function to find a binary string of n bits that does not occur in the givrn array arr [ ] ; stores the resultant string ; loop to iterate over all the given strings in a diagonal order ; append the complement of element at current index into ans ; return answer ; ",
        "context": "",
        "code": "def findString(arr, N):\n    ans = \"\"\n    for i in range(N):\n        ans += '1'if arr[i][i] == '0'else '0'\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [\"111\", \"011\", \"001\"]\n    N = len(arr)\n    print(findString(arr, N))\n",
        "output": "000\n",
        "fn_call": "findString"
    },
    {
        "text": "search an element in an unsorted array using minimum number of comparisons | function to search an element in minimum number of comparisons ; 1 st comparison ; no termination condition and thus no comparison ; this would be executed at - most n times and therefore at - most n comparisons ; replace arr [ n - 1 ] with its actual element as in original 'arr[]   ; if ' x ' is found before the ' ( n - 1 ) th ' index , then it is present in the array final comparison ; else not present in the array ; ",
        "context": "",
        "code": "def search(arr, n, x):\n    if (arr[n - 1] == x):\n        return \"Found\"\n    backup = arr[n - 1]\n    arr[n - 1] = x\n    i = 0\n    while (i < n):\n        if (arr[i] == x):\n            arr[n - 1] = backup\n            if (i < n - 1):\n                return \"Found\"\n            return \"Not Found\"\n        i = i + 1\n",
        "test": "\narr = [4, 6, 1, 5, 8]\nn = len(arr)\nx = 1\nprint(search(arr, n, x))\n",
        "output": "Found\n",
        "fn_call": "search"
    },
    {
        "text": "check if it is possible to construct an array of size n having sum as s and xor value as x | function to find if any sequence is possible or not . ; since , s is greater than equal to x , and either both are odd or even there always exists a sequence ; only one case possible is s == x or not ; considering the above conditions true , check if xor of s ^ ( s - x ) is x or not ; ",
        "context": "",
        "code": "def findIfPossible(N, S, X):\n    if (S >= X and S % 2 == X % 2):\n        if (N >= 3):\n            return \"Yes\"\n        if (N == 1):\n            if (S == X):\n                return \"Yes\"\n            else:\n                return \"No\"\n        if (N == 2):\n            C = (S - X) // 2\n            A = C\n            B = C\n            A = A + X\n            if (((A ^ B) == X)):\n                return \"Yes\"\n            else:\n                return \"No\"\n    else:\n        return \"No\"\n",
        "test": "\nN = 3\nS = 10\nX = 4\nprint(findIfPossible(N, S, X))\n",
        "output": "Yes\n",
        "fn_call": "findIfPossible"
    },
    {
        "text": "count of non | iterative function to calculate base ^ pow in o ( log y ) ; function to return the count of non palindromic strings ; count of strings using n characters with repetitions allowed ; count of palindromic strings ; count of non - palindromic strings ; ",
        "context": "",
        "code": "def power(base, pwr):\n    res = 1\n    while (pwr > 0):\n        if (pwr & 1):\n            res = res * base\n        base = base * base\n        pwr >>= 1\n    return res\n\n\ndef countNonPalindromicString(n, m):\n    total = power(n, m)\n    palindrome = power(n, m // 2 + m % 2)\n    count = total - palindrome\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    m = 5\n    print(countNonPalindromicString(n, m))\n",
        "output": "216\n",
        "fn_call": "countNonPalindromicString"
    },
    {
        "text": "the biggest possible circle that can be inscribed in a rectangle | function to find the area of the biggest circle ; the length and breadth cannot be negative ; area of the circle ; ",
        "context": "",
        "code": "def circlearea(l, b):\n    if (l < 0 or b < 0):\n        return -1\n    if (l < b):\n        return 3.14 * pow(l // 2, 2)\n    else:\n        return 3.14 * pow(b // 2, 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    l = 4\n    b = 8\n    print(circlearea(l, b))\n",
        "output": "12.56\n",
        "fn_call": "circlearea"
    },
    {
        "text": "converting decimal number lying between 1 to 3999 to roman numerals | function to calculate roman equivalent ; storing roman values of digits from 0 - 9 when placed at different places ; converting to roman ; ",
        "context": "",
        "code": "def intToRoman(num):\n    m = [\"\", \"M\", \"MM\", \"MMM\"]\n    c = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM \"]\n    x = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n    i = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    thousands = m[num // 1000]\n    hundereds = c[(num % 1000) // 100]\n    tens = x[(num % 100) // 10]\n    ones = i[num % 10]\n    ans = (thousands + hundereds + tens + ones)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    number = 3549\n    print(intToRoman(number))\n",
        "output": "MMMDXLIX\n",
        "fn_call": "intToRoman"
    },
    {
        "text": "Sort first k values in ascending order and remaining n | function to sort the array ; Sort first k elements in ascending order ; Sort remaining n - k elements in descending order ; Our arr contains 8 elements",
        "context": "",
        "code": "def printOrder(arr, n, k):\n    a = arr[0:k]\n    a .sort()\n    b = arr[k:n]\n    b .sort()\n    b .reverse()\n    return a + b\n",
        "test": "\narr = [5, 4, 6, 2, 1, 3, 8, 9, -1]\nk = 4\nn = len(arr)\narr = printOrder(arr, n, k)\nfor i in range(n):\n    print(arr[i], end=\" \")\n",
        "output": "2 4 5 6 9 8 3 1 -1 ",
        "fn_call": "printOrder"
    },
    {
        "text": "count of distinct integers belonging to first n terms of at least one of given gps | function to find the count of distinct integers that belong to the first n terms of at least one of them is gp ; stores the integers that occur in gps in a set data - structure ; stores the current integer of the first gp ; iterate first n terms of first gp ; insert the ith term of gp in s ; stores the current integer of the second gp ; iterate first n terms of second gp ; return answer ; ",
        "context": "",
        "code": "def UniqueGeometricTerms(N, a1, r1, a2, r2):\n    S = set()\n    p1 = a1\n    for i in range(N):\n        S .add(p1)\n        p1 = (p1 * r1)\n    p2 = a2\n    for i in range(N):\n        S .add(p2)\n        p2 = (p2 * r2)\n    return len(S)\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    a1 = 3\n    r1 = 2\n    a2 = 2\n    r2 = 3\n    print(UniqueGeometricTerms(N, a1, r1, a2, r2))\n",
        "output": "9\n",
        "fn_call": "UniqueGeometricTerms"
    },
    {
        "text": "count of n | python program for the above approach ; function to find the number of n digit numbers such that at least one digit occurs more than once ; base case ; if repeated is true , then for remaining positions any digit can be placed ; if the current state has already been computed , then return it ; stores the count of number for the current recursive calls ; if n = 1 , 0 can be also placed ; if a digit has occurred for the second time , then set repeated to 1 ; otherwise ; for remaining positions any digit can be placed ; if a digit has occurred for the second time , then set repeated to 1 ; return the resultant count for the current recursive call ; function to count all the n - digit numbers having at least one digit 's occurrence more than once ; function to count all possible number satisfying the given criteria ; ",
        "context": "\ndp = [[[-1 for i in range(2)]for i in range(1 << 10)]for i in range(50)]\n\n",
        "code": "def countOfNumbers(digit, mask, repeated, n):\n    global dp\n    if (digit == n + 1):\n        if (repeated):\n            return 1\n        return 0\n    if (repeated):\n        return pow(10, n - digit + 1)\n    val = dp[digit][mask][repeated]\n    if (val != -1):\n        return val\n    val = 4\n    if (digit == 1):\n        for i in range((0 if (n == 1)else 1), 10):\n            if (mask & (1 << i)):\n                val += countOfNumbers(digit + 1, mask | (1 << i), 1, n)\n        else:\n            val += countOfNumbers(digit + 1, mask | (1 << i), 0, n)\n    else:\n        for i in range(10):\n            if (mask & (1 << i)):\n                val += countOfNumbers(digit + 1, mask | (1 << i), 1, n)\n        else:\n            val += countOfNumbers(digit + 1, mask | (1 << i), 0, n)\n    dp[digit][mask][repeated] = val\n    return dp[digit][mask][repeated]\n\n\ndef countNDigitNumber(N):\n    print(countOfNumbers(1, 0, 0, N))\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    countNDigitNumber(N)\n",
        "output": "9\n",
        "fn_call": "countNDigitNumber"
    },
    {
        "text": "nth term of ruler function series | function to count the number of set bits in the number n ; store the number of setbits ; update the value of n ; update the count ; return the total count ; function to find the nth term of the ruler function series ; store the result ; print the result ; ",
        "context": "",
        "code": "def setBits(n):\n    count = 0\n    while (n > 0):\n        n = n & (n - 1)\n        count += 1\n    return count\n\n\ndef findNthTerm(N):\n    x = setBits(N ^ (N - 1))\n    print(x)\n",
        "test": "\nN = 8\nfindNthTerm(N)\n",
        "output": "4\n",
        "fn_call": "findNthTerm"
    },
    {
        "text": "minimum number of integers required such that each segment contains at least one of them | function to compute minimum number of points which cover all segments ; sort the list of tuples by their second element . ; to store the solution ; iterate over all the segments ; get the start point of next segment ; loop over all those segments whose start point is less than the end point of current segment ; print the possibles values of m ; ",
        "context": "",
        "code": "def minPoints(points):\n    points .sort(key=lambda x: x[1])\n    coordinates = []\n    i = 0\n    while i < n:\n        seg = points[i][1]\n        coordinates .append(seg)\n        p = i + 1\n        if p >= n:\n            break\n        arrived = points[p][0]\n        while seg >= arrived:\n            p += 1\n            if p >= n:\n                break\n            arrived = points[p][0]\n        i = p\n    for point in coordinates:\n        print(point, end=\" \")\n",
        "test": "\nn = 4\nstart = [4, 1, 2, 5]\nend = [7, 3, 5, 6]\npoints = []\nfor i in range(n):\n    tu = (start[i], end[i])\n    points .append(tu)\nminPoints(points)\n",
        "output": "3 6 ",
        "fn_call": "minPoints"
    },
    {
        "text": "count of quadruplets from range [ l , r ] having gcd equal to k | function to return the gcd of a and b ; function to return the count of quadruplets having gcd = k ; count the frequency of every possible gcd value in the range ; to store the required count ; calculate the answer using frequency values ; return the required count ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef countQuadruplets(l, r, k):\n    frequency = [0] * (r + 1)\n    for i in range(l, r + 1):\n        for j in range(l, r + 1):\n            frequency[gcd(i, j)] += 1\n    answer = 0\n    for i in range(l, r + 1):\n        for j in range(l, r + 1):\n            if (gcd(i, j) == k):\n                answer += (frequency[i] * frequency[j])\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    l, r, k = 1, 10, 2\n    print(countQuadruplets(l, r, k))\n",
        "output": "607\n",
        "fn_call": "countQuadruplets"
    },
    {
        "text": "maximum number of unique prime factors | return smallest number having maximum prime factors . ; sieve of eratosthenes method to count number of unique prime factors . ; return maximum element in arr [ ] ; ",
        "context": "",
        "code": "def maxPrimefactorNum(N):\n    arr = [0] * (N + 1)\n    i = 2\n    while (i * i <= N):\n        if (arr[i] > 0):\n            for j in range(2 * i, N + 1, i):\n                arr[j] += 1\n        i += 1\n        arr[i] = 1\n    return max(arr)\n",
        "test": "\nN = 40\nprint(maxPrimefactorNum(N))\n",
        "output": "3\n",
        "fn_call": "maxPrimefactorNum"
    },
    {
        "text": "sort array of strings after sorting each string after removing characters whose frequencies are not a powers of 2 | python3 program for the above approach ; function to check if n is power of 2 or not ; base case ; return true if n is power of 2 ; function to print array of strings in ascending order ; sort strings in ascending order ; print the array ; function to sort the strings after modifying each string according to the given conditions ; store the frequency of each characters of the string ; stores the required array of strings ; traverse the array of strings ; temporary string ; stores frequency of each alphabet of the string ; update frequency of s [ i ] [ j ] ; traverse the map freq ; check if the frequency of i . first is a power of 2 ; update string st ; clear the map ; null string ; sort the string in descending order ; update res ; print the array of strings ; ",
        "context": "\nfrom collections import defaultdict\nimport math\n\n",
        "code": "def isPowerOfTwo(n):\n    if (n == 0):\n        return False\n    return (math .ceil(math .log2(n)) == math .floor(math .log2(n)))\n\n\ndef printArray(res):\n    res .sort()\n    for i in range(len(res)):\n        print(res[i], end=\" \")\n\n\ndef sortedStrings(S, N):\n    freq = defaultdict(int)\n    res = []\n    for i in range(N):\n        st = \"\"\n        for j in range(len(S[i])):\n            freq[S[i][j]] += 1\n        for i in freq:\n            if (isPowerOfTwo(freq[i])):\n                for j in range(freq[i]):\n                    st += i\n        freq .clear()\n        if (len(st) == 0):\n            continue\n        st = list(st)\n        st .sort(reverse=True)\n        st = ''.join(st)\n        res .append(st)\n    printArray(res)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"aaacbb\", \"geeks\", \"aaa\"]\n    N = len(arr)\n    sortedStrings(arr, N)\n",
        "output": "cbb skgee ",
        "fn_call": "sortedStrings"
    },
    {
        "text": "minimum time required to reach a given score | function to calculate minimum time required to achieve given score target ; store the frequency of elements ; traverse the array p [ ] ; update the frequency ; stores the minimim time required ; store the current score at any time instant t ; iterate until sum is at least equal to target ; increment time with every iteration ; traverse the map ; increment the points ; prthe time required ; ",
        "context": "",
        "code": "def findMinimumTime(p, n, target):\n    um = {}\n    for i in range(n):\n        um[p[i]] = um .get(p[i], 0) + 1\n    time = 0\n    sum = 0\n    while (sum < target):\n        sum = 0\n        time += 1\n        for it in um:\n            sum += um[it] * (time // it)\n    print(time)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 3, 4]\n    N = len(arr)\n    target = 10\n    findMinimumTime(arr, N, target)\n",
        "output": "6\n",
        "fn_call": "findMinimumTime"
    },
    {
        "text": "group consecutive characters of same type in a string | function to return the modified string ; store original string ; remove all white spaces ; to store the resultant string ; traverse the string ; group upper case characters ; group numeric characters ; group arithmetic operators ; return the resultant string ; ",
        "context": "",
        "code": "def groupCharacters(s, l):\n    temp = \"\"\n    for i in range(l):\n        if (s[i] != ' '):\n            temp = temp + s[i]\n    l = len(temp)\n    ans = \"\"\n    i = 0\n    while (i < l):\n        if (ord(temp[i]) >= ord('A') and ord(temp[i]) <= ord('Z')):\n            while (\n                i < l and ord(\n                    temp[i]) >= ord('A') and ord(\n                    temp[i]) <= ord('Z')):\n                ans = ans + temp[i]\n                i += 1\n            ans = ans + \" \"\n        elif (ord(temp[i]) >= ord('0') and ord(temp[i]) <= ord('9')):\n            while (\n                i < l and ord(\n                    temp[i]) >= ord('0') and ord(\n                    temp[i]) <= ord('9')):\n                ans = ans + temp[i]\n                i += 1\n            ans = ans + \" \"\n        else:\n            while (i = ord(\n                    '*') and ord(temp[i]) <= ord('/')):\n                ans = ans + temp[i]\n                i += 1\n            ans = ans + \" \"\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"34FTG234+ +- *\"\n    l = len(s)\n    print(groupCharacters(s, l))\n",
        "output": "34 FTG 234 ++-* \n",
        "fn_call": "groupCharacters"
    },
    {
        "text": "nonagonal number | function to find nth nonagonal number . ; formula to find nth nonagonal number . ; ",
        "context": "",
        "code": "def Nonagonal(n):\n    return int(n * (7 * n - 5) / 2)\n",
        "test": "\nn = 10\nprint(Nonagonal(n))\n",
        "output": "325\n",
        "fn_call": "Nonagonal"
    },
    {
        "text": "check if a n base number is even or odd | to return value of a char . ; function to convert a number from n base to decimal ; power of base ; decimal equivalent is str [ len - 1 ] * 1 + str [ len - 1 ] * base + str [ len - 1 ] * ( base ^ 2 ) + ... ; a digit in input number must be less than number 's base ; returns true if n is even , else odd ; ",
        "context": "",
        "code": "def val(c):\n    if (ord(c) >= ord('0') and ord(c) <= ord('9')):\n        return ord(c) - ord('0')\n    else:\n        return ord(c) - ord('A') + 10\n\n\ndef toDeci(str, base):\n    Len = len(str)\n    power = 1\n    num = 0\n    for i in range(Len - 1, -1, -1):\n        if (val(str[i]) >= base):\n            print(\"Invalid Number\")\n            return -1\n        num += val(str[i]) * power\n        power = power * base\n    return num\n\n\ndef isEven(num, N):\n    deci = toDeci(num, N)\n    return (deci % 2 == 0)\n",
        "test": "\nif __name__ == '__main__':\n    num = \"11A\"\n    N = 16\n    if (isEven(num, N)):\n        print(\"Even\")\n    else:\n        print(\"Odd\")\n",
        "output": "Even\n",
        "fn_call": "isEven"
    },
    {
        "text": "replace every element in a circular array by sum of next k elements | function to print required resultant array ; reverse the array ; traverse the range ; store prefix sum ; find the prefix sum ; store the answer ; calculate the answers ; count of remaining elements ; add the sum of all elements y times ; add the remaining elements ; update ans [ i ] ; if array is reversed print ans in reverse ; ",
        "context": "",
        "code": "def sumOfKElements(arr, n, k):\n    rev = False\n    if (k < 0):\n        rev = True\n        k *= -1\n        l = 0\n        r = n - 1\n        while (l < r):\n            tmp = arr[l]\n            arr[l] = arr[r]\n            arr[r] = tmp\n            l += 1\n            r -= 1\n    dp = [0] * n\n    dp[0] = arr[0]\n    for i in range(1, n):\n        dp[i] += dp[i - 1] + arr[i]\n    ans = [0] * n\n    for i in range(n):\n        if (i + k < n):\n            ans[i] = dp[i + k] - dp[i]\n        else:\n            x = k - (n - 1 - i)\n            y = x // n\n            rem = x % n\n            ans[i] = (dp[n - 1] - dp[i] + y * dp[n - 1] +\n                      (dp[rem - 1]if rem - 1 >= 0 else 0))\n    if (rev):\n        for i in range(n - 1, -1, -1):\n            print(ans[i], end=\" \")\n    else:\n        for i in range(n):\n            print(ans[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 2, -5, 11]\n    N = len(arr)\n    K = 3\n    sumOfKElements(arr, N, K)\n",
        "output": "8 10 17 1 ",
        "fn_call": "sumOfKElements"
    },
    {
        "text": "minimize count of array elements to be removed such that at least k elements are equal to their index values | function to minimize the removals of array elements such that atleast k elements are equal to their indices ; store the array as 1 - based indexing copy of first array ; make a dp - table of ( n * n ) size ; delete the current element ; take the current element ; check for the minimum removals ; ",
        "context": "",
        "code": "def MinimumRemovals(a, N, K):\n    b = [0 for i in range(N + 1)]\n    for i in range(N):\n        b[i + 1] = a[i]\n    dp = [[0 for i in range(N + 1)]for j in range(N + 1)]\n    for i in range(N):\n        for j in range(i + 1):\n            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n            dp[i + 1][j + 1] = max(dp[i + 1][j + 1],\n                                   dp[i][j] + (1 if (b[i + 1] == j + 1)else 0))\n    j = N\n    while (j >= 0):\n        if (dp[N][j] >= K):\n            return (N - j)\n        j -= 1\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 1, 3, 2, 3]\n    K = 2\n    N = len(arr)\n    print(MinimumRemovals(arr, N, K))\n",
        "output": "2\n",
        "fn_call": "MinimumRemovals"
    },
    {
        "text": "bitwise xor of bitwise and of all pairs from two given arrays | function to find the bitwise xor of bitwise and of all pairs from the arrays arr1 [ ] and arr2 [ ] ; stores the result ; iterate over the range [ 0 , n - 1 ] ; iterate over the range [ 0 , m - 1 ] ; stores bitwise and of the pair { arr1 [ i ] , arr2 [ j ] } ; update res ; return the res ; ",
        "context": "",
        "code": "def findXORS(arr1, arr2, N, M):\n    res = 0\n    for i in range(N):\n        for j in range(M):\n            temp = arr1[i] & arr2[j]\n            res ^= temp\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr1 = [1, 2, 3]\n    arr2 = [6, 5]\n    N = len(arr1)\n    M = len(arr2)\n    print(findXORS(arr1, arr2, N, M))\n",
        "output": "0\n",
        "fn_call": "findXORS"
    },
    {
        "text": "maximize array sum after k negations | set 1 | function to calculate sum of the array ; iterate from 0 to n - 1 ; function to maximize sum ; iterate from 0 to n - 1 ; ",
        "context": "",
        "code": "def sumArray(arr, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    return sum\n\n\ndef maximizeSum(arr, n, k):\n    arr .sort()\n    i = 0\n    for i in range(n):\n        if (k and arr[i] < 0):\n            arr[i] *= -1\n            k -= 1\n            continue\n        break\n    if (i == n):\n        i -= 1\n    if (k == 0 or k % 2 == 0):\n        return sumArray(arr, n)\n    if (i != 0 and abs(arr[i]) >= abs(arr[i - 1])):\n        i -= 1\n    arr[i] *= -1\n    return sumArray(arr, n)\n",
        "test": "\nn = 5\nk = 4\narr = [-3, -2, -1, 5, 6]\nprint(maximizeSum(arr, n, k))\n",
        "output": "15\n",
        "fn_call": "maximizeSum"
    },
    {
        "text": "check if there is a cycle with odd weight sum in an undirected graph | this function returns true if the current subpart of the forest is two colorable , else false . ; assign first color to source ; create a queue ( fifo ) of vertex numbers and enqueue source vertex for bfs traversal ; run while there are vertices in queue ( similar to bfs ) ; find all non - colored adjacent vertices ; an edge from u to v exists and destination v is not colored ; assign alternate color to this adjacent v of u ; an edge from u to v exists and destination v is colored with same color as u ; this function returns true if graph g [ v ] [ v ] is two colorable , else false ; create a color array to store colors assigned to all veritces . vertex number is used as index in this array . the value ' - 1' of colorarr [ i ] is used to indicate that no color is assigned to vertex ' i ' . the value 1 is used to indicate first color is assigned and value 0 indicates second color is assigned . ; as we are dealing with graph , the input might come as a forest , thus start coloring from a node and if true is returned we 'll know that   we successfully colored the subpart of our   forest and we start coloring again from a new   uncolored node. this way we cover the entire forest.  ; returns false if an odd cycle is present else true int info [ ] [ ] is the information about our graph int n is the number of nodes int m is the number of informations given to us ; declaring adjacency list of a graph here at max , we can encounter all the edges with even weight thus there will be 1 pseudo node for each edge ; for odd weight edges , we directly add it in our graph ; for even weight edges , we break it ; entering a pseudo node between u -- - v ; keeping a record of number of pseudo nodes inserted ; making a new pseudo node for next time ; we pass number graph g [ ] [ ] and total number of node = actual number of nodes + number of pseudo nodes added . ; ",
        "context": "",
        "code": "def twoColorUtil(G, src, N, colorArr):\n    colorArr[src] = 1\n    q = [src]\n    while len(q) > 0:\n        u = q .pop(0)\n        for v in range(0, len(G[u])):\n            if colorArr[G[u][v]] == -1:\n                colorArr[G[u][v]] = 1 - colorArr[u]\n                q .append(G[u][v])\n            elif colorArr[G[u][v]] == colorArr[u]:\n                return False\n    return True\n\n\ndef twoColor(G, N):\n    colorArr = [-1] * N\n    for i in range(N):\n        if colorArr[i] == -1:\n            if twoColorUtil(G, i, N, colorArr) == False:\n                return False\n            return True\n\n\ndef isOddSum(info, n, m):\n    G = [[]for i in range(2 * n)]\n    pseudo, pseudo_count = n + 1, 0\n    for i in range(0, m):\n        if info[i][2] % 2 == 1:\n            u, v = info[i][0], info[i][1]\n            G[u].append(v)\n            G[v].append(u)\n        else:\n            u, v = info[i][0], info[i][1]\n            G[u].append(pseudo)\n            G[pseudo].append(u)\n            G[v].append(pseudo)\n            G[pseudo].append(v)\n            pseudo_count += 1\n            pseudo += 1\n    return twoColor(G, n + pseudo_count)\n",
        "test": "\nif __name__ == \"__main__\":\n    n, m = 4, 3\n    info = [[1, 2, 12], [2, 3, 1], [4, 3, 1], [4, 1, 20]]\n    if isOddSum(info, n, m):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n",
        "output": "No\n",
        "fn_call": "isOddSum"
    },
    {
        "text": "find two numbers from their sum and or | python 3 program for the above approach ; function to find the two integers from the given sum and bitwise or value ; check if z is non negative ; iterate through all the bits ; find the kth bit of a & b ; find the kth bit of a | b ; if bit1 = 1 and bit2 = 0 , then there will be no possible pairs ; print the possible pairs ; ",
        "context": "\nMaxBit = 32\n\n",
        "code": "def possiblePair(X, Y):\n    Z = Y - X\n    if (Z < 0):\n        print(\"-1\")\n        return 0\n    for k in range(MaxBit):\n        bit1 = (Z >> k) & 1\n        bit2 = (Z >> k) & 1\n        if (bit1 == 1 and bit2 == 0):\n            print(\"-1\")\n            return 0\n    print(Z, X)\n    return 0\n",
        "test": "\nif __name__ == '__main__':\n    X = 7\n    Y = 11\n    possiblePair(X, Y)\n",
        "output": "4 7\n",
        "fn_call": "possiblePair"
    },
    {
        "text": "count distinct elements in every window of size k | simple python3 program to count distinct elements in every window of size k ; counts distinct elements in window of size k ; traverse the window ; check if element arr [ i ] exists in arr [ 0. . i - 1 ] ; counts distinct elements in all windows of size k ; traverse through every window ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def countWindowDistinct(win, k):\n    dist_count = 0\n    for i in range(k):\n        j = 0\n        while j < i:\n            if (win[i] == win[j]):\n                break\n            else:\n                j += 1\n        if (j == i):\n            dist_count += 1\n    return dist_count\n\n\ndef countDistinct(arr, n, k):\n    for i in range(n - k + 1):\n        print(countWindowDistinct(arr[i:k + i], k))\n",
        "test": "\narr = [1, 2, 1, 3, 4, 2, 3]\nk = 4\nn = len(arr)\ncountDistinct(arr, n, k)\n",
        "output": "3\n4\n4\n3\n",
        "fn_call": "countDistinct"
    },
    {
        "text": "number of chocolates left after k iterations | function to find the chocolates left ; ",
        "context": "",
        "code": "def results(n, k):\n    return round(pow(n, (1.0 / pow(2, k))))\n",
        "test": "\nk = 3\nn = 100000000\nprint(\"Chocolates left after\"),\nprint(k),\nprint(\"iterations are\"),\nprint(int(results(n, k)))\n",
        "output": "Chocolates left after\n3\niterations are\n10\n",
        "fn_call": "results"
    },
    {
        "text": "count rotations required to sort given array in non | function to count minimum anti - clockwise rotations required to sort the array in non - increasing order ; stores count of arr [ i + 1 ] > arr [ i ] ; store last index of arr [ i + 1 ] > arr [ i ] ; traverse the given array ; if the adjacent elements are in increasing order ; increment count ; update index ; prthe result according to the following conditions ; otherwise , it is not possible to sort the array ; ",
        "context": "",
        "code": "def minMovesToSort(arr, N):\n    count = 0\n    index = 0\n    for i in range(N - 1):\n        if (arr[i] < arr[i + 1]):\n            count += 1\n            index = i\n    if (count == 0):\n        print(\"0\")\n    elif (count == N - 1):\n        print(N - 1)\n    elif (count == 1 and arr[0] <= arr[N - 1]):\n        print(index + 1)\n    else:\n        print(\"-1\")\n",
        "test": "\narr = [2, 1, 5, 4, 2]\nN = len(arr)\nminMovesToSort(arr, N)\n",
        "output": "2\n",
        "fn_call": "minMovesToSort"
    },
    {
        "text": "print all palindromic paths from top left to bottom right in a matrix | python 3 program to print all palindromic paths from top left to bottom right in a grid . ; i and j are row and column indexes of current cell ( initially these are 0 and 0 ) . ; if we have not reached bottom right corner , keep exlporing ; if we reach bottom right corner , we check if the path used is palindrome or not . ; ",
        "context": "",
        "code": "def isPalin(str):\n    l = len(str) // 2\n    for i in range(l):\n        if (str[i] != str[len(str) - i - 1]):\n            return False\n    return True\n\n\ndef palindromicPath(str, a, i, j, m, n):\n    if (j < m - 1 or i < n - 1):\n        if (i < n - 1):\n            palindromicPath(str + a[i][j], a, i + 1, j, m, n)\n        if (j < m - 1):\n            palindromicPath(str + a[i][j], a, i, j + 1, m, n)\n    else:\n        str = str + a[n - 1][m - 1]\n        if isPalin(str):\n            print(str)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [['a', 'a', 'a', 'b'], ['b', 'a', 'a', 'a'], ['a', 'b', 'b', 'a']]\n    str = \"\"\n    palindromicPath(str, arr, 0, 0, 4, 3)\n",
        "output": "abaaba\naaaaaa\naaaaaa\n",
        "fn_call": "palindromicPath"
    },
    {
        "text": "program to toggle k | function to toggle the kth bit of n ; ",
        "context": "",
        "code": "def toggleBit(n, k):\n    return (n ^ (1 << (k - 1)))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    k = 2\n    print(toggleBit(n, k))\n",
        "output": "7\n",
        "fn_call": "toggleBit"
    },
    {
        "text": "generate a circular permutation with number of mismatching bits between pairs of adjacent elements exactly 1 | function to find the permutation of integers from a given range such that number of mismatching bits between pairs of adjacent elements is 1 ; initialize an arraylist to store the resultant permutation ; store the index of rotation ; iterate over the range [ 0 , n - 1 ] ; traverse all the array elements up to ( 2 ^ k ) - th index in reverse ; if current element is s ; check if s is zero ; rotate the array by index value to the left ; ",
        "context": "",
        "code": "def circularPermutation(n, start):\n    res = [0]\n    ret = []\n    index, add = -1, 1\n    for k in range(n):\n        add = 1 << k\n        for i in range(len(res) - 1, -1, -1):\n            if (res[i] + add == start):\n                index = len(res)\n            res .append(res[i] + add)\n        add = 1 << k\n    if (start == 0):\n        return res\n    while (len(ret) < len(res)):\n        ret .append(res[index])\n        index = (index + 1) % len(res)\n    return ret\n",
        "test": "\nif __name__ == '__main__':\n    N, S = 2, 3\n    print(circularPermutation(N, S))\n",
        "output": "[3, 2, 0, 1]\n",
        "fn_call": "circularPermutation"
    },
    {
        "text": "count ways to select k array elements lying in a given range | function to calculate factorial of all the numbers up to n ; factorial of 0 is 1 ; calculate factorial of all the numbers upto n ; calculate factorial of i ; function to find count of ways to select at least k elements whose values in range [ l , r ] ; stores count of ways to select at leas k elements whose values in range [ l , r ] ; stores count of numbers having value lies in the range [ l , r ] ; traverse the array ; check if the array elements lie in the given range ; update cntnum ; stores factorial of numbers upto n ; calculate total ways to select at least k elements whose values lies in [ l , r ] ; update cntways ; ",
        "context": "",
        "code": "def calculateFactorial(N):\n    fact = [0] * (N + 1)\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i\n    return fact\n\n\ndef cntWaysSelection(arr, N, K, L, R):\n    cntWays = 0\n    cntNum = 0\n    for i in range(0, N):\n        if (arr[i] >= L and arr[i] <= R):\n            cntNum += 1\n    fact = list(calculateFactorial(cntNum))\n    for i in range(K, cntNum + 1):\n        cntWays += fact[cntNum] // (fact[i] * fact[cntNum - i])\n    return cntWays\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [12, 4, 6, 13, 5, 10]\n    N = len(arr)\n    K = 3\n    L = 4\n    R = 10\n    print(cntWaysSelection(arr, N, K, L, R))\n",
        "output": "5\n",
        "fn_call": "cntWaysSelection"
    },
    {
        "text": "largest factor of a given number which is a perfect square | python 3 program to find the largest factor of a number which is also a perfect square ; function to find the largest factor of a given number which is a perfect square ; initialise the answer to 1 ; finding the prime factors till sqrt ( num ) ; frequency of the prime factor in the factorisation initialised to 0 ; if the frequency is odd then multiply i frequency - 1 times to the answer ; else if it is even , multiply it frequency times ; ",
        "context": "\nimport math\n\n",
        "code": "def largestSquareFactor(num):\n    answer = 1\n    for i in range(2, int(math .sqrt(num))):\n        cnt = 0\n        j = i\n        while (num % j == 0):\n            cnt += 1\n            j *= i\n        if (cnt & 1):\n            cnt -= 1\n            answer *= pow(i, cnt)\n        else:\n            answer *= pow(i, cnt)\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 420\n    print(largestSquareFactor(N))\n",
        "output": "4\n",
        "fn_call": "largestSquareFactor"
    },
    {
        "text": "longest geometric progression | returns length of the longest gp subset of sett [ ] ; base cases ; let us sort the sett first ; an entry l [ i ] [ j ] in this table stores llgp with sett [ i ] and sett [ j ] as first two elements of gp and j > i . ; initialize result ( a single element is always a gp ) ; initialize values of last column ; consider every element as second element of gp ; search for i and k for j ; two cases when i , j and k don 't form  a gp. ; i , j and k form gp , llgp with i and j as first two elements is equal to llgp with j and k as first two elements plus 1. l [ j ] [ k ] must have been filled before as we run the loop from right side ; update overall llgp ; change i and k to fill more l [ i ] [ j ] values for current j ; if the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of sett [ j ] by sett [ i ] ; return result ; ",
        "context": "",
        "code": "def lenOfLongestGP(sett, n):\n    if n < 2:\n        return n\n    if n == 2:\n        return 2 if (sett[1] % sett[0] == 0)else 1\n    sett .sort()\n    L = [[0 for i in range(n)]for i in range(n)]\n    llgp = 1\n    for i in range(0, n - 1):\n        if sett[n - 1] % sett[i] == 0:\n            L[i][n - 1] = 2\n            if 2 > llgp:\n                llgp = 2\n        else:\n            L[i][n - 1] = 1\n    L[n - 1][n - 1] = 1\n    for j in range(n - 2, 0, -1):\n        i = j - 1\n        k = j + 1\n        while i >= 0 and k <= n - 1:\n            if sett[i] * sett[k] < sett[j] * sett[j]:\n                k += 1\n            elif sett[i] * sett[k] > sett[j] * sett[j]:\n                if sett[j] % sett[i] == 0:\n                    L[i][j] = 2\n                else:\n                    L[i][j] = 1\n                i -= 1\n            else:\n                if sett[j] % sett[i] == 0:\n                    L[i][j] = L[j][k] + 1\n                    if L[i][j] > llgp:\n                        llgp = L[i][j]\n                else:\n                    L[i][j] = 1\n                i -= 1\n                k += 1\n        while i >= 0:\n            if sett[j] % sett[i] == 0:\n                L[i][j] = 2\n            else:\n                L[i][j] = 1\n            i -= 1\n    return llgp\n",
        "test": "\nif __name__ == '__main__':\n    set1 = [1, 3, 9, 27, 81, 243]\n    n1 = len(set1)\n    print(lenOfLongestGP(set1, n1))\n    set2 = [1, 3, 4, 9, 7, 27]\n    n2 = len(set2)\n    print(lenOfLongestGP(set2, n2))\n    set3 = [2, 3, 5, 7, 11, 13]\n    n3 = len(set3)\n    print(lenOfLongestGP(set3, n3))\n",
        "output": "6\n4\n1\n",
        "fn_call": "lenOfLongestGP"
    },
    {
        "text": "central binomial coefficient | function to find the value of nth central binomial coefficient ; calculate value of binomial coefficient in bottom up manner ; base cases ; calculate value using previously stored values ; ",
        "context": "",
        "code": "def binomialCoeff(n, k):\n    C = [[0 for j in range(k + 1)]for i in range(n + 1)]\n    i = 0\n    j = 0\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0 or j == i:\n                C[i][j] = 1\n            else:\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j])\n    return C[n][k]\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    k = n\n    n = 2 * n\n    print(binomialCoeff(n, k))\n",
        "output": "20\n",
        "fn_call": "binomialCoeff"
    },
    {
        "text": "program to evaluate simple expressions | a utility function to check if a given character is operand ; utility function to find value of and operand ; this function evaluates simple expressions . it returns - 1 if the given expression is invalid . ; base case : given expression is empty ; the first character must be an operand , find its value ; traverse the remaining characters in pairs ; the next character must be an operator , and next to next an operand ; if next to next character is not an operand ; update result according to the operator ; if not a valid operator ; ",
        "context": "",
        "code": "def isOperand(c):\n    return (c >= '0' and c <= '9')\n\n\ndef value(c):\n    return ord(c) - ord('0')\n\n\ndef evaluate(exp):\n    len1 = len(exp)\n    if (len1 == 0):\n        return -1\n    res = value(exp[0])\n    for i in range(1, len1, 2):\n        opr = exp[i]\n        opd = exp[i + 1]\n        if (isOperand(opd) == False):\n            return -1\n        if (opr == '+'):\n            res += value(opd)\n        elif (opr == '-'):\n            res -= int(value(opd))\n        elif (opr == '*'):\n            res *= int(value(opd))\n        elif (opr == '/'):\n            res /= int(value(opd))\n        else:\n            return -1\n    return res\n",
        "test": "\nexpr1 = \"1+2*5+3\"\nres = evaluate(expr1)\nprint(\n    expr1,\n    \"is Invalid\")if (\n        res == -\n        1)else print(\n            \"Value of\",\n            expr1,\n            \"is\",\n    res)\nexpr2 = \"1+2*3\"\nres = evaluate(expr2)\nprint(\n    expr2,\n    \"is Invalid\")if (\n        res == -\n        1)else print(\n            \"Value of\",\n            expr2,\n            \"is\",\n    res)\nexpr3 = \"4-2+6*3\"\nres = evaluate(expr3)\nprint(\n    expr3,\n    \"is Invalid\")if (\n        res == -\n        1)else print(\n            \"Value of\",\n            expr3,\n            \"is\",\n    res)\nexpr4 = \"1++2\"\nres = evaluate(expr4)\nprint(\n    expr4,\n    \"is Invalid\")if (\n        res == -\n        1)else print(\n            \"Value of\",\n            expr4,\n            \"is\",\n    res)\n",
        "output": "Value of 1+2*5+3 is 18\nValue of 1+2*3 is 9\nValue of 4-2+6*3 is 24\n1++2 is Invalid\n",
        "fn_call": "evaluate"
    },
    {
        "text": "maximum sum after rearranging the array for k queries | function to find maximum sum after rearranging array elements ; auxiliary array to find the count of each selected elements initialize with 0 ; finding count of every element to be selected ; making it to 0 - indexing ; prefix sum array concept is used to obtain the count array ; iterating over the count array to get the final array ; variable to store the maximum sum ; sorting both the arrays ; loop to find the maximum sum ; ",
        "context": "",
        "code": "def maxSumArrangement(A, R, N, M):\n    count = [0 for i in range(N)]\n    for i in range(M):\n        l = R[i][0]\n        r = R[i][1] + 1\n        l = l - 1\n        r = r - 1\n        count[l] = count[l] + 1\n        if (r < N):\n            count[r] = count[r] - 1\n    for i in range(1, N):\n        count[i] = count[i] + count[i - 1]\n    ans = 0\n    count .sort()\n    A .sort()\n    for i in range(N - 1, -1, -1):\n        ans = ans + A[i] * count[i]\n    return ans\n",
        "test": "\nA = [2, 6, 10, 1, 5, 6]\nR = [[1, 3], [4, 6], [3, 4]]\nN = len(A)\nM = len(R)\nprint(maxSumArrangement(A, R, N, M))\n",
        "output": "46\n",
        "fn_call": "maxSumArrangement"
    },
    {
        "text": "min operations to reduce n to 1 by multiplying by a or dividing by b | function to check if it is possible to convert a number n to 1 by a minimum use of the two operations ; for the case b % a != 0 ; check if n equal to 1 ; check if n is not divisible by b ; initialize a variable c ; loop until n is divisible by b ; count number of divisions ; loop until n is divisible by c ; count number of operations ; check if n is reduced to 1 ; count steps ; return the total number of steps ; ",
        "context": "",
        "code": "def FindIfPossible(n, a, b):\n    if (b % a) != 0:\n        if n == 1:\n            return 0\n        elif (n % b) != 0:\n            return -1\n        else:\n            return int(n / b)\n    c = b / a\n    x = 0\n    y = 0\n    while (n % b == 0):\n        n /= b\n        x += 1\n    while (n % c == 0):\n        n /= c\n        y += 1\n    if n == 1:\n        total_steps = x + 2 * y\n        return total_steps\n    else:\n        return -1\n",
        "test": "\nn = 48\na = 3\nb = 12\nprint(FindIfPossible(n, a, b))\n",
        "output": "3\n",
        "fn_call": "FindIfPossible"
    },
    {
        "text": "check if a number can be expressed as a ^ b | set 2 | python 3 program to check if a number can be expressed as a ^ b ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def isPower(a):\n    if a == 1:\n        return True\n    for i in range(2, int(sqrt(a)) + 1):\n        val = log(a) / log(i)\n        if (round((val - int(val)), 8) < 0.00000001):\n            return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 16\n    if isPower(n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPower"
    },
    {
        "text": "program to find the count of coins of each type from the given ratio | function to calculate coin . ; converting each of them in rupees . as we are given totalrupees = 1800 ; ",
        "context": "",
        "code": "def coin(totalRupees, X, Y, Z):\n    one = X * 1\n    fifty = ((Y * 1) / 2.0)\n    twentyfive = ((Z * 1) / 4.0)\n    total = one + fifty + twentyfive\n    result = ((totalRupees) / total)\n    return int(result)\n",
        "test": "\nif __name__ == '__main__':\n    totalRupees = 1800\n    X, Y, Z = 1, 2, 4\n    Rupees = coin(totalRupees, X, Y, Z)\n    print(\"1 rupess coins = \", Rupees * 1)\n    print(\"50 paisa coins = \", Rupees * 2)\n    print(\"25 paisa coins = \", Rupees * 4)\n",
        "output": "1 rupess coins =  600\n50 paisa coins =  1200\n25 paisa coins =  2400\n",
        "fn_call": "coin"
    },
    {
        "text": "sum of array elements whose count of set bits are unique | function to count the number of set bits in an integer n ; stores the count of set bits ; iterate until n is non - zero ; stores the resultant count ; function to calculate sum of all array elements whose count of set bits are unique ; stores frequency of all possible count of set bits ; stores the sum of array elements ; traverse the array ; count the number of set bits ; traverse the array and update the value of ans ; if frequency is 1 ; ",
        "context": "",
        "code": "def setBitCount(n):\n    ans = 0\n    while n:\n        ans += n & 1\n        n >>= 1\n    return ans\n\n\ndef getSum(arr):\n    mp = {}\n    ans = 0\n    for i in arr:\n        key = setBitCount(i)\n        mp[key] = [0, i]\n    for i in arr:\n        key = setBitCount(i)\n        mp[key][0] += 1\n    for i in mp:\n        if mp[i][0] == 1:\n            ans += mp[i][1]\n    print(ans)\n",
        "test": "\narr = [8, 3, 7, 5, 3]\ngetSum(arr)\n",
        "output": "15\n",
        "fn_call": "getSum"
    },
    {
        "text": "generate an n | function to generate a string of length n having longest palindromic substring of length k ; fill first k characters with 'a ; stores a non - palindromic sequence to be repeated for n - k slots ; prn - k remaining characters ; ",
        "context": "",
        "code": "def string_palindrome(N, K):\n    for i in range(K):\n        print(\"a\", end=\"\")\n    s = \"bcd\"\n    for i in range(N - K):\n        print(s[i % 3], end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    N, K = 5, 3\n    string_palindrome(N, K)\n",
        "output": "aaabc",
        "fn_call": "string_palindrome"
    },
    {
        "text": "maximum score of deleting an element from an array based on given condition | python3 implementation to find the maximum score of the deleting a element from an array ; function to find the maximum score of the deleting an element from an array ; creating a map to keep the frequency of numbers ; loop to iterate over the elements of the array ; creating a dp array to keep count of max score at ith element and it will be filled in the bottom up manner ; loop to choose the elements of the array to delete from the array ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def findMaximumScore(a, n):\n    freq = defaultdict(int)\n    for i in range(n):\n        freq[a[i]] += 1\n    dp = [0] * (max(a) + 1)\n    dp[0] = 0\n    dp[1] = freq[1]\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + freq[i] * i)\n    return dp[-1]\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    a = [1, 2, 3]\n    print(findMaximumScore(a, n))\n",
        "output": "4\n",
        "fn_call": "findMaximumScore"
    },
    {
        "text": "minimum subsequences of a string a required to be appended to obtain the string b | python3 program for the above approach ; function to count the minimum subsequences of a a required to be appended to obtain the b ; size of the string ; maps characters to their respective indices ; insert indices of characters into the sets ; stores the position of the last visited index in the a . initially set it to - 1. ; stores the required count ; iterate over the characters of b ; if the character in b is not present in a , return - 1 ; fetch the next index from b [ i ] 's set ; if the iterator points to the end of that set ; if it doesn 't poto the  end, update previous ; prthe answer ; ",
        "context": "\nfrom bisect import bisect_right\n\n",
        "code": "def countminOpsToConstructAString(A, B):\n    N = len(A)\n    i = 0\n    mp = [[]for i in range(26)]\n    for i in range(N):\n        mp[ord(A[i]) - ord('a')].append(i)\n    previous = -1\n    ans, i = 1, 0\n    while i < len(B):\n        ch = B[i]\n        if (len(mp[ord(ch) - ord('a')]) == 0):\n            print(-1)\n            return\n        it = bisect_right(mp[ord(ch) - ord('a')], previous)\n        if (it == len(mp[ord(ch) - ord('a')])):\n            previous = -1\n            ans += 1\n            continue\n        previous = mp[ord(ch) - ord('a')][it]\n        i += 1\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    A, B = \"abc\", \"abac\"\n    countminOpsToConstructAString(A, B)\n",
        "output": "2\n",
        "fn_call": "countminOpsToConstructAString"
    },
    {
        "text": "convert string x to an anagram of string y with minimum replacements | python3 program to convert string x to string y which minimum number of changes . ; function that converts string x into lexicographically smallest anagram of string y with minimal changes ; counting frequency of characters in each string . ; we maintain two more counter arrays ctrx [ ] and ctry [ ] ctrx [ ] maintains the count of extra elements present in string x than string y ctry [ ] maintains the count of characters missing from string x which should be present in string y . ; this means that we cannot edit the current character as it 's frequency  in string x is equal to or less  than the frequency in string y.  thus, we go to the next position ; here , we try to find that character , which has more frequency in string y and less in string x . we try to find this character in lexicographical order so that we get lexicographically smaller string ; this portion deals with the lexicographical property . now , we put a character in string x when either this character has smaller value than the character present there right now or if this is the last position for it to exchange , else we fix the character already present here in this position . ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def printAnagramAndChanges(x, y):\n    x = list(x)\n    y = list(y)\n    countx, county = [0] * MAX, [0] * MAX\n    ctrx, ctry = [0] * MAX, [0] * MAX\n    change = 0\n    l = len(x)\n    for i in range(l):\n        countx[ord(x[i]) - ord('A')] += 1\n        county[ord(y[i]) - ord('A')] += 1\n    for i in range(MAX):\n        if countx[i] > county[i]:\n            ctrx[i] += (countx[i] - county[i])\n        elif countx[i] < county[i]:\n            ctry[i] += (county[i] - countx[i])\n        change += abs(county[i] - countx[i])\n    for i in range(l):\n        if ctrx[ord(x[i]) - ord('A')] == 0:\n            continue\n        j = 0\n        for j in range(MAX):\n            if ctry[j] > 0:\n                break\n        if countx[ord(x[i]) - ord('A')] == ctrx[ord(x[i]) -\n                                                ord('A')] or ord(x[i]) - ord('A') > j:\n            countx[ord(x[i]) - ord('A')] -= 1\n            ctrx[ord(x[i]) - ord('A')] -= 1\n            ctry[j] -= 1\n            x[i] = chr(ord('A') + j)\n        else:\n            countx[ord(x[i]) - ord('A')] -= 1\n    print(\"Anagram :\", ''.join(x))\n    print(\"Number of changes made :\", change // 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    x = \"CDBABC\"\n    y = \"ADCABD\"\n    printAnagramAndChanges(x, y)\n",
        "output": "Anagram : ADBADC\nNumber of changes made : 2\n",
        "fn_call": "printAnagramAndChanges"
    },
    {
        "text": "digits whose alphabetic representations are jumbled in a given string | function to convert the jumbled into digits ; strings of digits 0 - 9 ; initialize vector ; initialize answer ; size of the string ; traverse the string ; update the elements of the vector ; print the digits into their original format ; return answer ; ",
        "context": "",
        "code": "def finddigits(s):\n    num = [\n        \"zero\",\n        \"one\",\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\"]\n    arr = [0] * (10)\n    ans = \"\"\n    n = len(s)\n    for i in range(n):\n        if (s[i] == 'z'):\n            arr[0] += 1\n        if (s[i] == 'w'):\n            arr[2] += 1\n        if (s[i] == 'g'):\n            arr[8] += 1\n        if (s[i] == 'x'):\n            arr[6] += 1\n        if (s[i] == 'v'):\n            arr[5] += 1\n        if (s[i] == 'o'):\n            arr[1] += 1\n        if (s[i] == 's'):\n            arr[7] += 1\n        if (s[i] == 'f'):\n            arr[4] += 1\n        if (s[i] == 'h'):\n            arr[3] += 1\n        if (s[i] == 'i'):\n            arr[9] += 1\n    arr[7] -= arr[6]\n    arr[5] -= arr[7]\n    arr[4] -= arr[5]\n    arr[1] -= (arr[2] + arr[4] + arr[0])\n    arr[3] -= arr[8]\n    arr[9] -= (arr[5] + arr[6] + arr[8])\n    for i in range(10):\n        for j in range(arr[i]):\n            ans += chr((i) + ord('0'))\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    s = \"owoftnuoer\"\n    print(finddigits(s))\n",
        "output": "124\n",
        "fn_call": "finddigits"
    },
    {
        "text": "check if a string can be formed from another string by at most x circular clockwise shifts | function to check that the string s1 can be converted to s2 by clockwise circular shift of all characters of str1 atmost x times ; check for all characters of the strings whether the difference between their ascii values is less than x or not ; if both characters are the same ; condition to check if the difference less than 0 then find the circular shift by adding 26 to it ; if difference between their ascii values exceeds x ; ",
        "context": "",
        "code": "def isConversionPossible(s1, s2, x):\n    n = len(s1)\n    s1 = list(s1)\n    s2 = list(s2)\n    for i in range(n):\n        diff = ord(s2[i]) - ord(s1[i])\n        if diff == 0:\n            continue\n        if diff < 0:\n            diff = diff + 26\n        if diff > x:\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    s1 = \"you\"\n    s2 = \"ara\"\n    x = 6\n    result = isConversionPossible(s1, s2, x)\n    if result:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isConversionPossible"
    },
    {
        "text": "find maximum of minimum for every window size in a given array | a naive method to find maximum of minimum of all windows of different sizes ; consider all windows of different sizes starting from size 1 ; initialize max of min for current window size k ; traverse through all windows of current size k ; find minimum of current window ; update maxofmin if required ; print max of min for current window size ; ",
        "context": "\nINT_MIN = -1000000\n\n",
        "code": "def printMaxOfMin(arr, n):\n    for k in range(1, n + 1):\n        maxOfMin = INT_MIN\n        for i in range(n - k + 1):\n            min = arr[i]\n            for j in range(k):\n                if (arr[i + j] < min):\n                    min = arr[i + j]\n            if (min > maxOfMin):\n                maxOfMin = min\n        print(maxOfMin, end=\" \")\n",
        "test": "\narr = [10, 20, 30, 50, 10, 70, 30]\nn = len(arr)\nprintMaxOfMin(arr, n)\n",
        "output": "70 30 20 10 10 10 10 ",
        "fn_call": "printMaxOfMin"
    },
    {
        "text": "find number of days between two given dates | a date has day ' d ' , month ' m ' and year 'y ; to store number of days in all months from january to dec . ; this function counts number of leap years before the given date ; check if the current year needs to be considered for the count of leap years or not ; an year is a leap year if it is a multiple of 4 , multiple of 400 and not a multiple of 100. ; this function returns number of days between two given dates ; initialize count using years and day ; add days for months in given date ; since every leap year is of 366 days , add a day for every leap year ; similarly , count total number of days before 'dt2 ; return difference between two counts ; ",
        "context": "\n\nclass Date:\n    def __init__(self, d, m, y):\n        self.d = d\n        self.m = m\n        self.y = y\n\n\nmonthDays = [31, 28, 31, 30, 31, 30,\n             31, 31, 30, 31, 30, 31]\n\n",
        "code": "def countLeapYears(d):\n\n    years = d.y\n    if (d.m <= 2):\n        years -= 1\n    ans = int(years / 4)\n    ans -= int(years / 100)\n    ans += int(years / 400)\n    return ans\n\n\ndef getDifference(dt1, dt2):\n    n1 = dt1.y * 365 + dt1.d\n    for i in range(0, dt1.m - 1):\n        n1 += monthDays[i]\n    n1 += countLeapYears(dt1)\n    n2 = dt2.y * 365 + dt2.d\n    for i in range(0, dt2.m - 1):\n        n2 += monthDays[i]\n    n2 += countLeapYears(dt2)\n\n    return (n2 - n1)\n",
        "test": "\ndt1 = Date(1, 9, 2014)\ndt2 = Date(3, 9, 2020)\nprint(\"Difference between two dates is\", getDifference(dt1, dt2))\n",
        "output": "Difference between two dates is 2194\n",
        "fn_call": "getDifference"
    },
    {
        "text": "arrange a binary string to get maximum value within a range of indices | python implementation of the approach ; storing the count of 1 's in the string ; query of l and r ; applying range update technique . ; taking prefix sum to get the range update values ; final array which will store the arranged string ; if after maximizing the ranges any 1 is left then we maximize the string lexicographically . ; ",
        "context": "",
        "code": "def arrange(s):\n    cc = 0\n    for i in range(len(s)):\n        if (s[i] == \"1\"):\n            cc += 1\n    a = [0] * (len(s) + 1)\n    qq = [(2, 3), (5, 5)]\n    n = len(qq)\n    for i in range(n):\n        l, r = qq[i][0], qq[i][1]\n        l -= 1\n        r -= 1\n        a[l] += 1\n        a[r + 1] -= 1\n    for i in range(1, len(a)):\n        a[i] = a[i] + a[i - 1]\n    zz = [0] * len(s)\n    for i in range(len(a) - 1):\n        if (a[i] > 0):\n            if (cc > 0):\n                zz[i] = 1\n                cc -= 1\n            else:\n                break\n        if (cc == 0):\n            break\n    if (cc > 0):\n        for i in range(len(s)):\n            if (zz[i] == 0):\n                zz[i] = 1\n                cc -= 1\n            if (cc == 0):\n                break\n    print(*zz, sep=\"\")\n",
        "test": "\nstr = \"11100\"\narrange(str)\n",
        "output": "01101\n",
        "fn_call": "arrange"
    },
    {
        "text": "minimize swaps required to maximize the count of elements replacing a greater element in an array | function to find the minimum number of swaps required ; stores the frequency of the array elements ; stores maximum frequency ; find the max frequency ; update frequency ; update maximum frequency ; ",
        "context": "",
        "code": "def countSwaps(A, n):\n    mp = {}\n    max_frequency = 0\n    for i in range(n):\n        if A[i] in mp:\n            mp[A[i]] += 1\n        else:\n            mp[A[i]] = 1\n        max_frequency = max(max_frequency, mp[A[i]])\n    return n - max_frequency\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [6, 5, 4, 3, 2, 1]\n    print(countSwaps(A, 6))\n",
        "output": "5\n",
        "fn_call": "countSwaps"
    },
    {
        "text": "predict the winner of the game on the basis of absolute difference of sum by selecting numbers | function to decide the winner ; iterate for all numbers in the array ; if mod gives 0 ; if mod gives 1 ; if mod gives 2 ; if mod gives 3 ; check the winning condition for x ; ",
        "context": "",
        "code": "def decideWinner(a, n):\n    count0 = 0\n    count1 = 0\n    count2 = 0\n    count3 = 0\n    for i in range(n):\n        if (a[i] % 4 == 0):\n            count0 += 1\n        elif (a[i] % 4 == 1):\n            count1 += 1\n        elif (a[i] % 4 == 2):\n            count2 += 1\n        elif (a[i] % 4 == 3):\n            count3 += 1\n    if (count0 %\n        2 == 0 and count1 %\n        2 == 0 and count2 %\n            2 == 0 and count3 == 0):\n        return 1\n    else:\n        return 2\n",
        "test": "\na = [4, 8, 5, 9]\nn = len(a)\nif (decideWinner(a, n) == 1):\n    print(\"X wins\")\nelse:\n    print(\"Y wins\")\n",
        "output": "X wins\n",
        "fn_call": "decideWinner"
    },
    {
        "text": "construct an array whose prefix xor array starting from x is an n | function to print the required array ; iteratie from 1 to n ; print the i - th element ; update prev_xor to i ; ",
        "context": "",
        "code": "def GenerateArray(N, X):\n    prev_xor = X\n    for i in range(1, N + 1, 1):\n        print(i ^ prev_xor, end=\"\")\n        if (i != N):\n            print(\" \", end=\"\")\n        prev_xor = i\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    X = 3\n    print(\"The generated array is \", end=\"\")\n    GenerateArray(N, X)\n",
        "output": "The generated array is 2 3 1 7",
        "fn_call": "GenerateArray"
    },
    {
        "text": "nth term of a recurrence relation generated by two given arrays | python3 program for the above approach ; function to calculate nth term of general recurrence relations ; stores the generated sequence ; current term is sum of previous k terms ; print the nth term ; ",
        "context": "\nmod = 1e9 + 7\n\n",
        "code": "def NthTerm(F, C, K, n):\n    ans = [0] * (n + 1)\n    i = 0\n    while i < K:\n        ans[i] = F[i]\n        i += 1\n    i = K\n    while i <= n:\n        j = i - K\n        while j < i:\n            ans[i] += ans[j]\n            ans[i] %= mod\n            j += 1\n        i += 1\n    print(int(ans[n]))\n",
        "test": "\nif __name__ == '__main__':\n    F = [0, 1]\n    C = [1, 1]\n    K = 2\n    N = 10\n    NthTerm(F, C, K, N)\n",
        "output": "55\n",
        "fn_call": "NthTerm"
    },
    {
        "text": "rectangle with minimum possible difference between the length and the width | python3 implementation of the approach ; function to print the length ( l ) and breadth ( b ) of the rectangle having area = n and | l - b | as minimum as possible ; i is a factor ; l >= sqrt ( area ) >= i ; so here l is + ve always ; here l and b are length and breadth of the rectangle ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def find_rectangle(area):\n    l, b = 0, 0\n    M = mt .ceil(mt .sqrt(area))\n    ans = 0\n    for i in range(M, 0, -1):\n        if (area % i == 0):\n            l = (area // i)\n            b = i\n            break\n    print(\"l =\", l, \", b =\", b)\n",
        "test": "\narea = 99\nfind_rectangle(area)\n",
        "output": "l = 11 , b = 9\n",
        "fn_call": "find_rectangle"
    },
    {
        "text": "minimum number of characters to be removed to make a binary string alternate | returns count of minimum characters to be removed to make s alternate . ; if two alternating characters of string are same ; result += 1 then need to delete a character ; ",
        "context": "",
        "code": "def countToMake0lternate(s):\n\n    result = 0\n\n    for i in range(len(s) - 1):\n        if (s[i] == s[i + 1]):\n            result += 1\n\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    print(countToMake0lternate(\"000111\"))\n    print(countToMake0lternate(\"11111\"))\n    print(countToMake0lternate(\"01010101\"))\n",
        "output": "4\n4\n0\n",
        "fn_call": "countToMake0lternate"
    },
    {
        "text": "absolute difference of all pairwise consecutive elements in an array | function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; ",
        "context": "",
        "code": "def pairwiseDifference(arr, n):\n    for i in range(n - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        print(diff, end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 10, 15, 5, 6]\n    n = len(arr)\n    pairwiseDifference(arr, n)\n",
        "output": "6 5 10 1 ",
        "fn_call": "pairwiseDifference"
    },
    {
        "text": "sum of the natural numbers ( up to n ) whose modulo with k yield r | function to return the sum ; if current number gives r as the remainder on dividing by k ; update the sum ; return the sum ; ",
        "context": "",
        "code": "def count(N, K, R):\n    sum = 0\n    for i in range(1, N + 1):\n        if (i % K == R):\n            sum += i\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    N = 20\n    K = 4\n    R = 3\n    print(count(N, K, R))\n",
        "output": "55\n",
        "fn_call": "count"
    },
    {
        "text": "maximize sum of count of distinct prime factors of k array elements | python 3 program for the above approach ; function to find the maximum sum of count of distinct prime factors of k array elements ; stores the count of distinct primes ; stores 1 and 0 at prime and non - prime indices respectively ; initialize the count of factors to 0 ; sieve of eratosthenes ; count of factors of a prime number is 1 ; increment countdistinct of all multiples of i ; mark its multiples non - prime ; stores the maximum sum of distinct prime factors of k array elements ; stores the count of all distinct prime factors ; traverse the array to find count of all array elements ; maximum sum of k prime factors of array elements ; check for the largest prime factor ; increment sum ; decrement its count and k ; print the maximum sum ; ",
        "context": "\nMAX = 1000000\n\n",
        "code": "def maxSumOfDistinctPrimeFactors(arr, N, K):\n    CountDistinct = [0] * (MAX + 1)\n    prime = [False] * (MAX + 1)\n    for i in range(MAX + 1):\n        CountDistinct[i] = 0\n        prime[i] = True\n    for i in range(2, MAX + 1):\n        if (prime[i]):\n            CountDistinct[i] = 1\n            for j in range(i * 2, MAX + 1, i):\n                CountDistinct[j] += 1\n                prime[j] = False\n    sum = 0\n    PrimeFactor = [0] * 20\n    for i in range(N):\n        PrimeFactor[CountDistinct[arr[i]]] += 1\n    for i in range(19, 0, -1):\n        while (PrimeFactor[i] > 0):\n            sum += i\n            PrimeFactor[i] -= 1\n            K -= 1\n            if (K == 0):\n                break\n        if (K == 0):\n            break\n    print(sum)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 9, 12]\n    N = len(arr)\n    K = 2\n    maxSumOfDistinctPrimeFactors(arr, N, K)\n",
        "output": "4\n",
        "fn_call": "maxSumOfDistinctPrimeFactors"
    },
    {
        "text": "check whether bits are in alternate pattern in the given range | set | function to check whether rightmost kth bit is set or not in 'n ; function to set the rightmost kth bit in 'n ; kth bit of n is being set by this operation ; function to check if all the bits are set or not in the binary representation of 'n ; if true , then all bits are set ; else all bits are not set ; function to check if a number has bits in alternate pattern ; to check if all bits are set in 'num ; function to check whether bits are in alternate pattern in the given range ; preparing a number ' num ' and ' left _ shift ' which can be further used for the check of alternate pattern in the given range ; unset all the bits which are left to the rth bit of ( r + 1 ) th bit ; right shift ' num ' by ( l - 1 ) bits ; ",
        "context": "",
        "code": "def isKthBitSet(n, k):\n    if ((n >> (k - 1)) & 1):\n        return True\n    return False\n\n\ndef setKthBit(n, k):\n    return ((1 << (k - 1)) | n)\n\n\ndef allBitsAreSet(n):\n    if (((n + 1) & n) == 0):\n        return True\n    return False\n\n\ndef bitsAreInAltOrder(n):\n    num = n ^ (n >> 1)\n    return allBitsAreSet(num)\n\n\ndef bitsAreInAltPatrnInGivenRange(n, l, r):\n    if (isKthBitSet(n, r)):\n        num = n\n        left_shift = r\n\n    else:\n        num = setKthBit(n, (r + 1))\n        left_shift = r + 1\n    num = num & ((1 << left_shift) - 1)\n    num = num >> (l - 1)\n\n    return bitsAreInAltOrder(num)\n",
        "test": "\nif __name__ == '__main__':\n    n = 18\n    l = 1\n    r = 3\n    if (bitsAreInAltPatrnInGivenRange(n, l, r)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "bitsAreInAltPatrnInGivenRange"
    },
    {
        "text": "count total set bits in all numbers from range l to r | function to count set bits in x ; base case ; recursive call ; function that returns count of set bits present in all numbers from 1 to n ; initialize the result ; return the setbit count ; ",
        "context": "",
        "code": "def countSetBitsUtil(x):\n    if (x < 1):\n        return 0\n    if (x % 2 == 0):\n        return 0\n    else:\n        return 1 + (countSetBitsUtil(x / 2))\n\n\ndef countSetBits(L, R):\n    bitCount = 0\n    for i in range(L, R + 1):\n        bitCount += countSetBitsUtil(i)\n    return bitCount\n",
        "test": "\nif __name__ == '__main__':\n    L = 3\n    R = 5\n    print(\"Total set bit count is \", countSetBits(L, R))\n",
        "output": "Total set bit count is  5\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "maximum points of intersection n lines | nc2 = ( n ) * ( n - 1 ) / 2 ; ",
        "context": "",
        "code": "def countMaxIntersect(n):\n    return int(n * (n - 1) / 2)\n",
        "test": "\nif __name__ == '__main__':\n    n = 8\n    print(countMaxIntersect(n))\n",
        "output": "28\n",
        "fn_call": "countMaxIntersect"
    },
    {
        "text": "count all possible strings that can be generated by placing spaces | function to count the number of strings that can be generated by placing spaces between pair of adjacent characters ; length of the string ; count of positions for spaces ; count of possible strings ; ",
        "context": "",
        "code": "def countNumberOfStrings(s):\n    length = len(s)\n    n = length - 1\n    count = 2 ** n\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"ABCD\"\n    print(countNumberOfStrings(S))\n",
        "output": "8\n",
        "fn_call": "countNumberOfStrings"
    },
    {
        "text": "maximum possible sum of squares of stack elements satisfying the given properties | function to find the maximum sum of squares of stack elements ; stores the sum ofsquares of stack elements ; check if sum is valid ; initialize all stack elements with 1 ; stores the count the number of stack elements not equal to 1 ; add the sum of squares of stack elements not equal to 1 ; add 1 * 1 to res as the remaining stack elements are 1 ; print the result ; ",
        "context": "",
        "code": "def maxSumOfSquares(N, S):\n    res = 0\n    if (S  9 * N):\n        cout << -1\n        return\n    S = S - N\n    c = 0\n    while (S > 0):\n        c += 1\n        if (S // 8 > 0):\n            res += 9 * 9\n            S -= 8\n        else:\n            res += (S + 1) * (S + 1)\n            break\n    res = res + (N - c)\n    print(res)\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    S = 12\n    maxSumOfSquares(N, S)\n",
        "output": "86\n",
        "fn_call": "maxSumOfSquares"
    },
    {
        "text": "make all characters of a string same by minimum number of increments or decrements of ascii values of characters | function to check if all characters of the string can be made the same ; sort the string ; calculate ascii value of the median character ; stores the minimum number of operations required to make all characters equal ; traverse the string ; calculate absolute value of current character and median character ; print the minimum number of operations required ; ",
        "context": "",
        "code": "def sameChar(S, N):\n    S = ''.join(sorted(S))\n    mid = ord(S[N // 2])\n    total_operations = 0\n    for i in range(N):\n        total_operations += abs(ord(S[i]) - mid)\n    print(total_operations)\n",
        "test": "\nS = \"geeks\"\nN = len(S)\nsameChar(S, N)\n",
        "output": "20\n",
        "fn_call": "sameChar"
    },
    {
        "text": "sort an array when two halves are sorted | python program to merge two sorted halves of array into single sorted array ; sort the given array using sort stl ; ",
        "context": "",
        "code": "def mergeTwoHalf(A, n):\n    A .sort()\n",
        "test": "\nif __name__ == '__main__':\n    A = [2, 3, 8, -1, 7, 10]\n    n = len(A)\n    mergeTwoHalf(A, n)\n    for i in range(n):\n        print(A[i], end=\" \")\n",
        "output": "-1 2 3 7 8 10 ",
        "fn_call": "mergeTwoHalf"
    },
    {
        "text": "check if two strings are permutation of each other | function to check whether two strings are permutation of each other ; get lengths of both strings ; if length of both strings is not same , then they cannot be permutation ; sort both strings ; compare sorted strings ; ",
        "context": "",
        "code": "def arePermutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if (n1 != n2):\n        return False\n    a = sorted(str1)\n    str1 = \" \".join(a)\n    b = sorted(str2)\n    str2 = \" \".join(b)\n    for i in range(0, n1, 1):\n        if (str1[i] != str2[i]):\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"test\"\n    str2 = \"ttew\"\n    if (arePermutation(str1, str2)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "arePermutation"
    },
    {
        "text": "count of numbers in range [ l , r ] with lsb as 0 in their binary representation | function to return the count of required numbers ; count of numbers in range which are divisible by 2 ; ",
        "context": "",
        "code": "def countNumbers(l, r):\n    return ((r // 2) - (l - 1) // 2)\n",
        "test": "\nl = 10\nr = 20\nprint(countNumbers(l, r))\n",
        "output": "6\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "number of divisors of a given number n which are divisible by k | function to count number of divisors of n which are divisible by k ; variable to store count of divisors ; traverse from 1 to n ; increase the count if both the conditions are satisfied ; ",
        "context": "",
        "code": "def countDivisors(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if (n % i == 0 and i % k == 0):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    n, k = 12, 3\n    print(countDivisors(n, k))\n",
        "output": "3\n",
        "fn_call": "countDivisors"
    },
    {
        "text": "largest component size in a graph formed by connecting non |  ; mark this node as visited ; apply dfs and add nodes belonging to this component ; create graph and store in adjacency list form ; iterate over all pair of nodes ; if not co - prime ; build undirected graph ; visited array for dfs ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def dfs(u, adj, vis):\n    vis[u] = 1\n    componentSize = 1\n    for x in adj[u]:\n        if (vis[x] == 0):\n            componentSize += dfs(x, adj, vis)\n    return componentSize\n\n\ndef maximumComponentSize(a, n):\n    adj = [[]for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (gcd(a[i], a[j]) > 1):\n                adj[i].append(j)\n            adj[j].append(i)\n    answer = 0\n    vis = [0 for i in range(n)]\n    for i in range(n):\n        if (vis[i] == False):\n            answer = max(answer, dfs(i, adj, vis))\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    n = 8\n    A = [2, 3, 6, 7, 4, 12, 21, 39]\n    print(maximumComponentSize(A, n))\n",
        "output": "8\n",
        "fn_call": "maximumComponentSize"
    },
    {
        "text": "check if a number is quartan prime or not | utility function to check if a number is prime or not ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; ",
        "context": "",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n",
        "test": "\nn = 17\nif (isPrime(n) and (n % 16 == 1)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isPrime"
    },
    {
        "text": "area of decagon inscribed within the circle | python3 program to find the area of the decagon inscribed within a circle ; function to find the area of the decagon ; radius cannot be negative ; area of the decagon ; ",
        "context": "\nfrom math import sqrt, pow\n\n",
        "code": "def area(r):\n    if r < 0:\n        return -1\n    area = (5 * pow(r, 2) * (3 - sqrt(5)) * (sqrt(5) + (2 * sqrt(5)))) / 4\n    return area\n",
        "test": "\nif __name__ == '__main__':\n    r = 8\n    print(area(r))\n",
        "output": "409.96894379984855\n",
        "fn_call": "area"
    },
    {
        "text": "minimum number of single digit primes required whose sum is equal to n | function to check if i - th index is valid or not ; function to find the minimum number of single digit prime numbers required which when summed up equals to a given number n . ; not possible ; ",
        "context": "",
        "code": "def check(i, val):\n    if i - val < 0:\n        return False\n    return True\n\n\ndef MinimumPrimes(n):\n    dp = [10 ** 9] * (n + 1)\n    dp[0] = dp[2] = dp[3] = dp[5] = dp[7] = 1\n    for i in range(1, n + 1):\n        if check(i, 2):\n            dp[i] = min(dp[i], 1 + dp[i - 2])\n        if check(i, 3):\n            dp[i] = min(dp[i], 1 + dp[i - 3])\n        if check(i, 5):\n            dp[i] = min(dp[i], 1 + dp[i - 5])\n        if check(i, 7):\n            dp[i] = min(dp[i], 1 + dp[i - 7])\n    if dp[n] == 10 ** 9:\n        return -1\n    else:\n        return dp[n]\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 12\n    minimal = MinimumPrimes(n)\n    if minimal != -1:\n        print(\"Minimum number of single digit primes required : \", minimal)\n    else:\n        print(\"Not possible\")\n",
        "output": "Minimum number of single digit primes required :  2\n",
        "fn_call": "MinimumPrimes"
    },
    {
        "text": "check if a number is a mystery number | finds reverse of ",
        "context": "",
        "code": "def reverseNum(x):\n    s = str(x)\n    s = s[::-1]\n    return int(s)\n\n\ndef isMysteryNumber(n):\n    for i in range(1, n // 2 + 1):\n        j = reverseNum(i)\n        if i + j == n:\n            print(i, j)\n            return True\n    print(\"Not a Mystery Number\")\n    return False\n",
        "test": "\nn = 121\nisMysteryNumber(n)\n",
        "output": "29 92\n",
        "fn_call": "isMysteryNumber"
    },
    {
        "text": "count of root to leaf paths consisting of at most m consecutive nodes having value k | initialize the adjacency list and visited array ; function to find the number of root to leaf paths that contain atmost m consecutive nodes with value k ; mark the current node as visited ; if value at current node is k ; increment counter ; if count is greater than m return from that path ; path is allowed if size of present node becomes 0 i . e it has no child root and no more than m consecutive 1 's ; ",
        "context": "\nadj = [[]for i in range(100005)]\nvisited = [0 for i in range(100005)]\nans = 0\n\n",
        "code": "def dfs(node, count, m, arr, k):\n    global ans\n    visited[node] = 1\n    if (arr[node - 1] == k):\n        count += 1\n    else:\n        count = 0\n    if (count > m):\n        return\n    if (len(adj[node]) == 1 and node != 1):\n        ans += 1\n    for x in adj[node]:\n        if (not visited[x]):\n            dfs(x, count, m, arr, k)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 1, 3, 2, 1, 2, 1]\n    N = 7\n    K = 2\n    M = 2\n    adj[1].append(2)\n    adj[2].append(1)\n    adj[1].append(3)\n    adj[3].append(1)\n    adj[2].append(4)\n    adj[4].append(2)\n    adj[2].append(5)\n    adj[5].append(2)\n    adj[3].append(6)\n    adj[6].append(3)\n    adj[3].append(7)\n    adj[7].append(3)\n    counter = 0\n    dfs(1, counter, M, arr, K)\n    print(ans)\n",
        "output": "4\n",
        "fn_call": "dfs"
    },
    {
        "text": "check if the sum of k least and most frequent array elements are equal or not | function to compare the sum of k most and least occurrences ; stores frequency of array element ; stores the frequencies as indexes and putelements with the frequency in a vector ; find the frequency ; insert in the vector ; stores the count of elements ; traverse the frequency array ; find the kleastfreqsum ; if the count is k , break ; reinitialize the count to zero ; traverse the frequency ; find the kmostfreqsum ; if the count is k , break ; comparing the sum ; otherwise , return no ; ",
        "context": "",
        "code": "def checkSum(arr, n, k):\n    m = {}\n    for i in range(n):\n        if arr[i] in m:\n            m[arr[i]] += 1\n        else:\n            m[arr[i]] = 1\n    freq = [[]for i in range(n + 1)]\n    for i in range(n):\n        f = m[arr[i]]\n        if (f != -1):\n            freq[f].append(arr[i])\n            m[arr[i]] = -1\n    count = 0\n    kleastfreqsum = 0\n    for i in range(n + 1):\n        for x in freq[i]:\n            kleastfreqsum += x\n            count += 1\n            if (count == k):\n                break\n        if (count == k):\n            break\n    count = 0\n    kmostfreqsum = 0\n    i = n\n    while (i >= 0):\n        for x in freq[i]:\n            kmostfreqsum += x\n            count += 1\n            if (count == k):\n                break\n        i -= 1\n        if (count == k):\n            break\n    if (kleastfreqsum == kmostfreqsum):\n        return \"Yes\"\n    return \"No\"\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 2, 1, 2, 3, 3, 4]\n    N = len(arr)\n    K = 2\n    print(checkSum(arr, N, K))\n",
        "output": "Yes\n",
        "fn_call": "checkSum"
    },
    {
        "text": "maximum prime moves to convert x to y | function to return the maximum operations required to convert x to y ; x cannot be converted to y ; if the difference is 1 ; if the difference is even ; add 3 to x and the new difference will be even ; ",
        "context": "",
        "code": "def maxOperations(X, Y):\n    if (X > Y):\n        return -1\n    diff = Y - X\n    if (diff == 1):\n        return -1\n    if (diff % 2 == 0):\n        return (diff // 2)\n    return (1 + ((diff - 3) // 2))\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 5\n    Y = 16\n    print(maxOperations(X, Y))\n",
        "output": "5\n",
        "fn_call": "maxOperations"
    },
    {
        "text": "find nth term of the series 4 , 2 , 2 , 3 , 6 , ... | function to find nth term ; nth term ; ",
        "context": "",
        "code": "def nthTerm(N):\n    nth = 0\n    first_term = 4\n    pi = 1\n    po = 1\n    n = N\n    while (n > 1):\n        pi *= n - 1\n        n -= 1\n        po *= 2\n    nth = (first_term * pi) // po\n    return nth\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    print(nthTerm(N))\n",
        "output": "6\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "find the maximum gcd possible for some pair in a ",
        "context": "",
        "code": "def GCD(a, b):\n    if (b == 0):\n        return a\n    return GCD(b, a % b)\n\n\ndef maxGCDInRange(L, R):\n    ans = 1\n    for Z in range(R, 1, -1):\n        if (((R // Z) - (L - 1) // Z) > 1):\n            ans = Z\n            break\n    return ans\n",
        "test": "\nL = 102\nR = 139\nprint(maxGCDInRange(L, R))\n",
        "output": "34\n",
        "fn_call": "maxGCDInRange"
    },
    {
        "text": "reverse a subarray of the given array to minimize the sum of elements at even position | function that will give the max negative value ; check for count greater than 0 as we require only negative solution ; function to print the minimum sum ; taking sum of only even index elements ; initialize two vectors v1 , v2 ; v1 will keep account for change if 1 th index element goes to 0 ; v2 will keep account for change if 1 th index element goes to 2 ; get the max negative value ; ",
        "context": "",
        "code": "def after_rev(v):\n    mini = 0\n    count = 0\n    for i in range(len(v)):\n        count += v[i]\n        if (count > 0):\n            count = 0\n        if (mini > count):\n            mini = count\n    return mini\n\n\ndef print_f(arr):\n    sum = 0\n    for i in range(0, len(arr), 2):\n        sum += arr[i]\n    v1, v2 = [], []\n    i = 1\n    while i + 1 < len(arr):\n        v1 .append(arr[i + 1] - arr[i])\n        i += 2\n    i = 1\n    while i + 1 < len(arr):\n        v2 .append(arr[i] - arr[i + 1])\n        i += 2\n    change = min(after_rev(v1), after_rev(v2))\n    if (change < 0):\n        sum += change\n    print(sum)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 1, 4, 3]\n    print_f(arr)\n",
        "output": "1\n",
        "fn_call": "print_f"
    },
    {
        "text": "sum of p terms of an ap if mth and nth terms are given | python3 implementation of the above approach ; function to calculate the value of the ; calculate value of d using formula ; calculate value of a using formula ; return pair ; function to calculate value sum of first p numbers of the series ; first calculate value of a and d ; calculate the sum by using formula ; return the sum ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def findingValues(m, n, mth, nth):\n    d = ((abs(mth - nth)) / abs((m - 1) - (n - 1)))\n    a = mth - ((m - 1) * d)\n    return a, d\n\n\ndef findSum(m, n, mth, nth, p):\n    a, d = findingValues(m, n, mth, nth)\n    Sum = (p * (2 * a + (p - 1) * d)) / 2\n    return Sum\n",
        "test": "\nm = 6\nn = 10\nmTerm = 12\nnTerm = 20\np = 5\nprint(findSum(m, n, mTerm, nTerm, p))\n",
        "output": "30.0\n",
        "fn_call": "findSum"
    },
    {
        "text": "check if euler totient function is same for a given number and twice of that number | function to check if phi ( n ) is equals phi ( 2 * n ) ; return if n is odd ; ",
        "context": "",
        "code": "def sameEulerTotient(N):\n    return (N & 1)\n",
        "test": "\nif __name__ == '__main__':\n    N = 13\n    if (sameEulerTotient(N) == 1):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "sameEulerTotient"
    },
    {
        "text": "find index of closing bracket for a given opening bracket in an expression | python program to find index of closing bracket for a given opening bracket . ; function to find index of closing bracket for given opening bracket . ; if input is invalid . ; create a deque to use it as a stack . ; traverse through all elements starting from i . ; push all starting brackets ; pop a starting bracket for every closing bracket ; if deque becomes empty ; test function ; ",
        "context": "\nfrom collections import deque\n\n",
        "code": "def getIndex(s, i):\n    if s[i] != '[':\n        return -1\n    d = deque()\n    for k in range(i, len(s)):\n        if s[k] == '[':\n            d .append(s[i])\n        elif s[k] == ']':\n            d .popleft()\n        if not d:\n            return k\n    return -1\n\n\ndef test(s, i):\n    matching_index = getIndex(s, i)\n    print(s + \", \" + str(i) + \": \" + str(matching_index))\n\n\ndef main():\n    test(\"[ABC[23]][89]\", 0)\n    test(\"[ABC[23]][89]\", 4)\n    test(\"[ABC[23]][89]\", 9)\n    test(\"[ABC[23]][89]\", 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    main()\n",
        "output": "[ABC[23]][89], 0: 8\n[ABC[23]][89], 4: 7\n[ABC[23]][89], 9: 12\n[ABC[23]][89], 1: -1\n",
        "fn_call": "main"
    },
    {
        "text": "largest palindrome not exceeding n which can be expressed as product of two 3 | function to find the largest palindrome not exceeding n which can be expressed as the product of two 3 - digit numbers ; stores all palindromes ; stores the product ; check if x is palindrome ; check n is less than n ; if true , append it in the list ; print the largest palindrome ; ",
        "context": "",
        "code": "def palindrome_prod(N):\n    palindrome_list = []\n    for i in range(101, 1000):\n        for j in range(121, 1000, (1 if i % 11 == 0 else 11)):\n            n = i * j\n            x = str(n)\n            if x == x[::-1]:\n                if n < N:\n                    palindrome_list .append(i * j)\n    print(max(palindrome_list))\n",
        "test": "\nN = 101110\npalindrome_prod(N)\n",
        "output": "101101\n",
        "fn_call": "palindrome_prod"
    },
    {
        "text": "generate an array such with elements maximized through swapping bits | function to generate the maximized array elements ; traverse the array ; iterate to count set and unset bits ; count of unset bits ; count of set bits ; bitwise right shift ; shifting all 1 ' s \u2581 to \u2581 msb \u2581 \u2581 and \u2581 0' s to lsb ; ",
        "context": "",
        "code": "def maximizedArray(arr, N):\n    i = 0\n    while (N > 0):\n        num = arr[i]\n        one = 0\n        zero = 0\n        while (num):\n            if (num % 2 == 0):\n                zero += 1\n            else:\n                one += 1\n            num = num >> 1\n        for j in range(zero, (one + zero)):\n            num += (1 << j)\n        print(num, end=\"\")\n        i += 1\n        if (N > 0):\n            print(\", \", end=\"\")\n        N -= 1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [8, 15, 9, 10, 14]\n    N = len(arr)\n    maximizedArray(arr, N)\n",
        "output": "8, 15, 12, 12, 14, ",
        "fn_call": "maximizedArray"
    },
    {
        "text": "count of all possible values of x such that a % x = b | function to return the count of all possible values for x such that ( a % x ) = b ; case 1 ; case 2 ; case 3 ; find the number of divisors of x which are greater than b ; ",
        "context": "",
        "code": "def countX(a, b):\n    if (b > a):\n        return 0\n    elif (a == b):\n        return -1\n    else:\n        x = a - b\n        ans = 0\n        i = 1\n        while i * i <= x:\n            if (x % i == 0):\n                d1 = i\n                d2 = b - 1\n                if (i * i != x):\n                    d2 = x // i\n                if (d1 > b):\n                    ans += 1\n                if (d2 > b):\n                    ans += 1\n            i += 1\n        return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 21\n    b = 5\n    print(countX(a, b))\n",
        "output": "2\n",
        "fn_call": "countX"
    },
    {
        "text": "check if given intervals can be made non | function to check if two intervals overlap with each other ; condition to check if the intervals overlap ; function to check if there is a existing overlapping intervals ; path compression ; union of two intervals returns true if there is a overlapping with the same another interval ; both have same another overlapping interval ; function to check if the intervals can be added by x to form non - overlapping intervals ; if the intervals overlaps we will union them ; there is no cycle ; ",
        "context": "",
        "code": "def checkOverlapping(a, b):\n    a, b = max(a, b), min(a, b)\n    if b[0] <= a[0] <= b[1]:\n        return True\n    return False\n\n\ndef find(a, i):\n    if a[i] == i:\n        return i\n    a[i] = find(a, a[i])\n    return a[i]\n\n\ndef union(a, x, y):\n    xs = find(a, x)\n    ys = find(a, y)\n    if xs == ys:\n        return True\n    a[ys] = xs\n    return False\n\n\ndef checkNonOverlapping(arr, n):\n    dsu = [i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if checkOverlapping(arr[i], arr[j]):\n                if union(dsu, i, j):\n                    return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [[1, 4], [2, 2], [2, 3]]\n    n = len(arr)\n    print(\"YES\"if checkNonOverlapping(arr, n)else \"NO\")\n",
        "output": "NO\n",
        "fn_call": "checkNonOverlapping"
    },
    {
        "text": "minimum lcm of all subarrays of length at least 2 | python3 program for the above approach ; function to find lcm pf two numbers ; initialise lcm value ; check for divisibility of a and b by the lcm ; function to find the minimum lcm of all subarrays of length greater than 1 ; store the minimum lcm ; traverse the array ; find lcm of consecutive element ; check if the calculated lcm is less than the minlcm then update it ; print the minimum lcm ; ",
        "context": "\nimport sys\n\n",
        "code": "def LCM(a, b):\n    lcm = a if a > b else b\n    while (True):\n        if (lcm % a == 0 and lcm % b == 0):\n            break\n        else:\n            lcm += 1\n    return lcm\n\n\ndef findMinLCM(arr, n):\n    minLCM = sys .maxsize\n    for i in range(n - 1):\n        val = LCM(arr[i], arr[i + 1])\n        if (val < minLCM):\n            minLCM = val\n    print(minLCM)\n",
        "test": "\narr = [4, 8, 12, 16, 20, 24]\nn = len(arr)\nfindMinLCM(arr, n)\n",
        "output": "8\n",
        "fn_call": "findMinLCM"
    },
    {
        "text": "program to print the series 1 , 9 , 17 , 33 , 49 , 73 , 97. . . till n terms | function to prthe series ; generate the ith term and print ; ",
        "context": "",
        "code": "def printSeries(N):\n    ith_term = 0\n    for i in range(1, N + 1):\n        ith_term = 0\n        if (i % 2 == 0):\n            ith_term = 2 * i * i + 1\n        else:\n            ith_term = 2 * i * i - 1\n        print(ith_term, end=\", \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 7\n    printSeries(N)\n",
        "output": "1, 9, 17, 33, 49, 73, 97, ",
        "fn_call": "printSeries"
    },
    {
        "text": "print an n x m matrix such that each row and column has all the vowels in it | function to print the required matrix ; impossible to generate the required matrix ; store all the vowels ; print the matrix ; print vowels for every index ; shift the vowels by one ; ",
        "context": "",
        "code": "def printMatrix(n, m):\n    if (n < 5 or m < 5):\n        print(-1, end=\" \")\n        return\n    s = \"aeiou\"\n    s = list(s)\n    for i in range(n):\n        for j in range(m):\n            print(s[j % 5], end=\" \")\n        print()\n        c = s[0]\n        for i in range(4):\n            s[i] = s[i + 1]\n        s[4] = c\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    m = 5\n    printMatrix(n, m)\n",
        "output": "a e i o u \ne i o u a \ni o u a e \no u a e i \nu a e i o \n",
        "fn_call": "printMatrix"
    },
    {
        "text": "gcd of a number raised to some power and another number | python 3 program to find gcd of a ^ n and b . ; returns gcd of a ^ n and b . ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef powGCD(a, n, b):\n    for i in range(0, n + 1, 1):\n        a = a * a\n    return gcd(a, b)\n",
        "test": "\nif __name__ == '__main__':\n    a = 10\n    b = 5\n    n = 2\n    print(powGCD(a, n, b))\n",
        "output": "5\n",
        "fn_call": "powGCD"
    },
    {
        "text": "Sum of all leaf nodes of binary tree | Class for node creation ; constructor ; Utility function to calculate the sum of all leaf nodes ; add root data to sum if root is a leaf node ; propagate recursively in left and right subtree ; Binary tree Fromation ; Variable to store the sum of leaf nodes",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def leafSum(root):\n    global total\n    if root is None:\n        return\n    if (root .left is None and root .right is None):\n        total += root .data\n    leafSum(root .left)\n    leafSum(root .right)\n",
        "test": "\nif __name__ == '__main__':\n    root = Node(1)\n    root .left = Node(2)\n    root .left .left = Node(4)\n    root .left .right = Node(5)\n    root .right = Node(3)\n    root .right .right = Node(7)\n    root .right .left = Node(6)\n    root .right .left .right = Node(8)\n    total = 0\n    leafSum(root)\n    print(total)\n",
        "output": "24\n",
        "fn_call": "leafSum"
    },
    {
        "text": "given number of matches played , find number of teams in tournament | python implementation of the approach ; function to return the number of teams ; to store both roots of the equation ; sqrt ( b ^ 2 - 4 ac ) ; first root ( - b + sqrt ( b ^ 2 - 4 ac ) ) / 2 a ; second root ( - b - sqrt ( b ^ 2 - 4 ac ) ) / 2 a ; return the positive root ; ",
        "context": "\nimport math\n\n",
        "code": "def number_of_teams(M):\n    N1, N2, sqr = 0, 0, 0\n    sqr = math .sqrt(1 + (8 * M))\n    N1 = (1 + sqr) / 2\n    N2 = (1 - sqr) / 2\n    if (N1 > 0):\n        return int(N1)\n    return int(N2)\n\n\ndef main():\n    M = 45\n    print(number_of_teams(M))\n",
        "test": "\nif __name__ == '__main__':\n    main()\n",
        "output": "10\n",
        "fn_call": "main"
    },
    {
        "text": "sum of squares of first n natural numbers | return the sum of square of first n natural numbers ; iterate i from 1 and n finding square of i and add to sum . ; ",
        "context": "",
        "code": "def squaresum(n):\n    sm = 0\n    for i in range(1, n + 1):\n        sm = sm + (i * i)\n    return sm\n",
        "test": "\nn = 4\nprint(squaresum(n))\n",
        "output": "30\n",
        "fn_call": "squaresum"
    },
    {
        "text": "possibility of moving out of maze | function to check whether it will stay inside or come out ; marks all the positions that is visited ; initial starting point ; initial assumption is it comes out ; runs till it is inside or comes out ; if the movement is towards left then we move left . the start variable and mark that position as visited if not visited previously . else we break out ; it will be inside forever ; if the movement is towards right , then we move right . the start variable and mark that position as visited if not visited previously else we break out ; it will be inside forever ; ",
        "context": "",
        "code": "def checkingPossibility(a, n, s):\n    mark = [0] * n\n    start = 0\n    possible = 1\n    while start >= 0 and start < n:\n        if s[start] == \"<\":\n            if mark[start] == 0:\n                mark[start] = 1\n                start -= a[start]\n            else:\n                possible = 0\n                break\n        else:\n            if mark[start] == 0:\n                mark[start] = 1\n                start += a[start]\n            else:\n                possible = 0\n                break\n    if possible == 0:\n        return False\n\n    else:\n        return True\n",
        "test": "\nn = 2\ns = \"><\"\na = [1, 2]\nif (checkingPossibility(a, n, s)):\n    print(\"comes out\")\nelse:\n    print(\"it stays inside forever\")\n",
        "output": "comes out\n",
        "fn_call": "checkingPossibility"
    },
    {
        "text": "count maximum occurrence of subsequence in string such that indices in subsequence is in a . p . | function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; frequencies of subsequence ; loop to find the frequencies of subsequence of length 1 ; loop to find the frequencies subsequence of length 2 ; finding maximum frequency ; ",
        "context": "",
        "code": "def maximumOccurrence(s):\n    n = len(s)\n    freq = {}\n    for i in s:\n        temp = \"\"\n        temp += i\n        freq[temp] = freq .get(temp, 0) + 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp = \"\"\n            temp += s[i]\n            temp += s[j]\n            freq[temp] = freq .get(temp, 0) + 1\n    answer = -10 ** 9\n    for it in freq:\n        answer = max(answer, freq[it])\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    s = \"xxxyy\"\n    print(maximumOccurrence(s))\n",
        "output": "6\n",
        "fn_call": "maximumOccurrence"
    },
    {
        "text": "Find if it 's possible to rotate the page by an angle or not. | Function to find if it 's possible to rotate page or not ; Calculating distance b / w points ; If distance is not equal ; If the points are in same line ; Points a , b , and c",
        "context": "",
        "code": "def possibleOrNot(a1, a2, b1, b2, c1, c2):\n    dis1 = (pow(b1 - a1, 2) + pow(b2 - a2, 2))\n    dis2 = (pow(c1 - b1, 2) + pow(c2 - b2, 2))\n    if (dis1 != dis2):\n        print(\"No\")\n    elif (b1 == ((a1 + c1) // 2.0) and b2 == ((a2 + c2) // 2.0)):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n",
        "test": "\na1, b1, c1 = 1, 2, 3\na2 = b2 = c2 = 0\npossibleOrNot(a1, a2, b1, b2, c1, c2)\n",
        "output": "No\n",
        "fn_call": "possibleOrNot"
    },
    {
        "text": "maximize count of pairs ( i , j ) from two arrays having element from first array not exceeding that from second array | function to return the maximum number of required pairs ; max heap to add values of arr2 [ ] ; sort the array arr1 [ ] ; push all arr2 [ ] into max heap ; initialize the ans ; traverse the arr1 [ ] in decreasing order ; remove element until a required pair is found ; return maximum number of pairs ; ",
        "context": "",
        "code": "def numberOfPairs(arr1, n, arr2, m):\n    pq = []\n    arr1 .sort(reverse=False)\n    for j in range(m):\n        pq .append(arr2[j])\n    ans = 2\n    i = n - 1\n    while (i >= 0):\n        pq .sort(reverse=False)\n        if (pq[0] >= 2 * arr1[i]):\n            ans += 1\n            print(pq[0])\n            pq .remove(pq[0])\n        i -= 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr1 = [3, 2, 1]\n    arr2 = [3, 4, 2, 1]\n    N = len(arr1)\n    M = len(arr2)\n    print(numberOfPairs(arr1, N, arr2, M))\n",
        "output": "2\n",
        "fn_call": "numberOfPairs"
    },
    {
        "text": "rearrange array such that arr [ i ] >= arr [ j ] if i is even and arr [ i ] <= arr [ j ] if i is odd and j < i | python3 code to rearrange the array as per the given condition ; function to rearrange the array ; total even positions ; total odd positions ; copy original array in an auxiliary array ; sort the auxiliary array ; fill up odd position in original array ; fill up even positions in original array ; display array ; ",
        "context": "\nimport array as a\nimport numpy as np\n\n",
        "code": "def rearrangeArr(arr, n):\n    evenPos = int(n / 2)\n    oddPos = n - evenPos\n    tempArr = np .empty(n, dtype=object)\n    for i in range(0, n):\n        tempArr[i] = arr[i]\n    tempArr .sort()\n    j = oddPos - 1\n    for i in range(0, n, 2):\n        arr[i] = tempArr[j]\n        j = j - 1\n    j = oddPos\n    for i in range(1, n, 2):\n        arr[i] = tempArr[j]\n        j = j + 1\n    for i in range(0, n):\n        print(arr[i], end=' ')\n",
        "test": "\narr = a .array('i', [1, 2, 3, 4, 5, 6, 7])\nrearrangeArr(arr, 7)\n",
        "output": "4 5 3 6 2 7 1 ",
        "fn_call": "rearrangeArr"
    },
    {
        "text": "shortest path with exactly k edges in a directed and weighted graph | define number of vertices in the graph and inifinite value ; a naive recursive function to count walks from u to v with k edges ; base cases ; initialize result ; go to all adjacents of u and recur ; ",
        "context": "\nV = 4\nINF = 999999999999\n\n",
        "code": "def shortestPath(graph, u, v, k):\n    if k == 0 and u == v:\n        return 0\n    if k == 1 and graph[u][v] != INF:\n        return graph[u][v]\n    if k <= 0:\n        return INF\n    res = INF\n    for i in range(V):\n        if graph[u][i] != INF and u != i and v != i:\n            rec_res = shortestPath(graph, i, v, k - 1)\n            if rec_res != INF:\n                res = min(res, graph[u][i] + rec_res)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    INF = 999999999999\n    graph = [[0, 10, 3, 2], [INF, 0, INF, 7],\n             [INF, INF, 0, 6], [INF, INF, INF, 0]]\n    u = 0\n    v = 3\n    k = 2\n    print(\"Weight of the shortest path is\", shortestPath(graph, u, v, k))\n",
        "output": "Weight of the shortest path is 9\n",
        "fn_call": "shortestPath"
    },
    {
        "text": "minimize segments required to be removed such that at least one segment intersects with all remaining segments | pyhton3 program for the above approach ; function to find the minimum number of segments required to be deleted ; stores the start and end points ; traverse segments and fill the startpoints and endpoints ; sort the startpoints ; sort the startpoints ; store the minimum number of deletions required and initialize with ( n - 1 ) ; traverse the array segments [ ] ; store the starting point ; store the ending point ; store the number of segments satisfying the first condition of non - intersection ; store the number of segments satisfying the second condition of non - intersection ; update answer ; print the answer ; ",
        "context": "\nfrom bisect import bisect_left, bisect_right\n\n",
        "code": "def minSegments(segments, n):\n    startPoints = [0 for i in range(n)]\n    endPoints = [0 for i in range(n)]\n    for i in range(n):\n        startPoints[i] = segments[i][0]\n        endPoints[i] = segments[i][1]\n    startPoints .sort(reverse=False)\n    endPoints .sort(reverse=False)\n    ans = n - 1\n    for i in range(n):\n        f = segments[i][0]\n        s = segments[i][1]\n        leftDelete = bisect_left(endPoints, f)\n        rightDelete = max(0, n - bisect_right(startPoints, s))\n        ans = min(ans, leftDelete + rightDelete)\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, 2], [5, 6], [6, 7], [7, 10], [8, 9]]\n    N = len(arr)\n    minSegments(arr, N)\n",
        "output": "2\n",
        "fn_call": "minSegments"
    },
    {
        "text": "sum of elements in an array whose difference with the mean of another array is less than k | function for finding sum of elements whose diff with mean is not more than k ; find the mean of second array ; find sum of elements from array1 whose difference with mean is not more than k ; return result ; ",
        "context": "",
        "code": "def findSumofEle(arr1, m, arr2, n, k):\n    arraySum = 0\n    for i in range(n):\n        arraySum += arr2[i]\n    mean = arraySum / n\n    sumOfElements = 0\n    difference = 0\n    for i in range(m):\n        difference = arr1[i] - mean\n        if ((difference  (-1) * difference)):\n            sumOfElements += arr1[i]\n        if ((difference >= 0) and (k > difference)):\n            sumOfElements += arr1[i]\n    return sumOfElements\n",
        "test": "\narr1 = [1, 2, 3, 4, 7, 9]\narr2 = [0, 1, 2, 1, 1, 4]\nk = 2\nm = len(arr1)\nn = len(arr2)\nprint(findSumofEle(arr1, m, arr2, n, k))\n",
        "output": "6\n",
        "fn_call": "findSumofEle"
    },
    {
        "text": "elements of array which can be expressed as power of prime numbers | function to mark all the exponent of prime numbers ; if number is prime then marking all of its exponent true ; function to display all required elements ; function to print the required numbers ; to find the largest number ; function call to mark all the exponential prime nos . ; function call ; ",
        "context": "",
        "code": "def ModifiedSieveOfEratosthenes(N, Expo_Prime):\n    primes = [True] * N\n    for i in range(2, N):\n        if (primes[i]):\n            no = i\n            while (no <= N):\n                Expo_Prime[no] = True\n                no *= i\n            for j in range(i * i, N, i):\n                primes[j] = False\n\n\ndef Display(arr, Expo_Prime, n):\n    for i in range(n):\n        if (Expo_Prime[arr[i]]):\n            print(arr[i], end=\" \")\n\n\ndef FindExpoPrime(arr, n):\n    max = 0\n    for i in range(n):\n        if (max < arr[i]):\n            max = arr[i]\n    Expo_Prime = [False] * (max + 1)\n    ModifiedSieveOfEratosthenes(max + 1, Expo_Prime)\n    Display(arr, Expo_Prime, n)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 6, 9, 16, 1, 3, 12, 36, 625, 1000]\n    n = len(arr)\n    FindExpoPrime(arr, n)\n",
        "output": "4 9 16 3 625 ",
        "fn_call": "FindExpoPrime"
    },
    {
        "text": "maximum difference of zeros and ones in binary string | python program to find the length of substring with maximum difference of zeroes and ones in binary string . ; return true if there all 1 s ; checking each index is 0 or not . ; find the length of substring with maximum difference of zeroes and ones in binary string ; if string is over ; if the state is already calculated . ; returns length of substring which is having maximum difference of number of 0 s and number of 1 s ; if all 1 s return - 1. ; else find the length . ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def allones(s, n):\n    co = 0\n    for i in s:\n        co += 1 if i == '1'else 0\n    return co == n\n\n\ndef findlength(arr, s, n, ind, st, dp):\n    if ind >= n:\n        return 0\n    if dp[ind][st] != -1:\n        return dp[ind][st]\n    if not st:\n        dp[ind][st] = max(\n            arr[ind] +\n            findlength(\n                arr,\n                s,\n                n,\n                ind +\n                1,\n                1,\n                dp),\n            (findlength(\n                arr,\n                s,\n                n,\n                ind +\n                1,\n                0,\n                dp)))\n    else:\n        dp[ind][st] = max(arr[ind] + findlength(arr, s, n, ind + 1, 1, dp), 0)\n    return dp[ind][st]\n\n\ndef maxLen(s, n):\n    if allones(s, n):\n        return -1\n    arr = [0] * MAX\n    for i in range(n):\n        arr[i] = 1 if s[i] == '0'else -1\n    dp = [[-1] * 3 for _ in range(MAX)]\n    return findlength(arr, s, n, 0, 0, dp)\n",
        "test": "\ns = \"11000010001\"\nn = 11\nprint(maxLen(s, n))\n",
        "output": "6\n",
        "fn_call": "maxLen"
    },
    {
        "text": "find n distinct integers with zero sum | function to print distinct n numbers such that their sum is 0 ; print 2 symmetric numbers ; print a extra 0 if n is odd ; ",
        "context": "",
        "code": "def findNumbers(N):\n    for i in range(1, N // 2 + 1):\n        print(i, end=', ')\n        print(-i, end=', ')\n    if N % 2 == 1:\n        print(0, end='')\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    findNumbers(N)\n",
        "output": "1, -1, 2, -2, 3, -3, 4, -4, 5, -5, ",
        "fn_call": "findNumbers"
    },
    {
        "text": "find if string is k | find if given string is k - palindrome or not ; if first string is empty , the only option is to remove all characters of second string ; if second string is empty , the only option is to remove all characters of first string ; if last characters of two strings are same , ignore last characters and get count for remaining strings . ; if last characters are not same , 1. remove last char from str1 and recur for m - 1 and n 2. remove last char from str2 and recur for m and n - 1 take minimum of above two operations res = 1 + min ( iskpalrec ( str1 , str2 , m - 1 , n ) , remove from str1 ( iskpalrec ( str1 , str2 , m , n - 1 ) ) ) remove from str2 ; returns true if str is k palindrome . ; ",
        "context": "",
        "code": "def isKPalRec(str1, str2, m, n):\n    if not m:\n        return n\n    if not n:\n        return m\n    if str1[m - 1] == str2[n - 1]:\n        return isKPalRec(str1, str2, m - 1, n - 1)\n    res = 1 + min(isKPalRec(str1, str2, m-1, n),\n                  (isKPalRec(str1, str2, m, n-1)))\n    return res\n\n\ndef isKPal(string, k):\n    revStr = string[::-1]\n    l = len(string)\n    return (isKPalRec(string, revStr, l, l) <= k * 2)\n",
        "test": "\nstring = \"acdcb\"\nk = 2\nprint(\"Yes\" if isKPal(string, k) else \"No\")\n",
        "output": "Yes\n",
        "fn_call": "isKPal"
    },
    {
        "text": "print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | function to print the required pattern ; when condition fails ; when m = n - 1 ; ",
        "context": "",
        "code": "def printPattern(n, m):\n    if (m > 2 * (n + 1) or m < n - 1):\n        print(\"-1\", end=\"\")\n    elif (abs(n - m) <= 1):\n        while (n > 0 and m > 0):\n            print(\"01\", end=\"\")\n            n -= 1\n            m -= 1\n        if (n != 0):\n            print(\"0\", end=\"\")\n        if (m != 0):\n            print(\"1\", end=\"\")\n    else:\n        while (m - n > 1 and n > 0):\n            print(\"110\", end=\"\")\n            m = m - 2\n            n = n - 1\n        while (n > 0):\n            print(\"10\", end=\"\")\n            n -= 1\n            m -= 1\n        while (m > 0):\n            print(\"1\", end=\"\")\n            m -= 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    m = 8\n    printPattern(n, m)\n",
        "output": "110110110101",
        "fn_call": "printPattern"
    },
    {
        "text": "maximize the division result of array using given operations | function to find the max result ; sort the array in descending order ; loop to divide in this order arr [ 0 ] / ( arr [ 1 ] / arr [ 2 ] / ... . arr [ n - 2 ] / arr [ n - 1 ] ) ; return the final result ; ",
        "context": "",
        "code": "def maxDivision(arr, n):\n    arr .sort(reverse=True)\n    mxdiv = arr[1]\n    for i in range(2, n):\n        mxdiv = mxdiv / arr[i]\n    return arr[0] / mxdiv\n",
        "test": "\narr = [100, 1000, 10, 2]\nn = len(arr)\nprint(maxDivision(arr, n))\n",
        "output": "200.0\n",
        "fn_call": "maxDivision"
    },
    {
        "text": "smallest element greater than x not present in the array | function to return the smallest element greater than x which is not present in a [ ] ; sort the array ; continue until low is less than or equals to high ; find mid ; if element at mid is less than or equals to searching element ; if mid is equals to searching element ; increment searching element ; make high as n - 1 ; make low as mid + 1 ; make high as mid - 1 ; return the next greater element ; ",
        "context": "",
        "code": "def Next_greater(a, n, x):\n    a = sorted(a)\n    low, high, ans = 0, n - 1, x + 1\n    while (low <= high):\n        mid = (low + high) // 2\n        if (a[mid] <= ans):\n            if (a[mid] == ans):\n                ans += 1\n                high = n - 1\n            low = mid + 1\n        else:\n            high = mid - 1\n    return ans\n",
        "test": "\na = [1, 5, 10, 4, 7]\nx = 4\nn = len(a)\nprint(Next_greater(a, n, x))\n",
        "output": "6\n",
        "fn_call": "Next_greater"
    },
    {
        "text": "count of right | python3 program for the above approach ; function to find the number of right angled triangle that are formed from given n points whose perpendicular or base is parallel to x or y axis ; to store the number of points has same x or y coordinates ; store the total count of triangle ; iterate to check for total number of possible triangle ; add the count of triangles formed ; total possible triangle ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def RightAngled(a, n):\n    xpoints = defaultdict(lambda: 0)\n    ypoints = defaultdict(lambda: 0)\n    for i in range(n):\n        xpoints[a[i][0]] += 1\n        ypoints[a[i][1]] += 1\n    count = 0\n    for i in range(n):\n        if (xpoints[a[i][0]] >= 1 and ypoints[a[i][1]] >= 1):\n            count += ((xpoints[a[i][0]] - 1) * (ypoints[a[i][1]] - 1))\n    return count\n",
        "test": "\nN = 5\narr = [[1, 2], [2, 1], [2, 2], [2, 3], [3, 2]]\nprint(RightAngled(arr, N))\n",
        "output": "4\n",
        "fn_call": "RightAngled"
    },
    {
        "text": "maximum sum such that no two elements are adjacent | set 2 | python 3 program to implement above approach ; variable to store states of dp ; variable to check if a given state has been solved ; function to find the maximum sum subsequence such that no two elements are adjacent ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; ",
        "context": "\nmaxLen = 10\ndp = [0 for i in range(maxLen)]\nv = [0 for i in range(maxLen)]\n\n",
        "code": "def maxSum(arr, i, n):\n    if (i >= n):\n        return 0\n    if (v[i]):\n        return dp[i]\n    v[i] = 1\n    dp[i] = max(maxSum(arr, i + 1, n), arr[i] + maxSum(arr, i + 2, n))\n    return dp[i]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [12, 9, 7, 33]\n    n = len(arr)\n    print(maxSum(arr, 0, n))\n",
        "output": "45\n",
        "fn_call": "maxSum"
    },
    {
        "text": "find farthest node from each node in tree | add edge between u and v in tree ; edge from u to v ; edge from v to u ; dfs to find the first end node of diameter ; calculating level of nodes ; go in opposite direction of parent ; function to clear the levels of the nodes ; set all value of lvl [ ] to 0 for next dfs ; set maximum with 0 ; dfs will calculate second end of the diameter ; calculating level of nodes ; store the node with maximum depth from end1 ; go in opposite direction of parent ; function to find the distance of the farthest distant node ; storing distance from end1 to node u ; function to find the distance of nodes from second end of diameter ; storing distance from end2 to node u ; joining edge between two nodes of the tree ; find the one end of the diameter of tree ; find the other end of the diameter of tree ; find the distance to each node from end1 ; find the distance to each node from end2 ; comparing distance between the two ends of diameter ; ",
        "context": "",
        "code": "def AddEdge(u, v):\n    global adj\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef findFirstEnd(u, p):\n    global lvl, adj, end1, maxi\n    lvl[u] = 1 + lvl[p]\n    if (lvl[u] > maxi):\n        maxi = lvl[u]\n        end1 = u\n    for i in range(len(adj[u])):\n        if (adj[u][i] != p):\n            findFirstEnd(adj[u][i], u)\n\n\ndef clear(n):\n    global lvl, dist1, dist2\n    for i in range(n + 1):\n        lvl[i] = 0\n    maxi = 0\n    dist1[0] = dist2[0] = -1\n\n\ndef findSecondEnd(u, p):\n    global lvl, adj, maxi, end2\n    lvl[u] = 1 + lvl[p]\n    if (lvl[u] > maxi):\n        maxi = lvl[u]\n        end2 = u\n    for i in range(len(adj[u])):\n        if (adj[u][i] != p):\n            findSecondEnd(adj[u][i], u)\n\n\ndef findDistancefromFirst(u, p):\n    global dist1, adj\n    dist1[u] = 1 + dist1[p]\n    for i in range(len(adj[u])):\n        if (adj[u][i] != p):\n            findDistancefromFirst(adj[u][i], u)\n\n\ndef findDistancefromSecond(u, p):\n    global dist2, adj\n    dist2[u] = 1 + dist2[p]\n    for i in range(len(adj[u])):\n        if (adj[u][i] != p):\n            findDistancefromSecond(adj[u][i], u)\n\n\ndef findNodes():\n    global adj, lvl, dist1, dist2, end1, end2, maxi\n    n = 5\n    AddEdge(1, 2)\n    AddEdge(1, 3)\n    AddEdge(3, 4)\n    AddEdge(3, 5)\n    findFirstEnd(1, 0)\n    clear(n)\n    findSecondEnd(end1, 0)\n    findDistancefromFirst(end1, 0)\n    findDistancefromSecond(end2, 0)\n    for i in range(1, n + 1):\n        x = dist1[i]\n        y = dist2[i]\n        if (x >= y):\n            print(end1, end=\" \")\n        else:\n            print(end2, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    adj = [[]for i in range(10000)]\n    lvl = [0 for i in range(10000)]\n    dist1 = [-1 for i in range(10000)]\n    dist2 = [-1 for i in range(10000)]\n    end1, end2, maxi = 0, 0, 0\n    findNodes()\n",
        "output": "4 4 2 2 2 ",
        "fn_call": "findNodes"
    },
    {
        "text": "count subarrays consisting of first k natural numbers in descending order | function to count subarray having the decreasing sequence k to 1 ; traverse the array ; check if required sequence is present or not ; reset temp to k ; return the count ; ",
        "context": "",
        "code": "def CountSubarray(arr, n, k):\n    temp = k\n    count = 0\n    for i in range(n):\n        if (arr[i] == temp):\n            if (temp == 1):\n                count += 1\n                temp = k\n            else:\n                temp -= 1\n        else:\n            temp = k\n            if (arr[i] == k):\n                i -= 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 7, 9, 3, 2, 1, 8, 3, 2, 1]\n    N = len(arr)\n    K = 3\n    print(CountSubarray(arr, N, K))\n",
        "output": "2\n",
        "fn_call": "CountSubarray"
    },
    {
        "text": "frobenius coin problem | utility function to find gcd ; function to print the desired output ; solution doesn 't exist   if gcd is not 1 ; else apply the formula ; ",
        "context": "",
        "code": "def gcd(a, b):\n    while (a != 0):\n        c = a\n        a = b % a\n        b = c\n    return b\n\n\ndef forbenius(X, Y):\n    if (gcd(X, Y) != 1):\n        print(\"NA\")\n        return\n    A = (X * Y) - (X + Y)\n    N = (X - 1) * (Y - 1) // 2\n    print(\"Largest Amount =\", A)\n    print(\"Total Count =\", N)\n",
        "test": "\nX = 2\nY = 5\nforbenius(X, Y)\nX = 5\nY = 10\nprint(\"\")\nforbenius(X, Y)\n",
        "output": "Largest Amount = 3\nTotal Count = 2\n\nNA\n",
        "fn_call": "forbenius"
    },
    {
        "text": "check whether two numbers are in silver ratio | function to check that two numbers are in silver ratio ; swapping the numbers such that a contains the maximum number between these numbers ; first ratio ; second ratio ; condition to check that two numbers are in silver ratio ; ",
        "context": "",
        "code": "def checksilverRatio(a, b):\n    a, b = max(a, b), min(a, b)\n    ratio1 = round(a / b, 3)\n    ratio2 = round((2 * a + b) / a, 3)\n    if ratio1 == ratio2 and ratio1 == 2.414:\n        print(\"Yes\")\n        return True\n    else:\n        print(\"No\")\n        return False\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 2.414\n    b = 1\n    checksilverRatio(a, b)\n",
        "output": "Yes\n",
        "fn_call": "checksilverRatio"
    },
    {
        "text": "maximum score assigned to a subsequence of numerically consecutive and distinct array elements | ''function to find the maximum score possible ; '' base case ; '' if previously occurred  subproblem occurred ; '' check if lastpicked element differs  by 1 from the current element ; '' calculate score by including  the current element ; '' calculate score by excluding  the current element ; '' return maximum score from  the two possibilities ; ''function to print maximum score ; '' dp array to store results ; '' function call ; ''",
        "context": "",
        "code": "def maximumSum(a, b, n, index, lastpicked, dp):\n    if (index == n):\n        return 0\n    if (dp[index][lastpicked + 1] != -1):\n        return dp[index][lastpicked + 1]\n    option1, option2 = 0, 0\n    if (lastpicked == -1 or a[lastpicked] != a[index]):\n        option1 = (b[index] + maximumSum(a, b, n, index + 1, index, dp))\n    option2 = maximumSum(a, b, n, index + 1, lastpicked, dp)\n    dp[index][lastpicked + 1] = max(option1, option2)\n    return dp[index][lastpicked + 1]\n\n\ndef maximumPoints(arr, brr, n):\n    index = 0\n    lastPicked = -1\n    dp = [[-1 for x in range(n + 5)]for y in range(n + 5)]\n    print(maximumSum(arr, brr, n, index, lastPicked, dp))\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 3, 3, 1]\n    brr = [-1, 2, 10, 20, -10, -9]\n    N = len(arr)\n    maximumPoints(arr, brr, N)\n",
        "output": "22\n",
        "fn_call": "maximumPoints"
    },
    {
        "text": "program for chocolate and wrapper puzzle | returns maximum number of chocolates we can eat with given money , price of chocolate and number of wrapprices required to get a chocolate . ; corner case ; first find number of chocolates that can be purchased with the ",
        "context": "",
        "code": "def countMaxChoco(money, price, wrap):\n    if (money < price):\n        return 0\n    choc = int(money / price)\n    choc = choc + (choc - 1) / (wrap - 1)\n    return int(choc)\n",
        "test": "\nmoney = 15\nprice = 1\nwrap = 3\nprint(countMaxChoco(money, price, wrap))\n",
        "output": "22\n",
        "fn_call": "countMaxChoco"
    },
    {
        "text": "sum of series 1 * 1 ! + 2 * 2 ! + \u2026\u2026 . . + n * n ! | python program to find sum of the series . ; function to calculate required series ; ",
        "context": "",
        "code": "def factorial(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef calculateSeries(n):\n    return factorial(n + 1) - 1\n",
        "test": "\nn = 3\nprint(calculateSeries(n))\n",
        "output": "23\n",
        "fn_call": "calculateSeries"
    },
    {
        "text": "minimize swaps required to maximize the count of elements replacing a greater element in an array | function to find the minimum number of swaps required ; sort the array in ascending order ; iterate until a greater element is found ; keep incrementing ind ; if a greater element is found ; increase count of swap ; increment ind ; if end of array is reached ; return the answer ; ",
        "context": "",
        "code": "def countSwaps(A, n):\n    A .sort()\n    ind, res = 1, 0\n    for i in range(n):\n        while (ind < n and A[ind] == A[i]):\n            ind += 1\n        if (ind  A[i]):\n            res += 1\n            ind += 1\n        if (ind >= n):\n            break\n    return res\n",
        "test": "\nA = [4, 3, 3, 2, 5]\nprint(countSwaps(A, 5))\n",
        "output": "3\n",
        "fn_call": "countSwaps"
    },
    {
        "text": "maximum times x and y can be reduced to near 0 using numbers a or b | helper function to check if we can perform mid number of moves ; remove atleast mid * b from both x and y ; if any value is negative return false . ; calculate remaining values ; if val >= mid then it is possible to perform this much moves ; else return false ; initialize a variable to store the answer ; fix the left and right range ; binary search over the answer ; check for the middle value as the answer ; it is possible to perform this much moves ; maximise the answer ; return answer ; ",
        "context": "\nMAXN = 10000000\n\n",
        "code": "def can(Mid, X, Y, A, B):\n    p1 = X - Mid * B\n    p2 = Y - Mid * B\n    if (p1 < 0 or p2 < 0):\n        return False\n    k = A - B\n    if (k == 0):\n        return True\n    val = p1 // k + p2 // k\n    if (val >= Mid):\n        return True\n    return False\n\n\ndef maxPossibleMoves(X, Y, A, B):\n    ans = 0\n    L = 1\n    R = MAXN\n    while (L <= R):\n        Mid = (L + R) // 2\n        if (can(Mid, X, Y, A, B)):\n            L = Mid + 1\n            ans = max(ans, Mid)\n        else:\n            R = Mid - 1\n    return ans\n",
        "test": "\nX = 10\nY = 12\nA = 2\nB = 5\nif (A < B):\n    tmp = A\n    A = B\n    B = tmp\nprint(maxPossibleMoves(X, Y, A, B))\n",
        "output": "3\n",
        "fn_call": "maxPossibleMoves"
    },
    {
        "text": "lexicographically largest n | function to find the lexicographically largest bitonic sequence of size n elements lies in the range [ low , high ] ; store index of highest element ; if high_index > ( n - 1 ) / 2 , then remaining n / 2 elements cannot be placed in bitonic order ; if high_index <= 0 , then set high_index as 1 ; stores the resultant sequence ; store the high value ; maintain strictly decreasing sequence from index high_index to 0 starting with temp ; store the value and decrement the temp variable by 1 ; maintain the strictly decreasing sequence from index high_index + 1 to n - 1 starting with high - 1 ; store the value and decrement high by 1 ; print the resultant sequence ; ",
        "context": "",
        "code": "def LargestArray(N, low, high):\n    high_index = N - (high - low + 1)\n    if (high_index > (N - 1) // 2):\n        print(\"Not Possible\")\n        return\n    if (high_index <= 0):\n        high_index = 1\n    A = [0] * N\n    temp = high\n    for i in range(high_index, -1, -1):\n        A[i] = temp\n        temp = temp - 1\n    high -= 1\n    for i in range(high_index + 1, N):\n        A[i] = high\n        high = high - 1\n    for i in range(N):\n        print(A[i], end=\" \")\n",
        "test": "\nN = 5\nlow = 2\nhigh = 6\nLargestArray(N, low, high)\n",
        "output": "5 6 5 4 3 ",
        "fn_call": "LargestArray"
    },
    {
        "text": "modify the string by swapping continuous vowels or consonants | function to check if a character is a vowel ; function to swap two consecutively repeated vowels or consonants ; traverse through the length of the string ; check if the two consecutive characters are vowels or consonants ; swap the two characters ; ",
        "context": "",
        "code": "def isVowel(c):\n    c = c .lower()\n    if (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u'):\n        return True\n    return False\n\n\ndef swapRepeated(string):\n    for i in range(len(string) - 1):\n        if ((isVowel(string[i]) and isVowel(string[i + 1]))\n                or (not (isVowel(string[i])) and not (isVowel(string[i + 1])))):\n            (string[i], string[i + 1]) = (string[i + 1], string[i])\n    string = \"\".join(string)\n    return string\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    print(swapRepeated(list(string)))\n",
        "output": "geesfkogreesk\n",
        "fn_call": "swapRepeated"
    },
    {
        "text": "maximizing unique pairs from two arrays | returns count of maximum pairs that can be formed from a [ ] and b [ ] under given constraints . ; sorting the first array . ; sorting the second array . ; to keep track of visited elements of b [ ] ; for every element of a [ ] , find a pair for it and break as soon as a pair is found . ; increasing the count if a pair is formed . ; making the corresponding flag array element as 1 indicating the element in the second array element has been used . ; we break the loop to make sure an element of a [ ] is used only once . ; ",
        "context": "",
        "code": "def findMaxPairs(a, b, n, k):\n    a .sort()\n    b .sort()\n    flag = [False] * n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            if (abs(a[i] - b[j]) <= k and flag[j] == False):\n                result += 1\n                flag[j] = True\n                break\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [10, 15, 20]\n    b = [17, 12, 24]\n    n = len(a)\n    k = 3\n    print(findMaxPairs(a, b, n, k))\n",
        "output": "2\n",
        "fn_call": "findMaxPairs"
    },
    {
        "text": "sum of bitwise and of all possible subsets of given set | python3 program to calculate sum of bit - wise and sum of all subsets of an array ; assuming representation of each element is in 32 bit ; iterating array element ; counting the set bit of array in ith position ; counting subset which produce sum when particular bit position is set . ; multiplying every position subset with 2 ^ i to count the sum . ; ",
        "context": "\nBITS = 32\n\n",
        "code": "def andSum(arr, n):\n    ans = 0\n    for i in range(0, BITS):\n        countSetBits = 0\n        for j in range(0, n):\n            if (arr[j] & (1 << i)):\n                countSetBits = (countSetBits + 1)\n        subset = ((1 << countSetBits) - 1)\n        subset = (subset * (1 << i))\n        ans = ans + subset\n    return ans\n",
        "test": "\narr = [1, 2, 3]\nsize = len(arr)\nprint(andSum(arr, size))\n",
        "output": "9\n",
        "fn_call": "andSum"
    },
    {
        "text": "find tangent at a given point on the curve | function for find tangent ; differentiate given equation ; check that point on the curve or not ; if differentiate is negative ; differentiate is positive ; differentiate is zero ; ",
        "context": "",
        "code": "def findTangent(A, x, y):\n    dif = A - x * 2\n    if y == (2 * x - x * x):\n        if dif < 0:\n            print(\"y =\", dif, \"x\", (x * dif) + (y))\n        elif dif > 0:\n            print(\"y =\", dif, \"x+\", -x * dif + y)\n        else:\n            print(\"Not Possible\")\n",
        "test": "\nif __name__ == \"__main__\":\n    A, x, y = 2, 2, 0\n    findTangent(A, x, y)\n",
        "output": "y = -2 x -4\n",
        "fn_call": "findTangent"
    },
    {
        "text": "product of maximum in first array and minimum in second | function to calculate the product ; sort the arrays to find the maximum and minimum elements in given arrays ; return product of maximum and minimum . ; ",
        "context": "",
        "code": "def minmaxProduct(arr1, arr2, n1, n2):\n    arr1 .sort()\n    arr2 .sort()\n    return arr1[n1 - 1] * arr2[0]\n",
        "test": "\narr1 = [10, 2, 3, 6, 4, 1]\narr2 = [5, 1, 4, 2, 6, 9]\nn1 = len(arr1)\nn2 = len(arr2)\nprint(minmaxProduct(arr1, arr2, n1, n2))\n",
        "output": "10\n",
        "fn_call": "minmaxProduct"
    },
    {
        "text": "find sum of exponents of prime factors of numbers 1 to n | function to implement sieve of erastosthenes ; create a boolean array and initialize all entries as false ; initializing smallest factor equal to 2 for all the even numbers ; iterate for odd numbers less then equal to n ; s ( i ) for a prime is the number itself ; for all multiples of current prime number ; i is the smallest prime factor for number \" i * j \" ; function to generate prime factors and its power ; s [ i ] is going to store smallest prime factor of i ; current prime factor of n ; power of current prime factor ; calculating prime factors and their powers sum ; increment the count and continue the process ; add count to the sum ; reinitialize count ; return the result ; function to find the sum of all the power of prime factors of n ; iterate for in [ 2 , n ] ; ",
        "context": "",
        "code": "def sieveOfEratosthenes(N, s):\n    prime = [False] * (N + 1)\n    for i in range(2, N + 1, 2):\n        s[i] = 2\n    for i in range(3, N + 1, 2):\n        if (prime[i] == False):\n            s[i] = i\n            j = i\n            while (j * i <= N):\n                if (prime[i * j] == False):\n                    prime[i * j] = True\n                    s[i * j] = i\n                j += 2\n\n\ndef generatePrimeFactors(N):\n    s = [0] * (N + 1)\n    sum = 0\n    sieveOfEratosthenes(N, s)\n    curr = s[N]\n    cnt = 1\n    while (N > 1):\n        N //= s[N]\n        if (curr == s[N]):\n            cnt += 1\n            continue\n        sum = sum + cnt\n        curr = s[N]\n        cnt = 1\n    return sum\n\n\ndef findSum(N):\n    sum = 0\n    for i in range(2, N + 1):\n        sum += generatePrimeFactors(i)\n    print(sum)\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    findSum(N)\n",
        "output": "4\n",
        "fn_call": "findSum"
    },
    {
        "text": "count number of paths with at | python3 program to count number of paths with maximum k turns allowed ; table to store results of subproblems ; returns count of paths to reach ( i , j ) from ( 0 , 0 ) using at - most k turns . d is current direction , d = 0 indicates along row , d = 1 indicates along column . ; if invalid row or column indexes ; if current cell is top left itself ; if 0 turns left ; if direction is row , then we can reach here only if direction is row and row is 0. ; if direction is column , then we can reach here only if direction is column and column is 0. ; if this subproblem is already evaluated ; if current direction is row , then count paths for two cases 1 ) we reach here through previous row . 2 ) we reach here through previous column , so number of turns k reduce by 1. ; similar to above if direction is column ; this function mainly initializes ' dp ' array as - 1 and calls countpathsutil ( ) ; if ( 0 , 0 ) is target itself ; recur for two cases : moving along row and along column ; ",
        "context": "\nMAX = 100\ndp = [[[[-1 for col in range(2)]for col in range(MAX)]\n       for row in range(MAX)]for row in range(MAX)]\n\n",
        "code": "def countPathsUtil(i, j, k, d):\n    if (i < 0 or j < 0):\n        return 0\n    if (i == 0 and j == 0):\n        return 1\n    if (k == 0):\n        if (d == 0 and i == 0):\n            return 1\n        if (d == 1 and j == 0):\n            return 1\n        return 0\n    if (dp[i][j][k][d] != -1):\n        return dp[i][j][k][d]\n    if (d == 0):\n        dp[i][j][k][d] = countPathsUtil(\n            i, j - 1, k, d) + countPathsUtil(i - 1, j, k - 1, not d)\n        return dp[i][j][k][d]\n    dp[i][j][k][d] = countPathsUtil(\n        i - 1, j, k, d) + countPathsUtil(i, j - 1, k - 1, not d)\n    return dp[i][j][k][d]\n\n\ndef countPaths(i, j, k):\n    if (i == 0 and j == 0):\n        return 1\n    return countPathsUtil(i - 1, j, k, 1) + countPathsUtil(i, j - 1, k, 0)\n",
        "test": "\nif __name__ == '__main__':\n    m = 3\n    n = 3\n    k = 2\n    print(\"Number of paths is\", countPaths(m - 1, n - 1, k))\n",
        "output": "Number of paths is 4\n",
        "fn_call": "countPaths"
    },
    {
        "text": "minimum adjacent swaps required to make a binary string alternating | function to find the minimum number of adjacent swaps to make the string alternating ; count the no of zeros and ones ; base case ; store no of min swaps when string starts with \"1\" ; keep track of the odd positions ; checking for when the string starts with \"1\" ; adding the no of swaps to fix \"1\" at odd positions ; store no of min swaps when string starts with \"0\" ; keep track of the odd positions ; checking for when the string starts with \"0\" ; adding the no of swaps to fix \"1\" at odd positions ; returning the answer based on the conditions when string length is even ; when string length is odd ; when no of ones is greater than no of zeros ; when no of ones is greater than no of zeros ; ",
        "context": "",
        "code": "def minSwaps(s):\n    ones = 0\n    zeros = 0\n    N = len(s)\n    for i in range(N):\n        if s[i] == '1':\n            ones += 1\n        else:\n            zeros += 1\n    if ((N % 2 == 0 and ones != zeros) or (N %\n                                           2 == 1 and abs(ones - zeros) != 1)):\n        return -1\n    ans_1 = 0\n    j = 0\n    for i in range(N):\n        if (s[i] == '1'):\n            ans_1 += abs(j - i)\n            j += 2\n    ans_0 = 0\n    k = 0\n    for i in range(N):\n        if (s[i] == '0'):\n            ans_0 += abs(k - i)\n            k += 2\n    if (N % 2 == 0):\n        return min(ans_1, ans_0)\n    else:\n        if (ones > zeros):\n            return ans_1\n        else:\n            return ans_0\n",
        "test": "\nif __name__ == '__main__':\n    S = \"110100\"\n    print(minSwaps(S))\n",
        "output": "2\n",
        "fn_call": "minSwaps"
    },
    {
        "text": "maximum string partition | return the count of string ; p will store the answer ; current will store current string previous will store the previous that has been taken already ; add a character to current string ; here we will create a partition and update the previous with current string ; now we will clear the current string ; increment the count of partition . ; ",
        "context": "",
        "code": "def maxPartition(s):\n    n = len(s)\n    P = 0\n    current = \"\"\n    previous = \"\"\n    for i in range(n):\n        current += s[i]\n        if (current != previous):\n            previous = current\n            current = \"\"\n            P += 1\n    return P\n",
        "test": "\ns = \"geeksforgeeks\"\nans = maxPartition(s)\nprint(ans)\n",
        "output": "11\n",
        "fn_call": "maxPartition"
    },
    {
        "text": "maximum number of objects that can be created as per given conditions | function for finding the maximum number of objects from n type - 1 and m type - 2 items ; storing minimum of n and m ; storing maximum number of objects from given items ; ",
        "context": "",
        "code": "def numberOfObjects(N, M):\n    initial = min(N, M)\n    final = (N + M) // 3\n    return min(initial, final)\n",
        "test": "\nif __name__ == '__main__':\n    N = 8\n    M = 7\n    print(numberOfObjects(N, M))\n",
        "output": "5\n",
        "fn_call": "numberOfObjects"
    },
    {
        "text": "maximize profit that can be earned by selling an item among n buyers |  ; ''function to find the maximum profit earned by selling an item among n buyers ; '' stores the maximum profit ; '' stores the price of the item ; '' traverse the array ; '' count of buyers with  budget >= arr[i] ; '' increment count ; '' update the maximum profit ; '' return the maximum possible  price ; ''",
        "context": "\nimport sys\n\n",
        "code": "def maximumProfit(arr, n):\n    ans = -sys .maxsize - 1\n    price = 0\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if (arr[i] <= arr[j]):\n                count += 1\n        if (ans < count * arr[i]):\n            price = arr[i]\n            ans = count * arr[i]\n    return price\n",
        "test": "\nif __name__ == '__main__':\n    arr = [22, 87, 9, 50, 56, 43]\n    print(maximumProfit(arr, 6))\n",
        "output": "43\n",
        "fn_call": "maximumProfit"
    },
    {
        "text": "Arrangement of words without changing the relative position of vowel and consonants | this function return n ! ; this will return total number of ways ; freq maintains frequency of each character in word ; check character is vowel or not ; the characters that are not vowel must be consonant ; number of ways to arrange vowel ; multiply both as these are independent ; string contains only capital letters ; this will contain ans",
        "context": "",
        "code": "def factorial(n):\n    res = 1\n    for i in range(1, n + 1):\n        res = res * i\n    return res\n\n\ndef count(word):\n    freq = [0 for i in range(30)]\n    vowel = 0\n    consonant = 0\n    for i in range(len(word)):\n        freq[ord(word[i]) - 65] += 1\n        if (word[i] == 'A' or word[i] == 'E' or word[i]\n                == 'I' or word[i] == 'O' or word[i] == 'U'):\n            vowel += 1\n        else:\n            consonant += 1\n    vowelArrange = factorial(vowel)\n    vowelArrange //= factorial(freq[0])\n    vowelArrange //= factorial(freq[4])\n    vowelArrange //= factorial(freq[8])\n    vowelArrange //= factorial(freq[14])\n    vowelArrange //= factorial(freq[20])\n    consonantArrange = factorial(consonant)\n    for i in range(26):\n        if (i != 0 and i != 4 and i != 8 and i != 14 and i != 20):\n            consonantArrange //= factorial(freq[i])\n    total = vowelArrange * consonantArrange\n    return total\n",
        "test": "\nword = \"COMPUTER\"\nans = count(word)\nprint(ans)\n",
        "output": "720\n",
        "fn_call": "count"
    },
    {
        "text": "change all even bits in a number to 0 | returns modified number with all even bits 0. ; to store sum of bits at even positions . ; to store bits to shift ; one by one put all even bits to end ; if current last bit is set , add it to ans ; next shift position ; ",
        "context": "",
        "code": "def changeEvenBits(n):\n    to_subtract = 0\n    m = 0\n    x = n\n    while (x):\n        if (x & 1):\n            to_subtract += (1 << m)\n        m += 2\n        x >>= 2\n    return n - to_subtract\n",
        "test": "\nn = 30\nprint(changeEvenBits(n))\n",
        "output": "10\n",
        "fn_call": "changeEvenBits"
    },
    {
        "text": "count distinct non | this function counts number of pairs ( x , y ) that satisfy the inequality x * x + y * y < n . ; ",
        "context": "",
        "code": "def countSolutions(n):\n    res = 0\n    x = 0\n    while (x * x < n):\n        y = 0\n        while (x * x + y * y < n):\n            res = res + 1\n            y = y + 1\n        x = x + 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    print(\"Total Number of distinct Non-Negative pairs is \", countSolutions(6))\n",
        "output": "Total Number of distinct Non-Negative pairs is  8\n",
        "fn_call": "countSolutions"
    },
    {
        "text": "minimum time to finish tasks without skipping two consecutive | arr [ ] represents time taken by n given tasks ; corner cases ; initialize value for the case when there is only one task in task list . first task is included ; first task is exluded ; process remaining n - 1 tasks ; time taken if current task is included there are two possibilities ( a ) previous task is also included ( b ) previous task is not included ; time taken when current task is not included . there is only one possibility that previous task is also included . ; update incl and excl for next iteration ; return maximum of two values for last task ; ",
        "context": "",
        "code": "def minTime(arr, n):\n    if (n <= 0):\n        return 0\n    incl = arr[0]\n    excl = 0\n    for i in range(1, n):\n        incl_new = arr[i] + min(excl, incl)\n        excl_new = incl\n        incl = incl_new\n        excl = excl_new\n    return min(incl, excl)\n",
        "test": "\narr1 = [10, 5, 2, 7, 10]\nn1 = len(arr1)\nprint(minTime(arr1, n1))\n\narr2 = [10, 5, 7, 10]\nn2 = len(arr2)\nprint(minTime(arr2, n2))\n\narr3 = [10, 5, 2, 4, 8, 6, 7, 10]\nn3 = len(arr3)\nprint(minTime(arr3, n3))\n",
        "output": "12\n12\n22\n",
        "fn_call": "minTime"
    },
    {
        "text": "find the maximum possible value of last element of the array | function to find the maximum possible value of last element of the array ; traverse for all element ; find the distance ; if moves less than distance then we can not move this number to end ; how many number we can move to end ; take the minimum of both of them ; increment in the end ; remove taken moves ; return the last element ; ",
        "context": "",
        "code": "def maxValue(arr, n, moves):\n    for i in range(n - 2, -1, -1):\n        if (arr[i] > 0):\n            distance = n - 1 - i\n            if (moves < distance):\n                break\n            can_take = moves // distance\n            take = min(arr[i], can_take)\n            arr[n - 1] += take\n            moves -= take * distance\n    return arr[n - 1]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 0, 1]\n    M = 5\n    N = len(arr)\n    print(maxValue(arr, N, M))\n",
        "output": "3\n",
        "fn_call": "maxValue"
    },
    {
        "text": "circular convolution using matrix method | python program to compute circular convolution of two arrays ; function to find circular convolution ; finding the maximum size between the two input sequence sizes ; copying elements of x to row_vec and padding zeros if size of x < maxsize ; copying elements of h to col_vec and padding zeros if size of h is less than maxsize ; generating 2d matrix of circularly shifted elements ; computing result by matrix multiplication and printing results ; ",
        "context": "\nMAX_SIZE = 10\n\n",
        "code": "def convolution(x, h, n, m):\n    row_vec = [0] * MAX_SIZE\n    col_vec = [0] * MAX_SIZE\n    out = [0] * MAX_SIZE\n    circular_shift_mat = [[0 for i in range(MAX_SIZE)]for j in range(MAX_SIZE)]\n    if (n > m):\n        maxSize = n\n    else:\n        maxSize = m\n    for i in range(maxSize):\n        if (i >= n):\n            row_vec[i] = 0\n        else:\n            row_vec[i] = x[i]\n    for i in range(maxSize):\n        if (i >= m):\n            col_vec[i] = 0\n        else:\n            col_vec[i] = h[i]\n    k = 0\n    d = 0\n    for i in range(maxSize):\n        curIndex = k - d\n        for j in range(maxSize):\n            circular_shift_mat[j][i] = row_vec[curIndex % maxSize]\n            curIndex += 1\n        k = maxSize\n        d += 1\n    for i in range(maxSize):\n        for j in range(maxSize):\n            out[i] += circular_shift_mat[i][j] * col_vec[j]\n        print(out[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    x = [5, 7, 3, 2]\n    n = len(x)\n    h = [1, 5]\n    m = len(h)\n    convolution(x, h, n, m)\n",
        "output": "15 32 38 17 ",
        "fn_call": "convolution"
    },
    {
        "text": "check if a hexadecimal number is even or odd | check if the number is odd or even ; check if the last digit is either '0' , '2' , '4' , '6' , '8' , ' a ' ( = 10 ) , ' c ' ( = 12 ) or ' e ' ( = 14 ) ; ",
        "context": "",
        "code": "def even_or_odd(N):\n    l = len(N)\n    if (N[l -\n          1] == '0' or N[l -\n                         1] == '2' or N[l -\n                                        1] == '4' or N[l -\n                                                       1] == '6' or N[l -\n                                                                      1] == '8' or N[l -\n                                                                                     1] == 'A' or N[l -\n                                                                                                    1] == 'C' or N[l -\n                                                                                                                   1] == 'E'):\n        return (\"Even\")\n    else:\n        return (\"Odd\")\n",
        "test": "\nN = \"AB3454D\"\nprint(even_or_odd(N))\n",
        "output": "Odd\n",
        "fn_call": "even_or_odd"
    },
    {
        "text": "check if all characters of a string can be made equal by increments or decrements | function to check if it is possible to make all characters of string s same or not ; length of string ; stores the sum of ascii value ; traverse the string s ; update the weightofstring ; if the sum is divisible by n then pr \" yes \" ; otherwise pr \" no \" ; ",
        "context": "",
        "code": "def canMakeEqual(S):\n    N = len(S)\n    weightOfString = 0\n    for i in range(N):\n        weightOfString += ord(S[i]) - ord('a') + 1\n    if (weightOfString % N == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nS = \"beb\"\ncanMakeEqual(S)\n",
        "output": "Yes\n",
        "fn_call": "canMakeEqual"
    },
    {
        "text": "sum of common divisors of two numbers a and b | python 3 implementation of above approach ; function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; ",
        "context": "\nfrom math import gcd, sqrt\n\n",
        "code": "def sumcommDiv(a, b):\n    n = gcd(a, b)\n    sum = 0\n    N = int(sqrt(n)) + 1\n    for i in range(1, N, 1):\n        if (n % i == 0):\n            if (n / i == i):\n                sum += i\n            else:\n                sum += (n / i) + i\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    a = 10\n    b = 15\n    print(\"Sum =\", int(sumcommDiv(a, b)))\n",
        "output": "Sum = 6\n",
        "fn_call": "sumcommDiv"
    },
    {
        "text": "find number formed by k times alternatively reducing x and adding y to 0 | function to find the value obtained after alternatively reducing x and adding y to 0 total k number of times ; stores the final result after adding only y to 0 ; stores the final number after reducing only x from 0 ; return the result obtained ; ",
        "context": "",
        "code": "def positionAfterKJumps(X, Y, K):\n    addY = Y * (K // 2)\n    reduceX = -1 * X * (K // 2 + K % 2)\n    return addY + reduceX\n",
        "test": "\nX = 2\nY = 5\nK = 3\nprint(positionAfterKJumps(X, Y, K))\n",
        "output": "1\n",
        "fn_call": "positionAfterKJumps"
    },
    {
        "text": "print all numbers whose set of prime factors is a subset of the set of the prime factors of x | python3 program to implement the above approach ; function to print all the numbers ; iterate for every element in the array ; find the gcd ; iterate till gcd is 1 of number and x ; divide the number by gcd ; find the new gcdg ; if the number is 1 at the end then print the number ; if no numbers have been there ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def printNumbers(a, n, x):\n    flag = False\n    for i in range(n):\n        num = a[i]\n        g = gcd(num, x)\n        while (g != 1):\n            num //= g\n            g = gcd(num, x)\n        if (num == 1):\n            flag = True\n            print(a[i], end=\" \")\n    if (not flag):\n        print(\"There are no such numbers\")\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 60\n    a = [2, 5, 10, 7, 17]\n    n = len(a)\n    printNumbers(a, n, x)\n",
        "output": "2 5 10 ",
        "fn_call": "printNumbers"
    },
    {
        "text": "program to find the interior and exterior angle of a regular polygon | function to find the interior and exterior angle ; formula to find the interior angle ; formula to find the exterior angle ; displaying the output ; ",
        "context": "",
        "code": "def findAngle(n):\n    interiorAngle = int((n - 2) * 180 / n)\n    exteriorAngle = int(360 / n)\n    print(\"Interior angle: \", interiorAngle)\n    print(\"Exterior angle: \", exteriorAngle)\n",
        "test": "\nn = 10\nfindAngle(n)\n",
        "output": "Interior angle:  144\nExterior angle:  36\n",
        "fn_call": "findAngle"
    },
    {
        "text": "smallest substring with each letter occurring both in uppercase and lowercase | python 3 program for the above approach ; function to check if the current string is balanced or not ; for every character , check if there exists uppercase as well as lowercase characters ; function to find smallest length substring in the given string which is balanced ; store frequency of lowercase characters ; stores frequency of uppercase characters ; count frequency of characters ; mark those characters which are not present in both lowercase and uppercase ; initialize the frequencies back to 0 ; marks the start and end of current substring ; marks the start and end of required substring ; stores the length of smallest balanced substring ; remove all characters obtained so far ; remove extra characters from front of the current substring ; if substring ( st , i ) is balanced ; no balanced substring ; store answer string ; ",
        "context": "\nimport sys\n\n",
        "code": "def balanced(small, caps):\n    for i in range(26):\n        if (small[i] != 0 and (caps[i] == 0)):\n            return 0\n        elif ((small[i] == 0) and (caps[i] != 0)):\n            return 0\n    return 1\n\n\ndef smallestBalancedSubstring(s):\n    small = [0 for i in range(26)]\n    caps = [0 for i in range(26)]\n    for i in range(len(s)):\n        if (ord(s[i]) >= 65 and ord(s[i]) <= 90):\n            caps[ord(s[i]) - 65] += 1\n        else:\n            small[ord(s[i]) - 97] += 1\n    mp = {}\n    for i in range(26):\n        if (small[i] and caps[i] == 0):\n            mp[chr(i + 97)] = 1\n        elif (caps[i] and small[i] == 0):\n            mp[chr(i + 65)] = 1\n    for i in range(len(small)):\n        small[i] = 0\n        caps[i] = 0\n    i = 0\n    st = 0\n    start = -1\n    end = -1\n    minm = sys .maxsize\n    while (i < len(s)):\n        if (s[i] in mp):\n            while (st < i):\n                if (ord(s[st]) >= 65 and ord(s[st]) <= 90):\n                    caps[ord(s[st]) - 65] -= 1\n                else:\n                    small[ord(s[st]) - 97] -= 1\n                st += 1\n            i += 1\n            st = i\n        else:\n            if (ord(s[i]) >= 65 and ord(s[i]) <= 90):\n                caps[ord(s[i]) - 65] += 1\n            else:\n                small[ord(s[i]) - 97] += 1\n            while (1):\n                if (ord(s[st]) >= 65 and ord(s[st]) <=\n                        90 and caps[ord(s[st]) - 65] > 1):\n                    caps[ord(s[st]) - 65] -= 1\n                    st += 1\n                elif (ord(s[st]) >= 97 and ord(s[st])  1):\n                    small[ord(s[st]) - 97] -= 1\n                    st += 1\n                else:\n                    break\n            if (balanced(small, caps)):\n                if (minm > (i - st + 1)):\n                    minm = i - st + 1\n                    start = st\n                    end = i\n            i += 1\n    if (start == -1 or end == -1):\n        print(-1)\n    else:\n        ans = \"\"\n        for i in range(start, end + 1, 1):\n            ans += s[i]\n        print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    s = \"azABaabba\"\n    smallestBalancedSubstring(s)\n",
        "output": "ABaab\n",
        "fn_call": "smallestBalancedSubstring"
    },
    {
        "text": "count total set bits in all numbers from range l to r | function to count set bit in [ l , r ] ; variable for count set bit in range ; count set bit for all number in range ; use inbuilt function ; ",
        "context": "",
        "code": "def countSetBit(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n\n\ndef countSetBits(L, R):\n    count = 0\n    for i in range(L, R + 1):\n        count += countSetBit(i)\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    L = 3\n    R = 5\n    print(\"Total set bit count is \", countSetBits(L, R))\n",
        "output": "Total set bit count is  5\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "maximum size square sub | function to find the maximum size of matrix with sum <= k ; n size of rows and m size of cols ; to store the prefix sum of matrix ; create prefix sum ; traverse each rows ; update the prefix sum till index i x j ; to store the maximum size of matrix with sum <= k ; traverse the sum matrix ; index out of bound ; maximum possible size of matrix ; binary search ; find middle index ; check whether sum <= k or not if yes check for other half of the search ; else check it in first half ; update the maximum size matrix ; print the final answer ; ",
        "context": "",
        "code": "def findMaxMatrixSize(arr, K):\n    n = len(arr)\n    m = len(arr[0])\n    sum = [[0 for i in range(m + 1)]for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if (i == 0 or j == 0):\n                sum[i][j] = 0\n                continue\n            sum[i][j] = arr[i - 1][j - 1] + sum[i - 1][j] + \\\n                sum[i][j - 1] - sum[i - 1][j - 1]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i + ans - 1 > n or j + ans - 1 > m):\n                break\n            mid = ans\n            lo = ans\n            hi = min(n - i + 1, m - j + 1)\n            while (lo < hi):\n                mid = (hi + lo + 1) // 2\n                if (sum[i + mid - 1][j + mid - 1] + sum[i - 1][j - 1] -\n                        sum[i + mid - 1][j - 1] - sum[i - 1][j + mid - 1] <= K):\n                    lo = mid\n                else:\n                    hi = mid - 1\n            ans = max(ans, lo)\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2]]\n    K = 4\n    findMaxMatrixSize(arr, K)\n",
        "output": "2\n",
        "fn_call": "findMaxMatrixSize"
    },
    {
        "text": "largest and smallest n | function to return the largest n - digit number in octal number system ; append '7' n times ; function to return the smallest n - digit number in octal number system ; append '0' ( n - 1 ) times to 1 ; function to print the largest and smallest n - digit octal number ; ",
        "context": "",
        "code": "def findLargest(N):\n    largest = strings(N, '7')\n    return largest\n\n\ndef findSmallest(N):\n    smallest = \"1\" + strings((N - 1), '0')\n    return smallest\n\n\ndef strings(N, c):\n    temp = \"\"\n    for i in range(N):\n        temp += c\n    return temp\n\n\ndef printLargestSmallest(N):\n    print(\"Largest: \", findLargest(N))\n    print(\"Smallest: \", findSmallest(N))\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    printLargestSmallest(N)\n",
        "output": "Largest:  7777\nSmallest:  1000\n",
        "fn_call": "printLargestSmallest"
    },
    {
        "text": "find first k natural numbers missing in given array | prints first k natural numbers in arr [ 0. . n - 1 ] ; find first positive number ; now find missing numbers between array elements ; find missing numbers after maximum . ; ",
        "context": "",
        "code": "def printKMissing(arr, n, k):\n    arr .sort()\n    i = 0\n    while (i < n and arr[i] <= 0):\n        i = i + 1\n    count = 0\n    curr = 1\n    while (count < k and i < n):\n        if (arr[i] != curr):\n            print(str(curr) + \" \", end='')\n            count = count + 1\n        else:\n            i = i + 1\n        curr = curr + 1\n    while (count < k):\n        print(str(curr) + \" \", end='')\n        curr = curr + 1\n        count = count + 1\n",
        "test": "\narr = [2, 3, 4]\nn = len(arr)\nk = 3\nprintKMissing(arr, n, k)\n",
        "output": "1 5 6 ",
        "fn_call": "printKMissing"
    },
    {
        "text": "turn off the rightmost set bit | unsets the rightmost set bit of n and returns the result ; ",
        "context": "",
        "code": "def fun(n):\n    return n & (n - 1)\n",
        "test": "\nn = 7\nprint(\"The number after unsetting the rightmost set bit\", fun(n))\n",
        "output": "The number after unsetting the rightmost set bit 6\n",
        "fn_call": "fun"
    },
    {
        "text": "distinct palindromic sub | python3 implementation of the approach ; function to return the count of distinct palindromic sub - strings of the given string s ; to store the positions of palindromic sub - strings ; map to store the sub - strings ; sub - strings of length 1 are palindromes ; store continuous palindromic sub - strings ; store palindromes of size 2 ; if str [ i ... ( i + 1 ) ] is not a palindromic then set dp [ i ] [ i + 1 ] = 0 ; find palindromic sub - strings of length >= 3 ; end of palindromic substring ; if s [ start ] = = s [ end ] and dp [ start + 1 ] [ end - 1 ] is already palindrome then s [ start ... . end ] is also a palindrome ; set dp [ start ] [ end ] = 1 ; not a palindrome ; return the count of distinct palindromes ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def palindromeSubStrs(s):\n    dp = np .zeros((len(s), len(s)))\n    m = {}\n    for i in range(len(s)):\n        dp[i][i] = 1\n        m[s[i:i + 1]] = 1\n    for i in range(len(s) - 1):\n        if (s[i] == s[i + 1]):\n            dp[i][i + 1] = 1\n            m[s[i:i + 2]] = 1\n        else:\n            dp[i][i + 1] = 0\n    for length in range(3, len(s) + 1):\n        for st in range(len(s) - length + 1):\n            end = st + length - 1\n            if (s[st] == s[end] and dp[st + 1][end - 1]):\n                dp[st][end] = 1\n                m[s[st:end + 1]] = 1\n            else:\n                dp[st][end] = 0\n    return len(m)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abaaa\"\n    print(palindromeSubStrs(s))\n",
        "output": "5\n",
        "fn_call": "palindromeSubStrs"
    },
    {
        "text": "sum of values of all possible non | function to return the required sum ; find the sum of the array elements ; every element appears 2 ^ ( n - 1 ) times ; ",
        "context": "",
        "code": "def sum(arr, n):\n    sum = 0\n    for i in arr:\n        sum += i\n    sum = sum * pow(2, n - 1)\n    return sum\n",
        "test": "\narr = [2, 1, 5, 6]\nn = len(arr)\nprint(sum(arr, n))\n",
        "output": "112\n",
        "fn_call": "sum"
    },
    {
        "text": "sort an array of 0 s , 1 s and 2 s | utility function to print contents of an array ; function to sort the array of 0 s , 1 s and 2 s ; count the number of 0 s , 1 s and 2 s in the array ; update the array ; store all the 0 s in the beginning ; then all the 1 s ; finally all the 2 s ; prthe sorted array ; ",
        "context": "",
        "code": "def printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end=\" \")\n\n\ndef sortArr(arr, n):\n    cnt0 = 0\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if arr[i] == 0:\n            cnt0 += 1\n        elif arr[i] == 1:\n            cnt1 += 1\n        elif arr[i] == 2:\n            cnt2 += 1\n    i = 0\n    while (cnt0 > 0):\n        arr[i] = 0\n        i += 1\n        cnt0 -= 1\n    while (cnt1 > 0):\n        arr[i] = 1\n        i += 1\n        cnt1 -= 1\n    while (cnt2 > 0):\n        arr[i] = 2\n        i += 1\n        cnt2 -= 1\n    printArr(arr, n)\n",
        "test": "\narr = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]\nn = len(arr)\nsortArr(arr, n)\n",
        "output": "0 0 0 0 0 1 1 1 1 1 2 2 ",
        "fn_call": "sortArr"
    },
    {
        "text": "find the number of elements x such that x + k also exists in the array | function to return the count of element x such that x + k also lies in this array ; key in map will store elements and value will store the frequency of the elements ; find if i . first + k is present in this map or not ; if we find i . first or key + k in this map then we have to increase in answer the frequency of this element ; ",
        "context": "",
        "code": "def count_element(N, K, arr):\n    mp = dict()\n    for i in range(N):\n        mp[arr[i]] = mp .get(arr[i], 0) + 1\n    answer = 0\n    for i in mp:\n        if i + K in mp:\n            answer += mp[i]\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 6, 2, 8, 7, 6, 5, 9]\n    N = len(arr)\n    K = 2\n    print(count_element(N, K, arr))\n",
        "output": "5\n",
        "fn_call": "count_element"
    },
    {
        "text": "minimum division by 10 and multiplication by 2 required to reduce given number to 1 | function to find the minimum number operations required to reduce n to 1 ; stores count of powers of 2 and 5 ; calculating the primefactors 2 ; calculating the primefactors 5 ; if n is 1 and cnt2 <= cnt5 ; return the minimum operations ; otherwise , n can 't be reduced ; ",
        "context": "",
        "code": "def minimumMoves(n):\n    cnt2 = 0\n    cnt5 = 0\n    while (n % 2 == 0):\n        n //= 2\n        cnt2 += 1\n    while (n % 5 == 0):\n        n //= 5\n        cnt5 += 1\n    if (n == 1 and cnt2 <= cnt5):\n        return 2 * cnt5 - cnt2\n    else:\n        return -1\n",
        "test": "\nif __name__ == '__main__':\n    N = 25\n    print(minimumMoves(N))\n",
        "output": "4\n",
        "fn_call": "minimumMoves"
    },
    {
        "text": "find a k | utility function to check if subarray of size k exits whose xor of elements equal to xor ofremaning array elements ; find xor of whole array ; find xor of first k elements ; adding xor of next element ; removing xor of previous element ; check if xor of current subarray matches with the xor of remaining elements or not ; function to check if subarray of size k exits whose xor of elements equal to xor ofremaning array elements ; ",
        "context": "",
        "code": "def isSubarrayExistUtil(arr, K, N):\n    totalXOR = 0\n    SubarrayXOR = 0\n    for i in range(N):\n        totalXOR ^= arr[i]\n    for i in range(K):\n        SubarrayXOR ^= arr[i]\n    if (SubarrayXOR == (totalXOR ^ SubarrayXOR)):\n        return True\n    for i in range(K, N):\n        SubarrayXOR ^= arr[i]\n        SubarrayXOR ^= arr[i - 1]\n        if (SubarrayXOR == (totalXOR ^ SubarrayXOR)):\n            return True\n    return False\n\n\ndef isSubarrayExist(arr, K, N):\n    if (isSubarrayExistUtil(arr, K, N)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 3, 5, 7, 7, 3, 4]\n    N = len(arr)\n    K = 5\n    isSubarrayExist(arr, K, N)\n",
        "output": "YES\n",
        "fn_call": "isSubarrayExist"
    },
    {
        "text": "maximize maximum possible subarray sum of an array by swapping with elements from another array | function to find the maximum subarray sum possible by swapping elements from array arr [ ] with that from array brr [ ] ; stores elements from the arrays arr [ ] and brr [ ] ; store elements of array arr [ ] and brr [ ] in the vector crr ; sort the vector crr in descending order ; stores maximum sum ; calculate the sum till the last index in crr [ ] which is less than n which contains a positive element ; print the sum ; ",
        "context": "",
        "code": "def maxSum(arr, brr, N, K):\n    crr = []\n    for i in range(N):\n        crr .append(arr[i])\n    for i in range(K):\n        crr .append(brr[i])\n    crr = sorted(crr)[::-1]\n    sum = 0\n    for i in range(N):\n        if (crr[i] > 0):\n            sum += crr[i]\n        else:\n            break\n    print(sum)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [7, 2, -1, 4, 5]\n    N = len(arr)\n    brr = [1, 2, 3, 2]\n    K = len(brr)\n    maxSum(arr, brr, N, K)\n",
        "output": "21\n",
        "fn_call": "maxSum"
    },
    {
        "text": "minimum cost to convert one given string to another using swap , insert or delete operations | function to find the minimum cost to convert a to b ; stores the frequency of string a and b respectively ; store the frequencies of characters in a ; store the frequencies of characters in b ; minimum cost to convert a to b ; find the minimum cost ; print the minimum cost ; ",
        "context": "",
        "code": "def minimumCost(a, b):\n    fre1 = [0] * (256)\n    fre2 = [0] * (256)\n    for c in a:\n        fre1[ord(c)] += 1\n    for c in b:\n        fre2[ord(c)] += 1\n    mincost = 0\n    for i in range(256):\n        mincost += abs(fre1[i] - fre2[i])\n    print(mincost)\n",
        "test": "\nif __name__ == '__main__':\n    A = \"1AB+-\"\n    B = \"cc\"\n    minimumCost(A, B)\n",
        "output": "7\n",
        "fn_call": "minimumCost"
    },
    {
        "text": "count numbers from range whose prime factors are only 2 and 3 | function to count the number within a range whose prime factors are only 2 and 3 ; start with 2 so that 1 doesn 't get counted ; while num is divisible by 2 , divide it by 2 ; while num is divisible by 3 , divide it by 3 ; if num got reduced to 1 then it has only 2 and 3 as prime factors ; ",
        "context": "",
        "code": "def findTwoThreePrime(l, r):\n    if (l == 1):\n        l += 1\n    count = 0\n    for i in range(l, r + 1):\n        num = i\n        while (num % 2 == 0):\n            num //= 2\n        while (num % 3 == 0):\n            num //= 3\n        if (num == 1):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    l = 1\n    r = 10\n    print(findTwoThreePrime(l, r))\n",
        "output": "6\n",
        "fn_call": "findTwoThreePrime"
    },
    {
        "text": "check if characters of a given string can be rearranged to form a palindrome | python3 implementation of above approach . ; bitvector to store the record of which character appear odd and even number of times ; ",
        "context": "",
        "code": "def canFormPalindrome(s):\n    bitvector = 0\n    for str in s:\n        bitvector ^= 1 << ord(str)\n    return bitvector == 0 or bitvector & (bitvector - 1) == 0\n",
        "test": "\nif canFormPalindrome(\"geeksforgeeks\"):\n    print('Yes')\nelse:\n    print('No')\n",
        "output": "No\n",
        "fn_call": "canFormPalindrome"
    },
    {
        "text": "longest substring with count of 1 s more than 0 s | function to find longest substring having count of 1 s more than count of 0 s . ; to store sum . ; to store first occurrence of each sum value . ; to store maximum length . ; to store current substring length . ; add 1 if current character is 1 else subtract 1. ; if sum is positive , then maximum length substring is bin1 [ 0. . i ] ; if sum is negative , then maximum length substring is bin1 [ j + 1. . i ] , where sum of substring bin1 [ 0. . j ] is sum - 1. ; make entry for this sum value in hash table if this value is not present . ; ",
        "context": "",
        "code": "def findLongestSub(bin1):\n    n = len(bin1)\n    sum = 0\n    prevSum = {i: 0 for i in range(n)}\n    maxlen = 0\n    for i in range(n):\n        if (bin1[i] == '1'):\n            sum += 1\n        else:\n            sum -= 1\n        if (sum > 0):\n            maxlen = i + 1\n        elif (sum <= 0):\n            if ((sum - 1) in prevSum):\n                currlen = i - prevSum[sum - 1]\n                maxlen = max(maxlen, currlen)\n        if ((sum)not in prevSum):\n            prevSum[sum] = i\n    return maxlen\n",
        "test": "\nif __name__ == '__main__':\n    bin1 = \"1010\"\n    print(findLongestSub(bin1))\n",
        "output": "3\n",
        "fn_call": "findLongestSub"
    },
    {
        "text": "count distinct subsequences | python3 program to print distinct subsequences of a given string ; create an empty set to store the subsequences ; function for generating the subsequences ; base case ; insert each generated subsequence into the set ; recursive case ; when a particular character is taken ; when a particular character isn 't taken ; ",
        "context": "\nimport math\nsn = []\nglobal m\nm = 0\n\n",
        "code": "def subsequences(s, op, i, j):\n    if (i == m):\n        op[j] = None\n        temp = \"\".join([i for i in op if i])\n        sn .append(temp)\n        return\n    else:\n        op[j] = s[i]\n        subsequences(s, op, i + 1, j + 1)\n        subsequences(s, op, i + 1, j)\n        return\n",
        "test": "\nstr = \"ggg\"\nm = len(str)\nn = int(math .pow(2, m) + 1)\nop = [None for i in range(n)]\nsubsequences(str, op, 0, 0)\nprint(len(set(sn)))\n",
        "output": "4\n",
        "fn_call": "subsequences"
    },
    {
        "text": "count divisors of n in o ( n ^ 1 / 3 ) | python3 implementation of naive method to count all divisors ; function to count the divisors ; if divisors are equal , count only one ; else : otherwise count both ; ",
        "context": "\nimport math\n\n",
        "code": "def countDivisors(n):\n    cnt = 0\n    for i in range(1, (int)(math .sqrt(n)) + 1):\n        if (n % i == 0):\n            if (n / i == i):\n                cnt = cnt + 1\n                cnt = cnt + 2\n    return cnt\n",
        "test": "\nprint(\"Total distinct divisors of 100 are : \", countDivisors(100))\n",
        "output": "Total distinct divisors of 100 are :  3\n",
        "fn_call": "countDivisors"
    },
    {
        "text": "minimum cuts required to convert a palindromic string to a different palindromic string | recursive function to find minimum number of cuts if length of string is even ; if length is odd then return 2 ; to check if half of palindromic string is itself a palindrome ; if not then return 1 ; else call function with half palindromic string ; function to find minimum number of cuts if length of string is odd ; if length is <= 3 then it is impossible ; array to store frequency of characters ; store count of characters in a array ; condition for edge cases ; if length is even ; if length is odd ; ",
        "context": "",
        "code": "def solveEven(s):\n    if len(s) % 2 == 1:\n        return 2\n    ls = s[0:len(s) // 2]\n    rs = s[len(s) // 2:len(s)]\n    if ls != rs:\n        return 1\n    return solveEven(ls)\n\n\ndef solveOdd(s):\n    return 2\n\n\ndef solve(s):\n    if len(s) <= 3:\n        return -1\n    cnt = [0] * 25\n    for i in range(0, len(s)):\n        cnt[ord(s[i]) - ord('a')] += 1\n    if max(cnt) >= len(s) - 1:\n        return -1\n    if len(s) % 2 == 0:\n        return solveEven(s)\n    if len(s) % 2 == 1:\n        return solveOdd(s)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"nolon\"\n    print(solve(s))\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "count of subarrays consisting of only prime numbers | function to check if a number is prime or not . ; if n has any factor other than 1 , then n is non - prime . ; function to return the count of subarrays made up of prime numbers only ; stores the answer ; stores the count of continuous prime numbers in an array ; if the current array element is prime ; increase the count ; update count of subarrays ; if the array ended with a continuous prime sequence ; ",
        "context": "",
        "code": "def is_prime(n):\n    if (n <= 1):\n        return 0\n    i = 2\n    while (i * i <= n):\n        if (n % i == 0):\n            return 0\n        i += 1\n    return 1\n\n\ndef count_prime_subarrays(ar, n):\n    ans = 0\n    count = 0\n    for i in range(n):\n        if (is_prime(ar[i])):\n            count += 1\n        else:\n            if (count):\n                ans += count * (count + 1) // 2\n                count = 0\n    if (count):\n        ans += count * (count + 1) // 2\n    return ans\n",
        "test": "\nN = 10\nar = [2, 3, 5, 6, 7, 11, 3, 5, 9, 3]\nprint(count_prime_subarrays(ar, N))\n",
        "output": "17\n",
        "fn_call": "count_prime_subarrays"
    },
    {
        "text": "space efficient iterative method to fibonacci number | get second msb ; consectutively set all the bits ; returns the second msb ; multiply function ; function to calculate f [ ] [ ] raise to the power n ; base case ; take 2d array to store number 's ; run loop till msb > 0 ; to return fibonacci number ; ",
        "context": "",
        "code": "def getMSB(n):\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    return ((n + 1) >> 2)\n\n\ndef multiply(F, M):\n    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\n    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\n    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\n    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\n    F[0][0] = x\n    F[0][1] = y\n    F[1][0] = z\n    F[1][1] = w\n\n\ndef power(F, n):\n    if (n == 0 or n == 1):\n        return\n    M = [[1, 1], [1, 0]]\n    m = getMSB(n)\n    while m:\n        multiply(F, F)\n        if (n & m):\n            multiply(F, M)\n        m = m >> 1\n\n\ndef fib(n):\n    F = [[1, 1], [1, 0]]\n    if (n == 0):\n        return 0\n    power(F, n - 1)\n    return F[0][0]\n",
        "test": "\nn = 6\nprint(fib(n))\n",
        "output": "8\n",
        "fn_call": "fib"
    },
    {
        "text": "gapful numbers | python3 program for the above approach ; find the first digit ; find total number of digits - 1 ; find first digit ; return first digit ; find the last digit ; return the last digit ; a function to check gapful numbers ; return true if n is gapful number ; ",
        "context": "\nimport math\n\n",
        "code": "def firstDigit(n):\n    digits = math .log10(n)\n    n = (n / math .pow(10, digits))\n    return n\n\n\ndef lastDigit(n):\n    return (n % 10)\n\n\ndef isGapful(n):\n    concatenation = (firstDigit(n) * 10) + lastDigit(n)\n    return (n % concatenation)\n",
        "test": "\nif __name__ == '__main__':\n    n = 108\n    if (isGapful(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isGapful"
    },
    {
        "text": "minimum insertions to form a palindrome | dp | a naive recursive program to find minimum number insertions needed to make a string palindrome ; recursive function to find minimum number of insertions ; base cases ; check if the first and last characters are same . on the basis of the comparison result , decide which subrpoblem ( s ) to call ; ",
        "context": "\nimport sys\n\n",
        "code": "def findMinInsertions(str, l, h):\n    if (l > h):\n        return sys .maxsize\n    if (l == h):\n        return 0\n    if (l == h - 1):\n        return 0 if (str[l] == str[h])else 1\n    if (str[l] == str[h]):\n        return findMinInsertions(str, l + 1, h - 1)\n    else:\n        return (min(findMinInsertions(str, l, h - 1),\n                findMinInsertions(str, l + 1, h)) + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"geeks\"\n    print(findMinInsertions(str, 0, len(str) - 1))\n",
        "output": "3\n",
        "fn_call": "findMinInsertions"
    },
    {
        "text": "minimum index sum for common elements of two lists | function to print common strings with minimum index sum ; resultant list ; iterating over sum in ascending order ; iterating over one list and check index ( corresponding to ",
        "context": "",
        "code": "def find(list1, list2):\n    res = []\n    max_possible_sum = len(list1) + len(list2) - 2\n    for sum in range(max_possible_sum + 1):\n        for i in range(sum + 1):\n            if (i < len(list1) and (sum - i) < len(list2)\n                    and list1[i] == list2[sum - i]):\n                res .append(list1[i])\n        if (len(res) > 0):\n            break\n    for i in range(len(res)):\n        print(res[i], end=\" \")\n",
        "test": "\nlist1 = []\nlist1 .append(\"GeeksforGeeks\")\nlist1 .append(\"Udemy\")\nlist1 .append(\"Coursera\")\nlist1 .append(\"edX\")\nlist2 = []\nlist2 .append(\"Codecademy\")\nlist2 .append(\"Khan Academy\")\nlist2 .append(\"GeeksforGeeks\")\nfind(list1, list2)\n",
        "output": "GeeksforGeeks ",
        "fn_call": "find"
    },
    {
        "text": "find the largest divisor subset in the array | function to find the required subsequence ; sort the array ; keep a count of the length of the subsequence and the previous element set the initial values ; maximum length of the subsequence and the last element ; run a loop for every element ; check for all the divisors ; if the element is a divisor and the length of subsequence will increase by adding j as previous element of i ; increase the count ; update the max count ; get the last index of the subsequence ; print the element ; move the index to the previous element ; ",
        "context": "",
        "code": "def findSubSeq(arr, n):\n    arr .sort()\n    count = [1] * n\n    prev = [-1] * n\n    max = 0\n    maxprev = -1\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if (arr[i] % arr[j] == 0 and count[j] + 1 > count[i]):\n                count[i] = count[j] + 1\n                prev[i] = j\n        if (max < count[i]):\n            max = count[i]\n            maxprev = i\n    i = maxprev\n    while (i >= 0):\n        if (arr[i] != -1):\n            print(arr[i], end=\" \")\n        i = prev[i]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    n = len(arr)\n    findSubSeq(arr, n)\n",
        "output": "4 2 1 ",
        "fn_call": "findSubSeq"
    },
    {
        "text": "sum of all elements in an array between zeros | function to find the sum between two zeros in the given array arr [ ] ; to store the sum of the element between two zeros ; to store the sum ; find first index of 0 ; traverse the given array arr [ ] ; if 0 occurs then add it to a [ ] ; else add element to the sum ; print all the sum stored in a ; if there is no such element print - 1 ; ",
        "context": "",
        "code": "def sumBetweenZero(arr, N):\n    i = 0\n    A = []\n    sum = 0\n    for i in range(N):\n        if (arr[i] == 0):\n            i += 1\n            break\n    k = i\n    for i in range(k, N, 1):\n        if (arr[i] == 0):\n            A .append(sum)\n            sum = 0\n        else:\n            sum += arr[i]\n    for i in range(len(A)):\n        print(A[i], end=' ')\n    if (len(A) == 0):\n        print(\"-1\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 0, 3, 4, 0, 4, 4, 0, 2, 1, 4, 0, 3]\n    N = len(arr)\n    sumBetweenZero(arr, N)\n",
        "output": "7 8 7 ",
        "fn_call": "sumBetweenZero"
    },
    {
        "text": "maximum path sum that starting with any cell of 0 | python3 program to find maximum path sum start any column in row '0' and ends up to any column in row 'n-1 ; function find maximum sum path ; create 2d matrix to store the sum of the path initialize all dp matrix as '0 ;  ; copy all element of first column into dp first column ; find maximum path sum that end ups at any column of last row 'n-1 ; return maximum sum path ; ",
        "context": "\nN = 4\n\n",
        "code": "def MaximumPath(Mat):\n    result = 0\n    dp = [[0 for i in range(N + 2)]for j in range(N)]\n    for i in range(N):\n        for j in range(1, N + 1):\n            dp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j],\n                           dp[i - 1][j + 1])) + Mat[i][j - 1]\n\n    for i in range(N + 1):\n        result = max(result, dp[N - 1][i])\n    return result\n",
        "test": "\nMat = [[4, 2, 3, 4], [2, 9, 1, 10], [15, 1, 3, 0], [16, 92, 41, 44]]\nprint(MaximumPath(Mat))\n",
        "output": "120\n",
        "fn_call": "MaximumPath"
    },
    {
        "text": "find triplets in an array whose and is maximum | python3 program to find triplet with maximum bitwise and . ; flag array initially set to true for all numbers ; 2d array for bit representation of all the numbers . initially all bits are set to 0. ; finding bit representation of every number and storing it in bits array . ; checking last bit of the number ; dividing number by 2. ; maximum and number initially 0. ; traversing the 2d binary representation . 0 th index represents 32 th bits while 32 th index represents 0 th bit . ; if cnt greater than 3 then ( 32 - i ) th bits of the number will be set . ; setting flags of the numbers whose ith bit is not set . ; counting the numbers whose flag are true . ; ",
        "context": "",
        "code": "def maxTriplet(a, n):\n    f = [True for i in range(n)]\n    bits = [[0 for i in range(33)]for i in range(n)]\n    for i in range(n):\n        num = a[i]\n        j = 32\n        while (num):\n            if (num & 1):\n                bits[i][j] = 1\n            j -= 1\n            num >>= 1\n    ans = 0\n    for i in range(33):\n        cnt = 0\n        for j in range(n):\n            if (bits[j][i] and f[j]):\n                cnt += 1\n        if (cnt >= 3):\n            ans += pow(2, 32 - i)\n            for j in range(n):\n                if (bits[j][i] == False):\n                    f[j] = False\n    cnt = 0\n    for i in range(n):\n        if (f[i]):\n            cnt += 1\n    NumberOfTriplets = (cnt * (cnt - 1) * (cnt - 2)) // 6\n    print(NumberOfTriplets, ans)\n",
        "test": "\na = [4, 11, 10, 15, 26]\nn = len(a)\nmaxTriplet(a, n)\n",
        "output": "4 10\n",
        "fn_call": "maxTriplet"
    },
    {
        "text": "search in a row wise and column wise sorted matrix | searches the element x in mat [ ] [ ] . if the element is found , then prints its position and returns true , otherwise prints \" not \u2581 found \" and returns false ; traverse through the matrix ; if the element is found ; ",
        "context": "",
        "code": "def search(mat, n, x):\n    if (n == 0):\n        return -1\n    for i in range(n):\n        for j in range(n):\n            if (mat[i][j] == x):\n                print(\"Element found at (\", i, \",\", j, \")\")\n                return 1\n    print(\" Element not found\")\n    return 0\n",
        "test": "\nmat = [[10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50]]\nsearch(mat, 4, 29)\n",
        "output": "Element found at ( 2 , 1 )\n",
        "fn_call": "search"
    },
    {
        "text": "count pairs from two arrays with difference exceeding k | function to count pairs that satisfy the given conditions ; stores index of the left pointer . ; stores index of the right pointer ; stores count of total pairs that satisfy the conditions ; sort arr [ ] array ; sort brr [ ] array ; traverse both the array and count then pairs ; if the value of ( brr [ j ] - arr [ i ] ) exceeds k ; update cntpairs ; update ; update j ; ",
        "context": "",
        "code": "def count_pairs(arr, brr, N, M, K):\n    i = 0\n    j = 0\n    cntPairs = 0\n    arr = sorted(arr)\n    brr = sorted(brr)\n    while (i < N and j < M):\n        if (brr[j] - arr[i] > K):\n            cntPairs += (M - j)\n            i += 1\n        else:\n            j += 1\n    return cntPairs\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 9, 1, 8]\n    brr = [10, 12, 7, 4, 2, 3]\n    K = 3\n    N = len(arr)\n    M = len(brr)\n    print(count_pairs(arr, brr, N, M, K))\n",
        "output": "6\n",
        "fn_call": "count_pairs"
    },
    {
        "text": "happy numbers | returns sum of squares of digits of a number n . for example for n = 12 it returns 1 + 4 = 5 ; returns true if n is happy number else returns false . ; keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; number is happy if we reach 1 ; replace n with sum of squares of digits ; number is not happy if we reach 4 ; ",
        "context": "",
        "code": "def sumDigitSquare(n):\n    sq = 0\n    while (n):\n        digit = n % 10\n        sq = sq + digit * digit\n        n = n // 10\n    return sq\n\n\ndef isHappy(n):\n    while (1):\n        if (n == 1):\n            return True\n        n = sumDigitSquare(n)\n        if (n == 4):\n            return False\n    return False\n",
        "test": "\nn = 23\nif (isHappy(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isHappy"
    },
    {
        "text": "find selling price from given profit percentage and cost | function to calculate the selling price ; decimal equivalent of profit percentage ; find the selling price ; return the calculated selling price ; ",
        "context": "",
        "code": "def SellingPrice(CP, PP):\n    Pdecimal = 1 + (PP / 100)\n    res = Pdecimal * CP\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    C = 720\n    P = 13\n    print(SellingPrice(C, P))\n",
        "output": "813.5999999999999\n",
        "fn_call": "SellingPrice"
    }
]