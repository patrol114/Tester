[
    {
        "text": "find array elements with rightmost set bit at the position of the rightmost set bit in k | function to find the mask for finding rightmost set bit in k ; function to find all array elements with rightmost set bit same as that in k ; stores mask of k ; store position of rightmost set bit ; traverse the array ; check if rightmost set bit of current array element is same as position of rightmost set bit in k ; ",
        "context": "",
        "code": "def findMask(K):\n    mask = 1\n    while ((K & mask) == 0):\n        mask = mask << 1\n    return mask\n\n\ndef sameRightSetBitPos(arr, N, K):\n    mask = findMask(K)\n    pos = (K & mask)\n    for i in range(N):\n        if ((arr[i] & mask) == pos):\n            print(arr[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 4, 6, 7, 9, 12, 15]\n    N = len(arr)\n    K = 7\n    sameRightSetBitPos(arr, N, K)\n",
        "output": "3 7 9 15 ",
        "fn_call": "sameRightSetBitPos"
    },
    {
        "text": "determine if a string has all unique characters | python3 program to illustrate string with unique characters ; converting string to set ; if length of set is equal to len of string then it will have unique characters ; ",
        "context": "",
        "code": "def uniqueCharacters(str):\n    setstring = set(str)\n    if (len(setstring) == len(str)):\n        return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    input = \"GeeksforGeeks\"\n    if (uniqueCharacters(input)):\n        print(\"The String \" + input + \" has all unique characters\")\n    else:\n        print(\"The String \" + input + \" has duplicate characters\")\n",
        "output": "The String GeeksforGeeks has duplicate characters\n",
        "fn_call": "uniqueCharacters"
    },
    {
        "text": "check whether two numbers are in golden ratio | function to check that two numbers are in golden ratio ; swapping the numbers such that a contains the maximum number between these numbers ; first ratio ; second ratio ; condition to check that two numbers are in golden ratio ; ",
        "context": "",
        "code": "def checkGoldenRatio(a, b):\n    a, b = max(a, b), min(a, b)\n    ratio1 = round(a / b, 3)\n    ratio2 = round((a + b) / a, 3)\n    if ratio1 == ratio2 and ratio1 == 1.618:\n        print(\"Yes\")\n        return True\n    else:\n        print(\"No\")\n        return False\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 0.618\n    b = 1\n    checkGoldenRatio(a, b)\n",
        "output": "Yes\n",
        "fn_call": "checkGoldenRatio"
    },
    {
        "text": "longest common substring in an array of strings | function to find the stem ( longestcommon substring ) from the string array ; determine size of the array ; take first word from array as reference ; generating all possible substrings of our reference string arr [ 0 ] i . e s ; check if the generated stem is common to all words ; if current substring is present in all strings and its length is greater than current result ; ",
        "context": "",
        "code": "def findstem(arr):\n    n = len(arr)\n    s = arr[0]\n    l = len(s)\n    res = \"\"\n    for i in range(l):\n        for j in range(i + 1, l + 1):\n            stem = s[i:j]\n            k = 1\n            for k in range(1, n):\n                if stem not in arr[k]:\n                    break\n            if (k + 1 == n and len(res) < len(stem)):\n                res = stem\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [\"grace\", \"graceful\", \"disgraceful\", \"gracefully\"]\n    stems = findstem(arr)\n    print(stems)\n",
        "output": "grace\n",
        "fn_call": "findstem"
    },
    {
        "text": "maximum subset sum possible by negating the entire sum after selecting the first array element | function returns maximum subset sum from the given array = ; case 2 : negate values from a [ 1 ] to a [ n - 1 ] ; include only positives for max subset sum ; return max sum obtained ; function to return maximum of the maximum subset sum calculated for the two cases ; case 1 ; case 2 ; modifying the sum ; including first element ; negating again ; return the required answer ; ",
        "context": "",
        "code": "def maxSubset(A, flag):\n    n = len(A)\n    sum = 0\n    if (flag):\n        for i in range(1, n):\n            A[i] = -A[i]\n    for i in range(1, n):\n        if (A[i] > 0):\n            sum += A[i]\n    return sum\n\n\ndef findBest(A):\n    x = maxSubset(A, 0)\n    y = maxSubset(A, 1)\n    y = -y\n    y += A[0]\n    y = -y\n    return max(x, y)\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 10, 4, -6, 3]\n    print(findBest(A))\n",
        "output": "17\n",
        "fn_call": "findBest"
    },
    {
        "text": "first negative integer in every window of size k | function to find the first negative integer in every window of size k ; loop for each subarray ( window ) of size k ; traverse through the current window ; if a negative integer is found , then it is the first negative integer for current window . print it , set the flag and break ; if the current window does not contain a negative integer ; ",
        "context": "",
        "code": "def printFirstNegativeInteger(arr, n, k):\n    for i in range(0, (n - k + 1)):\n        flag = False\n        for j in range(0, k):\n            if (arr[i + j] < 0):\n                print(arr[i + j], end=\" \")\n                flag = True\n                break\n        if (not (flag)):\n            print(\"0\", end=\" \")\n",
        "test": "\narr = [12, -1, -7, 8, -15, 30, 16, 28]\nn = len(arr)\nk = 3\nprintFirstNegativeInteger(arr, n, k)\n",
        "output": "-1 -1 -7 -15 -15 0 ",
        "fn_call": "printFirstNegativeInteger"
    },
    {
        "text": "sum of both diagonals of a spiral odd | function returns sum of diagonals ; as order should be only odd we should pass only odd integers ; ",
        "context": "",
        "code": "def spiralDiaSum(n):\n    if n == 1:\n        return 1\n    return (4 * n * n - 6 * n + 6 + spiralDiaSum(n - 2))\n",
        "test": "\nn = 7\nprint(spiralDiaSum(n))\n",
        "output": "261\n",
        "fn_call": "spiralDiaSum"
    },
    {
        "text": "length of the perpendicular bisector of the line joining the centers of two circles | python program to find the length of the perpendicular bisector of the line joining the centers of two circles in which one lies completely inside touching the bigger circle at one point ; ",
        "context": "",
        "code": "def lengperpbisect(r1, r2):\n    z = 2 * (((r1 * r1) - ((r1 - r2) * (r1 - r2) / 4))**(1 / 2))\n    print(\"The length of the perpendicular bisector is \", z)\n",
        "test": "\nr1 = 5\nr2 = 3\nlengperpbisect(r1, r2)\n",
        "output": "The length of the perpendicular bisector is  9.797958971132712\n",
        "fn_call": "lengperpbisect"
    },
    {
        "text": "how to check aadhar number is valid or not using regular expression | python3 program to validate aadhar number using regex . ; function to validate aadhar number . ; regex to check valid aadhar number . ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : str4 = \"3675 \u2581 98af \u2581 602\" ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidAadharNumber(str):\n    regex = (\"^[2-9]{1}[0-9]{3}\\\\\" + \"s[0-9]{4}\\\\s[0-9]{4}$\")\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"3675 9834 6015\"\nprint(isValidAadharNumber(str1))\nstr2 = \"4675 9834 6012 8\"\nprint(isValidAadharNumber(str2))\nstr3 = \"0175 9834 6012\"\nprint(isValidAadharNumber(str3))\nstr5 = \"417598346012\"\nprint(isValidAadharNumber(str5))\n",
        "output": "True\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidAadharNumber"
    },
    {
        "text": "number of squares of side length required to cover an n * m rectangle | function to find number of squares of a * a required to cover n * m rectangle ; ",
        "context": "",
        "code": "def Squares(n, m, a):\n    return (((m + a - 1) // a) * ((n + a - 1) // a))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 6\n    m = 6\n    a = 4\n    print(Squares(n, m, a))\n",
        "output": "4\n",
        "fn_call": "Squares"
    },
    {
        "text": "check if all the set bits of the binary representation of n are at least k places away | python3 program to check if all the set bits of the binary representation of n are at least k places away . ; initialize check and count with 0 ; the i - th bit is a set bit ; this is the first set bit so , start calculating all the distances between consecutive bits from here ; if count is less than k return false ; adding the count as the number of zeroes increase between set bits ; ",
        "context": "",
        "code": "def CheckBits(N, K):\n    check = 0\n    count = 0\n    for i in range(31, -1, -1):\n        if ((1 << i) & N):\n            if (check == 0):\n                check = 1\n            else:\n                if (count < K):\n                    return False\n            count = 0\n        else:\n            count += 1\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    K = 1\n    if (CheckBits(N, K)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "CheckBits"
    },
    {
        "text": "rearrange array to make it non | python3 program for above approach ; function to check if the array can be made non - decreasing ; iterate till n ; find the minimum element ; sort the array ; iterate till n ; check if the element is at its correct position ; return the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def check(a, n):\n    b = [None] * n\n    minElement = sys .maxsize\n    for i in range(0, n):\n        b[i] = a[i]\n        minElement = min(minElement, a[i])\n    b .sort()\n    k = 1\n    for i in range(0, n):\n        if ((a[i] != b[i]) and (a[i] % minElement != 0)):\n            k = 0\n            break\n    if k == 1:\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [4, 3, 6, 6, 2, 9]\n    n = len(a)\n    if check(a, n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "count of palindromic strings possible by swapping of a pair of characters | function to return the count of possible palindromic strings ; stores the frequencies of each character ; stores the length of the string ; increase the number of swaps , the current character make with its previous occurrences ; increase frequency ; ",
        "context": "",
        "code": "def findNewString(s):\n    ans = 0\n    freq = [0] * 26\n    n = len(s)\n    for i in range(n):\n        ans += freq[ord(s[i]) - ord('a')]\n        freq[ord(s[i]) - ord('a')] += 1\n    return ans\n",
        "test": "\ns = \"aaabaaa\"\nprint(findNewString(s))\n",
        "output": "15\n",
        "fn_call": "findNewString"
    },
    {
        "text": "finding integreand using weedle 's rule | a sample function f ( x ) = 1 / ( 1 + x ^ 2 ) ; function to find the integral value of f ( x ) with step size h , with initial lower limit and upper limit a and b ; find step size h ; to store the final sum ; find sum using weedle 's formula ; return the final sum ; ",
        "context": "",
        "code": "def y(x):\n    num = 1\n    denom = float(1.0 + x * x)\n    return num / denom\n\n\ndef WeedleRule(a, b):\n    h = (b - a) / 6\n    sum = 0\n    sum = sum + (((3 * h) / 10) * (y(a) + y(a + 2 * h) + 5 * y(a + h) +\n                 6 * y(a + 3 * h) + y(a + 4 * h) + 5 * y(a + 5 * h) + y(a + 6 * h)))\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    a = 0\n    b = 6\n    num = WeedleRule(a, b)\n    print(\"f(x) = {0:.6f}\".format(num))\n",
        "output": "f(x) = 1.373447\n",
        "fn_call": "WeedleRule"
    },
    {
        "text": "powers of 2 to required sum | python3 program to find the blocks for given number . ; converting the decimal number into its binary equivalent . ; displaying the output when the bit is '1' in binary equivalent of number . ; ",
        "context": "",
        "code": "def block(x):\n    v = []\n    print(\"Blocks for %d : \" % x, end=\"\")\n    while (x > 0):\n        v .append(int(x % 2))\n        x = int(x / 2)\n    for i in range(0, len(v)):\n        if (v[i] == 1):\n            print(i, end=\"\")\n            if (i != len(v) - 1):\n                print(\", \", end=\"\")\n    print(\"\")\n",
        "test": "\nblock(71307)\nblock(1213)\nblock(29)\nblock(100)\n",
        "output": "Blocks for 71307 : 0, 1, 3, 7, 9, 10, 12, 16\nBlocks for 1213 : 0, 2, 3, 4, 5, 7, 10\nBlocks for 29 : 0, 2, 3, 4\nBlocks for 100 : 2, 5, 6\n",
        "fn_call": "block"
    },
    {
        "text": "rearrange array to make bitwise xor of similar indexed elements of two arrays is same | function to rearrange the array b [ ] such that a [ i ] ^ b [ i ] is same for each element ; store frequency of elements ; stores xor value ; taking xor of all the values of both arrays ; store frequency of b [ ] ; find the array b [ ] after rearrangement ; if the updated value is present then decrement its frequency ; otherwise return empty vector ; utility function to rearrange the array b [ ] such that a [ i ] ^ b [ i ] is same for each element ; store rearranged array b ; if rearrangement possible ; otherwise return - 1 ; ",
        "context": "",
        "code": "def rearrangeArray(A, B, N):\n    m = {}\n    xor_value = 0\n\n    for i in range(0, N):\n        xor_value ^= A[i]\n        xor_value ^= B[i]\n        if B[i] in m:\n            m[B[i]] = m[B[i]] + 1\n        else:\n            m[B[i]] = 1\n\n    for i in range(0, N):\n        B[i] = A[i] ^ xor_value\n        if B[i] in m:\n            m[B[i]] = m[B[i]] - 1\n        else:\n            X = []\n            return X\n\n    return B\n\n\ndef rearrangeArrayUtil(A, B, N):\n    ans = rearrangeArray(A, B, N)\n    if (len(ans) > 0):\n        for x in ans:\n            print(x, end=' ')\n    else:\n        print(\"-1\")\n",
        "test": "\nif __name__ == '__main__':\n    A = [13, 21, 33, 49, 53]\n    B = [54, 50, 34, 22, 14]\n    N = len(A)\n    rearrangeArrayUtil(A, B, N)\n",
        "output": "14 22 34 50 54 ",
        "fn_call": "rearrangeArrayUtil"
    },
    {
        "text": "program to implement inverse interpolation using lagrange formula | consider a structure to keep each pair of x and y together ; function to calculate the inverse interpolation ; initialize final x ; calculate each term of the given formula ; add term to final result ; ",
        "context": "\nclass Data:\n    def __init__(self, x, y):\n        self .x = x\n        self .y = y\n\n",
        "code": "def inv_interpolate(d: list, n: int, y: float) -> float:\n    x = 0\n    for i in range(n):\n        xi = d[i].x\n        for j in range(n):\n            if j != i:\n                xi = (xi * (y - d[j].y) / (d[i].y - d[j].y))\n        x += xi\n    return x\n",
        "test": "\nif __name__ == \"__main__\":\n    d = [Data(1.27, 2.3), Data(2.25, 2.95), Data(2.5, 3.5), Data(3.6, 5.1)]\n    n = 4\n    y = 4.5\n    print(\"Value of x at y = 4.5 :\", round(inv_interpolate(d, n, y), 5))\n",
        "output": "Value of x at y = 4.5 : 2.79501\n",
        "fn_call": "inv_interpolate"
    },
    {
        "text": "sum of bit differences for numbers from 0 to n | set 2 | recursive function to find sum of different bits between consecutive numbers from 0 to n ; base case ; calculate the nth term ; ",
        "context": "",
        "code": "def totalCountDifference(n):\n    if (n == 1):\n        return 1\n    return n + totalCountDifference(n // 2)\n",
        "test": "\nN = 5\nprint(totalCountDifference(N))\n",
        "output": "8\n",
        "fn_call": "totalCountDifference"
    },
    {
        "text": "count of pairs of array elements which are divisible by k when concatenated | python3 program to count pairs of array elements which are divisible by k when concatenated ; function to calculate and return the count of pairs ; compute power of 10 modulo k ; calculate length of a [ i ] ; increase count of remainder ; calculate ( a [ i ] * 10 ^ lenj ) % k ; calculate ( k - ( a [ i ] * 10 ^ lenj ) % k ) % k ; increase answer by count ; if a pair ( a [ i ] , a [ i ] ) is counted ; return the count of pairs ; ",
        "context": "\nrem = [[0 for x in range(11)]for y in range(11)]\n\n",
        "code": "def countPairs(a, n, k):\n    l = [0] * n\n    p = [0] * (11)\n    p[0] = 1\n    for i in range(1, 11):\n        p[i] = (p[i - 1] * 10) % k\n    for i in range(n):\n        x = a[i]\n        while (x > 0):\n            l[i] += 1\n            x //= 10\n        rem[l[i]][a[i] % k] += 1\n    ans = 0\n    for i in range(n):\n        for j in range(1, 11):\n            r = (a[i] * p[j]) % k\n            xr = (k - r) % k\n            ans += rem[j][xr]\n            if (l[i] == j and (r + a[i] % k) % k == 0):\n                ans -= 1\n    return ans\n",
        "test": "\na = [4, 5, 2]\nn = len(a)\nk = 2\nprint(countPairs(a, n, k))\n",
        "output": "4\n",
        "fn_call": "countPairs"
    },
    {
        "text": "radix sort | a function to do counting sort of arr [ ] according to the digit represented by exp . ; the output array elements that will have sorted arr ; initialize count array as 0 ; store count of occurrences in count [ ] ; change count [ i ] so that count [ i ] now contains actual position of this digit in output array ; build the output array ; copying the output array to arr [ ] , so that arr now contains sorted numbers ; method to do radix sort ; find the maximum number to know number of digits ; do counting sort for every digit . note that instead of passing digit number , exp is passed . exp is 10 ^ i where i is current digit number ; ",
        "context": "",
        "code": "def countingSort(arr, exp1):\n    n = len(arr)\n    output = [0] * (n)\n    count = [0] * (10)\n    for i in range(0, n):\n        index = (arr[i] / exp1)\n        count[int(index % 10)] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    i = n - 1\n    while i >= 0:\n        index = (arr[i] / exp1)\n        output[count[int(index % 10)] - 1] = arr[i]\n        count[int(index % 10)] -= 1\n        i -= 1\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n\n\ndef radixSort(arr):\n    max1 = max(arr)\n    exp = 1\n    while max1 / exp > 0:\n        countingSort(arr, exp)\n        exp *= 10\n",
        "test": "\narr = [170, 45, 75, 90, 802, 24, 2, 66]\nradixSort(arr)\nfor i in range(len(arr)):\n    print(arr[i])\n",
        "output": "2\n24\n45\n66\n75\n90\n170\n802\n",
        "fn_call": "radixSort"
    },
    {
        "text": "sum of absolute differences of indices of occurrences of each array element | set 2 | stores the count of occurrences and previous index of every element ; constructor ; function to calculate the sum of absolute differences of indices of occurrences of array element ; stores the count of elements and their previous indices ; initialize 2 arrays left [ ] and right [ ] of size n ; traverse the given array ; if arr [ i ] is present in the map ; update left [ i ] to 0 and update the value of arr [ i ] in map ; otherwise , get the value from the map and update left [ i ] ; clear the map to calculate right [ ] array ; traverse the array arr [ ] in reverse ; if arr [ i ] is present in themap ; update right [ i ] to 0 and update the value of arr [ i ] in the map ; otherwise get the value from the map and update right [ i ] ; iterate in the range [ 0 , n - 1 ] and print the sum of left [ i ] and right [ i ] as the result ; ",
        "context": "\nclass pair:\n    def __init__(self, count, prevIndex):\n        self .count = count\n        self .prevIndex = prevIndex\n\n",
        "code": "def findSum(arr, n):\n    map = {}\n    left = [0 for i in range(n)]\n    right = [0 for i in range(n)]\n    for i in range(n):\n        if (arr[i]not in map):\n            left[i] = 0\n            map[arr[i]] = pair(1, i)\n        else:\n            tmp = map[arr[i]]\n            left[i] = (tmp .count) * (i - tmp .prevIndex) + \\\n                left[tmp .prevIndex]\n            map[arr[i]] = pair(tmp .count + 1, i)\n    map .clear()\n    for i in range(n - 1, -1, -1):\n        if (arr[i]not in map):\n            right[i] = 0\n            map[arr[i]] = pair(1, i)\n        else:\n            tmp = map[arr[i]]\n            right[i] = (tmp .count) * (abs(i - tmp .prevIndex)) + \\\n                right[tmp .prevIndex]\n            map[arr[i]] = pair(tmp .count + 1, i)\n    for i in range(n):\n        print(left[i] + right[i], end=\" \")\n",
        "test": "\narr = [1, 3, 1, 1, 2]\nN = len(arr)\nfindSum(arr, N)\n",
        "output": "5 0 3 4 0 ",
        "fn_call": "findSum"
    },
    {
        "text": "queries to find minimum swaps required to sort given array with updates | function to return the position of the given value using binary search ; return 0 if every value is greater than the given value ; return n - 1 if every value is smaller than the given value ; perform binary search ; iterate till start < end ; find the mid ; update start and end ; return the position of the given value ; function to return the number of make the array sorted ; index x to update ; increment value by y ; set newelement equals to x + y ; compute the new index ; print the minimum number of swaps ; ",
        "context": "",
        "code": "def computePos(arr, n, value):\n    if (value < arr[0]):\n        return 0\n    if (value > arr[n - 1]):\n        return n - 1\n    start = 0\n    end = n - 1\n    while (start < end):\n        mid = (start + end + 1) // 2\n        if (arr[mid] >= value):\n            end = mid - 1\n        else:\n            start = mid\n    return start\n\n\ndef countShift(arr, n, queries):\n    for q in queries:\n        index = q[0]\n        update = q[1]\n        newElement = arr[index] + update\n        newIndex = computePos(arr, n, newElement)\n        print(abs(newIndex - index), end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 4, 5, 6]\n    N = len(arr)\n    queries = [[0, -1], [4, -11]]\n    countShift(arr, N, queries)\n",
        "output": "0 4 ",
        "fn_call": "countShift"
    },
    {
        "text": "find the rotation count in rotated sorted array | returns count of rotations for an array which is first sorted in ascending order , then rotated ; we basically find index of minimum element ; ",
        "context": "",
        "code": "def countRotations(arr, n):\n    min = arr[0]\n    for i in range(0, n):\n        if (min > arr[i]):\n            min = arr[i]\n            min_index = i\n    return min_index\n",
        "test": "\narr = [15, 18, 2, 3, 6, 12]\nn = len(arr)\nprint(countRotations(arr, n))\n",
        "output": "2\n",
        "fn_call": "countRotations"
    },
    {
        "text": "check if a number has two adjacent set bits | python 3 program to check if there are two adjacent set bits . ; ",
        "context": "",
        "code": "def adjacentSet(n):\n    return (n & (n >> 1))\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    if (adjacentSet(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "adjacentSet"
    },
    {
        "text": "print all palindrome dates between the given years | python 3 implementation of the approach ; returns true if given year is valid ; return true if year is a multiple pf 4 and not multiple of 100. or year is multiple of 400. ; returns true if given year is valid or not . ; if year , month and day are not in given range ; handle february month with leap year ; months of april , june , sept and nov must have number of days less than or equal to 30. ; function to print the palindrome dates between the given years ; for every year ; current year as a string ; to store the reverse of year ; get the day and the month ; if the current palindrome date is valid ; ",
        "context": "\nMAX_VALID_YR = 9999\nMIN_VALID_YR = 1800\n\n",
        "code": "def isLeap(year):\n    return (((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0))\n\n\ndef isValidDate(d, m, y):\n    if (y > MAX_VALID_YR or y < MIN_VALID_YR):\n        return False\n    if (m  12):\n        return False\n    if (d  31):\n        return False\n    if (m == 2):\n        if (isLeap(y)):\n            return (d <= 29)\n        else:\n            return (d <= 28)\n    if (m == 4 or m == 6 or m == 9 or m == 11):\n        return (d <= 30)\n    return True\n\n\ndef printPalindromeDates(y1, y2):\n    for year in range(y1, y2 + 1, 1):\n        str1 = str(year)\n        rev = str1\n        rev = rev[::-1]\n        day = int(rev[0:2])\n        month = int(rev[2:4])\n        rev += str1\n        if (isValidDate(day, month, year)):\n            print(rev)\n",
        "test": "\nif __name__ == '__main__':\n    y1 = 2001\n    y2 = 2005\n    printPalindromeDates(y1, y2)\n",
        "output": "10022001\n20022002\n",
        "fn_call": "printPalindromeDates"
    },
    {
        "text": "find the number in a range having maximum product of the digits | returns the product of digits of number x ; this function returns the number having maximum product of the digits ; converting both integers to strings ; let the current answer be r ; stores the current number having current digit one less than current digit in b ; replace all following digits with 9 to maximise the product ; convert string to number ; check if it lies in range and its product is greater than max product ; ",
        "context": "",
        "code": "def product(x):\n    prod = 1\n    while (x):\n        prod *= (x % 10)\n        x //= 10\n    return prod\n\n\ndef findNumber(l, r):\n    a = str(l)\n    b = str(r)\n    ans = r\n    for i in range(len(b)):\n        if (b[i] == '0'):\n            continue\n        curr = list(b)\n        curr[i] = str(((ord(curr[i]) - ord('0')) - 1) + ord('0'))\n        for j in range(i + 1, len(curr)):\n            curr[j] = str(ord('9'))\n        num = 0\n        for c in curr:\n            num = num * 10 + (int(c) - ord('0'))\n        if (num >= l and product(ans) < product(num)):\n            ans = num\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    l, r = 1, 10\n    print(findNumber(l, r))\n    l, r = 51, 62\n    print(findNumber(l, r))\n",
        "output": "9\n59\n",
        "fn_call": "findNumber"
    },
    {
        "text": "count substrings of same length differing by a single character from two given strings | function to count the number of substrings of equal length which differ by a single character ; stores the count of pairs of substrings ; traverse the string s ; traverse the string t ; different character ; increment the answer ; count equal substrings from next index ; increment the count ; increment q ; check the condition ; increment k ; add q to count ; decrement z ; return the final count ; ",
        "context": "",
        "code": "def countSubstrings(s, t):\n    answ = 0\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if t[j] != s[i]:\n                answ += 1\n                k = 1\n                z = -1\n                q = 1\n                while (j + z >= 0 <= i + z and s[i + z] == t[j + z]):\n                    z -= 1\n                    answ += 1\n                    q += 1\n                while (len(s) > i + k and j + k <\n                       len(t) and s[i + k] == t[j + k]):\n                    k += 1\n                    answ += q\n                    z = -1\n    return answ\n",
        "test": "\nS = \"aba\"\nT = \"baba\"\nprint(countSubstrings(S, T))\n",
        "output": "6\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "count pairs from an array having equal sum and quotient | function to count all pairs ( i , j ) such that a [ i ] + [ j ] = a [ i ] / a [ j ] ; stores total count of pairs ; generate all possible pairs ; if a valid pair is found ; increment count ; return the final count ; ",
        "context": "",
        "code": "def countPairs(a, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[j] != 0 and a[i] % a[j] == 0):\n                if ((a[i] + a[j]) == (a[i] // a[j])):\n                    count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-4, -3, 0, 2, 1]\n    N = len(arr)\n    print(countPairs(arr, N))\n",
        "output": "1\n",
        "fn_call": "countPairs"
    },
    {
        "text": "smallest number not less than n which is divisible by all digits of n | python3 program for the above approach ; function to calculate the lcm ; function to find the smallest number satisfying given constraints ; lcm value is 1 initially ; finding the lcm of all non zero digits ; update the value lcm ; stores ceil value ; print the answer ; ",
        "context": "\nimport math\n\n",
        "code": "def LCM(A, B):\n    return (A * B // math .gcd(A, B))\n\n\ndef findSmallestNumber(X):\n    lcm = 1\n    temp = X\n    while (temp):\n        last = temp % 10\n        temp //= 10\n        if (not last):\n            continue\n        lcm = LCM(lcm, last)\n    answer = ((X + lcm - 1) // lcm) * lcm\n    print(answer)\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 280\n    findSmallestNumber(X)\n",
        "output": "280\n",
        "fn_call": "findSmallestNumber"
    },
    {
        "text": "generate all possible strings such that char at index i is either str1 [ i ] or str2 [ i ] | recursive function to generate the required strings ; if length of the current string is equal to the length of the given strings then the current string is part of the result ; choosing the current character from the string a ; choosing the current character from the string b ; ",
        "context": "",
        "code": "def generateStr(a, b, s, count, len):\n    if (count == len):\n        print(s)\n        return\n    generateStr(a[1:], b[1:], s + a[0], count + 1, len)\n    generateStr(a[1:], b[1:], s + b[0], count + 1, len)\n",
        "test": "\na = \"abc\"\nb = \"def\"\nn = len(a)\ngenerateStr(a, b, \"\", 0, n)\n",
        "output": "abc\nabf\naec\naef\ndbc\ndbf\ndec\ndef\n",
        "fn_call": "generateStr"
    },
    {
        "text": "modify string by sorting characters after removal of characters whose frequency is not equal to power of 2 | python3 program for the above approach ; function to remove all the characters from a that whose frequencies are not equal to a perfect power of 2 ; stores the frequency of each character in s ; iterate over characters of string ; update frequency of current character in the array freq [ ] ; traverse the array freq [ ] ; check if the i - th letter is absent from s ; calculate log of frequency of the current character in the s ; calculate power of 2 of lg ; check if freq [ i ] is a power of 2 ; print letter i + ' a ' freq [ i ] times ; ",
        "context": "\nfrom math import log2\n\n",
        "code": "def countFrequency(S, N):\n    freq = [0] * 26\n    for i in range(N):\n        freq[ord(S[i]) - ord('a')] += 1\n    for i in range(26):\n        if (freq[i] == 0):\n            continue\n        lg = int(log2(freq[i]))\n        a = pow(2, lg)\n        if (a == freq[i]):\n            while (freq[i]):\n                print(chr(i + ord('a')), end=\"\")\n                freq[i] -= 1\n",
        "test": "\nif __name__ == '__main__':\n    S = \"aaacbb\"\n    N = len(S)\n    countFrequency(S, N)\n",
        "output": "bbc",
        "fn_call": "countFrequency"
    },
    {
        "text": "number of co | python3 program to count the pairs whose sum of digits is co - prime ; recursive function to return the frequency of numbers having their sum of digits i ; returns 1 or 0 ; returns value of the dp if already stored ; loop from digit 0 to 9 ; to change the tight to 1 ; calling the recursive function to find the frequency ; function to find out frequency of numbers from 1 to n having their sum of digits from 1 to 162 and store them in array ; number to string conversion ; calling the recursive function and pushing it into array ; function to find the pairs ; calling the formarray function of a - 1 numbers ; calling the formarray function of b numbers ; subtracting the frequency of higher number array with lower number array and thus finding the range of numbers from a to b having sum from 1 to 162 ; to find out total number of pairs which are co - prime ; ",
        "context": "\nimport math\n\n",
        "code": "def recursive(idx, sum, tight, st, dp, num):\n    if (idx == num):\n        return sum == 0\n    if (dp[idx][tight][sum] != -1):\n        return dp[idx][tight][sum]\n    ans = 0\n    for d in range(10):\n        newTight = False\n        if (tight and ord(st[idx]) - ord('0') < d):\n            continue\n        if (tight and ord(st[idx]) - ord('0') == d):\n            newTight = True\n        if (sum >= d):\n            ans += recursive(idx + 1, sum - d, newTight, st, dp, num)\n    dp[idx][tight][sum] = ans\n    return dp[idx][tight][sum]\n\n\ndef formArray(N):\n    dp = [[[-1 for x in range(166)]for y in range(2)]for z in range(20)]\n    st = str(N)\n    num = len(st)\n    arr = []\n    for i in range(1, 163):\n        arr .append(recursive(0, i, 1, st, dp, num))\n    return arr\n\n\ndef findPair(a, b):\n    arr_smaller = formArray(a - 1)\n    arr_greater = formArray(b)\n    for i in range(len(arr_greater)):\n        arr_greater[i] -= arr_smaller[i]\n    ans = 0\n    for i in range(1, 163):\n        for j in range(i + 1, 163):\n            if (math .gcd(i, j) == 1):\n                ans = (ans + arr_greater[i - 1] * arr_greater[j - 1])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 12\n    b = 15\n    print(findPair(a, b))\n",
        "output": "4\n",
        "fn_call": "findPair"
    },
    {
        "text": "count all unique outcomes possible by performing s flips on n coins | function to recursively count the number of unique outcomes possible s flips are performed on n coins ; base cases ; recursive calls ; ",
        "context": "",
        "code": "def numberOfUniqueOutcomes(N, S):\n    if (S < N):\n        return 0\n    if (N == 1 or N == S):\n        return 1\n    return (\n        numberOfUniqueOutcomes(\n            N -\n            1,\n            S -\n            1) +\n        numberOfUniqueOutcomes(\n            N -\n            1,\n            S -\n            2))\n",
        "test": "\nif __name__ == '__main__':\n    N, S = 3, 4\n    print(numberOfUniqueOutcomes(N, S))\n",
        "output": "3\n",
        "fn_call": "numberOfUniqueOutcomes"
    },
    {
        "text": "find the sum of numbers from 1 to n excluding those which are powers of k | function to return the sum of all the powers of k from the range [ 1 , n ] ; to store the sum of the series ; while current power of k <= n ; add current power to the sum ; next power of k ; return the sum of the series ; find to return the sum of the elements from the range [ 1 , n ] excluding those which are powers of k ; sum of all the powers of k from [ 1 , n ] ; sum of all the elements from [ 1 , n ] ; return the required sum ; ",
        "context": "",
        "code": "def sumPowersK(n, k):\n    sum = 0\n    num = 1\n    while (num <= n):\n        sum += num\n        num *= k\n    return sum\n\n\ndef getSum(n, k):\n    pwrK = sumPowersK(n, k)\n    sumAll = (n * (n + 1)) / 2\n    return (sumAll - pwrK)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10\n    k = 3\n    print(getSum(n, k))\n",
        "output": "42.0\n",
        "fn_call": "getSum"
    },
    {
        "text": "program to compute log a to any base b ( logb a ) | recursive function to compute log a to the base b ; ",
        "context": "",
        "code": "def log_a_to_base_b(a, b):\n    rslt = (1 + log_a_to_base_b(a // b, b))if (a > (b - 1))else 0\n    return rslt\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 3\n    b = 2\n    print(log_a_to_base_b(a, b))\n    a = 256\n    b = 4\n    print(log_a_to_base_b(a, b))\n",
        "output": "1\n4\n",
        "fn_call": "log_a_to_base_b"
    },
    {
        "text": "distance of chord from center when distance between center and another equal length chord is given | python 3 program to find the distance of chord from center when distance between center and another equal length chord is given ; ",
        "context": "",
        "code": "def lengequichord(z):\n    print(\"The distance between the\", \"chord and the center is\", z)\n",
        "test": "\nif __name__ == \"__main__\":\n    z = 48\n    lengequichord(z)\n",
        "output": "The distance between the chord and the center is 48\n",
        "fn_call": "lengequichord"
    },
    {
        "text": "place n boys and m girls in different rows such that count of persons placed in each row is maximized | function to calculate gcd of two numbers ; function to count maximum persons that can be placed in a row ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef maximumRowValue(n, m):\n    return gcd(n, m)\n",
        "test": "\nif __name__ == '__main__':\n    N = 4\n    M = 2\n    print(maximumRowValue(N, M))\n",
        "output": "2\n",
        "fn_call": "maximumRowValue"
    },
    {
        "text": "total count of sorted numbers upto n digits in range [ l , r ] ( magnificent necklace combinatorics problem ) | function to count total number of ways ; stores all dp - states ; stores the result ; traverse the range [ 0 , n ] ; traverse the range [ 1 , r - l ] ; update dp [ i ] [ j ] ; assign dp [ 0 ] [ r - l ] to ans ; traverse the range [ 1 , n ] ; traverse the range [ 1 , r - l ] ; update dp [ i ] [ j ] ; increment ans by dp [ i - 1 ] [ j ] ; return ans ; ",
        "context": "",
        "code": "def Count(N, L, R):\n    dp = [[0 for i in range(R - L + 1)]for i in range(N)]\n    ans = 0\n    for i in range(N):\n        dp[i][0] = 1\n    for i in range(1, len(dp[0])):\n        dp[0][i] = dp[0][i - 1] + 1\n    ans = dp[0][R - L]\n    for i in range(1, N):\n        for j in range(1, len(dp[0])):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        ans += dp[i][R - L]\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    L = 6\n    R = 9\n    print(Count(N, L, R))\n",
        "output": "34\n",
        "fn_call": "Count"
    },
    {
        "text": "check if a prime number can be expressed as sum of two prime numbers | python3 program to check if a prime number can be expressed as sum of two prime numbers ; function to check whether a number is prime or not ; function to check if a prime number can be expressed as sum of two prime numbers ; if the number is prime , and number - 2 is also prime ; ",
        "context": "\nimport math\n\n",
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math .sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef isPossible(n):\n    if isPrime(n) and isPrime(n - 2):\n        return True\n    else:\n        return False\n",
        "test": "\nn = 13\nif isPossible(n):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "nth positive number whose absolute difference of adjacent digits is at most 1 | return nth number with absolute difference between all adjacent digits at most 1. ; to store all such numbers ; enqueue all integers from 1 to 9 in increasing order . ; perform the operation n times so that we can get all such n numbers . ; store the front element of queue , in array and pop it from queue . ; if the last digit of dequeued integer is not 0 , then enqueue the next such number . ; enqueue the next such number ; if the last digit of dequeued integer is not 9 , then enqueue the next such number . ; ",
        "context": "",
        "code": "def findNthNumber(N):\n    arr = [0 for i in range(N + 1)]\n    q = []\n    for i in range(1, 10, 1):\n        q .append(i)\n    for i in range(1, N + 1, 1):\n        arr[i] = q[0]\n        q .remove(q[0])\n        if (arr[i] % 10 != 0):\n            q .append(arr[i] * 10 + arr[i] % 10 - 1)\n        q .append(arr[i] * 10 + arr[i] % 10)\n        if (arr[i] % 10 != 9):\n            q .append(arr[i] * 10 + arr[i] % 10 + 1)\n    print(arr[N])\n",
        "test": "\nif __name__ == '__main__':\n    N = 21\n    findNthNumber(N)\n",
        "output": "45\n",
        "fn_call": "findNthNumber"
    },
    {
        "text": "stable sort for descending order | bubble sort implementation to sort elements in descending order . ; sorts a [ ] in descending order using bubble sort . ; ",
        "context": "",
        "code": "def print1(a, n):\n    for i in range(0, n + 1):\n        print(a[i], end=\" \")\n    print(\"\")\n\n\ndef sort(a, n):\n    for i in range(n, 0, -1):\n        for j in range(n, n - i, -1):\n            if (a[j] > a[j - 1]):\n                a[j], a[j - 1] = a[j - 1], a[j]\n    print1(a, n)\n",
        "test": "\nn = 7\na = [2, 4, 3, 2, 4, 5, 3]\nsort(a, n - 1)\n",
        "output": "5 4 4 3 3 2 2 \n",
        "fn_call": "sort"
    },
    {
        "text": "multiplicative congruence method for generating pseudo random numbers | function to generate random numbers ; initialize the seed state ; traverse to generate required numbers of random numbers ; follow the linear congruential method ; ",
        "context": "",
        "code": "def multiplicativeCongruentialMethod(Xo, m, a, randomNums, noOfRandomNums):\n    randomNums[0] = Xo\n    for i in range(1, noOfRandomNums):\n        randomNums[i] = (randomNums[i - 1] * a) % m\n",
        "test": "\nif __name__ == '__main__':\n    Xo = 3\n    m = 15\n    a = 7\n    noOfRandomNums = 10\n    randomNums = [0] * (noOfRandomNums)\n    multiplicativeCongruentialMethod(Xo, m, a, randomNums, noOfRandomNums)\n    for i in randomNums:\n        print(i, end=\" \")\n",
        "output": "3 6 12 9 3 6 12 9 3 6 ",
        "fn_call": "multiplicativeCongruentialMethod"
    },
    {
        "text": "lexicographically largest sub | function to return the lexicographically largest sub - sequence of s ; get the max character from the string ; use all the occurrences of the current maximum character ; repeat the steps for the remaining string ; ",
        "context": "",
        "code": "def getSubSeq(s, n):\n    res = \"\"\n    cr = 0\n    while (cr < n):\n        mx = s[cr]\n        for i in range(cr + 1, n):\n            mx = max(mx, s[i])\n        lst = cr\n        for i in range(cr, n):\n            if (s[i] == mx):\n                res += s[i]\n                lst = i\n        cr = lst + 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    s = \"geeksforgeeks\"\n    n = len(s)\n    print(getSubSeq(s, n))\n",
        "output": "ss\n",
        "fn_call": "getSubSeq"
    },
    {
        "text": "product of n terms of a given geometric series | function to calculate product of geometric series ; initialise final product with 1 ; multiply product with each term stored in a ; return the final product ; ",
        "context": "",
        "code": "def productOfGP(a, r, n):\n    product = 1\n    for i in range(0, n):\n        product = product * a\n        a = a * r\n    return product\n",
        "test": "\na = 1\nr = 2\nN = 4\nprint(productOfGP(a, r, N))\n",
        "output": "64\n",
        "fn_call": "productOfGP"
    },
    {
        "text": "find the first natural number whose factorial is divisible by x | gcd function to compute the greatest divisor among a and b ; returns first number whose factorial divides x . ; i = 1 result ; remove common factors ; we found first i . ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if ((a % b) == 0):\n        return b\n    return gcd(b, a % b)\n\n\ndef firstFactorialDivisibleNumber(x):\n    new_x = x\n    for i in range(1, x):\n        new_x /= gcd(i, new_x)\n        if (new_x == 1):\n            break\n    return i\n\n\ndef main():\n    x = 16\n    print(firstFactorialDivisibleNumber(x))\n",
        "test": "\nif __name__ == '__main__':\n    main()\n",
        "output": "6\n",
        "fn_call": "main"
    },
    {
        "text": "sequences of given length where every element is more than or equal to twice of previous | recursive function to find the number of special sequences ; a special sequence cannot exist if length n is more than the maximum value m . ; if n is 0 , found an empty special sequence ; there can be two possibilities : ( 1 ) reduce last element value ( 2 ) consider last element as m and reduce number of terms ; ",
        "context": "",
        "code": "def getTotalNumberOfSequences(m, n):\n    if m < n:\n        return 0\n    if n == 0:\n        return 1\n    res = (getTotalNumberOfSequences(m - 1, n) +\n           getTotalNumberOfSequences(m // 2, n - 1))\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    m = 10\n    n = 4\n    print('Total number of possible sequences:',\n          getTotalNumberOfSequences(m, n))\n",
        "output": "Total number of possible sequences: 4\n",
        "fn_call": "getTotalNumberOfSequences"
    },
    {
        "text": "find length of diagonal of hexagon | function to find the diagonal of the hexagon ; side cannot be negative ; diagonal of the hexagon ; ",
        "context": "",
        "code": "def hexadiagonal(a):\n    if (a < 0):\n        return -1\n    return 2 * a\n",
        "test": "\nif __name__ == '__main__':\n    a = 4\n    print(hexadiagonal(a))\n",
        "output": "8\n",
        "fn_call": "hexadiagonal"
    },
    {
        "text": "k | python3 program to find kth element from two sorted arrays ; in case we have reached end of array 1 ; in case we have reached end of array 2 ; k should never reach 0 or exceed sizes of arrays ; compare first elements of arrays and return ; size of array 1 is less than k / 2 ; last element of array 1 is not kth we can directly return the ( k - m ) th element in array 2 ; size of array 2 is less than k / 2 ; normal comparison , move starting index of one array k / 2 to the right ; ",
        "context": "",
        "code": "def kth(arr1, arr2, m, n, k, st1=0, st2=0):\n    if (st1 == m):\n        return arr2[st2 + k - 1]\n    if (st2 == n):\n        return arr1[st1 + k - 1]\n    if (k == 0 or k > (m - st1) + (n - st2)):\n        return -1\n    if (k == 1):\n        if (arr1[st1] < arr2[st2]):\n            return arr1[st1]\n        else:\n            return arr2[st2]\n    curr = int(k / 2)\n    if (curr - 1 >= m - st1):\n        if (arr1[m - 1] < arr2[st2 + curr - 1]):\n            return arr2[st2 + (k - (m - st1) - 1)]\n        else:\n            return kth(arr1, arr2, m, n, k - curr, st1, st2 + curr)\n    if (curr - 1 >= n - st2):\n        if (arr2[n - 1] < arr1[st1 + curr - 1]):\n            return arr1[st1 + (k - (n - st2) - 1)]\n        else:\n            return kth(arr1, arr2, m, n, k - curr, st1 + curr, st2)\n    else:\n        if (arr1[curr + st1 - 1] < arr2[curr + st2 - 1]):\n            return kth(arr1, arr2, m, n, k - curr, st1 + curr, st2)\n        else:\n            return kth(arr1, arr2, m, n, k - curr, st1, st2 + curr)\n",
        "test": "\narr1 = [2, 3, 6, 7, 9]\narr2 = [1, 4, 8, 10]\nk = 5\nprint(kth(arr1, arr2, 5, 4, k))\n",
        "output": "6\n",
        "fn_call": "kth"
    },
    {
        "text": "rearrange an array such that arr [ i ] = i | function to tranform the array ; iterate over the array ; check is any ar [ j ] exists such that ar [ j ] is equal to i ; iterate over array ; if not present ; print the output ; ",
        "context": "",
        "code": "def fixArray(ar, n):\n    for i in range(n):\n        for j in range(n):\n            if (ar[j] == i):\n                ar[j], ar[i] = ar[i], ar[j]\n    for i in range(n):\n        if (ar[i] != i):\n            ar[i] = -1\n    print(\"Array after Rearranging\")\n    for i in range(n):\n        print(ar[i], end=\" \")\n",
        "test": "\nar = [-1, -1, 6, 1, 9, 3, 2, -1, 4, -1]\nn = len(ar)\nfixArray(ar, n)\n",
        "output": "Array after Rearranging\n-1 1 2 3 4 -1 6 -1 -1 9 ",
        "fn_call": "fixArray"
    },
    {
        "text": "check whether the number has only first and last bits set | set 2 | function to check whether the number has only first and last bits set ; ",
        "context": "",
        "code": "def onlyFirstAndLastAreSet(n):\n    if (n == 1):\n        return True\n    if (n == 2):\n        return False\n    return (((n - 1) & (n - 2)) == 0)\n",
        "test": "\nn = 9\nif (onlyFirstAndLastAreSet(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "onlyFirstAndLastAreSet"
    },
    {
        "text": "check whether bitwise and of n numbers is even or odd | function to check if the bitwise and of the array elements is even or odd ; if at least an even element is present then the bitwise and of the array elements will be even ; ",
        "context": "",
        "code": "def checkEvenOdd(arr, n):\n    for i in range(n):\n        if (arr[i] % 2 == 0):\n            print(\"Even\", end=\"\")\n            return\n    print(\"Odd\", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 12, 20, 36, 38]\n    n = len(arr)\n    checkEvenOdd(arr, n)\n",
        "output": "Even",
        "fn_call": "checkEvenOdd"
    },
    {
        "text": "sum of all subsets whose sum is a perfect number from a given array | python3 program for the above approach ; function to check is a given number is a perfect number or not ; stores the sum of its divisors ; add all divisors of x to sum_div ; if the sum of divisors is equal to the given number , return true ; otherwise , return false ; function to find sum of all subsets from an array whose sum is a perfect number ; prthe current subset sum if it is a perfect number ; check if sum is a perfect number or not ; calculate sum of the subset including arr [ l ] ; calculate sum of the subset excluding arr [ l ] ; ",
        "context": "\nimport math\n\n",
        "code": "def isPerfect(x):\n    sum_div = 1\n    for i in range(2, (x // 2) + 1):\n        if (x % i == 0):\n            sum_div += i\n    if (sum_div == x):\n        return 1\n    else:\n        return 0\n\n\ndef subsetSum(arr, l, r, sum):\n    if (l > r):\n        if (isPerfect(sum) != 0):\n            print(sum, end=\" \")\n        return\n    subsetSum(arr, l + 1, r, sum + arr[l])\n    subsetSum(arr, l + 1, r, sum)\n",
        "test": "\narr = [5, 4, 6]\nN = len(arr)\nsubsetSum(arr, 0, N - 1, 0)\n",
        "output": "6 ",
        "fn_call": "subsetSum"
    },
    {
        "text": "how to validate gst ( goods and services tax ) number using regular expression | python3 program to validate gst ( goods and services tax ) number using regular expression ; function to validate gst ( goods and services tax ) number . ; regex to check valid gst ( goods and services tax ) number ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidMasterCardNo(str):\n    regex = \"^[0-9]{2}[A-Z]{5}[0-9]{4}\"+\"[A-Z]{1}[1-9A-Z]{1}\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"06BZAHM6385P6Z2\"\nprint(isValidMasterCardNo(str1))\nstr2 = \"06BZAF67\"\nprint(isValidMasterCardNo(str2))\nstr3 = \"AZBZAHM6385P6Z2\"\nprint(isValidMasterCardNo(str3))\nstr4 = \"06BZ63AHM85P6Z2\"\nprint(isValidMasterCardNo(str4))\nstr5 = \"06BZAHM6385P6F2\"\nprint(isValidMasterCardNo(str5))\n",
        "output": "True\nFalse\nFalse\nFalse\nTrue\n",
        "fn_call": "isValidMasterCardNo"
    },
    {
        "text": "count subarrays made up of elements having exactly k set bits | function to count the number of set bits in an integer n ; stores the count of set bits ; while n is non - zero ; if the lsb is 1 , then increment ans by 1 ; return the total set bits ; function to count the number of subarrays having made up of elements having k set bits ; stores the total count of resultant subarrays ; traverse the given array ; if the current element has k set bits ; otherwise ; increment count of subarrays ; return total count of subarrays ; ",
        "context": "",
        "code": "def countSet(N):\n    ans = 0\n    while N:\n        ans += N & 1\n        N >>= 1\n    return ans\n\n\ndef countSub(arr, k):\n    ans = 0\n    setK = 0\n    for i in arr:\n        if countSet(i) == k:\n            setK += 1\n        else:\n            setK = 0\n        ans += setK\n    return ans\n",
        "test": "\narr = [4, 2, 1, 5, 6]\nK = 2\nprint(countSub(arr, K))\n",
        "output": "3\n",
        "fn_call": "countSub"
    },
    {
        "text": "find maximum topics to prepare in order to pass the exam | python3 implementation of the approach ; function to return the maximum marks by considering topics which can be completed in the given time duration ; if we are given 0 time then nothing can be done so all values are 0 ; if we are given 0 topics then the time required will be 0 for sure ; calculating the maximum marks that can be achieved under the given time constraints ; if time taken to read that topic is more than the time left now at position j then do no read that topic ; two cases arise : 1 ) considering current topic 2 ) ignoring current topic we are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; it means we have not considered reading this topic for max weightage sum ; adding the topic time ; evaluating the left over time after considering this current topic ; one topic completed ; it contains the maximum weightage sum formed by considering the topics ; condition when exam cannot be passed ; return the marks that can be obtained after passing the exam ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def MaximumMarks(marksarr, timearr, h, n, p):\n    no_of_topics = n + 1\n    total_time = h + 1\n    T = np .zeros((no_of_topics, total_time))\n    for i in range(no_of_topics):\n        T[i][0] = 0\n    for j in range(total_time):\n        T[0][j] = 0\n    for i in range(1, no_of_topics):\n        for j in range(1, total_time):\n            if (j < timearr[i]):\n                T[i][j] = T[i - 1][j]\n            else:\n                T[i][j] = max(marksarr[i] + T[i - 1]\n                              [j - timearr[i]], T[i - 1][j])\n    i = no_of_topics - 1\n    j = total_time - 1\n    sum = 0\n    while (i > 0 and j > 0):\n        if (T[i][j] == T[i - 1][j]):\n            i -= 1\n        else:\n            sum += timearr[i]\n            j -= timearr[i]\n            i -= 1\n    marks = T[no_of_topics - 1][total_time - 1]\n    if (marks < p):\n        return -1\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    h = 10\n    p = 10\n    marksarr = [0, 6, 4, 2, 8]\n    timearr = [0, 4, 6, 2, 7]\n    print(MaximumMarks(marksarr, timearr, h, n, p))\n",
        "output": "10\n",
        "fn_call": "MaximumMarks"
    },
    {
        "text": "consecutive prime numbers greater than equal to given number . | python 3 program for the above approach function to check prime . ; function to check prime . ; it means it is not a prime ; no factor other than 1 therefore prime number ; function to find out the required consecutive primes . ; finding first prime just less than sqrt ( n ) . ; finding prime just greater than sqrt ( n ) . ; product of both prime is greater than n then print it ; finding prime greater than second ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def is_prime(n):\n    if (n == 1):\n        return False\n    for i in range(2, int(sqrt(n)) + 1, 1):\n        if (n % i == 0):\n            return False\n    return True\n\n\ndef consecutive_primes(n):\n    first = -1\n    second = -1\n    i = int(sqrt(n))\n    while (i >= 2):\n        if (is_prime(i)):\n            first = i\n            break\n        i -= 1\n    for i in range(int(sqrt(n)) + 1, n // 2 + 1, 1):\n        if (is_prime(i)):\n            second = i\n            break\n    if (first * second >= n):\n        print(first, second)\n    else:\n        for i in range(second + 1, n + 1, 1):\n            if (is_prime(i)):\n                print(second, i)\n                return\n",
        "test": "\nif __name__ == '__main__':\n    n = 14\n    consecutive_primes(n)\n",
        "output": "3 5\n",
        "fn_call": "consecutive_primes"
    },
    {
        "text": "minimum length paths between 1 to n including each node | function to calculate the distances from node 1 to n ; vector to store our edges ; storing the edgees in the vector ; initialize queue ; bfs from first node using queue ; pop from queue ; traversing its adjacency list ; initialize queue ; bfs from last node using queue ; pop from queue ; traversing its adjacency list ; printing the minimum distance including node i ; if not reachable ; path exists ; ",
        "context": "",
        "code": "def minDisIncludingNode(n, m, edges):\n    g = [[]for i in range(10005)]\n    for i in range(m):\n        a = edges[i][0] - 1\n        b = edges[i][1] - 1\n        g[a].append(b)\n        g[b].append(a)\n    q = []\n    q .append([0, 0])\n    dist = [1e9 for i in range(n)]\n    dist[0] = 0\n    while (len(q) > 0):\n        up = q[0]\n        q = q[1:]\n        x = up[0]\n        lev = up[1]\n        if (lev > dist[x]):\n            continue\n        if (x == n - 1):\n            continue\n        for y in g[x]:\n            if (dist[y] > lev + 1):\n                dist[y] = lev + 1\n                q .append([y, lev + 1])\n    q1 = []\n    q1 .append([n - 1, 0])\n    dist1 = [1e9 for i in range(n)]\n    dist1[n - 1] = 0\n    while (len(q1) > 0):\n        up = q1[0]\n        q1 = q1[1:]\n        x = up[0]\n        lev = up[1]\n        if (lev > dist1[x]):\n            continue\n        if (x == 0):\n            continue\n        for y in g[x]:\n            if (dist1[y] > lev + 1):\n                dist1[y] = lev + 1\n                q1 .append([y, lev + 1])\n    for i in range(n):\n        if (dist[i] + dist1[i] > 1e9):\n            print(-1, end=\" \")\n        else:\n            print(dist[i] + dist1[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    m = 7\n    edges = [[1, 2], [1, 4], [2, 3], [2, 5], [4, 3], [4, 5], [1, 5]]\n    minDisIncludingNode(n, m, edges)\n",
        "output": "1 2 4 2 1 ",
        "fn_call": "minDisIncludingNode"
    },
    {
        "text": "xor of all subarray xors | set 1 | returns xor of all subarray xors ; initialize result by 0 as ( a xor 0 = a ) ; loop over all elements once ; get the frequency of current element ; if frequency is odd , then include it in the result ; return the result ; ",
        "context": "",
        "code": "def getTotalXorOfSubarrayXors(arr, N):\n    res = 0\n    for i in range(0, N):\n        freq = (i + 1) * (N - i)\n        if (freq % 2 == 1):\n            res = res ^ arr[i]\n    return res\n",
        "test": "\narr = [3, 5, 2, 4, 6]\nN = len(arr)\nprint(getTotalXorOfSubarrayXors(arr, N))\n",
        "output": "7\n",
        "fn_call": "getTotalXorOfSubarrayXors"
    },
    {
        "text": "find the count of m character words which have at least one character repeated | function to return the factorial of a number ; function to return the value of npr ; function to return the total number of m length words which have at least a single character repeated more than once ; ",
        "context": "",
        "code": "def fact(n):\n    if (n <= 1):\n        return 1\n    return n * fact(n - 1)\n\n\ndef nPr(n, r):\n    return fact(n) // fact(n - r)\n\n\ndef countWords(N, M):\n    return pow(N, M) - nPr(N, M)\n",
        "test": "\nN = 10\nM = 5\nprint(countWords(N, M))\n",
        "output": "69760\n",
        "fn_call": "countWords"
    },
    {
        "text": "maximize array sum after changing sign of any elements for exactly m times | function to find the maximum sum with m flips ; declare a priority queue i . e . min heap ; declare the sum as zero ; push all elements of the array in it ; iterate for m times ; get the top element ; flip the sign of the top element ; remove the top element ; update the sum ; push the temp into the queue ; ",
        "context": "",
        "code": "def findMaximumSumWithMflips(arr, N, M):\n    pq = []\n    sum = 0\n    for i in range(N):\n        pq .append(arr[i])\n        sum += arr[i]\n        pq .sort()\n    while (M > 0):\n        sum -= pq[0]\n        temp = -1 * pq[0]\n        pq = pq[1:]\n        sum += temp\n        pq .append(temp)\n        pq .sort()\n        M -= 1\n    print(sum)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-3, 7, -1, -5, -3]\n    N = len(arr)\n    M = 4\n    findMaximumSumWithMflips(arr, N, M)\n",
        "output": "19\n",
        "fn_call": "findMaximumSumWithMflips"
    },
    {
        "text": "modify string by inserting characters such that every k | function to replace all ' ? ' characters in a string such that the given conditions are satisfied ; traverse the string to map the characters with respective positions ; traverse the string again and replace all unknown characters ; if i % k is not found in the map m , then return - 1 ; update s [ i ] ; print the string s ; ",
        "context": "",
        "code": "def fillString(s, k):\n    mp = {}\n    for i in range(len(s)):\n        if (s[i] != '?'):\n            mp[i % k] = s[i]\n    s = list(s)\n    for i in range(len(s)):\n        if ((i % k)not in mp):\n            print(-1)\n            return\n        s[i] = mp[i % k]\n    s = ''.join(s)\n    print(s)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"????abcd\"\n    K = 4\n    fillString(S, K)\n",
        "output": "abcdabcd\n",
        "fn_call": "fillString"
    },
    {
        "text": "count substrings with same first and last characters | returns true if first and last characters of s are same . ; starting point of substring ; length of substring ; check if current substring has same starting and ending characters . ; ",
        "context": "",
        "code": "def checkEquality(s):\n    return (ord(s[0]) == ord(s[len(s) - 1]))\n\n\ndef countSubstringWithEqualEnds(s):\n    result = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(1, n - i + 1):\n            if (checkEquality(s[i:i + j])):\n                result += 1\n    return result\n",
        "test": "\ns = \"abcab\"\nprint(countSubstringWithEqualEnds(s))\n",
        "output": "7\n",
        "fn_call": "countSubstringWithEqualEnds"
    },
    {
        "text": "count pairs from an array whose bitwise or is greater than bitwise and | function to count the number of pairs ( i , j ) their bitwise or is greater than bitwise and ; store the required answer ; check for all possible pairs ; if the condition satisfy then increment count by 1 ; prthe answer ; ",
        "context": "",
        "code": "def countPairs(A, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ((A[i] | A[j]) > (A[i] & A[j])):\n                count += 1\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 4, 7]\n    N = len(A)\n    countPairs(A, N)\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "check for possible path in 2d matrix | python3 program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; directions ; queue ; insert the top right corner . ; until queue is empty ; mark as visited ; destination is reached . ; check all four directions ; using the direction array ; not blocked and valid ; ",
        "context": "\nrow = 5\ncol = 5\n\n",
        "code": "def isPath(arr):\n    Dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    q = []\n    q .append((0, 0))\n    while (len(q) > 0):\n        p = q[0]\n        q .pop(0)\n        arr[p[0]][p[1]] = -1\n        if (p == (row - 1, col - 1)):\n            return True\n        for i in range(4):\n            a = p[0] + Dir[i][0]\n            b = p[1] + Dir[i][1]\n            if (a >= 0 and b >= 0 and a < row and b < col and arr[a][b] != -1):\n                q .append((a, b))\n    return False\n",
        "test": "\narr = [[0, 0, 0, -1, 0], [-1, 0, 0, -1, -1],\n       [0, 0, 0, -1, 0], [-1, 0, -1, 0, -1], [0, 0, -1, 0, 0]]\nif (isPath(arr)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isPath"
    },
    {
        "text": "minimum cost to convert given string to consist of only vowels | function to find the minimum cost ; store vowels ; loop for iteration of string ; loop to calculate the cost ; add minimum cost ; ",
        "context": "",
        "code": "def min_cost(st):\n    vow = \"aeiou\"\n    cost = 0\n    for i in range(len(st)):\n        costs = []\n        for j in range(5):\n            costs .append(abs(ord(st[i]) - ord(vow[j])))\n        cost += min(costs)\n    return cost\n",
        "test": "\nstr = \"abcde\"\nprint(min_cost(str))\n",
        "output": "4\n",
        "fn_call": "min_cost"
    },
    {
        "text": "minimum moves to reach target on a infinite line | set 2 | python code to find minimum moves to reach target ; function to find minimum steps to reach target ; handling negatives by symmetry ; keep moving while sum is smaller i . e calculating n ; case 1 : d is even ; d is odd ; ",
        "context": "\nimport math\n\n",
        "code": "def StepstoReachTarget(target):\n    target = abs(target)\n    n = math .ceil((-1.0 + math .sqrt(1 + 8.0 * target)) / 2)\n    sum = n * (n + 1) / 2\n    if (sum == target):\n        return n\n    d = sum - target\n    if ((int(d) & 1) == 0):\n        return n\n    else:\n        if (int(d) & 1):\n            return n + 2\n        return n + 1\n",
        "test": "\ntarget = 5\nprint(StepstoReachTarget(target))\n",
        "output": "5\n",
        "fn_call": "StepstoReachTarget"
    },
    {
        "text": "find the k | function to find the k - th minimum element from an array concatenated m times ; sort the elements in ascending order ; return k 'th min element  present at k-1 index ; ",
        "context": "",
        "code": "def KthMinValAfterMconcatenate(A, N, M, K):\n    V = []\n    for i in range(0, M):\n        for j in range(0, N):\n            V .append(A[j])\n    V .sort()\n    return V[K - 1]\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [3, 1, 2]\n    M, K = 3, 4\n    N = len(A)\n    print(KthMinValAfterMconcatenate(A, N, M, K))\n",
        "output": "2\n",
        "fn_call": "KthMinValAfterMconcatenate"
    },
    {
        "text": "Split the array and add the first part to the end | Python program to split array and move first part to end . ; Rotate array by 1. ; main",
        "context": "",
        "code": "def splitArr(arr, n, k):\n    for i in range(0, k):\n        x = arr[0]\n        for j in range(0, n - 1):\n            arr[j] = arr[j + 1]\n        arr[n - 1] = x\n",
        "test": "\narr = [12, 10, 5, 6, 52, 36]\nn = len(arr)\nposition = 2\nsplitArr(arr, n, position)\nfor i in range(0, n):\n    print(arr[i], end=' ')\n",
        "output": "5 6 52 36 12 10 ",
        "fn_call": "splitArr"
    },
    {
        "text": "total no of 1 's in numbers | python3 code to count the frequency of 1 in numbers less than or equal to the given number . ; ",
        "context": "",
        "code": "def countDigitOne(n):\n    countr = 0\n    for i in range(1, n + 1):\n        str1 = str(i)\n        countr += str1 .count(\"1\")\n    return countr\n",
        "test": "\nn = 13\nprint(countDigitOne(n))\nn = 131\nprint(countDigitOne(n))\nn = 159\nprint(countDigitOne(n))\n",
        "output": "6\n66\n96\n",
        "fn_call": "countDigitOne"
    },
    {
        "text": "determine position of two points with respect to a 3d plane | function to check position of two points with respect to a plane in 3d ; put coordinates in plane equation ; if both values have same sign ; if both values have different sign ; if both values are zero ; if either of the two values is zero ; ",
        "context": "",
        "code": "def check_position(a, b, c, d, x1, y1, z1, x2, y2, z2):\n    value_1 = a * x1 + b * y1 + c * z1 + d\n    value_2 = a * x2 + b * y2 + c * z2 + d\n    if ((value_1 > 0 and value_2 > 0) or (value_1 < 0 and value_2 < 0)):\n        print(\"On same side\")\n    if ((value_1 > 0 and value_2  0)):\n        print(\"On different sides\")\n    if (value_1 == 0 and value_2 == 0):\n        print(\"Both on the plane\")\n    if (value_1 == 0 and value_2 != 0):\n        print(\"Point 1 on the plane\")\n    if (value_1 != 0 and value_2 == 0):\n        print(\"Point 2 on the plane\")\n",
        "test": "\nif __name__ == '__main__':\n    a, b, c, d = 1, 2, 3, 4\n    x1, y1, z1 = -2, -2, 1\n    x2, y2, z2 = -4, 11, -1\n    check_position(a, b, c, d, x1, y1, z1, x2, y2, z2)\n",
        "output": "On same side\n",
        "fn_call": "check_position"
    },
    {
        "text": "count quadruples from four sorted arrays whose sum is equal to a given value x | count pairs from the two sorted array whose sum is equal to the given ' value ' ; traverse ' arr1 [ ] ' from left to right traverse ' arr2 [ ] ' from right to left ; if the ' sum ' is equal to ' value ' , then increment ' l ' , decrement ' r ' and increment ' count ' ; if the ' sum ' is greater than ' value ' , then decrement r ; else increment l ; required count of pairs print ( count ) ; function to count all quadruples from four sorted arrays whose sum is equal to a ",
        "context": "",
        "code": "def countPairs(arr1, arr2, n, value):\n    count = 0\n    l = 0\n    r = n - 1\n    while (l = 0):\n        sum = arr1[l] + arr2[r]\n        if (sum == value):\n            l += 1\n            r -= 1\n            count += 1\n        elif (sum > value):\n            r -= 1\n        else:\n            l += 1\n    return count\n\n\ndef countQuadruples(arr1, arr2, arr3, arr4, n, x):\n    count = 0\n    for i in range(0, n):\n        for j in range(0, n):\n            p_sum = arr1[i] + arr2[j]\n            count += int(countPairs(arr3, arr4, n, x - p_sum))\n    return count\n",
        "test": "\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8]\nn = len(arr1)\nx = 30\nprint(\"Count = \", countQuadruples(arr1, arr2, arr3, arr4, n, x))\n",
        "output": "Count =  4\n",
        "fn_call": "countQuadruples"
    },
    {
        "text": "maximum number of teams of size k possible with each player from different country | function to find if t number of teams can be formed or not ; store the sum of array elements ; traverse the array teams [ ] ; required condition ; function to find the maximum number of teams possible ; lower and upper part of the range ; perform the binary search ; find the value of mid ; perform the binary search ; otherwise , update the search range ; otherwise , update the search range ; ",
        "context": "",
        "code": "def is_possible(teams, T, k):\n    sum = 0\n    for i in range(len(teams)):\n        sum += min(T, teams[i])\n    return (sum >= (T * k))\n\n\ndef countOfTeams(teams_list, N, K):\n    lb = 0\n    ub = 1000000000\n    while (lb <= ub):\n        mid = lb + (ub - lb) // 2\n        if (is_possible(teams_list, mid, K)):\n            if (is_possible(teams_list, mid + 1, K) == False):\n                return mid\n            else:\n                lb = mid + 1\n        else:\n            ub = mid - 1\n    return 0\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 4]\n    K = 2\n    N = len(arr)\n    print(countOfTeams(arr, N, K))\n",
        "output": "4\n",
        "fn_call": "countOfTeams"
    },
    {
        "text": "xnor of two numbers | python program to find xnor of two numbers ; please refer below post for details of this function https : www . geeksforgeeks . org / toggle - bits - significant - bit / ; make a copy of n as we are going to change it . ; suppose n is 273 ( binary is 100010001 ) . it does following 100010001 | 010001000 = 110011001 ; this makes sure 4 bits ( from msb and including msb ) are set . it does following 110011001 | 001100110 = 111111111 ; returns xnor of num1 and num2 ; make sure num1 is larger ; ",
        "context": "\nimport math\n\n",
        "code": "def togglebit(n):\n    if (n == 0):\n        return 1\n    i = n\n    n = n | (n >> 1)\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    return i ^ n\n\n\ndef xnor(num1, num2):\n    if (num1 < num2):\n        temp = num1\n        num1 = num2\n        num2 = temp\n    num1 = togglebit(num1)\n    return num1 ^ num2\n",
        "test": "\na = 10\nb = 20\nprint(xnor(a, b))\n",
        "output": "1\n",
        "fn_call": "xnor"
    },
    {
        "text": "calculate area and height of an isosceles triangle whose sides are radii of a circle | python3 program for the above approach ; function to convert given angle from degree to radian ; function to calculate height and area of the triangle oab ; stores the angle oab and oba ; stores the angle in radians ; stores the height ; print height of the triangle ; stores the base of triangle oab ; stores the area of the triangle ; print the area of triangle oab ; ",
        "context": "\nfrom math import sin, cos\n\n",
        "code": "def Convert(degree):\n    pi = 3.14159265359\n    return (degree * (pi / 180))\n\n\ndef areaAndHeightOfTraingle(radius, a):\n    if (a >= 180 or a == 0):\n        print(\"Not possible\")\n        return\n    base_angle = (180 - a) / 2\n    radians = Convert(base_angle)\n    height = sin(radians) * radius\n    print(\"Height of triangle \", round(height, 1))\n    base = cos(radians) * radius\n    area = base * height\n    print(\"Area of triangle \", round(area, 4))\n",
        "test": "\nif __name__ == '__main__':\n    R, angle = 5, 120\n    areaAndHeightOfTraingle(R, angle)\n",
        "output": "Height of triangle  2.5\nArea of triangle  10.8253\n",
        "fn_call": "areaAndHeightOfTraingle"
    },
    {
        "text": "maximum students to pass after giving bonus to everybody and not exceeding 100 marks | function to return the number of students that can pass ; maximum marks ; maximum bonus marks that can be given ; counting the number of students that can pass ; ",
        "context": "",
        "code": "def check(n, marks):\n    x = max(marks)\n    bonus = 100 - x\n    c = 0\n    for i in range(n):\n        if (marks[i] + bonus >= 50):\n            c += 1\n    return c\n",
        "test": "\nn = 5\nmarks = [0, 21, 83, 45, 64]\nprint(check(n, marks))\n",
        "output": "3\n",
        "fn_call": "check"
    },
    {
        "text": "maximum size of sub | function that compares a and b ; function to return length of longest subarray that satisfies one of the given conditions ; ",
        "context": "",
        "code": "def cmp(a, b):\n    return (a > b) - (a < b)\n\n\ndef maxSubarraySize(arr):\n    N = len(arr)\n    ans = 1\n    anchor = 0\n    for i in range(1, N):\n        c = cmp(arr[i - 1], arr[i])\n        if c == 0:\n            anchor = i\n        elif i == N - 1 or c * cmp(arr[i], arr[i + 1]) != -1:\n            ans = max(ans, i - anchor + 1)\n            anchor = i\n    return ans\n",
        "test": "\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxSubarraySize(arr))\n",
        "output": "5\n",
        "fn_call": "maxSubarraySize"
    },
    {
        "text": "perform range sum queries on string as per given condition | function to perform range sum queries on string as per the given condition ; initialize n by string size ; create array a [ ] for prefix sum ; iterate till n ; traverse the queries ; check if if l == 1 range sum will be a [ r - 1 ] ; condition if l > 1 range sum will be a [ r - 1 ] - a [ l - 2 ] ; given string ; ",
        "context": "",
        "code": "def Range_sum_query(S, Query):\n    N = len(S)\n    A = [0] * N\n    A[0] = ord(S[0]) - ord('a') + 1\n    for i in range(1, N):\n        A[i] = ord(S[i]) - ord('a') + 1\n        A[i] = A[i] + A[i - 1]\n    for i in range(len(Query)):\n        if (Query[i][0] == 1):\n            print(A[Query[i][1] - 1])\n        else:\n            print(A[Query[i][1] - 1] - A[Query[i][0] - 2])\n",
        "test": "\nS = \"abcd\"\nQuery = []\nQuery .append([2, 4])\nQuery .append([1, 3])\nRange_sum_query(S, Query)\n",
        "output": "9\n6\n",
        "fn_call": "Range_sum_query"
    },
    {
        "text": "count of pairs with sum n from first n natural numbers | funciton to calculate the value of count ; stores the count of pairs ; set the two pointers ; check if the sum of pirs is equal to n ; increase the count of pairs ; move to the next pair ; ",
        "context": "",
        "code": "def numberOfPairs(n):\n    count = 0\n    i = 1\n    j = n - 1\n    while (i < j):\n        if (i + j) == n:\n            count += 1\n        i += 1\n        j -= 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 8\n    print(numberOfPairs(n))\n",
        "output": "3\n",
        "fn_call": "numberOfPairs"
    },
    {
        "text": "largest number dividing maximum number of elements in the array | python3 implementation of the approach ; function to return the largest number that divides the maximum elements from the given array ; finding gcd of all the numbers in the array ; ",
        "context": "\nfrom math import gcd as __gcd\n\n",
        "code": "def findLargest(arr, n):\n    gcd = 0\n    for i in range(n):\n        gcd = __gcd(arr[i], gcd)\n    return gcd\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 6, 9]\n    n = len(arr)\n    print(findLargest(arr, n))\n",
        "output": "3\n",
        "fn_call": "findLargest"
    },
    {
        "text": "split array into two subsequences having minimum count of pairs with sum equal to x | function to split the array into two subsequences ; stores the two subsequences ; flag to set / reset to split arrays elements alternately into two arrays ; traverse the given array ; if 2 * arr [ i ] is less than x ; push element into the first array ; if 2 * arr [ i ] is greater than x ; push element into the second array ; if 2 * arr [ i ] is equal to x ; alternatively place the elements into the two arrays ; print both the arrays ; ",
        "context": "",
        "code": "def solve(arr, N, X):\n    A = []\n    B = []\n    c = 0\n    for i in range(N):\n        if ((2 * arr[i]) < X):\n            A .append(arr[i])\n        elif ((2 * arr[i]) > X):\n            B .append(arr[i])\n        else:\n            if (c % 2 == 0):\n                A .append(arr[i])\n            else:\n                B .append(arr[i])\n            c += 1\n    print(\"The First Array is - \", end=\" \")\n    for i in range(len(A)):\n        print(A[i], end=\" \")\n    print()\n    print(\"The Second Array is - \", end=\" \")\n    for i in range(len(B)):\n        print(B[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 5, 4, 3, 6, 2, 4, 3]\n    X = 7\n    N = len(arr)\n    solve(arr, N, X)\n",
        "output": "The First Array is -  1 3 2 3 \nThe Second Array is -  5 4 6 4 ",
        "fn_call": "solve"
    },
    {
        "text": "first digit in product of an array of numbers | python implementation to find first digit of a single number ; keep dividing by 10 until it is greater than equal to 10 ; ",
        "context": "",
        "code": "def firstDigit(x):\n    while (x >= 10):\n        x = x // 10\n    return x\n",
        "test": "\nprint(firstDigit(12345))\nprint(firstDigit(5432))\n",
        "output": "1\n5\n",
        "fn_call": "firstDigit"
    },
    {
        "text": "count subsequences with same values of bitwise and , or and xor | ''function for finding count of possible subsequence ; '' creating a map to count the frequency of each element ; store frequency of each element ; iterate through the map ; add all possible combination for key equal zero ; add all ( odd number of elements ) possible combination for key other than zero ; ",
        "context": "",
        "code": "def countSubseq(arr, n):\n    count = 0\n    mp = {}\n    for x in arr:\n        if x in mp .keys():\n            mp[x] += 1\n        else:\n            mp[x] = 1\n    for i in mp .keys():\n        if (i == 0):\n            count += pow(2, mp[i]) - 1\n        else:\n            count += pow(2, mp[i] - 1)\n    return count\n",
        "test": "\narr = [2, 2, 2, 5, 6]\nn = len(arr)\nprint(countSubseq(arr, n))\n",
        "output": "6\n",
        "fn_call": "countSubseq"
    },
    {
        "text": "radius of a circle having area equal to the sum of area of the circles having given radii | function to calculate radius of the circle having area equal to sum of the area of two circles with given radii ; area of first circle ; area of second circle ; area of third circle ; radius of third circle ; ",
        "context": "",
        "code": "def findRadius(r1, r2):\n    a1, a2, a3, r3 = 0, 0, 0, 0\n    a1 = 3.14 * r1 * r1\n    a2 = 3.14 * r2 * r2\n    a3 = a1 + a2\n    r3 = ((a3 / 3.14)**(1 / 2))\n    return r3\n",
        "test": "\nif __name__ == '__main__':\n    r1 = 8\n    r2 = 6\n    print(int(findRadius(r1, r2)))\n",
        "output": "10\n",
        "fn_call": "findRadius"
    },
    {
        "text": "sorting boundary elements of a matrix | python program for the above approach ; appending border elements ; sorting the list ; printing first row with first n elements from a ; printing n - 2 rows ; print elements from last ; print middle elements from original matrix ; print elements from front ; printing last row ; dimensions of a matrix ; ",
        "context": "",
        "code": "def printMatrix(grid, m, n):\n    A = []\n    for i in range(m):\n        for j in range(n):\n            if j == n - 1 or (i == m - 1) or j == 0 or i == 0:\n                A .append(grid[i][j])\n    A .sort()\n    print(*A[:n])\n    for i in range(m - 2):\n        print(A[len(A) - i - 1], end=\" \")\n        for j in range(1, n - 1):\n            print(grid[i + 1][j], end=\" \")\n        print(A[n + i])\n    print(*reversed(A[n + m - 2:n + m - 2 + n]))\n",
        "test": "\nm, n = 4, 5\ngrid = [[1, 2, 3, 4, 0], [1, 1, 1, 1, 2], [1, 2, 2, 2, 4], [1, 9, 3, 1, 7]]\nprintMatrix(grid, m, n)\n",
        "output": "0 1 1 1 1\n9 1 1 1 1\n7 2 2 2 2\n4 4 3 3 2\n",
        "fn_call": "printMatrix"
    },
    {
        "text": "find larger of x ^ y and y ^ x | python3 program to print greater of x ^ y and y ^ x ; ",
        "context": "\nimport math\n\n",
        "code": "def printGreater(x, y):\n    X = y * math .log(x)\n    Y = x * math .log(y)\n    if (abs(X - Y) < 1e-9):\n        print(\"Equal\")\n    elif (X > Y):\n        print(x, \"^\", y)\n    else:\n        print(y, \"^\", x)\n",
        "test": "\nx = 5\ny = 8\nprintGreater(x, y)\n",
        "output": "5 ^ 8\n",
        "fn_call": "printGreater"
    },
    {
        "text": "minimize subtraction followed by increments of adjacent elements required to make all array elements equal | function to find the minimum number of moves required to make all array elements equal ; store the total sum of the array ; calculate total sum of the array ; if the sum is not divisible by n , then print \" - 1\" ; stores the average ; stores the count of operations ; traverse the array arr [ ] ; update number of moves required to make current element equal to avg ; update the overall count ; return the minimum operations required ; ",
        "context": "",
        "code": "def findMinMoves(arr, N):\n    sum = 0\n    for i in range(N):\n        sum += arr[i]\n    if (sum % N != 0):\n        return -1\n    avg = sum // N\n    total = 0\n    needCount = 0\n    for i in range(N):\n        needCount += (arr[i] - avg)\n        total = max(max(abs(needCount), arr[i] - avg), total)\n    return total\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 0, 5]\n    N = len(arr)\n    print(findMinMoves(arr, N))\n",
        "output": "3\n",
        "fn_call": "findMinMoves"
    },
    {
        "text": "number of minimum length paths between 1 to n including each node | function to calculate the distances from node 1 to n ; stores the number of edges ; storing the edges in vector ; initialize queue ; bfs from 1 st node using queue ; pop from queue ; traversing the adjacency list ; initialize queue ; bfs from last node ; pop from queue ; traverse the adjacency list ; print the count of minimum distance ; ",
        "context": "",
        "code": "def countMinDistance(n, m, edges):\n    g = [[]for i in range(10005)]\n    for i in range(m):\n        a = edges[i][0] - 1\n        b = edges[i][1] - 1\n        g[a].append(b)\n        g[b].append(a)\n    queue1 = []\n    queue1 .append([0, 0])\n    dist = [1e9 for i in range(n)]\n    ways1 = [0 for i in range(n)]\n    dist[0] = 0\n    ways1[0] = 1\n    while (len(queue1) > 0):\n        up = queue1[0]\n        queue1 = queue1[:-1]\n        x = up[0]\n        dis = up[1]\n        if (dis > dist[x]):\n            continue\n        if (x == n - 1):\n            continue\n        for y in g[x]:\n            if (dist[y] > dis + 1):\n                dist[y] = dis + 1\n                ways1[y] = ways1[x]\n                queue1 .append([y, dis + 1])\n            elif (dist[y] == dis + 1):\n                ways1[y] += ways1[x]\n    queue2 = []\n    queue2 .append([n - 1, 0])\n    dist1 = [1e9 for i in range(n)]\n    ways2 = [0 for i in range(n)]\n    dist1[n - 1] = 0\n    ways2[n - 1] = 1\n    while (len(queue2) > 0):\n        up = queue2[0]\n        queue2 = queue2[:-1]\n        x = up[0]\n        dis = up[1]\n        if (dis > dist1[x]):\n            continue\n        if (x == 0):\n            continue\n        for y in g[x]:\n            if (dist1[y] > dis + 1):\n                dist1[y] = dis + 1\n                ways2[y] = ways2[x]\n                queue2 .append([y, dis + 1])\n            elif (dist1[y] == 1 + dis):\n                ways2[y] += ways2[x]\n    ways1[n - 1] = 1\n    ways2[n - 1] = 1\n    for i in range(n):\n        print(ways1[i] * ways2[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    M = 5\n    edges = [[1, 2], [1, 4], [1, 3], [2, 5], [2, 4]]\n    countMinDistance(N, M, edges)\n",
        "output": "1 1 0 1 1 ",
        "fn_call": "countMinDistance"
    },
    {
        "text": "find the n | function to find nth number made of even digits only ; if n = 1 return 0 ; vector to store the digits when converted into base 5 ; reduce n to n - 1 to exclude 0 ; reduce n to base 5 number and store digits ; pushing the digits into vector ; variable to represent the number after converting it to base 5. since the digits are be in reverse order , we traverse vector from back ; return 2 * result ( to convert digits 0 , 1 , 2 , 3 , 4 to 0 , 2 , 4 , 6 , 8. ; ",
        "context": "",
        "code": "def findNthEvenDigitNumber(n):\n    if (n == 1):\n        return 0\n    v = []\n    n = n - 1\n    while (n > 0):\n        v .append(n % 5)\n        n = n // 5\n    result = 0\n    for i in range(len(v) - 1, -1, -1):\n        result = result * 10\n        result = result + v[i]\n    return 2 * result\n",
        "test": "\nif __name__ == \"__main__\":\n    print(findNthEvenDigitNumber(2))\n    print(findNthEvenDigitNumber(10))\n",
        "output": "2\n28\n",
        "fn_call": "findNthEvenDigitNumber"
    },
    {
        "text": "count of maximum occurring subsequence using only those characters whose indices are in gp | function to count maximum occurring subsequence using only those characters whose indexes are in gp ; initialize 1 - d array and 2 - d dp array to 0 ; iterate till the length of the given string ; update ans for 1 - length subsequence ; update ans for 2 - length subsequence ; return the answer ; ",
        "context": "",
        "code": "def findMaxTimes(S):\n    arr = [0] * 26\n    dp = [[0 for x in range(26)]for y in range(26)]\n    for i in range(len(S)):\n        now = ord(S[i]) - ord('a')\n        for j in range(26):\n            dp[j][now] += arr[j]\n        arr[now] += 1\n    ans = 0\n    for i in range(26):\n        ans = max(ans, arr[i])\n    for i in range(26):\n        for j in range(26):\n            ans = max(ans, dp[i][j])\n    return ans\n",
        "test": "\nS = \"ddee\"\nprint(findMaxTimes(S))\n",
        "output": "4\n",
        "fn_call": "findMaxTimes"
    },
    {
        "text": "find a square matrix such that sum of elements in every row and column is k | function to print the required matrix ; print k for the left diagonal elements ; print 0 for the rest ; ",
        "context": "",
        "code": "def printMatrix(n, k):\n    for i in range(n):\n        for j in range(n):\n            if (i == j):\n                print(k, end=\" \")\n            else:\n                print(\"0\", end=\" \")\n        print()\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    k = 7\n    printMatrix(n, k)\n",
        "output": "7 0 0 \n0 7 0 \n0 0 7 \n",
        "fn_call": "printMatrix"
    },
    {
        "text": "distributing m items in a circle of size n starting from k | n == > size of circle m == > number of items k == > initial position ; n - k + 1 is number of positions before we reach beginning of circle if m is less than this value , then we can simply return ( m - 1 ) th position ; let us compute remaining items before we reach beginning . ; we compute m % n to skip all complete rounds . if we reach end , we return n else we return m % n ; ",
        "context": "",
        "code": "def lastPosition(n, m, k):\n    if (m <= n - k + 1):\n        return m + k - 1\n    m = m - (n - k + 1)\n    if (m % n == 0):\n        return n\n    else:\n        return m % n\n",
        "test": "\nn = 5\nm = 8\nk = 2\nprint(lastPosition(n, m, k))\n",
        "output": "4\n",
        "fn_call": "lastPosition"
    },
    {
        "text": "count of n | function to return the count of n - digit numbers that satisfy the given conditions ; dp array to store the pre - caluclated states ; base cases ; i - digit numbers ending with 0 can be formed by concatenating 0 in the end of all the ( i - 1 ) - digit number ending at a non - zero digit ; i - digit numbers ending with non - zero can be formed by concatenating any non - zero digit in the end of all the ( i - 1 ) - digit number ending with any digit ; n - digit number ending with and ending with non - zero ; ",
        "context": "",
        "code": "def count_numbers(k, n):\n    dp = [[0 for i in range(2)]for i in range(n + 1)]\n    dp[1][0] = 0\n    dp[1][1] = k - 1\n    for i in range(2, n + 1):\n        dp[i][0] = dp[i - 1][1]\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) * (k - 1)\n    return dp[n][0] + dp[n][1]\n",
        "test": "\nk = 10\nn = 3\nprint(count_numbers(k, n))\n",
        "output": "891\n",
        "fn_call": "count_numbers"
    },
    {
        "text": "smallest of three integers without comparison operators | python3 implementation of above approach ; function to find minimum of x and y ; function to find minimum of 3 numbers x , y and z ; ",
        "context": "\nCHAR_BIT = 8\n\n",
        "code": "def min(x, y):\n    return y + ((x - y) & ((x - y) >> (32 * CHAR_BIT - 1)))\n\n\ndef smallest(x, y, z):\n    return min(x, min(y, z))\n",
        "test": "\nx = 12\ny = 15\nz = 5\nprint(\"Minimum of 3 numbers is \", smallest(x, y, z))\n",
        "output": "Minimum of 3 numbers is  5\n",
        "fn_call": "smallest"
    },
    {
        "text": "delannoy number | return the nth delannoy number . ; base case ; recursive step . ; ",
        "context": "",
        "code": "def dealnnoy(n, m):\n    if (m == 0 or n == 0):\n        return 1\n    return dealnnoy(m - 1, n) + dealnnoy(m - 1, n - 1) + dealnnoy(m, n - 1)\n",
        "test": "\nn = 3\nm = 4\nprint(dealnnoy(n, m))\n",
        "output": "129\n",
        "fn_call": "dealnnoy"
    },
    {
        "text": "maximize count of array elements required to obtain given sum | function that count the maximum number of elements to obtain sum v ; stores the maximum number of elements required to obtain v ; base case ; initialize all table values as infinite ; find the max arr required for all values from 1 to v ; go through all arr smaller than i ; if current coin value is less than i ; update table [ i ] ; return the final count ; ",
        "context": "",
        "code": "def maxCount(arr, m, V):\n    table = [0 for i in range(V + 1)]\n    table[0] = 0\n    for i in range(1, V + 1, 1):\n        table[i] = -1\n        for i in range(1, V + 1, 1):\n            for j in range(0, m, 1):\n                if (arr[j] <= i):\n                    sub_res = table[i - arr[j]]\n                    if (sub_res != -1 and sub_res + 1 > table[i]):\n                        table[i] = sub_res + 1\n    return table[V]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [25, 10, 5]\n    m = len(arr)\n    V = 30\n    print('Maximumnumberofarrayelementsrequired:', maxCount(arr, m, V))\n",
        "output": "Maximumnumberofarrayelementsrequired: 6\n",
        "fn_call": "maxCount"
    },
    {
        "text": "number of binary search trees of height h consisting of h + 1 nodes | function to calculate x ^ y modulo 1000000007 in o ( log y ) ; stores the value of x ^ y ; update x if it exceeds mod ; if x is divisible by mod ; if y is odd , then multiply x with result ; divide y by 2 ; update the value of x ; return the value of x ^ y ; function to count the number of of bsts of height h consisting of ( h + 1 ) nodes ; ",
        "context": "",
        "code": "def power(x, y):\n    mod = 1000000007\n    res = 1\n    x = x % mod\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return res\n\n\ndef CountBST(H):\n    return power(2, H)\n",
        "test": "\nH = 2\nprint(CountBST(H))\n",
        "output": "4\n",
        "fn_call": "CountBST"
    },
    {
        "text": "find the number occurring odd number of times | function to find the element occurring odd number of times ; ",
        "context": "",
        "code": "def getOddOccurrence(arr, arr_size):\n    for i in range(0, arr_size):\n        count = 0\n        for j in range(0, arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if (count % 2 != 0):\n            return arr[i]\n    return -1\n",
        "test": "\narr = [2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2]\nn = len(arr)\nprint(getOddOccurrence(arr, n))\n",
        "output": "5\n",
        "fn_call": "getOddOccurrence"
    },
    {
        "text": "calculating factorials using stirling approximation | python3 program for calculating factorial of a number using stirling approximation ; function for calculating factorial ; value of natural e ; evaluating factorial using stirling approximation ; ",
        "context": "\nimport math\n\n",
        "code": "def stirlingFactorial(n):\n    if (n == 1):\n        return 1\n    e = 2.71\n    z = (math .sqrt(2 * 3.14 * n) * math .pow((n / e), n))\n    return math .floor(z)\n",
        "test": "\nprint(stirlingFactorial(1))\nprint(stirlingFactorial(2))\nprint(stirlingFactorial(3))\nprint(stirlingFactorial(4))\nprint(stirlingFactorial(5))\nprint(stirlingFactorial(6))\nprint(stirlingFactorial(7))\n",
        "output": "1\n1\n5\n23\n119\n723\n5086\n",
        "fn_call": "stirlingFactorial"
    },
    {
        "text": "print combinations of distinct numbers which add up to give sum n | arr [ ] to store all the distinct elements index - next location in array num - given number reducednum - reduced number ; set to store all the distinct elements ; base condition ; iterate over all the elements and store it into the set ; calculate the sum of all the elements of the set ; compare whether the sum is equal to n or not , if it is equal to n print the numbers ; find previous number stored in the array ; store all the numbers recursively into the arr [ ] ; function to find all the distinct combinations of n ; ",
        "context": "",
        "code": "def findCombinationsUtil(arr, index, n, red_num):\n    s = set()\n    sum = 0\n    if (red_num < 0):\n        return\n    if (red_num == 0):\n        for i in range(index):\n            s .add(arr[i])\n        for itr in s:\n            sum = sum + (itr)\n        if (sum == n):\n            for i in s:\n                print(i, end=\" \")\n            print(\"\",  end=\"\")\n            return\n    if (index == 0):\n        prev = 1\n    else:\n        prev = arr[index - 1]\n    for k in range(prev, n + 1, 1):\n        arr[index] = k\n        findCombinationsUtil(arr, index + 1, n, red_num - k)\n\n\ndef findCombinations(n):\n    a = [0 for i in range(n + 1)]\n    findCombinationsUtil(a, 0, n, n)\n",
        "test": "\nif __name__ == '__main__':\n    n = 7\n    findCombinations(n)\n",
        "output": "1 2 4 1 6 2 5 3 4 7 ",
        "fn_call": "findCombinations"
    },
    {
        "text": "xor and or of all n | function to check if a number is armstrong or not ; function to find xor of all n - digits armstrong number ; to store the xor and or of all armstrong number ; starting n - digit armstrong number ; ending n - digit armstrong number ; iterate over starting and ending number ; to check if i is armstrong or not ; print the xor and or of all armstrong number ; ",
        "context": "",
        "code": "def isArmstrong(x, n):\n    sum1 = 0\n    temp = x\n    while temp > 0:\n        digit = temp % 10\n        sum1 += digit ** n\n        temp //= 10\n    return sum1 == x\n\n\ndef CalculateXORandOR(n):\n    CalculateXOR = 0\n    CalculateOR = 0\n    start = 10 ** (n - 1)\n    end = (10 ** n) - 1\n    for i in range(start, end + 1):\n        if (isArmstrong(i, n)):\n            CalculateXOR = CalculateXOR ^ i\n            CalculateOR = CalculateOR | i\n    print(\"XOR = \", CalculateXOR)\n    print(\"OR = \", CalculateOR)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    CalculateXORandOR(n)\n",
        "output": "XOR =  880\nOR =  10098\n",
        "fn_call": "CalculateXORandOR"
    },
    {
        "text": "time until distance gets equal to x between two objects moving in opposite direction | function to return the time for which the two policemen can communicate ; time = distance / speed ; ",
        "context": "",
        "code": "def getTime(u, v, x):\n    speed = u + v\n    time = x / speed\n    return time\n",
        "test": "\nif __name__ == \"__main__\":\n    u, v, x = 3, 3, 3\n    print(getTime(u, v, x))\n",
        "output": "0.5\n",
        "fn_call": "getTime"
    },
    {
        "text": "count elements in the given range which have maximum number of divisors | function to count the elements with maximum number of divisors ; to store number of divisors initialise with zero ; to store the maximum number of divisors ; to store required answer ; find the first divisible number ; count number of divisors ; find number of elements with maximum number of divisors ; ",
        "context": "",
        "code": "def MaximumDivisors(X, Y):\n    arr = [0] * (Y - X + 1)\n    mx = 0\n    cnt = 0\n    i = 1\n    while i * i <= Y:\n        sq = i * i\n        if ((X // i) * i >= X):\n            first_divisible = (X // i) * i\n        else:\n            first_divisible = (X // i + 1) * i\n        for j in range(first_divisible, Y + 1, i):\n            if j < sq:\n                continue\n            elif j == sq:\n                arr[j - X] += 1\n            else:\n                arr[j - X] += 2\n        i += 1\n    for i in range(X, Y + 1):\n        if arr[i - X] > mx:\n            cnt = 1\n            mx = arr[i - X]\n        elif arr[i - X] == mx:\n            cnt += 1\n    return cnt\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 1\n    Y = 10\n    print(MaximumDivisors(X, Y))\n",
        "output": "3\n",
        "fn_call": "MaximumDivisors"
    },
    {
        "text": "find lost element from a duplicated array | this function mainly does xor of all elements of arr1 [ ] and arr2 [ ] ; do xor of all element ; ",
        "context": "",
        "code": "def findMissing(arr1, arr2, M, N):\n    if (M != N - 1 and N != M - 1):\n        print(\"Invalid Input\")\n        return\n    res = 0\n    for i in range(0, M):\n        res = res ^ arr1[i]\n    for i in range(0, N):\n        res = res ^ arr2[i]\n    print(\"Missing element is\", res)\n",
        "test": "\narr1 = [4, 1, 5, 9, 7]\narr2 = [7, 5, 9, 4]\nM = len(arr1)\nN = len(arr2)\nfindMissing(arr1, arr2, M, N)\n",
        "output": "Missing element is 1\n",
        "fn_call": "findMissing"
    },
    {
        "text": "count non | function to find the total count of triplets ( i , j , k ) such that i < j < k and ( j - i ) != ( k - j ) ; stores indices of 0 s ; stores indices of 1 s ; stores indices of 2 s ; traverse the array ; if current array element is 0 ; if current array element is 1 ; if current array element is 2 ; total count of triplets ; traverse the array zero_i [ ] ; traverse the array one_i [ ] ; stores index of 0 s ; stores index of 1 s ; stores third element of triplets that does not satisfy the condition ; if r present in the map ; update r ; if r present in the map ; update r ; if r present in the map and equidistant ; print the obtained count ; ",
        "context": "",
        "code": "def countTriplets(arr, N):\n    zero_i = []\n    one_i = []\n    mp = {}\n    for i in range(N):\n        if (arr[i] == 0):\n            zero_i .append(i + 1)\n        elif (arr[i] == 1):\n            one_i .append(i + 1)\n        else:\n            mp[i + 1] = 1\n    total = len(zero_i) * len(one_i) * len(mp)\n    for i in range(len(zero_i)):\n        for j in range(len(one_i)):\n            p = zero_i[i]\n            q = one_i[j]\n            r = 2 * p - q\n            if (r in mp):\n                total -= 1\n            r = 2 * q - p\n            if (r in mp):\n                total -= 1\n            r = (p + q) // 2\n            if ((r in mp) and abs(r - p) == abs(r - q)):\n                total -= 1\n    print(total)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 1, 2, 1]\n    N = len(arr)\n    countTriplets(arr, N)\n",
        "output": "1\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "number of balanced bracket expressions that can be formed from a string | max string length ; function to check whether index start and end can form a bracket pair or not ; check for brackets ( ) ; check for brackets [ ] ; check for brackets { } ; function to find number of proper bracket expressions ; if starting index is greater than ending index ; if dp [ start ] [ end ] has already been computed ; search for the bracket in from next index ; if bracket pair is formed , add number of combination ; if ? comes then all three bracket expressions are possible ; return answer ; if n is odd , string cannot be balanced ; ",
        "context": "\nMAX = 300\n\n",
        "code": "def checkFunc(i, j, st):\n    if (st[i] == '(' and st[j] == ')'):\n        return 1\n    if (st[i] == '(' and st[j] == '?'):\n        return 1\n    if (st[i] == '?' and st[j] == ')'):\n        return 1\n    if (st[i] == '[' and st[j] == ']'):\n        return 1\n    if (st[i] == '[' and st[j] == '?'):\n        return 1\n    if (st[i] == '?' and st[j] == ']'):\n        return 1\n    if (st[i] == '{' and st[j] == '}'):\n        return 1\n    if (st[i] == '{' and st[j] == '?'):\n        return 1\n    if (st[i] == '?' and st[j] == '}'):\n        return 1\n    return 0\n\n\ndef countRec(start, end, dp, st):\n    sum = 0\n    if (start > end):\n        return 1\n    if (dp[start][end] != -1):\n        return dp[start][end]\n    r = 0\n    for i in range(start + 1, end + 1, 2):\n        if (checkFunc(start, i, st)):\n            sum = (\n                sum +\n                countRec(\n                    start +\n                    1,\n                    i -\n                    1,\n                    dp,\n                    st) *\n                countRec(\n                    i +\n                    1,\n                    end,\n                    dp,\n                    st))\n        elif (st[start] == '?' and st[i] == '?'):\n            sum = (\n                sum +\n                countRec(\n                    start +\n                    1,\n                    i -\n                    1,\n                    dp,\n                    st) *\n                countRec(\n                    i +\n                    1,\n                    end,\n                    dp,\n                    st) *\n                3)\n    dp[start][end] = sum\n    return dp[start][end]\n\n\ndef countWays(st):\n    n = len(st)\n    if (n % 2 == 1):\n        return 0\n    dp = [[-1 for i in range(MAX)]for i in range(MAX)]\n    return countRec(0, n - 1, dp, st)\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"(?([?)]?}?\"\n    print(countWays(st))\n",
        "output": "3\n",
        "fn_call": "countWays"
    },
    {
        "text": "program to check if a number can be expressed as an even power of 2 or not | function to check if n can be expressed as an even power of 2 or not ; if n is not a power of 2 ; bitwise and operation ; ",
        "context": "",
        "code": "def checkEvenPower(N):\n    if ((N & (N - 1)) != 0):\n        return false\n    N = N & 0x55555555\n    return (N > 0)\n",
        "test": "\nN = 4\nprint(1 if checkEvenPower(N)else 0)\n",
        "output": "1\n",
        "fn_call": "checkEvenPower"
    },
    {
        "text": "find element position in given monotonic sequence | python 3 implementation of the approach ; function to return the value of f ( n ) for given values of a , b , c , n ; if c is 0 , then value of n can be in order of 10 ^ 15. if c != 0 , then n ^ 3 value has to be in order of 10 ^ 18 so maximum value of n can be 10 ^ 6. ; for efficient searching , use binary search . ; ",
        "context": "\nfrom math import log2, floor\nSMALL_N = 1000000\nLARGE_N = 1000000000000000\n\n",
        "code": "def func(a, b, c, n):\n    res = a * n\n    logVlaue = floor(log2(n))\n    res += b * n * logVlaue\n    res += c * (n * n * n)\n    return res\n\n\ndef getPositionInSeries(a, b, c, k):\n    start = 1\n    end = SMALL_N\n    if (c == 0):\n        end = LARGE_N\n    ans = 0\n    while (start <= end):\n        mid = (start + end) // 2\n        val = func(a, b, c, mid)\n        if (val == k):\n            ans = mid\n            break\n        elif (val > k):\n            end = mid - 1\n        else:\n            start = mid + 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 2\n    b = 1\n    c = 1\n    k = 12168587437017\n    print(getPositionInSeries(a, b, c, k))\n",
        "output": "23001\n",
        "fn_call": "getPositionInSeries"
    },
    {
        "text": "convert given string to a valid mobile number | function to print valid and formatted phone number ; length of given ; store digits in temp ; iterate given m ; if any digit : append it to temp ; find new length of ; if length is not equal to 10 ; store final result ; make groups of 3 digits and enclose them within ( ) and separate them with \" - \" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; print final result ; ",
        "context": "",
        "code": "def Validate(M):\n    lenn = len(M)\n    temp = \"\"\n    for i in range(lenn):\n        if (M[i].isdigit()):\n            temp += M[i]\n    nwlenn = len(temp)\n    if (nwlenn != 10):\n        print(\"Invalid\")\n        return\n    res = \"\"\n    x = temp[0:3]\n    res += \"(\" + x + \")-\"\n    x = temp[3:3 + 3]\n    res += \"(\" + x + \")-\"\n    x = temp[6:3 + 6]\n    res += \"(\" + x + \")-\"\n    x = temp[9:1 + 9]\n    res += \"(\" + x + \")\"\n    print(res)\n",
        "test": "\nif __name__ == '__main__':\n    M = \"91 234rt5%34*0 3\"\n    Validate(M)\n",
        "output": "(912)-(345)-(340)-(3)\n",
        "fn_call": "Validate"
    },
    {
        "text": "print matrix elements from top | function to traverse the matrix diagonally upwards ; store the number of rows ; initialize queue ; push the index of first element i . e . , ( 0 , 0 ) ; get the front element ; pop the element at the front ; insert the element below if the current element is in first column ; insert the right neighbour if it exists ; ",
        "context": "",
        "code": "def printDiagonalTraversal(nums):\n    m = len(nums)\n    q = []\n    q .append([0, 0])\n    while (len(q) != 0):\n        p = q[0]\n        q .pop(0)\n        print(nums[p[0]][p[1]], end=\" \")\n        if (p[1] == 0 and p[0] + 1 < m):\n            q .append([p[0] + 1, p[1]])\n        if (p[1] + 1 < len(nums[p[0]])):\n            q .append([p[0], p[1] + 1])\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    printDiagonalTraversal(arr)\n",
        "output": "1 4 2 7 5 3 8 6 9 ",
        "fn_call": "printDiagonalTraversal"
    },
    {
        "text": "check whether the number can be made palindromic after adding k | function to check whether a number is a palindrome or not ; convert num to stringing ; comparing kth character from the beginning and n - kth character from the end . if all the characters match , then the number is a palindrome ; if all the above conditions satisfy , it means that the number is a palindrome ; ",
        "context": "",
        "code": "def checkPalindrome(num):\n    string = str(num)\n    l = 0\n    r = len(string) - 1\n    while (l < r):\n        if (string[l] != string[r]):\n            print(\"No\")\n            return\n        l = l + 1\n        r = r - 1\n    print(\"Yes\")\n    return\n",
        "test": "\nif __name__ == '__main__':\n    n = 19\n    k = 3\n    checkPalindrome(n + k)\n",
        "output": "Yes\n",
        "fn_call": "checkPalindrome"
    },
    {
        "text": "rearrange array by interchanging positions of even and odd elements in the given array | function to replace odd elements with even elements and vice versa ; length of the array ; traverse the given array ; if arr [ i ] is visited ; find the next odd element ; find next even element ; mark them visited ; swap them ; print the final array ; ",
        "context": "",
        "code": "def swapEvenOdd(arr):\n    n = len(arr)\n    o = -1\n    e = -1\n    for i in range(n):\n        if (arr[i] < 0):\n            continue\n        r = -1\n        if (arr[i] % 2 == 0):\n            o += 1\n            while (arr[o] % 2 == 0 or arr[o] < 0):\n                o += 1\n            r = o\n        else:\n            e += 1\n            while (arr[e] % 2 == 1 or arr[e] < 0):\n                e += 1\n            r = e\n        arr[i] *= -1\n        arr[r] *= -1\n        tmp = arr[i]\n        arr[i] = arr[r]\n        arr[r] = tmp\n    for i in range(n):\n        print((-1 * arr[i]), end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 2, 4]\n    swapEvenOdd(arr)\n",
        "output": "2 4 1 3 ",
        "fn_call": "swapEvenOdd"
    },
    {
        "text": "length of largest subarray whose all elements powerful number | python 3 program to find the length of the largest sub - array of an array every element of whose is a powerful number ; function to check if the number is powerful ; first divide the number repeatedly by 2 ; if only 2 ^ 1 divides n ( not higher powers ) , then return false ; if n is not a power of 2 then this loop will execute repeat above process ; find highest power of \" factor \" that divides n ; if only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime numenr . since prime numbers are not powerful , we return false if n is not 1. ; function to return the length of the largest sub - array of an array every element of whose is a powerful number ; if arr [ i ] is a powerful number ; ",
        "context": "\nimport math\n\n",
        "code": "def isPowerful(n):\n    while (n % 2 == 0):\n        power = 0\n        while (n % 2 == 0):\n            n = n // 2\n            power = power + 1\n        if (power == 1):\n            return False\n    for factor in range(3, int(math .sqrt(n)) + 1, 2):\n        power = 0\n        while (n % factor == 0):\n            n = n // factor\n            power = power + 1\n        if (power == 1):\n            return false\n    return (n == 1)\n\n\ndef contiguousPowerfulNumber(arr, n):\n    current_length = 0\n    max_length = 0\n    for i in range(0, n, 1):\n        if (isPowerful(arr[i])):\n            current_length += 1\n        else:\n            current_length = 0\n        max_length = max(max_length, current_length)\n    return max_length\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 7, 36, 4, 6, 28, 4]\n    n = len(arr)\n    print(contiguousPowerfulNumber(arr, n))\n",
        "output": "2\n",
        "fn_call": "contiguousPowerfulNumber"
    },
    {
        "text": "split array into minimum number of subsets having maximum pair sum at most k | function to get the minimum count of subsets that satisfy the given condition ; store the minimum count of subsets that satisfy the given condition ; stores start index of the sorted array . ; stores end index of the sorted array ; sort the given array ; traverse the array ; if only two elements of sorted array left ; if only one elements left in the array ; ",
        "context": "",
        "code": "def cntMinSub(arr, N, K):\n    res = 0\n    start = 0\n    end = N - 1\n    arr = sorted(arr)\n    while (end - start > 1):\n        if (arr[start] + arr[end] <= K):\n            start += 1\n        else:\n            res += 1\n            end -= 1\n    if (end - start == 1):\n        if (arr[start] + arr[end] <= K):\n            res += 1\n            start += 1\n            end -= 1\n        else:\n            res += 1\n            end -= 1\n    if (start == end):\n        res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 6, 8, 10, 20, 25]\n    N = len(arr)\n    K = 26\n    print(cntMinSub(arr, N, K))\n",
        "output": "3\n",
        "fn_call": "cntMinSub"
    },
    {
        "text": "longest sub | function to return the length of the largest subsequence with non - negative sum ; to store the current sum ; sort the input array in non - increasing order ; traverse through the array ; add the current element to the sum ; condition when c_sum falls below zero ; complete array has a non - negative sum ; ",
        "context": "",
        "code": "def maxLen(arr, n):\n    c_sum = 0\n    arr .sort(reverse=True)\n    for i in range(n):\n        c_sum += arr[i]\n        if (c_sum < 0):\n            return i\n    return n\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 5, -6]\n    n = len(arr)\n    print(maxLen(arr, n))\n",
        "output": "3\n",
        "fn_call": "maxLen"
    },
    {
        "text": "trapping rain water | python program to find maximum amount of water that can be trapped within given set of bars . ; left [ i ] contains height of tallest bar to the left of i 'th bar including itself ; right [ i ] contains height of tallest bar to the right of ith bar including itself ; initialize result ; fill left array ; fill right array ; calculate the accumulated water element by element consider the amount of water on i 'th bar, the  amount of water accumulated on this particular  bar will be equal to min(left[i], right[i]) - arr[i] . ; ",
        "context": "",
        "code": "def findWater(arr, n):\n    left = [0] * n\n    right = [0] * n\n    water = 0\n    left[0] = arr[0]\n    for i in range(1, n):\n        left[i] = max(left[i - 1], arr[i])\n    right[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        right[i] = max(right[i + 1], arr[i])\n    for i in range(0, n):\n        water += min(left[i], right[i]) - arr[i]\n    return water\n",
        "test": "\narr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nn = len(arr)\nprint(\"Maximum water that can be accumulated is\", findWater(arr, n))\n",
        "output": "Maximum water that can be accumulated is 6\n",
        "fn_call": "findWater"
    },
    {
        "text": "count of only repeated element in a sorted array of consecutive elements | assumptions : vector a is sorted , max - difference of two adjacent elements is 1 ; if a [ m ] = m + a [ 0 ] , there is no repeating character in [ s . . m ] ; if a [ m ] < m + a [ 0 ] , there is a repeating character in [ s . . m ] ; ",
        "context": "",
        "code": "def sequence(a):\n    if (len(a) == 0):\n        return [0, 0]\n    s = 0\n    e = len(a) - 1\n    while (s < e):\n        m = (s + e) // 2\n        if (a[m] >= m + a[0]):\n            s = m + 1\n        else:\n            e = m\n    return [a[s], len(a) - (a[len(a) - 1] - a[0])]\n",
        "test": "\np = sequence([1, 2, 3, 4, 4, 4, 5, 6])\nprint(\"Repeated element is\", p[0], \", it appears\", p[1], \"times\")\n",
        "output": "Repeated element is 4 , it appears 3 times\n",
        "fn_call": "sequence"
    },
    {
        "text": "analysis of algorithms | set 2 ( worst , average and best cases ) | linearly search x in arr [ ] . if x is present then return the index , otherwise return - 1 ; ",
        "context": "",
        "code": "def search(arr, x):\n    for index, value in enumerate(arr):\n        if value == x:\n            return index\n    return -1\n",
        "test": "\narr = [1, 10, 30, 15]\nx = 30\nprint(x, \"is present at index\", search(arr, x))\n",
        "output": "30 is present at index 2\n",
        "fn_call": "search"
    },
    {
        "text": "maximum distinct lines passing through a single point | python3 program to find maximum number of lines which can pass through a single point ; function to find maximum lines which passes through a single point ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxLines(n, x1, y1, x2, y2):\n    s = []\n    slope = sys .maxsize\n    for i in range(n):\n        if (x1[i] == x2[i]):\n            slope = sys .maxsize\n        else:\n            slope = (y2[i] - y1[i]) * 1.0 / (x2[i] - x1[i]) * 1.0\n        s .append(slope)\n    return len(s)\n",
        "test": "\nn = 2\nx1 = [1, 2]\ny1 = [1, 2]\nx2 = [2, 4]\ny2 = [2, 10]\nprint(maxLines(n, x1, y1, x2, y2))\n",
        "output": "2\n",
        "fn_call": "maxLines"
    },
    {
        "text": "minimum possible value of | ai + aj | function for finding pairs and min value ; initialize smallest and count ; iterate over all pairs ; is abs value is smaller than smallest update smallest and reset count to 1 ; if abs value is equal to smallest increment count value ; print result ; ",
        "context": "",
        "code": "def pairs(arr, n, k):\n    smallest = 999999999999\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(arr[i] + arr[j] - k) < smallest:\n                smallest = abs(arr[i] + arr[j] - k)\n                count = 1\n            elif abs(arr[i] + arr[j] - k) == smallest:\n                count += 1\n    print(\"Minimal Value = \", smallest)\n    print(\"Total Pairs = \", count)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 5, 7, 5, 1, 9, 9]\n    k = 12\n    n = len(arr)\n    pairs(arr, n, k)\n",
        "output": "Minimal Value =  0\nTotal Pairs =  4\n",
        "fn_call": "pairs"
    },
    {
        "text": "minimum number of coins having value equal to powers of 2 required to obtain n | function to count of set bit in n ; stores count of set bit in n ; iterate over the range [ 0 , 31 ] ; if current bit is set ; update result ; ",
        "context": "",
        "code": "def count_setbit(N):\n    result = 0\n    for i in range(32):\n        if ((1 << i) & N):\n            result = result + 1\n    print(result)\n",
        "test": "\nif __name__ == '__main__':\n    N = 43\n    count_setbit(N)\n",
        "output": "4\n",
        "fn_call": "count_setbit"
    },
    {
        "text": "minimum replacements required to make sum of all k | function to find minimum number of operations required to make sum of all subarrays of size k equal ; stores number of operations ; iterate in the range [ 0 , k - 1 ] ; stores frequency of elements separated by distance k ; stores maximum frequency and corresponding element ; find max frequency element and its frequency ; update the number of operations ; print the result ; ",
        "context": "",
        "code": "def findMinOperations(arr, N, K):\n    operations = 0\n    for i in range(K):\n        freq = {}\n        for j in range(i, N, K):\n            if arr[j] in freq:\n                freq[arr[j]] += 1\n            else:\n                freq[arr[j]] = 1\n        max1 = 0\n        num = 0\n        for key, value in freq .items():\n            if (value > max1):\n                max1 = value\n                num = key\n        for key, value in freq .items():\n            if (key != num):\n                operations += value\n    print(operations)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 4, 3, 5, 6]\n    K = 2\n    N = len(arr)\n    findMinOperations(arr, N, K)\n",
        "output": "2\n",
        "fn_call": "findMinOperations"
    },
    {
        "text": "sum of the series 0.6 , 0.06 , 0.006 , 0.0006 , ... to n terms | python3 program to find sum of 0.6 , 0.06 , 0.006 , 0.0006 , ... to n terms ; function which return the sum of series ; ",
        "context": "\nimport math\n\n",
        "code": "def sumOfSeries(n):\n    return ((0.666) * (1 - 1 / pow(10, n)))\n",
        "test": "\nn = 2\nprint(sumOfSeries(n))\n",
        "output": "0.65934\n",
        "fn_call": "sumOfSeries"
    },
    {
        "text": "check if all prefixes of a number is divisible by remaining count of digits | function to check if all prefixes of a number is divisible by remaining count of digits or not ; traverse and check divisibility for each updated number ; update the original number ; ",
        "context": "",
        "code": "def prefixDivisble(n):\n    i = 1\n    while n > 0:\n        if n % i != 0:\n            return False\n        n = n // 10\n        i += 1\n    return True\n",
        "test": "\nn = 52248\nif (prefixDivisble(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "prefixDivisble"
    },
    {
        "text": "sum of bitwise and of all unordered triplets of an array | function to calculate sum of bitwise and of all unordered triplets from a given array such that ( i < j < k ) ; stores the resultant sum of bitwise and of all triplets ; generate all triplets of ( arr [ i ] , arr [ j ] , arr [ k ] ) ; add bitwise and to ans ; print the result ; ",
        "context": "",
        "code": "def tripletAndSum(arr, n):\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n, 1):\n            for k in range(j + 1, n, 1):\n                ans += arr[i] & arr[j] & arr[k]\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 5, 4, 7]\n    N = len(arr)\n    tripletAndSum(arr, N)\n",
        "output": "5\n",
        "fn_call": "tripletAndSum"
    },
    {
        "text": "multiplication of two numbers with shift operator | function for multiplication ; check for set bit and left shift n , count times ; increment of place value ( count ) ; ",
        "context": "",
        "code": "def multiply(n, m):\n    ans = 0\n    count = 0\n    while (m):\n        if (m % 2 == 1):\n            ans += n << count\n        count += 1\n        m = int(m / 2)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 20\n    m = 13\n    print(multiply(n, m))\n",
        "output": "260\n",
        "fn_call": "multiply"
    },
    {
        "text": "find the foot of perpendicular of a point in a 3 d plane | function to find foot of perpendicular ; ",
        "context": "",
        "code": "def foot(a, b, c, d, x1, y1, z1):\n    k = (-a * x1 - b * y1 - c * z1 - d) / (a * a + b * b + c * c)\n    x2 = a * k + x1\n    y2 = b * k + y1\n    z2 = c * k + z1\n    print(\"x2 =\", round(x2, 1))\n    print(\"y2 =\", round(y2, 1))\n    print(\"z2 =\", round(z2, 1))\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 1\n    b = -2\n    c = 0\n    d = 0\n    x1 = -1\n    y1 = 3\n    z1 = 4\n    foot(a, b, c, d, x1, y1, z1)\n",
        "output": "x2 = 0.4\ny2 = 0.2\nz2 = 4.0\n",
        "fn_call": "foot"
    },
    {
        "text": "tetracontagon number | finding the nth tetracontagon number ; ",
        "context": "",
        "code": "def tetracontagonNum(n):\n    return (38 * n * n - 36 * n) // 2\n",
        "test": "\nn = 3\nprint(\"3rd tetracontagon Number is = \", tetracontagonNum(n))\n",
        "output": "3rd tetracontagon Number is =  117\n",
        "fn_call": "tetracontagonNum"
    },
    {
        "text": "leftmost column with atleast one 1 in a row | python3 program to calculate leftmost column having at least a 1 ; function return leftmost column having at least a 1 ; if current element is 1 decrement column by 1 ; if current element is 0 increment row by 1 ; ",
        "context": "\nN = 3\nM = 4\n\n",
        "code": "def findColumn(mat: list) -> int:\n    row = 0\n    col = M - 1\n    while row = 0:\n        if mat[row][col] == 1:\n            col -= 1\n            flag = 1\n        else:\n            row += 1\n    col += 1\n    if flag:\n        return col + 1\n    else:\n        return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    mat = [[0, 0, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1]]\n    print(findColumn(mat))\n",
        "output": "2\n",
        "fn_call": "findColumn"
    },
    {
        "text": "make palindromic string non | function to print the non - palindromic string if it exists , otherwise prints - 1 ; if all characters are not same , set flag to 1 ; update frequency of the current character ; if all characters are same ; print characters in sorted manner ; ",
        "context": "",
        "code": "def findNonPalinString(s):\n    freq = [0] * (26)\n    flag = 0\n    for i in range(0, len(s)):\n        if s[i] != s[0]:\n            flag = 1\n        freq[ord(s[i]) - ord('a')] += 1\n    if not flag:\n        print(\"-1\")\n    else:\n        for i in range(0, 26):\n            for j in range(0, freq[i]):\n                print(chr(ord('a') + i), end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abba\"\n    findNonPalinString(s)\n",
        "output": "aabb",
        "fn_call": "findNonPalinString"
    },
    {
        "text": "rat in a maze with multiple steps or jump allowed | maze size ; a utility function to prsolution matrix sol ; a utility function to check if x , y is valid index for n * n maze ; if ( x , y outside maze ) return false ; this function solves the maze problem using backtracking . it mainly uses solvemazeutil ( ) to solve the problem . it returns false if no path is possible , otherwise return true and prints the path in the form of 1 s . please note that there may be more than one solutions , this function prints one of the feasible solutions . ; a recursive utility function to solve maze problem ; if ( x , y is goal ) return true ; check if maze [ x ] [ y ] is valid ; mark x , y as part of solution path ; move forward in x direction ; move forward in x direction ; if moving in x direction doesn 't give  solution then move down in y direction  ; if none of the above movements work then backtrack : unmark x , y as part of solution path ; ",
        "context": "\nN = 4\n\n",
        "code": "def printSolution(sol):\n    for i in range(N):\n        for j in range(N):\n            print(sol[i][j], end=\" \")\n        print()\n\n\ndef isSafe(maze, x, y):\n    if (x >= 0 and x = 0 and y < N and maze[x][y] != 0):\n        return True\n    return False\n\n\ndef solveMazeUtil(maze, x, y, sol):\n    if (x == N - 1 and y == N - 1):\n        sol[x][y] = 1\n        return True\n    if (isSafe(maze, x, y)):\n        sol[x][y] = 1\n        for i in range(1, N):\n            if (i <= maze[x][y]):\n                if (solveMazeUtil(maze, x + i, y, sol)):\n                    return True\n                if (solveMazeUtil(maze, x, y + i, sol)):\n                    return True\n        sol[x][y] = 0\n        return False\n    return False\n\n\ndef solveMaze(maze):\n    sol = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    if (solveMazeUtil(maze, 0, 0, sol) == False):\n        print(\"Solution doesn't exist\")\n        return False\n    printSolution(sol)\n    return True\n",
        "test": "\nmaze = [[2, 1, 0, 0], [3, 0, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1]]\nsolveMaze(maze)\n",
        "output": "1 0 0 0 \n1 0 0 1 \n0 0 0 1 \n0 0 0 1 \n",
        "fn_call": "solveMaze"
    },
    {
        "text": "program to remove html tags from a given string | python3 program for the above approach ; function to remove the html tags from the given tags ; print string after removing tags ; ",
        "context": "\n\nimport re\n\n",
        "code": "def RemoveHTMLTags(strr):\n    print(re .compile(']+>').sub('', strr))\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"Geeks for Geeks\"\n    RemoveHTMLTags(strr)\n",
        "output": "Geeks for Geeks\n",
        "fn_call": "RemoveHTMLTags"
    },
    {
        "text": "factorial of a number without using multiplication | function to calculate factorial of the number without using multiplication operator ; variable to store the final factorial ; outer loop ; inner loop ; ",
        "context": "",
        "code": "def factorialWithoutMul(N):\n    ans = N\n    i = N - 1\n    while (i > 0):\n        sum = 0\n        for j in range(i):\n            sum += ans\n        ans = sum\n        i -= 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    print(factorialWithoutMul(N))\n",
        "output": "120\n",
        "fn_call": "factorialWithoutMul"
    },
    {
        "text": "minimize operations to convert each node of n | create adjacency list ; function to add an edges in graph ; function to perform the dfs of graph recursively from a given vertex u ; check for the condition for the flipping of node 's initial value ; traverse all the children of the current source node u ; swap foo and foo1 signifies there is change of level ; function to perform the dfsutil ( ) for all the unvisited vertices ; traverse the given set of nodes ; if the current node is unvisited ; print the number of operations ; function to count the number of flips required to change initial node values to final node value ; add the given edges ; dfs traversal ; ",
        "context": "\nN = 3\nadj = []\nfor i in range(N + 1):\n    adj .append([])\nvisited = []\nans = 0\n\n",
        "code": "def addEdges(u, v):\n    global adj\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef DFSUtil(u, foo, foo1, initial, finall):\n    global visited, ans, adj\n    visited[u] = True\n    if ((initial[u - 1] ^ foo) ^ finall[u - 1]):\n        ans += 1\n        foo ^= True\n    for i in range(len(adj[u])):\n        if (visited[adj[u][i]] == False):\n            DFSUtil(adj[u][i], foo1, foo, initial, finall)\n\n\ndef DFS(V, initial, finall):\n    global ans, visited\n    ans = 0\n    visited = [False] * V\n    for u in range(1, 2):\n        if (visited[u] == False):\n            DFSUtil(u, 0, 0, initial, finall)\n    print(ans)\n\n\ndef countOperations(N, initial, finall, Edges):\n    for i in range(N - 1):\n        addEdges(Edges[i][0], Edges[i][1])\n    DFS(N + 1, initial, finall)\n",
        "test": "\nEdges = [[1, 2], [1, 3]]\ninitial = [True, True, False]\nfinall = [False, True, True]\ncountOperations(N, initial, finall, Edges)\n",
        "output": "2\n",
        "fn_call": "countOperations"
    },
    {
        "text": "longest common subsequence of two arrays out of which one array consists of distinct elements only | python3 program to to implement the above approach ; function to find the longest common subsequence between the two arrays ; maps elements of firstarr [ ] to their respective indices ; traverse the array firstarr [ ] ; stores the indices of common elements between firstarr [ ] and secondarr [ ] ; traverse the array secondarr [ ] ; if current element exists in the map ; stores lis from temparr [ ] ; ",
        "context": "\nfrom bisect import bisect_left\n\n",
        "code": "def LCS(firstArr, secondArr):\n    mp = {}\n    for i in range(len(firstArr)):\n        mp[firstArr[i]] = i + 1\n    tempArr = []\n    for i in range(len(secondArr)):\n        if (secondArr[i] in mp):\n            tempArr .append(mp[secondArr[i]])\n    tail = []\n    tail .append(tempArr[0])\n    for i in range(1, len(tempArr)):\n        if (tempArr[i] > tail[-1]):\n            tail .append(tempArr[i])\n        elif (tempArr[i] < tail[0]):\n            tail[0] = tempArr[i]\n        else:\n            it = bisect_left(tail, tempArr[i])\n            it = tempArr[i]\n    return len(tail)\n",
        "test": "\nif __name__ == '__main__':\n    firstArr = [3, 5, 1, 8]\n    secondArr = [3, 3, 5, 3, 8]\n    print(LCS(firstArr, secondArr))\n",
        "output": "3\n",
        "fn_call": "LCS"
    },
    {
        "text": "sort given array to descending | function to sort first k array elements in descending and last n - k in ascending order ; sort the array in descending order ; sort last ( n - k ) array elements in ascending order ; ",
        "context": "",
        "code": "def sortArrayInDescAsc(arr, N, K):\n    arr = sorted(arr)\n    arr = arr[::-1]\n    for i in arr[:K]:\n        print(i, end=\" \")\n    for i in reversed(arr[K:]):\n        print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [7, 6, 8, 9, 0, 1, 2, 2, 1, 8, 9, 6, 7]\n    N = len(arr)\n    K = 6\n    sortArrayInDescAsc(arr, N, K)\n",
        "output": "9 9 8 8 7 7 0 1 1 2 2 6 6 ",
        "fn_call": "sortArrayInDescAsc"
    },
    {
        "text": "count pairs from two arrays with even sum | function to return count of required pairs ; count of odd and even numbers from both the arrays ; find the count of odd and even elements in a [ ] ; find the count of odd and even elements in b [ ] ; count the number of pairs ; return the number of pairs ; ",
        "context": "",
        "code": "def count_pairs(a, b, n, m):\n    odd1 = 0\n    even1 = 0\n    odd2 = 0\n    even2 = 0\n    for i in range(n):\n        if (a[i] % 2 == 1):\n            odd1 += 1\n        else:\n            even1 += 1\n    for i in range(m):\n        if (b[i] % 2 == 1):\n            odd2 += 1\n        else:\n            even2 += 1\n    pairs = min(odd1, odd2) + min(even1, even2)\n    return pairs\n",
        "test": "\nif __name__ == '__main__':\n    a = [9, 14, 6, 2, 11]\n    b = [8, 4, 7, 20]\n    n = len(a)\n    m = len(b)\n    print(count_pairs(a, b, n, m))\n",
        "output": "4\n",
        "fn_call": "count_pairs"
    },
    {
        "text": "maximum given sized rectangles that can be cut out of a sheet of paper | function to return the maximum rectangles possible ; cut rectangles horizontally if possible ; one rectangle is a single cell ; total rectangles = total cells ; cut rectangles vertically if possible ; return the maximum possible rectangles ; ",
        "context": "",
        "code": "def maxRectangles(L, B, l, b):\n    horizontal, vertical = 0, 0\n    if l <= L and b <= B:\n        columns = B // b\n        rows = L // l\n        horizontal = rows * columns\n    if l <= B and b <= L:\n        columns = L // b\n        rows = B // l\n        vertical = rows * columns\n    return max(horizontal, vertical)\n",
        "test": "\nif __name__ == \"__main__\":\n    L, B, l, b = 10, 7, 4, 3\n    print(maxRectangles(L, B, l, b))\n",
        "output": "4\n",
        "fn_call": "maxRectangles"
    },
    {
        "text": "min cost path | dp | python3 program for the above approach ; for 1 st column ; for 1 st row ; for rest of the 2d matrix ; returning the value in last cell ; ",
        "context": "",
        "code": "def minCost(cost, row, col):\n    for i in range(1, row):\n        cost[i][0] += cost[i - 1][0]\n    for j in range(1, col):\n        cost[0][j] += cost[0][j - 1]\n    for i in range(1, row):\n        for j in range(1, col):\n            cost[i][j] += (min(cost[i - 1][j - 1],\n                           min(cost[i - 1][j], cost[i][j - 1])))\n    return cost[row - 1][col - 1]\n",
        "test": "\nif __name__ == '__main__':\n    row = 3\n    col = 3\n    cost = [[1, 2, 3], [4, 8, 2], [1, 5, 3]]\n    print(minCost(cost, row, col))\n",
        "output": "8\n",
        "fn_call": "minCost"
    },
    {
        "text": "count pairs from two arrays whose modulo operation yields k | function to return the total pairs of elements whose modulo yield k ; set is used to avoid duplicate pairs ; check which element is greater and proceed according to it ; check if modulo is equal to k ; return size of the set ; ",
        "context": "",
        "code": "def totalPairs(arr1, arr2, K, n, m):\n    s = {}\n    for i in range(n):\n        for j in range(m):\n            if (arr1[i] > arr2[j]):\n                if (arr1[i] % arr2[j] == K):\n                    s[(arr1[i], arr2[j])] = 1\n            else:\n                if (arr2[j] % arr1[i] == K):\n                    s[(arr2[j], arr1[i])] = 1\n    return len(s)\n",
        "test": "\narr1 = [8, 3, 7, 50]\narr2 = [5, 1, 10, 4]\nK = 3\nn = len(arr1)\nm = len(arr2)\nprint(totalPairs(arr1, arr2, K, n, m))\n",
        "output": "3\n",
        "fn_call": "totalPairs"
    },
    {
        "text": "maximum bitwise or pair from a range | python3 implementation of the approach ; function to return the maximum bitwise or possible among all the possible pairs ; if there is only a single value in the range [ l , r ] ; loop through each bit from msb to lsb ; msbs where the bits differ , all bits from that bit are set ; if msbs are same , then ans bit is same as that of bit of right or left limit ; ",
        "context": "\nMAX = 64\n\n",
        "code": "def maxOR(L, R):\n    if (L == R):\n        return L\n    ans = 0\n    for i in range(MAX - 1, -1, -1):\n        p = 1 << i\n        lbit = (L >> i) & 1\n        rbit = (R >> i) & 1\n        if ((rbit == 1) and (lbit == 0)):\n            ans += (p << 1) - 1\n            break\n        if (rbit == 1):\n            ans += p\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    L = 4\n    R = 5\n    print(maxOR(L, R))\n",
        "output": "5\n",
        "fn_call": "maxOR"
    },
    {
        "text": "counting pairs when a person can form pair with at most one | python program to find number of ways in which participant can take part . ; ",
        "context": "",
        "code": "def numberOfWays(x):\n    dp = []\n    dp .append(1)\n    dp .append(1)\n    for i in range(2, x + 1):\n        dp .append(dp[i - 1] + (i - 1) * dp[i - 2])\n    return (dp[x])\n",
        "test": "\nx = 3\nprint(numberOfWays(x))\n",
        "output": "4\n",
        "fn_call": "numberOfWays"
    },
    {
        "text": "distribute the white and black objects into maximum groups under certain constraints | function to check if it is possible to distribute w and b into maximum groups possible ; if w is greater than b , swap them ; distribution is not possible ; distribution is possible ; ",
        "context": "",
        "code": "def isPossible(W, B, D):\n    if (W > B):\n        temp = W\n        W = B\n        B = temp\n    if (B > W * (D + 1)):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n",
        "test": "\nif __name__ == '__main__':\n    W = 2\n    B = 5\n    D = 2\n    isPossible(W, B, D)\n",
        "output": "YES\n",
        "fn_call": "isPossible"
    },
    {
        "text": "sum of fibonacci numbers | set 2 | pyhton3 program for the above approach ; function to find the sum of first n + 1 fibonacci numbers ; apply the formula ; print the result ; ",
        "context": "\nimport math\n\n",
        "code": "def sumFib(N):\n    num = (1 - math .sqrt(5)) / 2\n    val = round(abs(1 / (pow(num, N + 2) + pow(num, N + 1) +\n                pow(num, N) + pow(num, N - 1))) - 1)\n    print(val)\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    sumFib(N)\n",
        "output": "4\n",
        "fn_call": "sumFib"
    },
    {
        "text": "check if a string is substring of another | python program for the above approach ; iterate from 0 to len - 1 ; ",
        "context": "",
        "code": "def Substr(Str, target):\n    t = 0\n    Len = len(Str)\n    i = 0\n    for i in range(Len):\n        if (t == len(target)):\n            break\n        if (Str[i] == target[t]):\n            t += 1\n        else:\n            t = 0\n    if (t < len(target)):\n        return -1\n    else:\n        return (i - t)\n",
        "test": "\nprint(Substr(\"GeeksForGeeks\", \"Fr\"))\nprint(Substr(\"GeeksForGeeks\", \"For\"))\n",
        "output": "-1\n5\n",
        "fn_call": "Substr"
    },
    {
        "text": "count of square submatrices with average at least k | function to count submatrixes with average greater than or equals to k ; stores count of submatrices ; stores the prefix sum of matrix ; iterate over the range [ 1 , n ] ; iterate over the range [ 1 , m ] ; update the prefix sum ; iterate over the range [ 1 , n ] ; iterate over the range [ 1 , m ] ; iterate until l and r are greater than 0 ; update count ; stores sum of submatrix with bottom right corner as ( i , j ) and top left corner as ( l , r ) ; if sum1 is less than or equal to sum2 ; increment cnt by 1 ; return cnt as the answer ; ",
        "context": "",
        "code": "def cntMatrices(arr, N, M, K):\n    cnt = 0\n    pre = [[0 for i in range(M + 1)]for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            pre[i][j] = (arr[i - 1][j - 1] + pre[i - 1][j] +\n                         pre[i][j - 1] - pre[i - 1][j - 1])\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            l, r = i, j\n            while l > 0 and r > 0:\n                sum1 = (K * (i - l + 1) * (i - r + 1))\n                sum2 = (pre[i][j] - pre[l - 1][r] -\n                        pre[l][r - 1] + pre[l - 1][r - 1])\n                if (sum1 <= sum2):\n                    cnt += 1\n                l -= 1\n                r -= 1\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[2, 2, 3], [3, 4, 5], [4, 5, 5]]\n    K = 4\n    N = len(arr)\n    M = len(arr[0])\n    print(cntMatrices(arr, N, M, K))\n",
        "output": "7\n",
        "fn_call": "cntMatrices"
    },
    {
        "text": "min cost path | dp | a naive recursive implementation of mcp ( minimum cost path ) problem ; a utility function that returns minimum of 3 integers ; returns cost of minimum cost path from ( 0 , 0 ) to ( m , n ) in mat [ r ] [ c ] ; ",
        "context": "\nimport sys\nR = 3\nC = 3\n\n",
        "code": "def min(x, y, z):\n    if (x < y):\n        return x if (x < z)else z\n    else:\n        return y if (y < z)else z\n\n\ndef minCost(cost, m, n):\n    if (n < 0 or m < 0):\n        return sys .maxsize\n    elif (m == 0 and n == 0):\n        return cost[m][n]\n    else:\n        return cost[m][n] + min(minCost(cost, m - 1, n - 1),\n                                minCost(cost, m - 1, n), minCost(cost, m, n - 1))\n",
        "test": "\ncost = [[1, 2, 3], [4, 8, 2], [1, 5, 3]]\nprint(minCost(cost, 2, 2))\n",
        "output": "8\n",
        "fn_call": "minCost"
    },
    {
        "text": "minimum product spanning tree | a python3 program for getting minimum product spanning tree the program is for adjacency matrix representation of the graph ; number of vertices in the graph ; a utility function to find the vertex with minimum key value , from the set of vertices not yet included in mst ; initialize min value ; a utility function to print the constructed mst stored in parent [ ] and print minimum obtaiable product ; function to construct and print mst for a graph represented using adjacency matrix representation inputgraph is sent for printing actual edges and loggraph is sent for actual mst operations ; array to store constructed mst ; key values used to pick minimum ; weight edge in cut to represent set of vertices not ; always include first 1 st vertex in mst make key 0 so that this vertex is ; picked as first vertex first node is always root of mst ; the mst will have v vertices ; pick the minimum key vertex from the set of vertices not yet included in mst ; add the picked vertex to the mst set ; update key value and parent index of the adjacent vertices of the picked vertex . consider only those vertices which are not yet included in mst ; loggraph [ u ] [ v ] is non zero only for adjacent vertices of m mstset [ v ] is false for vertices not yet included in mst . update the key only if loggraph [ u ] [ v ] is smaller than key [ v ] ; print the constructed mst ; method to get minimum product spanning tree ; constructing loggraph from original graph ; applyting standard prim 's mst algorithm  on log graph. ; ",
        "context": "\nimport math\nV = 5\n\n",
        "code": "def minKey(key, mstSet):\n    min = 10000000\n    min_index = 0\n    for v in range(V):\n        if (mstSet[v] == False and key[v] < min):\n            min = key[v]\n            min_index = v\n    return min_index\n\n\ndef printMST(parent, n, graph):\n    print(\"Edge Weight\")\n    minProduct = 1\n    for i in range(1, V):\n        print(\"{} - {} {} \".format(parent[i], i, graph[i][parent[i]]))\n        minProduct *= graph[i][parent[i]]\n    print(\"Minimum Obtainable product is {}\".format(minProduct))\n\n\ndef primMST(inputGraph, logGraph):\n    parent = [0 for i in range(V)]\n    key = [10000000 for i in range(V)]\n    mstSet = [False for i in range(V)]\n    key[0] = 0\n    parent[0] = -1\n    for count in range(0, V - 1):\n        u = minKey(key, mstSet)\n        mstSet[u] = True\n        for v in range(V):\n            if (logGraph[u][v] > 0 and mstSet[v] ==\n                    False and logGraph[u][v] < key[v]):\n                parent[v] = u\n                key[v] = logGraph[u][v]\n    printMST(parent, V, inputGraph)\n\n\ndef minimumProductMST(graph):\n    logGraph = [[0 for j in range(V)]for i in range(V)]\n    for i in range(V):\n        for j in range(V):\n            if (graph[i][j] > 0):\n                logGraph[i][j] = math .log(graph[i][j])\n            else:\n                logGraph[i][j] = 0\n    primMST(graph, logGraph)\n",
        "test": "\nif __name__ == '__main__':\n    graph = [[0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [\n        0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0], ]\n    minimumProductMST(graph)\n",
        "output": "Edge Weight\n0 - 1 2 \n1 - 2 3 \n0 - 3 6 \n1 - 4 5 \nMinimum Obtainable product is 180\n",
        "fn_call": "minimumProductMST"
    },
    {
        "text": "two clique problem ( check if graph can be divided in two cliques ) | python3 program to find out whether a given graph can be converted to two cliques or not . ; this function returns true if subgraph reachable from src is bipartite or not . ; create a queue ( fifo ) of vertex numbers and enqueue source vertex for bfs traversal ; run while there are vertices in queue ( similar to bfs ) ; dequeue a vertex from queue ; find all non - colored adjacent vertices ; an edge from u to v exists and destination v is not colored ; assign alternate color to this adjacent v of u ; an edge from u to v exists and destination v is colored with same color as u ; if we reach here , then all adjacent vertices can be colored with alternate color ; returns true if a graph g [ ] [ ] is bipartite or not . note that g may not be connected . ; create a color array to store colors assigned to all veritces . vertex number is used as index in this array . the value ' - 1' of colorarr [ i ] is used to indicate that no color is assigned to vertex ' i ' . the value 1 is used to indicate first color is assigned and value 0 indicates second color is assigned . ; one by one check all not yet colored vertices . ; returns true if g can be divided into two cliques , else false . ; find complement of g [ ] [ ] all values are complemented except diagonal ones ; return true if complement is bipartite else false . ; ",
        "context": "\nfrom queue import Queue\n\n",
        "code": "def isBipartiteUtil(G, src, colorArr):\n    global V\n    colorArr[src] = 1\n    q = Queue()\n    q .put(src)\n    while (not q .empty()):\n        u = q .get()\n        for v in range(V):\n            if (G[u][v] and colorArr[v] == -1):\n                colorArr[v] = 1 - colorArr[u]\n                q .put(v)\n            elif (G[u][v] and colorArr[v] == colorArr[u]):\n                return False\n    return True\n\n\ndef isBipartite(G):\n    global V\n    colorArr = [-1] * V\n    for i in range(V):\n        if (colorArr[i] == -1):\n            if (isBipartiteUtil(G, i, colorArr) == False):\n                return False\n    return True\n\n\ndef canBeDividedinTwoCliques(G):\n    global V\n    GC = [[None] * V for i in range(V)]\n    for i in range(V):\n        for j in range(V):\n            GC[i][j] = not G[i][j]if i != j else 0\n    return isBipartite(GC)\n",
        "test": "\nV = 5\nG = [[0, 1, 1, 1, 0], [1, 0, 1, 0, 0], [\n    1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 0]]\nif canBeDividedinTwoCliques(G):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "canBeDividedinTwoCliques"
    },
    {
        "text": "area of a square from diagonal length | returns area of square from given diagonal ; ",
        "context": "",
        "code": "def findArea(d):\n    return (d * d) / 2\n",
        "test": "\nd = 10\nprint(\"%.2f\" % findArea(d))\n",
        "output": "50.00\n",
        "fn_call": "findArea"
    },
    {
        "text": "maximum integral co | making set of coordinates such that any two points are non - integral distance apart ; used to avoid duplicates in result ; ",
        "context": "",
        "code": "def printSet(x, y):\n    arr = []\n    for i in range(min(x, y) + 1):\n        pq = [i, min(x, y) - i]\n        arr .append(pq)\n    for it in arr:\n        print(it[0], it[1])\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 4\n    y = 4\n    printSet(x, y)\n",
        "output": "0 4\n1 3\n2 2\n3 1\n4 0\n",
        "fn_call": "printSet"
    },
    {
        "text": "program to find the kth character after decrypting a string | function to print kth character of string s after decrypting it ; get the length of string ; initialise pointer to character of input string to zero ; total length of resultant string ; traverse the string from starting and check if each character is alphabet then increment total_len ; if total_leg equal to k then return string else increment i ; parse the number ; update next_total_len ; get the position of kth character ; position not found then update position with total_len ; recursively find the kth position ; else update total_len by next_total_len ; return - 1 if character not found ; ",
        "context": "",
        "code": "def findKthChar(s, k):\n    len1 = len(s)\n    i = 0\n    total_len = 0\n    while (i < len1):\n        if (s[i].isalpha()):\n            total_len += 1\n            if (total_len == k):\n                return s[i]\n            i += 1\n        else:\n            n = 0\n            while (i < len1 and s[i].isalpha() == False):\n                n = n * 10 + (ord(s[i]) - ord('0'))\n                i += 1\n            next_total_len = total_len * n\n            if (k <= next_total_len):\n                pos = k % total_len\n                if (pos == 0):\n                    pos = total_len\n                return findKthChar(s, pos)\n            else:\n                total_len = next_total_len\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    s = \"ab2c3\"\n    k = 5\n    print(findKthChar(s, k))\n",
        "output": "c\n",
        "fn_call": "findKthChar"
    },
    {
        "text": "make all array elements divisible by a number k | function to make array divisible ; for each element of array how much number to be subtracted to make it divisible by k ; for each element of array how much number to be added to make it divisible by k ; calculate minimum difference ; ",
        "context": "",
        "code": "def makeDivisble(arr, k):\n    n = len(arr)\n    b1 = []\n    b2 = []\n    for i in range(n):\n        b1 .append(arr[i] % k)\n    for j in range(n):\n        if ((arr[j] % k) != 0):\n            b2 .append(k - (arr[j] % k))\n        else:\n            b2 .append(0)\n    c = 0\n    mini = float('inf')\n    suml = 0\n    sumr = 0\n    index = -1\n    for c in range(0, n + 1, 1):\n        suml = sum(b1[:c + 1])\n        sumr = sum(b2)\n        if suml >= sumr:\n            rem = suml - sumr\n            if rem < mini:\n                mini = rem\n                index = c\n    return index, mini\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 14, 4, 41, 1]\n    k = 7\n    index, diff = makeDivisble(arr, k)\n    print(index, diff)\n",
        "output": "-1 inf\n",
        "fn_call": "makeDivisble"
    },
    {
        "text": "count n | function to count n - length strings consisting of vowels only sorted lexicographically ; ",
        "context": "",
        "code": "def findNumberOfStrings(n):\n    return int((n + 1) * (n + 2) * (n + 3) * (n + 4) / 24)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    print(findNumberOfStrings(N))\n",
        "output": "15\n",
        "fn_call": "findNumberOfStrings"
    },
    {
        "text": "program to get the sum of series : 1 | python3 code to get the sum of the series ; function to get the series ; sum of n - 1 terms starting from 2 nd term ; ",
        "context": "\nimport math\n\n",
        "code": "def Series(x, n):\n    sum = 1\n    term = 1\n    y = 2\n    for i in range(1, n):\n        fct = 1\n        for j in range(1, y + 1):\n            fct = fct * j\n        term = term * (-1)\n        m = term * math .pow(x, y) / fct\n        sum = sum + m\n        y += 2\n    return sum\n",
        "test": "\nx = 9\nn = 10\nprint('%.4f' % Series(x, n))\n",
        "output": "-5.1463\n",
        "fn_call": "Series"
    },
    {
        "text": "count of elements not divisible by any other elements of array | function to count the number of elements of array which are not divisible by any other element in the array arr [ ] ; iterate over the array ; check if the element is itself or not ; check for divisibility ; return the final result ; ",
        "context": "",
        "code": "def count(a, n):\n    countElements = 0\n    for i in range(n):\n        flag = True\n        for j in range(n):\n            if (i == j):\n                continue\n            if (a[i] % a[j] == 0):\n                flag = False\n                break\n        if (flag):\n            countElements += 1\n    return countElements\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [86, 45, 18, 4, 8, 28, 19, 33, 2]\n    n = len(arr)\n    print(count(arr, n))\n",
        "output": "4\n",
        "fn_call": "count"
    },
    {
        "text": "minimum number of elements that should be removed to make the array good | function to return the minimum number of elements that must be removed to make the given array good ; count frequency of each element ; for each element check if there exists another element that makes a valid pair ; if does not exist then increment answer ; ",
        "context": "",
        "code": "def minimumRemoval(n, a):\n    c = dict .fromkeys(a, 0)\n    for i in range(n):\n        c[a[i]] += 1\n    ans = 0\n    for i in range(n):\n        ok = False\n        for j in range(31):\n            x = (1 << j) - a[i]\n            if (x in c and (c[x] > 1 or (c[x] == 1 and x != a[i]))):\n                ok = True\n                break\n        if (not ok):\n            ans += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [4, 7, 1, 5, 4, 9]\n    n = len(a)\n    print(minimumRemoval(n, a))\n",
        "output": "1\n",
        "fn_call": "minimumRemoval"
    },
    {
        "text": "check if an array can be sorted by picking only the corner array elements | function to check if an array can be sorted using given operations ; if sequence becomes increasing after an already non - decreasing to non - increasing pattern ; if a decreasing pattern is observed ; ",
        "context": "",
        "code": "def check(arr, n):\n    g = 0\n    for i in range(1, n):\n        if (arr[i] - arr[i - 1] > 0 and g == 1):\n            return False\n        if (arr[i] - arr[i] < 0):\n            g = 1\n    return True\n",
        "test": "\narr = [2, 3, 4, 10, 4, 3, 1]\nn = len(arr)\nif (check(arr, n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "count of decreasing pairs formed from numbers 1 to n | function to count the possible number of pairs ; if the number is even then the answer in ( n / 2 ) - 1 ; if the number is odd then the answer in n / 2 ; ",
        "context": "",
        "code": "def divParts(N):\n    if (N % 2 == 0):\n        print((N / 2) - 1)\n    else:\n        print(N / 2)\n",
        "test": "\nN = 8\ndivParts(N)\n",
        "output": "3.0\n",
        "fn_call": "divParts"
    },
    {
        "text": "maximum size of subset such that product of all subset elements is a factor of n | function to find the maximum size of the subset such that the product of subset elements is a factor of n ; base case ; stores maximum size of valid subset ; traverse the given array ; if n % arr [ i ] = 0 , include arr [ i ] in a subset and recursively call for the remaining array integers ; return answer ; ",
        "context": "",
        "code": "def maximizeSubset(N, arr, M, x=0):\n    if (x == M):\n        return 0\n    ans = 0\n    for i in range(x, M):\n        if (N % arr[i] == 0):\n            ans = max(ans, maximizeSubset(N // arr[i], arr, M, x + 1) + 1)\n    return ans\n",
        "test": "\nN = 64\narr = [1, 2, 4, 8, 16, 32]\nM = len(arr)\nprint(maximizeSubset(N, arr, M))\n",
        "output": "4\n",
        "fn_call": "maximizeSubset"
    },
    {
        "text": "count the number of ways to tile the floor of size n x m using 1 x m size tiles | function to count the total number of ways ; table to store values of subproblems ; fill the table upto value n ; recurrence relation ; base cases ; i = = m ; required number of ways ; ",
        "context": "",
        "code": "def countWays(n, m):\n    count = []\n    for i in range(n + 2):\n        count .append(0)\n    count[0] = 0\n    for i in range(1, n + 1):\n        if (i > m):\n            count[i] = count[i - 1] + count[i - m]\n        elif (i < m or i == 1):\n            count[i] = 1\n        else:\n            count[i] = 2\n    return count[n]\n",
        "test": "\nn = 7\nm = 4\nprint(\"Number of ways = \", countWays(n, m))\n",
        "output": "Number of ways =  5\n",
        "fn_call": "countWays"
    },
    {
        "text": "check if the binary representation of a number has equal number of 0 s and 1 s in blocks | function to check ; converting integer to its equivalent binary number ; if adjacent character are same then increase counter ; ",
        "context": "",
        "code": "def hasEqualBlockFrequency(N):\n    S = bin(N).replace(\"0b\", \"\")\n    p = set()\n    c = 1\n    for i in range(len(S) - 1):\n        if (S[i] == S[i + 1]):\n            c += 1\n        else:\n            p .add(c)\n            c = 1\n        p .add(c)\n    if (len(p) == 1):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nN = 5\nhasEqualBlockFrequency(N)\n",
        "output": "Yes\n",
        "fn_call": "hasEqualBlockFrequency"
    },
    {
        "text": "Interpolation Search | If x is present in arr [ 0. . n - 1 ] , then returns index of it , else returns - 1. ; Since array is sorted , an element present in array must be in range defined by corner ; Probing the position with keeping uniform distribution in mind . ; Condition of target found ; If x is larger , x is in right subarray ; If x is smaller , x is in left subarray ; Array of items in which search will be conducted ; Element to be searched ; If element was found",
        "context": "",
        "code": "def interpolationSearch(arr, lo, hi, x):\n    if (lo = arr[lo] and x <= arr[hi]):\n        pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) * (x - arr[lo]))\n        if arr[pos] == x:\n            return pos\n        if arr[pos] < x:\n            return interpolationSearch(arr, pos + 1, hi, x)\n        if arr[pos] > x:\n            return interpolationSearch(arr, lo, pos - 1, x)\n    return -1\n",
        "test": "\narr = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]\nn = len(arr)\nx = 18\nindex = interpolationSearch(arr, 0, n - 1, x)\nif index != -1:\n    print(\"Element found at index\", index)\nelse:\n    print(\"Element not found\")\n",
        "output": "Element found at index 4\n",
        "fn_call": "interpolationSearch"
    },
    {
        "text": "find two numbers such that difference of their squares equal to n | python3 program to find two numbers with difference of their squares equal to n ; function to check and print the required two positive integers ; iterate till sqrt ( n ) to find factors of n ; check if x is one of the factors of n ; store the factor ; compute the other factor ; check if the two factors are of the same parity ; compute a and b ; if no pair exists ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def solve(n):\n    for x in range(1, int(sqrt(n)) + 1):\n        if (n % x == 0):\n            small = x\n            big = n // x\n            if (small % 2 == big % 2):\n                a = (small + big) // 2\n                b = (big - small) // 2\n                print(a, b)\n                return\n    print(-1)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 7\n    solve(n)\n",
        "output": "4 3\n",
        "fn_call": "solve"
    },
    {
        "text": "program to find sum of harmonic series | function to return sum of harmonic series ; ",
        "context": "",
        "code": "def sum(n):\n    i = 1\n    s = 0.0\n    for i in range(1, n + 1):\n        s = s + 1 / i\n    return s\n",
        "test": "\nn = 5\nprint(\"Sum is\", round(sum(n), 6))\n",
        "output": "Sum is 2.283333\n",
        "fn_call": "sum"
    },
    {
        "text": "find if an array of strings can be chained to form a circle | set 2 | python3 code to check if cyclic order is possible among strings under given constrainsts ; utility method for a depth first search among vertices ; returns true if all vertices are strongly connected i . e . can be made as loop ; initialize all vertices as not visited ; perform a dfs from s ; now loop through all characters ; i character is marked ( i . e . it was first or last character of some string ) then it should be visited in last dfs ( as for looping , graph should be strongly connected ) ; if we reach that means graph is connected ; return true if an order among strings is possible ; create an empty graph ; initialize all vertices as not marked ; initialize indegree and outdegree of every vertex as 0. ; process all strings one by one ; find first and last characters ; mark the characters ; increase indegree and outdegree count ; add an edge in graph ; if for any character indegree is not equal to outdegree then ordering is not possible ; ",
        "context": "\nM = 26\n\n",
        "code": "def dfs(g, u, visit):\n    visit[u] = True\n    for i in range(len(g[u])):\n        if (not visit[g[u][i]]):\n            dfs(g, g[u][i], visit)\n\n\ndef isConnected(g, mark, s):\n    visit = [False for i in range(M)]\n    dfs(g, s, visit)\n    for i in range(M):\n        if (mark[i] and (not visit[i])):\n            return False\n    return True\n\n\ndef possibleOrderAmongString(arr, N):\n    g = {}\n    mark = [False for i in range(M)]\n    In = [0 for i in range(M)]\n    out = [0 for i in range(M)]\n    for i in range(N):\n        f = (ord(arr[i][0]) - ord('a'))\n        l = (ord(arr[i][-1]) - ord('a'))\n        mark[f] = True\n        mark[l] = True\n        In[l] += 1\n        out[f] += 1\n        if f not in g:\n            g[f] = []\n        g[f].append(l)\n    for i in range(M):\n        if (In[i] != out[i]):\n            return False\n    return isConnected(g, mark, ord(arr[0][0]) - ord('a'))\n",
        "test": "\narr = [\"ab\", \"bc\", \"cd\", \"de\", \"ed\", \"da\"]\nN = len(arr)\nif (possibleOrderAmongString(arr, N) == False):\n    print(\"Ordering not possible\")\nelse:\n    print(\"Ordering is possible\")\n",
        "output": "Ordering is possible\n",
        "fn_call": "possibleOrderAmongString"
    },
    {
        "text": "shuffle 2 n integers as a1 | function to reverse the array from the position ' start ' to position 'end ; stores mid of start and end ; traverse the array in the range [ start , end ] ; stores arr [ start + i ] ; update arr [ start + i ] ; update arr [ end - i ] ; utility function to shuffle the given array in the of form { a1 , b1 , a2 , b2 , ... . an , bn } ; stores the length of the array ; if length of the array is 2 ; stores mid of the { start , end } ; divide array into two halves of even length ; update mid ; calculate the mid - points of both halves of the array ; reverse the subarray made from mid1 to mid2 ; reverse the subarray made from mid1 to mid ; reverse the subarray made from mid to mid2 ; recursively calls for both the halves of the array ; function to shuffle the given array in the form of { a1 , b1 , a2 , b2 , ... . an , bn } ; function call ; print the modified array ; ",
        "context": "",
        "code": "def reverse(arr, start, end):\n    mid = (end - start + 1) // 2\n    for i in range(mid):\n        temp = arr[start + i]\n        arr[start + i] = arr[end - i]\n        arr[end - i] = temp\n    return arr\n\n\ndef shuffleArrayUtil(arr, start, end):\n    i = 0\n    l = end - start + 1\n    if (l == 2):\n        return\n    mid = start + l // 2\n    if (l % 4):\n        mid -= 1\n    mid1 = start + (mid - start) // 2\n    mid2 = mid + (end + 1 - mid) // 2\n    arr = reverse(arr, mid1, mid2 - 1)\n    arr = reverse(arr, mid1, mid - 1)\n    arr = reverse(arr, mid, mid2 - 1)\n    shuffleArrayUtil(arr, start, mid - 1)\n    shuffleArrayUtil(arr, mid, end)\n\n\ndef shuffleArray(arr, N, start, end):\n    shuffleArrayUtil(arr, start, end)\n    for i in arr:\n        print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 5, 2, 4, 6]\n    N = len(arr)\n    shuffleArray(arr, N, 0, N - 1)\n",
        "output": "1 2 3 4 5 6 ",
        "fn_call": "shuffleArray"
    },
    {
        "text": "check if an array can be divided into pairs whose sum is divisible by k | python3 program to check if arr [ 0. . n - 1 ] can be divided in pairs such that every pair is divisible by k . ; returns true if arr [ 0. . n - 1 ] can be divided into pairs with sum divisible by k . ; an odd length array cannot be divided into pairs ; create a frequency array to count occurrences of all remainders when divided by k . ; count occurrences of all remainders ; traverse input array and use freq [ ] to decide if given array can be divided in pairs ; remainder of current element ; if remainder with current element divides k into two halves . ; then there must be even occurrences of such remainder ; if remainder is 0 , then there must be two elements with 0 remainde ; then there must be even occurrences of such remainder ; else number of occurrences of remainder must be equal to number of occurrences of k - remainder ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def canPairs(arr, n, k):\n    if (n & 1):\n        return 0\n    freq = defaultdict(lambda: 0)\n    for i in range(0, n):\n        freq[((arr[i] % k) + k) % k] += 1\n    for i in range(0, n):\n        rem = ((arr[i] % k) + k) % k\n        if (2 * rem == k):\n            if (freq[rem] % 2 != 0):\n                return 0\n        elif (rem == 0):\n            if (freq[rem] & 1):\n                return 0\n        elif (freq[rem] != freq[k - rem]):\n            return 0\n    return 1\n",
        "test": "\narr = [92, 75, 65, 48, 45, 35]\nk = 10\nn = len(arr)\nif (canPairs(arr, n, k)):\n    print(\"True\")\nelse:\n    print(\"False\")\n",
        "output": "True\n",
        "fn_call": "canPairs"
    },
    {
        "text": "bitwise recursive addition of two integers | python program to do recursive addition of two integers ; if bitwise & is 0 , then there is not going to be any carry . hence result of xor is addition . ; ",
        "context": "",
        "code": "def add(x, y):\n    keep = (x & y) << 1\n    res = x ^ y\n    if (keep == 0):\n        return res\n    return add(keep, res)\n",
        "test": "\nprint(add(15, 38))\n",
        "output": "53\n",
        "fn_call": "add"
    },
    {
        "text": "minimize operations of removing 2 i | function to find minimum count of steps required to remove all the array elements ; stores minimum count of steps required to remove all the array elements ; update n ; traverse each bit of n ; if current bit is set ; update cntstep ; ",
        "context": "",
        "code": "def minimumStepReqArr(arr, N):\n    cntStep = 0\n    N += 1\n    i = 31\n    while (i >= 0):\n        if (N & (1 << i)):\n            cntStep += 1\n        i -= 1\n    return cntStep\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3]\n    N = len(arr)\n    print(minimumStepReqArr(arr, N))\n",
        "output": "1\n",
        "fn_call": "minimumStepReqArr"
    },
    {
        "text": "count of pairs in an array whose sum is a perfect square | function to return an arraylist containing all the perfect squares upto n ; while current perfect square is less than or equal to n ; function to print the sum of maximum two elements from the array ; function to return the count of numbers that when added with n give a perfect square ; temp > n is checked so that pairs ( x , y ) and ( y , x ) don 't get counted twice  ; function to count the pairs whose sum is a perfect square ; sum of the maximum two elements from the array ; list of perfect squares upto max ; contains all the array elements ; add count of the elements that when added with arr [ i ] give a perfect square ; ",
        "context": "",
        "code": "def getPerfectSquares(n):\n    perfectSquares = []\n    current = 1\n    i = 1\n    while (current <= n):\n        perfectSquares .append(current)\n        i += 1\n        current = int(pow(i, 2))\n    return perfectSquares\n\n\ndef maxPairSum(arr):\n    n = len(arr)\n    max = 0\n    secondMax = 0\n    if (arr[0] > arr[1]):\n        max = arr[0]\n        secondMax = arr[1]\n    else:\n        max = arr[1]\n        secondMax = arr[0]\n    for i in range(2, n):\n        if (arr[i] > max):\n            secondMax = max\n            max = arr[i]\n        elif (arr[i] > secondMax):\n            secondMax = arr[i]\n    return (max + secondMax)\n\n\ndef countPairsWith(n, perfectSquares, nums):\n    count = 0\n    for i in range(len(perfectSquares)):\n        temp = perfectSquares[i] - n\n        if (temp > n and (temp in nums)):\n            count += 1\n    return count\n\n\ndef countPairs(arr):\n    n = len(arr)\n    max = maxPairSum(arr)\n    perfectSquares = getPerfectSquares(max)\n    nums = []\n    for i in range(n):\n        nums .append(arr[i])\n    count = 0\n    for i in range(n):\n        count += countPairsWith(arr[i], perfectSquares, nums)\n    return count\n",
        "test": "\narr = [2, 3, 6, 9, 10, 20]\nprint(countPairs(arr))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "shortest path in a binary maze | python program to find the shortest path between a given source cell to a destination cell . ; to store matrix cell cordinates ; a data structure for queue used in bfs ; the cordinates of the cell ; cell 's distance from the source ; check whether given cell ( row , col ) is a valid cell or not ; return true if row number and column number is in range ; these arrays are used to get row and column numbers of 4 neighbours of a given cell ; function to find the shortest path between a given source cell to a destination cell . ; check source and destination cell of the matrix have value 1 ; mark the source cell as visited ; create a queue for bfs ; distance of source cell is 0 ; enqueue source cell ; do a bfs starting from source cell ; if we have reached the destination cell , we are done ; otherwise enqueue its adjacent cells ; if adjacent cell is valid , has path and not visited yet , enqueue it . ; mark cell as visited and enqueue it ; return - 1 if destination cannot be reached ; ",
        "context": "\nfrom collections import deque\nROW = 9\nCOL = 10\n\n\nclass Point:\n    def __init__(self, x: int, y: int):\n        self .x = x\n        self .y = y\n\n\nclass queueNode:\n    def __init__(self, pt: Point, dist: int):\n        self .pt = pt\n        self .dist = dist\n\n",
        "code": "def isValid(row: int, col: int):\n    return (row >= 0) and (row = 0) and (col < COL)\n\n\nrowNum = [-1, 0, 0, 1]\ncolNum = [0, -1, 1, 0]\n\n\ndef BFS(mat, src: Point, dest: Point):\n    if mat[src .x][src .y] != 1 or mat[dest .x][dest .y] != 1:\n        return -1\n    visited = [[False for i in range(COL)]for j in range(ROW)]\n    visited[src .x][src .y] = True\n    q = deque()\n    s = queueNode(src, 0)\n    q .append(s)\n    while q:\n        curr = q .popleft()\n        pt = curr .pt\n        if pt .x == dest .x and pt .y == dest .y:\n            return curr .dist\n        for i in range(4):\n            row = pt .x + rowNum[i]\n            col = pt .y + colNum[i]\n            if (isValid(row, col) and mat[row][col]\n                    == 1 and not visited[row][col]):\n                visited[row][col] = True\n                Adjcell = queueNode(Point(row, col), curr .dist + 1)\n                q .append(Adjcell)\n    return -1\n\n\ndef main():\n    mat = [\n        [\n            1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [\n            1, 0, 1, 0, 1, 1, 1, 0, 1, 1], [\n                1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [\n                    0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [\n                        1, 1, 1, 0, 1, 1, 1, 0, 1, 0], [\n                            1, 0, 1, 1, 1, 1, 0, 1, 0, 0], [\n                                1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [\n                                    1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [\n                                        1, 1, 0, 0, 0, 0, 1, 0, 0, 1]]\n    source = Point(0, 0)\n    dest = Point(3, 4)\n    dist = BFS(mat, source, dest)\n    if dist != -1:\n        print(\"Shortest Path is\", dist)\n    else:\n        print(\"Shortest Path doesn't exist\")\n",
        "test": "\nmain()\n",
        "output": "Shortest Path is 11\n",
        "fn_call": "main"
    },
    {
        "text": "euler 's totient function for all numbers smaller than or equal to n | computes and prints totient of all numbers smaller than or equal to n . ; create and initialize an array to store phi or totient values ; compute other phi values ; if phi [ p ] is not computed already , then number p is prime ; phi of a prime number p is always equal to p - 1. ; update phi values of all multiples of p ; add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; print precomputed phi values ; ",
        "context": "",
        "code": "def computeTotient(n):\n    phi = []\n    for i in range(n + 2):\n        phi .append(0)\n    for i in range(1, n + 1):\n        phi[i] = i\n    for p in range(2, n + 1):\n        if (phi[p] == p):\n            phi[p] = p - 1\n            for i in range(2 * p, n + 1, p):\n                phi[i] = (phi[i] // p) * (p - 1)\n    for i in range(1, n + 1):\n        print(\"Totient of \", i, \" is \", phi[i])\n",
        "test": "\nn = 12\ncomputeTotient(n)\n",
        "output": "Totient of  1  is  1\nTotient of  2  is  1\nTotient of  3  is  2\nTotient of  4  is  2\nTotient of  5  is  4\nTotient of  6  is  2\nTotient of  7  is  6\nTotient of  8  is  4\nTotient of  9  is  6\nTotient of  10  is  4\nTotient of  11  is  10\nTotient of  12  is  4\n",
        "fn_call": "computeTotient"
    },
    {
        "text": "check whether the given matrix is balanced or not | define the size of the matrix ; function to check given matrix balanced or unbalanced ; flag for check matrix is balanced or unbalanced ; iterate row until condition is true ; iterate cols until condition is true ; check for corner edge elements ; check for border elements ; check for the middle ones ; return balanced or not ; ",
        "context": "\nN = 4\nM = 4\n\n",
        "code": "def balancedMatrix(mat):\n    is_balanced = True\n    i = 0\n    while i < N and is_balanced:\n        j = 0\n        while j < N and is_balanced:\n            if ((i == 0 or i == N - 1) and (j == 0 or j == M - 1)):\n                if mat[i][j] >= 2:\n                    isbalanced = False\n            elif (i == 0 or i == N - 1 or j == 0 or j == M - 1):\n                if mat[i][j] >= 3:\n                    is_balanced = False\n            else:\n                if mat[i][j] >= 4:\n                    is_balanced = False\n            j += 1\n        i += 1\n    if is_balanced:\n        return \"Balanced\"\n    else:\n        return \"Unbalanced\"\n",
        "test": "\nmat = [[1, 2, 3, 4], [3, 5, 2, 6], [5, 3, 6, 1], [9, 5, 6, 0]]\nprint(balancedMatrix(mat))\n",
        "output": "Unbalanced\n",
        "fn_call": "balancedMatrix"
    },
    {
        "text": "construct mex array from the given array | python3 program for the above approach ; function to construct array b [ ] that stores mex of array a [ ] excluding a [ i ] ; stores elements present in arr [ ] ; mark all values 1 , if present ; initialize variable to store mex ; find mex of arr [ ] ; stores mex for all indices ; traverse the given array ; update mex ; mex default ; prthe array b ; ",
        "context": "\nMAXN = 100001\n\n",
        "code": "def constructMEX(arr, N):\n    hash = [0] * MAXN\n    for i in range(N):\n        hash[arr[i]] = 1\n    MexOfArr = 0\n    for i in range(1, MAXN):\n        if (hash[i] == 0):\n            MexOfArr = i\n            break\n    B = [0] * N\n    for i in range(N):\n        if (arr[i] < MexOfArr):\n            B[i] = arr[i]\n        else:\n            B[i] = MexOfArr\n    for i in range(N):\n        print(B[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 1, 5, 3]\n    N = len(arr)\n    constructMEX(arr, N)\n",
        "output": "2 1 4 3 ",
        "fn_call": "constructMEX"
    },
    {
        "text": "k | function to find the kth digit from last in an eger n ; if k is less than equal to 0 ; divide the number n by 10 upto k - 1 times ; if the number n is equal 0 ; pr the right most digit ; ",
        "context": "",
        "code": "def kthDigitFromLast(n, k):\n    if (k <= 0):\n        print(\"-1\")\n        return\n    while ((k - 1) > 0 and n > 0):\n        n = n / 10\n        k -= 1\n    if (n == 0):\n        print(\"-1\")\n    else:\n        print(int(n % 10))\n",
        "test": "\nif __name__ == '__main__':\n    n = 2354\n    k = 2\n    kthDigitFromLast(n, k)\n",
        "output": "5\n",
        "fn_call": "kthDigitFromLast"
    },
    {
        "text": "check whether a number is non | python3 program to check if a given number is non - hypotenuse number or not . ; function to find prime factor and check if it is of the form 4 k + 1 or not ; 2 is a prime number but not of the form 4 k + 1 so , keep dividing n by 2 until n is divisible by 2 ; n must be odd at this point . so we can skip one element ( note i = i + 2 ) ; if i divides n check if i is of the form 4 k + 1 or not ; while i divides n divide n by i and update n ; this condition is to handle the case when n is a prime number greater than 2 ; test function ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isNonHypotenuse(n):\n    while (n % 2 == 0):\n        n = n // 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if (n % i == 0):\n            if ((i - 1) % 4 == 0):\n                return False\n            while (n % i == 0):\n                n = n // i\n    if (n > 2 and (n - 1) % 4 == 0):\n        return False\n    else:\n        return True\n\n\ndef test(n):\n    print(\"Testing for\", n, \":\", end=\" \")\n    if (isNonHypotenuse(n)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 11\n    test(n)\n    n = 10\n    test(n)\n",
        "output": "Testing for 11 : YES\nTesting for 10 : NO\n",
        "fn_call": "test"
    },
    {
        "text": "find the number of integers from 1 to n which contains digits 0 ' s \u2581 and \u2581 1' s only | function to find the number of integers from 1 to n which contains 0 ' s \u2581 and \u2581 1' s only ; if number is greater than n ; otherwise add count this number and call two functions ; ",
        "context": "",
        "code": "def countNumbers(x, n):\n    if x > n:\n        return 0\n    return (1 + countNumbers(x * 10, n) + countNumbers(x * 10 + 1, n))\n",
        "test": "\nif __name__ == '__main__':\n    n = 120\n    print(countNumbers(1, n))\n",
        "output": "7\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "count pairs from an array whose quotient of division of larger number by the smaller number does not exceed k | python3 program for the above approach ; function to count the number having quotient of division of larger element by the smaller element in the pair not exceeding k ; sort the array in ascending order ; store the required result ; traverse the array ; store the upper bound for the current array element ; update the number of pairs ; prthe result ; ",
        "context": "\nfrom bisect import bisect_right\n\n",
        "code": "def countPairs(arr, n, k):\n    arr .sort()\n    ans = 0\n    for i in range(n - 1):\n        high = bisect_right(arr, k * arr[i])\n        ans += high - i - 1\n    print(ans)\n",
        "test": "\narr = [2, 3, 9, 5]\nn = len(arr)\nk = 2\ncountPairs(arr, n, k)\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "count of elements on the left which are divisible by current element | utility function to print the elements of the array ; function to generate and print the required array ; for every element of the array ; to store the count of elements on the left that the current element divides ; print the generated array ; ",
        "context": "",
        "code": "def printArr(arr, n):\n    for i in arr:\n        print(i, end=\" \")\n\n\ndef generateArr(A, n):\n    B = [0 for i in range(n)]\n    for i in range(n):\n        cnt = 0\n        for j in range(i):\n            if (A[j] % A[i] == 0):\n                cnt += 1\n        B[i] = cnt\n    printArr(B, n)\n",
        "test": "\nA = [3, 5, 1]\nn = len(A)\ngenerateArr(A, n)\n",
        "output": "0 0 2 ",
        "fn_call": "generateArr"
    },
    {
        "text": "minimize difference between maximum and minimum array elements by exactly k removals | function to minimize the difference of the maximum and minimum array elements by removing k elements ; base condition ; sort the array ; initialize left and right pointers ; iterate for k times ; removing right element to reduce the difference ; removing the left element to reduce the difference ; print the minimum difference ; ",
        "context": "",
        "code": "def minimumRange(arr, N, K):\n    if (K >= N):\n        print(0, end='')\n        return\n    arr .sort()\n    left = 0\n    right = N - 1\n    for i in range(K):\n        if (arr[right - 1] - arr[left] < arr[right] - arr[left + 1]):\n            right -= 1\n        else:\n            left += 1\n    print(arr[right] - arr[left], end='')\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 10, 12, 14, 21, 54, 61]\n    N = len(arr)\n    K = 4\n    minimumRange(arr, N, K)\n",
        "output": "4",
        "fn_call": "minimumRange"
    },
    {
        "text": "maximum sum by picking elements from two arrays in order | set 2 | function to calculate maximum sum ; maximum elements that can be chosen from array a ; maximum elements that can be chosen from array b ; stores the maximum sum possible ; fill the dp [ ] for base case when all elements are selected from a [ ] ; fill the dp [ ] for base case when all elements are selected from b [ ] ; return the final answer ; ",
        "context": "",
        "code": "def maximumSum(A, B, length, X, Y):\n    l = length\n    l1 = min(length, X)\n    l2 = min(length, Y)\n    dp = [[0 for i in range(l2 + 1)]for i in range(l1 + 1)]\n    dp[0][0] = 0\n    max_sum = -10 * 9\n    for i in range(1, l1 + 1):\n        dp[i][0] = dp[i - 1][0] + A[i - 1]\n        max_sum = max(max_sum, dp[i][0])\n    for i in range(1, l2 + 1):\n        dp[0][i] = dp[0][i - 1] + B[i - 1]\n        max_sum = max(max_sum, dp[0][i])\n    for i in range(1, l1 + 1):\n        for j in range(1, l2 + 1):\n            if (i + j <= l):\n                dp[i][j] = max(dp[i - 1][j] + A[i + j - 1],\n                               dp[i][j - 1] + B[i + j - 1])\n            max_sum = max(dp[i][j], max_sum)\n    return max_sum\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5]\n    B = [5, 4, 3, 2, 1]\n    X = 3\n    Y = 2\n    N = len(A)\n    print(maximumSum(A, B, N, X, Y))\n",
        "output": "21\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "equally divide into two sets such that one set has maximum distinct elements | python3 program to equally divide n elements into two sets such that second set has maximum distinct elements . ; insert all the resources in the set there will be unique resources in the set ; return minimum of distinct resources and n / 2 ; ",
        "context": "",
        "code": "def distribution(arr, n):\n    resources = set()\n    for i in range(n):\n        resources .add(arr[i])\n    return min(len(resources), n // 2)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 2, 1, 3, 4]\n    n = len(arr)\n    print(distribution(arr, n), \"\")\n",
        "output": "3 \n",
        "fn_call": "distribution"
    },
    {
        "text": "first term from given nth term of the equation f ( n ) = ( 2 * f ( n | python3 program to implement the above approach ; function to find the value of power ( x , n ) % m ; stores the value of ( x ^ n ) % m ; calculate the value of power ( x , n ) % m ; if n is odd ; update res ; update x ; update n ; function to find modulo multiplicative inverse of x under modulo m ; function to find the value of f ( 1 ) ; stores power ( 2 , n - 1 ) ; stores modulo multiplicative inverse of p_2 under modulo m ; stores the value of f ( 1 ) ; update res ; ",
        "context": "\nM = 1000000007\n\n",
        "code": "def power(x, N):\n    res = 1\n    while (N > 0):\n        if (N & 1):\n            res = (res * x) % M\n        x = (x * x) % M\n        N = N >> 1\n    return res\n\n\ndef moduloInverse(X):\n    return power(X, M - 2)\n\n\ndef F_1(N, F_N):\n    P_2 = power(2, N - 1)\n    modInv = moduloInverse(P_2)\n    res = 0\n    res = ((modInv % M) * (F_N % M)) % M\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    F_N = 6\n    print(F_1(N, F_N))\n",
        "output": "500000005\n",
        "fn_call": "F_1"
    },
    {
        "text": "minimum product subset of an array | def to find maximum product of a subset ; find count of negative numbers , count of zeros , maximum valued negative number , minimum valued positive number and product of non - zero numbers ; if number is 0 , we don 't  multiply it with product. ; count negatives and keep track of maximum valued negative . ; track minimum positive number of array ; if there are all zeros or no negative number present ; if there are all positive ; if there are even number of negative numbers and count_neg not 0 ; otherwise result is product of all non - zeros divided by maximum valued negative . ; ",
        "context": "",
        "code": "def minProductSubset(a, n):\n    if (n == 1):\n        return a[0]\n    max_neg = float('-inf')\n    min_pos = float('inf')\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range(0, n):\n        if (a[i] == 0):\n            count_zero = count_zero + 1\n            continue\n        if (a[i] < 0):\n            count_neg = count_neg + 1\n            max_neg = max(max_neg, a[i])\n        if (a[i] > 0):\n            min_pos = min(min_pos, a[i])\n        prod = prod * a[i]\n    if (count_zero == n or (count_neg == 0 and count_zero > 0)):\n        return 0\n    if (count_neg == 0):\n        return min_pos\n    if ((count_neg & 1) == 0 and count_neg != 0):\n        prod = int(prod / max_neg)\n    return prod\n",
        "test": "\na = [-1, -1, -2, 4, 3]\nn = len(a)\nprint(minProductSubset(a, n))\n",
        "output": "-24\n",
        "fn_call": "minProductSubset"
    },
    {
        "text": "count of distinct power of prime factor of n | function to count the number of distinct positive power of prime factor of integer n ; iterate for all prime factor ; if it is a prime factor , count the total number of times it divides n . ; find the number of distinct possible positive numbers ; return the final count ; ",
        "context": "",
        "code": "def countFac(n):\n    m = n\n    count = 0\n    i = 2\n    while ((i * i) <= m):\n        total = 0\n        while (n % i == 0):\n            n /= i\n            total += 1\n        temp = 0\n        j = 1\n        while ((temp + j) <= total):\n            temp += j\n            count += 1\n            j += 1\n        i += 1\n    if (n != 1):\n        count += 1\n    return count\n",
        "test": "\nN = 24\nprint(countFac(N))\n",
        "output": "3\n",
        "fn_call": "countFac"
    },
    {
        "text": "smallest even digits number not less than n | function to check if all digits are even of a given number ; iterate for all digits ; if digit is odd ; all digits are even ; function to return the smallest number with all digits even ; iterate till we find a number with all digits even ; ",
        "context": "",
        "code": "def check_digits(n):\n    while (n):\n        if ((n % 10) % 2):\n            return 0\n        n = int(n / 10)\n    return 1\n\n\ndef smallest_number(n):\n    for i in range(n, 2401):\n        if (check_digits(i) == 1):\n            return (i)\n",
        "test": "\nN = 2397\nprint(str(smallest_number(N)))\n",
        "output": "2400\n",
        "fn_call": "smallest_number"
    },
    {
        "text": "sum of each element raised to ( prime | function to return the required sum ; ",
        "context": "",
        "code": "def getSum(arr, p):\n    return len(arr)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 6, 8]\n    p = 7\n    print(getSum(arr, p))\n",
        "output": "3\n",
        "fn_call": "getSum"
    },
    {
        "text": "divide the two given numbers by their common divisors | print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; ",
        "context": "",
        "code": "def divide(a, b):\n    for i in range(2, min(a, b) + 1):\n        while (a % i == 0 and b % i == 0):\n            a = a // i\n            b = b // i\n    print(\"A =\", a, \", B =\", b)\n",
        "test": "\nif __name__ == \"__main__\":\n    A, B = 10, 15\n    divide(A, B)\n",
        "output": "A = 2 , B = 3\n",
        "fn_call": "divide"
    },
    {
        "text": "program for sum of cosh ( x ) series upto nth term | function to return the factorial of a number ; function to return the sum of the series ; ",
        "context": "",
        "code": "def fact(n):\n    i, fac = 1, 1\n    for i in range(1, n + 1):\n        fac = fac * i\n    return fac\n\n\ndef log_Expansion(x, n):\n    Sum = 0\n    i = 0\n    for i in range(n):\n        Sum = Sum + pow(x, 2 * i) / fact(2 * i)\n    return Sum\n",
        "test": "\nx = 1\nn = 10\nprint(log_Expansion(x, n))\n",
        "output": "1.543080634815244\n",
        "fn_call": "log_Expansion"
    },
    {
        "text": "swap bits in a given number | python program to swap bits in a given number ; move all bits of first set to rightmost side ; moce all bits of second set to rightmost side ; xor the two sets ; put the xor bits back to their original positions ; xor the ' xor ' with the original number so that the two sets are swapped ; ",
        "context": "",
        "code": "def swapBits(x, p1, p2, n):\n    set1 = (x >> p1) & ((1 << n) - 1)\n    set2 = (x >> p2) & ((1 << n) - 1)\n    xor = (set1 ^ set2)\n    xor = (xor << p1) | (xor << p2)\n    result = x ^ xor\n    return result\n",
        "test": "\nres = swapBits(28, 0, 3, 2)\nprint(\"Result =\", res)\n",
        "output": "Result = 7\n",
        "fn_call": "swapBits"
    },
    {
        "text": "generate a sequence with the given operations | function to find minimum required permutation ; ",
        "context": "",
        "code": "def StringMatch(S):\n    lo, hi = 0, len(S)\n    ans = []\n    for x in S:\n        if x == 'I':\n            ans .append(lo)\n            lo += 1\n        else:\n            ans .append(hi)\n            hi -= 1\n    return ans + [lo]\n",
        "test": "\nS = \"IDID\"\nprint(StringMatch(S))\n",
        "output": "[0, 4, 1, 3, 2]\n",
        "fn_call": "StringMatch"
    },
    {
        "text": "replace each element of array with it 's corresponding rank | function to assign rank to array elements ; copy input array into newarray ; sort newarray [ ] in ascending order ; dictionary to store the rank of the array element ; update rank of element ; assign ranks to elements ; ",
        "context": "",
        "code": "def changeArr(input1):\n    newArray = sorted(input1 .copy())\n    ranks = {}\n    rank = 1\n    for index in range(len(newArray)):\n        element = newArray[index]\n        if element not in ranks:\n            ranks[element] = rank\n            rank += 1\n    for index in range(len(input1)):\n        element = input1[index]\n        input1[index] = ranks[input1[index]]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [100, 2, 70, 2]\n    changeArr(arr)\n    print(arr)\n",
        "output": "[3, 1, 2, 1]\n",
        "fn_call": "changeArr"
    },
    {
        "text": "maximum value at each level in an n | function to find the maximum value at each level of n - ary tree ; stores the adjacency list ; create the adjacency list ; perform level order traversal of nodes at each level ; push the root node ; iterate until queue is empty ; get the size of queue ; iterate for : all the nodes in the queue currently ; dequeue an node from queue ; enqueue the children of dequeued node ; print the result ; ",
        "context": "",
        "code": "def maxAtLevel(N, M, Value, Edges):\n    adj = [[]for i in range(N)]\n    for i in range(M):\n        u = Edges[i][0]\n        v = Edges[i][1]\n        adj[u].append(v)\n    q = []\n    q .append(0)\n    while (len(q)):\n        count = len(q)\n        maxVal = 0\n        while (count):\n            temp = q[0]\n            q .remove(q[0])\n            maxVal = max(maxVal, Value[temp])\n            for i in range(len(adj[temp])):\n                q .append(adj[temp][i])\n            count -= 1\n        print(maxVal, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    Edges = [\n        [\n            0, 1], [\n            0, 2], [\n                0, 3], [\n                    1, 4], [\n                        1, 5], [\n                            3, 6], [\n                                6, 7], [\n                                    6, 8], [\n                                        6, 9]]\n    Value = [1, 2, -1, 3, 4, 5, 8, 6, 12, 7]\n    maxAtLevel(N, N - 1, Value, Edges)\n",
        "output": "1 3 8 12 ",
        "fn_call": "maxAtLevel"
    },
    {
        "text": "find the number of ordered pairs such that a * p + b * q = n , where p and q are primes | python3 program to find the number of ordered pairs such that a * p + b * q = n where p and q are primes ; sieve of erastothenes to store the prime numbers and their frequency in form a * p + b * q ; performing sieve of eratosthenes to find the prime numbers unto 10001 ; loop to find the number of ordered pairs for every combination of the prime numbers ; ",
        "context": "\nfrom math import sqrt\nsize = 1000\nprime = [0 for i in range(size)]\nfreq = [0 for i in range(size)]\n\n",
        "code": "def sieve(a, b):\n    prime[1] = 1\n    for i in range(2, int(sqrt(size)) + 1, 1):\n        if (prime[i] == 0):\n            for j in range(i * 2, size, i):\n                prime[j] = 1\n    for p in range(1, size, 1):\n        for q in range(1, size, 1):\n            if (prime[p] == 0 and prime[q] == 0 and a * p + b * q < size):\n                freq[a * p + b * q] += 1\n",
        "test": "\nif __name__ == '__main__':\n    queries = 2\n    a = 1\n    b = 2\n    sieve(a, b)\n    arr = [15, 25]\n    for i in range(queries):\n        print(freq[arr[i]], end=\" \")\n",
        "output": "2 3 ",
        "fn_call": "sieve"
    },
    {
        "text": "size of array after repeated deletion of lis | function to construct maximum sum lis ; l [ i ] - the maximum sum increasing subsequence that ends with arr [ i ] ; l [ 0 ] is equal to arr [ 0 ] ; start from index 1 ; for every j less than i ; l [ i ] = maxsum ( l [ j ] ) + arr [ i ] where j  sign makes sure that the lis ending first is chose . ; function to minimize array ; find lis of current array ; if all elements are in decreasing order ; remove lis elements from current array . note that both lis [ ] and arr [ ] are sorted in increasing order . ; if first element of lis [ ] is found ; remove lis element from arr [ ] ; erase first element of lis [ ] ; print remaining element of array ; print - 1 for empty array ; ",
        "context": "\nfrom typing import List\n\n",
        "code": "def findLIS(arr: List[int], n: int) -> List[int]:\n    L = [0] * n\n    for i in range(n):\n        L[i] = []\n    L[0].append(arr[0])\n    for i in range(1, n):\n        for j in range(i):\n            if (arr[i] > arr[j] and (len(L[i]) < len(L[j]))):\n                L[i] = L[j].copy()\n        L[i].append(arr[i])\n    maxSize = 1\n    lis: List[int] = []\n    for x in L:\n        if (len(x) > maxSize):\n            lis = x .copy()\n            maxSize = len(x)\n    return lis\n\n\ndef minimize(input: List[int], n: int) -> None:\n    arr = input .copy()\n    while len(arr):\n        lis = findLIS(arr, len(arr))\n        if (len(lis) < 2):\n            break\n        i = 0\n        while i  0:\n            if (arr[i] == lis[0]):\n                arr .remove(arr[i])\n                i -= 1\n                lis .remove(lis[0])\n            i += 1\n    i = 0\n    while i < len(arr):\n        print(arr[i], end=\" \")\n        i += 1\n    if (i == 0):\n        print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    input = [3, 2, 6, 4, 5, 1]\n    n = len(input)\n    minimize(input, n)\n",
        "output": "1 ",
        "fn_call": "minimize"
    },
    {
        "text": "check whether the number can be made perfect square after adding 1 | python3 implementation of the approach ; function that returns true if x is a perfect square ; find floating po value of square root of x ; if square root is an eger ; function that returns true if n is a sunny number ; if ( n + 1 ) is a perfect square ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def isPerfectSquare(x):\n    sr = mt .sqrt(x)\n    return ((sr - mt .floor(sr)) == 0)\n\n\ndef isSunnyNum(n):\n    if (isPerfectSquare(n + 1)):\n        return True\n    return False\n",
        "test": "\nn = 3\nif (isSunnyNum(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isSunnyNum"
    },
    {
        "text": "pointer | function to find the product of digits of a number n ; function that returns true if n is prime else returns false ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to return the smallest prime number greater than n ; base case ; loop continuously until isprime returns true for a number greater than n ; function to check pointer - prime numbers ; ",
        "context": "",
        "code": "def digProduct(n):\n    product = 1\n    while (n != 0):\n        product = product * (n % 10)\n        n = int(n / 10)\n    return product\n\n\ndef isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef nextPrime(N):\n    if (N <= 1):\n        return 2\n    prime = N\n    found = False\n    while (not found):\n        prime = prime + 1\n        if (isPrime(prime)):\n            found = True\n    return prime\n\n\ndef isPointerPrime(n):\n    if (isPrime(n) and (n + digProduct(n) == nextPrime(n))):\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 23\n    if (isPointerPrime(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPointerPrime"
    },
    {
        "text": "print all the pairs that contains the positive and negative values of an element | utility binary search ; function ; sort the array ; traverse the array ; for every arr [ i ]  0. ; if found , print the pair . ; ",
        "context": "",
        "code": "def binary_search(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        midval = a[mid]\n        if midval < x:\n            lo = mid + 1\n        elif midval > x:\n            hi = mid\n        else:\n            return mid\n    return -1\n\n\ndef printPairs(arr, n):\n    pair_exists = False\n    arr .sort()\n    for i in range(n):\n        if (arr[i] < 0):\n            if (binary_search(arr, -arr[i])):\n                print(arr[i], \", \", -arr[i])\n                pair_exists = True\n        else:\n            break\n    if (pair_exists == False):\n        print(\"No such pair exists\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 8, 9, -4, 1, -1, -8, -9]\n    n = len(arr)\n    printPairs(arr, n)\n",
        "output": "-9 ,  9\n-8 ,  8\n-4 ,  4\n-1 ,  1\n",
        "fn_call": "printPairs"
    },
    {
        "text": "print the maximum subarray sum | function to print the elements of subarray with maximum sum ; initialize currmax and globalmax with first value of nums ; iterate for all the elemensts of the array ; update currmax ; check if currmax is greater than globalmax ; traverse in left direction to find start index of subarray ; decrement the start index ; printing the elements of subarray with max sum ; ",
        "context": "",
        "code": "def SubarrayWithMaxSum(nums):\n    currMax = nums[0]\n    globalMax = nums[0]\n    for i in range(1, len(nums)):\n        currMax = max(nums[i], nums[i] + currMax)\n        if (currMax > globalMax):\n            globalMax = currMax\n            endIndex = i\n    startIndex = endIndex\n    while (startIndex >= 0):\n        globalMax -= nums[startIndex]\n        if (globalMax == 0):\n            break\n        startIndex -= 1\n    for i in range(startIndex, endIndex + 1):\n        print(nums[i], end=\" \")\n",
        "test": "\narr = [-2, -5, 6, -2, -3, 1, 5, -6]\nSubarrayWithMaxSum(arr)\n",
        "output": "6 -2 -3 1 5 ",
        "fn_call": "SubarrayWithMaxSum"
    },
    {
        "text": "palindrome partitioning | dp | ",
        "context": "",
        "code": "def minCut(a):\n    cut = [0 for i in range(len(a))]\n    palindrome = [[False for i in range(len(a))]for j in range(len(a))]\n    for i in range(len(a)):\n        minCut = i\n        for j in range(i + 1):\n            if (a[i] == a[j] and (i - j < 2 or palindrome[j + 1][i - 1])):\n                palindrome[j][i] = True\n                minCut = min(minCut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = minCut\n    return cut[len(a) - 1]\n",
        "test": "\nif __name__ == '__main__':\n    print(minCut(\"aab\"))\n    print(minCut(\"aabababaxx\"))\n",
        "output": "1\n2\n",
        "fn_call": "minCut"
    },
    {
        "text": "maximum number of groups that can receive fresh donuts distributed in batches of size k | recursive function to find the maximum number of groups that will receive fresh donuts ; store the result for the current state ; check if the leftover donuts from the previous batch is 0 ; if true , then one by one give the fresh donuts to each group ; decrement arr [ i ] ; update the maximum number of groups ; increment arr [ i ] ; otherwise , traverse the given array , arr [ ] ; decrement arr [ i ] ; update the maximum number of groups ; increment arr [ i ] ; return the value of q ; function to find the maximum number of groups that will receive fresh donuts ; stores count of remainder by k ; traverse the array arr [ ] ; stores maximum number of groups ; return the answer ; ",
        "context": "",
        "code": "def dfs(arr, left, K):\n    q = 0\n    if (left == 0):\n        for i in range(1, K, 1):\n            if (arr[i] > 0):\n                arr[i] -= 1\n                q = max(q, 1 + dfs(arr, K - i, K))\n                arr[i] += 1\n    else:\n        for i in range(1, K, 1):\n            if (arr[i] > 0):\n                arr[i] -= 1\n                nleft = left - i if i <= left else K + left - i\n                q = max(q, dfs(arr, nleft, K))\n                arr[i] += 1\n    return q\n\n\ndef maxGroups(K, arr, n):\n    V = [0 for i in range(K)]\n    for x in range(n):\n        V[arr[x] % K] += 1\n    ans = V[0] + dfs(V, 0, K)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    n = len(arr)\n    K = 3\n    print(maxGroups(K, arr, n))\n",
        "output": "4\n",
        "fn_call": "maxGroups"
    },
    {
        "text": "additive congruence method for generating pseudo random numbers | function to generate random numbers ; initialize the seed state ; traverse to generate required numbers of random numbers ; follow the linear congruential method ; ",
        "context": "",
        "code": "def additiveCongruentialMethod(Xo, m, c, randomNums, noOfRandomNums):\n    randomNums[0] = Xo\n    for i in range(1, noOfRandomNums):\n        randomNums[i] = (randomNums[i - 1] + c) % m\n",
        "test": "\nif __name__ == '__main__':\n    Xo = 3\n    m = 15\n    c = 2\n    noOfRandomNums = 20\n    randomNums = [0] * (noOfRandomNums)\n    additiveCongruentialMethod(Xo, m, c, randomNums, noOfRandomNums)\n    for i in randomNums:\n        print(i, end=\" \")\n",
        "output": "3 5 7 9 11 13 0 2 4 6 8 10 12 14 1 3 5 7 9 11 ",
        "fn_call": "additiveCongruentialMethod"
    },
    {
        "text": "count of minimum reductions required to get the required sum k | python3 program to find the count of minimum reductions required to get the required sum k ; function to return the count of minimum reductions ; if the sum is already less than k ; sort in non - increasing order of difference ; ",
        "context": "\nfrom typing import Any, List\n\n",
        "code": "def countReductions(v: List[Any], K: int) -> int:\n    sum = 0\n    for i in v:\n        sum += i[0]\n    if (sum <= K):\n        return 0\n    v .sort(key=lambda a: a[0] - a[1])\n    i = 0\n    while (sum > K and i < len(v)):\n        sum -= (v[i][0] - v[i][1])\n        i += 1\n    if (sum <= K):\n        return i\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    K = 25\n    v = [[0, 0]for _ in range(N)]\n    v[0] = [10, 5]\n    v[1] = [20, 9]\n    v[2] = [12, 10]\n    v[3] = [4, 2]\n    print(countReductions(v, K))\n",
        "output": "-1\n",
        "fn_call": "countReductions"
    },
    {
        "text": "hcf of array of fractions ( or rational numbers ) | python 3 program to find hcf of array of ; find hcf of numerator series ; return hcf of numerator ; find lcm of denominator series ; ans contains lcm of arr [ 0 ] [ 1 ] , . . arr [ i ] [ 1 ] ; return lcm of denominator ; core function ; found hcf of numerator ; found lcm of denominator ; return result ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def findHcf(arr, size):\n    ans = arr[0][0]\n    for i in range(1, size, 1):\n        ans = gcd(ans, arr[i][0])\n    return (ans)\n\n\ndef findLcm(arr, size):\n    ans = arr[0][1]\n    for i in range(1, size, 1):\n        ans = int((((arr[i][1] * ans)) / (gcd(arr[i][1], ans))))\n    return (ans)\n\n\ndef hcfOfFraction(arr, size):\n    hcf_of_num = findHcf(arr, size)\n    lcm_of_deno = findLcm(arr, size)\n    result = [0 for i in range(2)]\n    result[0] = hcf_of_num\n    result[1] = lcm_of_deno\n    i = int(result[0] / 2)\n    while (i > 1):\n        if ((result[1] % i == 0) and (result[0] % i == 0)):\n            result[1] = int(result[1] / i)\n            result[0] = (result[0] / i)\n    return (result)\n",
        "test": "\nif __name__ == '__main__':\n    size = 4\n    arr = [0 for i in range(size)]\n    for i in range(size):\n        arr[i] = [0 for i in range(2)]\n    arr[0][0] = 9\n    arr[0][1] = 10\n    arr[1][0] = 12\n    arr[1][1] = 25\n    arr[2][0] = 18\n    arr[2][1] = 35\n    arr[3][0] = 21\n    arr[3][1] = 40\n    result = hcfOfFraction(arr, size)\n    print(result[0], \",\", result[1])\n",
        "output": "3 , 1400\n",
        "fn_call": "hcfOfFraction"
    },
    {
        "text": "minimize cost of converting all array elements to fibonacci numbers | python program for the above approach ; function to find the n - th fibonacci number ; find the value of a , b , and r ; find the n - th fibonacci ; return the result ; function to find the fibonacci number which is nearest to x ; calculate the value of n for x ; return the nearest fibonacci number ; function to find the minimum cost to convert all array elements to fibonacci numbers ; stores the total minimum cost ; traverse the given array arr [ ] ; find the nearest fibonacci number ; add the cost ; return the final cost ; ",
        "context": "\nimport math\n\n",
        "code": "def nthFibo(n):\n    a = (5 ** (1 / 2) + 1) / 2\n    b = (-5 ** (1 / 2) + 1) / 2\n    r = 5 ** (1 / 2)\n    ans = (a ** n - b ** n) / r\n    return int(ans)\n\n\ndef nearFibo(X):\n    a = (5 ** (1 / 2) + 1) / 2\n    n = int(math .log((5 ** (1 / 2)) * X) / math .log(a))\n    nth = nthFibo(n)\n    nplus = nthFibo(n + 1)\n    if abs(X - nth) < abs(X - nplus):\n        return nth\n    else:\n        return nplus\n\n\ndef getCost(arr):\n    cost = 0\n    for i in arr:\n        fibo = nearFibo(i)\n        cost += abs(i - fibo)\n    return cost\n",
        "test": "\narr = [56, 34, 23, 98, 7]\nprint(getCost(arr))\n",
        "output": "13\n",
        "fn_call": "getCost"
    },
    {
        "text": "farthest cell from a given cell in a matrix | function to find the farthest cell distance from the given cell ; from cell ( n , m ) ; from cell ( 1 , 1 ) ; from cell ( n , 1 ) ; from cell ( 1 , m ) ; finding out maximum ; prthe answer ; ",
        "context": "",
        "code": "def farthestCellDistance(N, M, R, C):\n    d1 = N + M - R - C\n    d2 = R + C - 2\n    d3 = N - R + C - 1\n    d4 = M - C + R - 1\n    maxDistance = max(d1, max(d2, max(d3, d4)))\n    print(maxDistance)\n",
        "test": "\nif __name__ == '__main__':\n    N = 15\n    M = 12\n    R = 1\n    C = 6\n    farthestCellDistance(N, M, R, C)\n",
        "output": "20\n",
        "fn_call": "farthestCellDistance"
    },
    {
        "text": "print all distinct coprime sets possible from 1 to n | function to prall co - prime sets ; check if n is less than 4 then simply prall values till n ; for all the values of n > 3 ; check if n is even then every set will contain 2 adjacent elements up - to n ; if n is odd then every set will contain 2 adjacent element except the last set which will have last three elements ; last element for odd case ; ",
        "context": "",
        "code": "def coPrimeSet(n):\n    firstadj = 0\n    secadj = 0\n    if (n < 4):\n        print(\"( \")\n        for i in range(1, n + 1):\n            print(i + \", \")\n        print(\")\")\n    else:\n        if (n % 2 == 0):\n            for i in range(0, n / 2):\n                firstadj = 2 * i + 1\n                secadj = 2 * i + 2\n                print(\"(\", firstadj, \", \", secadj, \")\")\n        else:\n            for i in range(0, int(n / 2) - 1):\n                firstadj = 2 * i + 1\n                secadj = 2 * i + 2\n                print(\"(\", firstadj, \", \", secadj, \")\")\n            print(\"(\", (n - 2), \", \", (n - 1), \", \", n, \")\")\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    coPrimeSet(n)\n",
        "output": "( 1 ,  2 )\n( 3 ,  4 ,  5 )\n",
        "fn_call": "coPrimeSet"
    },
    {
        "text": "program to print numbers from n to 1 in reverse order | recursive function to print from n to 1 ; if n is less than 1 then return void function ; recursive call of the function ; ",
        "context": "",
        "code": "def PrintReverseOrder(N):\n    if (N <= 0):\n        return\n    else:\n        print(N, end=\" \")\n        PrintReverseOrder(N - 1)\n",
        "test": "\nN = 5\nPrintReverseOrder(N)\n",
        "output": "5 4 3 2 1 ",
        "fn_call": "PrintReverseOrder"
    },
    {
        "text": "find maximum of minimum for every window size in a given array | an efficient python3 program to find maximum of all minimums of windows of different sizes ; used to find previous and next smaller ; initialize elements of left [ ] and right [ ] ; fill elements of left [ ] using logic discussed on www . geeksforgeeks . org / next - greater - element https : ; empty the stack as stack is going to be used for right [ ] ; fill elements of right [ ] using same logic ; create and initialize answer array ; fill answer array by comparing minimums of all . lengths computed using left [ ] and right [ ] ; length of the interval ; arr [ i ] is a possible answer for this length ' len ' interval , check if arr [ i ] is more than max for 'len   ; some entries in ans [ ] may not be filled yet . fill them by taking values from right side of ans [ ] ; print the result ; ",
        "context": "",
        "code": "def printMaxOfMin(arr, n):\n    s = []\n    left = [-1] * (n + 1)\n    right = [n] * (n + 1)\n    for i in range(n):\n        while (len(s) != 0 and arr[s[-1]] >= arr[i]):\n            s .pop()\n        if (len(s) != 0):\n            left[i] = s[-1]\n        s .append(i)\n    while (len(s) != 0):\n        s .pop()\n    for i in range(n - 1, -1, -1):\n        while (len(s) != 0 and arr[s[-1]] >= arr[i]):\n            s .pop()\n        if (len(s) != 0):\n            right[i] = s[-1]\n        s .append(i)\n    ans = [0] * (n + 1)\n    for i in range(n + 1):\n        ans[i] = 0\n    for i in range(n):\n        Len = right[i] - left[i] - 1\n        ans[Len] = max(ans[Len], arr[i])\n    for i in range(n - 1, 0, -1):\n        ans[i] = max(ans[i], ans[i + 1])\n    for i in range(1, n + 1):\n        print(ans[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 20, 30, 50, 10, 70, 30]\n    n = len(arr)\n    printMaxOfMin(arr, n)\n",
        "output": "70 30 20 10 10 10 10 ",
        "fn_call": "printMaxOfMin"
    },
    {
        "text": "check if a large number is divisible by 13 or not | returns true if number is divisible by 13 else returns false ; append required 0 s at the beginning . ; same as strcat ( num , \"00\" ) ; in c . ; same as strcat ( num , \"0\" ) ; in c . ; alternatively add / subtract digits in group of three to result . ; store group of three numbers in group variable . ; generate alternate series of plus and minus ; ",
        "context": "",
        "code": "def checkDivisibility(num):\n    length = len(num)\n    if (length == 1 and num[0] == '0'):\n        return True\n    if (length % 3 == 1):\n        num = str(num) + \"00\"\n        length += 2\n    elif (length % 3 == 2):\n        num = str(num) + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    for i in range(length - 1, -1, -1):\n        group = 0\n        group += ord(num[i]) - ord('0')\n        i -= 1\n        group += (ord(num[i]) - ord('0')) * 10\n        i -= 1\n        group += (ord(num[i]) - ord('0')) * 100\n        sum = sum + group * p\n        p *= (-1)\n    sum = abs(sum)\n    return (sum % 13 == 0)\n",
        "test": "\nif __name__ == \"__main__\":\n    number = \"83959092724\"\n    if (checkDivisibility(number)):\n        print(number, \"is divisible by 13.\")\n    else:\n        print(number, \"is not divisible by 13.\")\n",
        "output": "83959092724 is divisible by 13.\n",
        "fn_call": "checkDivisibility"
    },
    {
        "text": "xor of all subarray xors | set 2 | returns xor of all subarray xors ; if even number of terms are there , all numbers will appear even number of times . so result is 0. ; else initialize result by 0 as ( a xor 0 = a ) ; ",
        "context": "",
        "code": "def getTotalXorOfSubarrayXors(arr, N):\n    if (N % 2 == 0):\n        return 0\n    res = 0\n    for i in range(0, N, 2):\n        res ^= arr[i]\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 5, 2, 4, 6]\n    N = len(arr)\n    print(getTotalXorOfSubarrayXors(arr, N))\n",
        "output": "7\n",
        "fn_call": "getTotalXorOfSubarrayXors"
    },
    {
        "text": "find all the patterns of \"1(0 + ) 1\" in a given string | set 1 ( general approach ) | function to count patterns ; variable to store the last character ; we found 0 and last character was '1' , state change ; after the stream of 0 ' s , \u2581 we \u2581 got \u2581 a \u2581 ' 1 ',  counter incremented ; last character stored ; ",
        "context": "",
        "code": "def patternCount(str):\n    last = str[0]\n    i = 1\n    counter = 0\n    while (i < len(str)):\n        if (str[i] == '0' and last == '1'):\n            while (str[i] == '0'):\n                i += 1\n                if (str[i] == '1'):\n                    counter += 1\n        last = str[i]\n        i += 1\n    return counter\n",
        "test": "\nstr = \"1001ab010abc01001\"\nans = patternCount(str)\nprint(ans)\n",
        "output": "2\n",
        "fn_call": "patternCount"
    },
    {
        "text": "count subsets having distinct even numbers | function to count the required subsets ; inserting even numbers in the set ' us ' single copy of each number is retained ; counting distinct even numbers ; total count of required subsets ; ",
        "context": "",
        "code": "def countSubSets(arr, n):\n    us = set()\n    even_count = 0\n    for i in range(n):\n        if arr[i] % 2 == 0:\n            us .add(arr[i])\n    even_count = len(us)\n    return pow(2, even_count) - 1\n",
        "test": "\narr = [4, 2, 1, 9, 2, 6, 5, 3]\nn = len(arr)\nprint(\"Numbers of subset=\", countSubSets(arr, n))\n",
        "output": "Numbers of subset= 7\n",
        "fn_call": "countSubSets"
    },
    {
        "text": "string formed with middle character of every right substring followed by left sequentially | function to decrypt and print the new string ; if the whole string has been traversed ; to calculate middle index of the string ; print the character at middle index ; recursively call for right - substring ; recursive call for left - substring ; ",
        "context": "",
        "code": "def decrypt(Str, Start, End):\n    if (Start > End):\n        return\n    mid = (Start + End) >> 1\n    print(Str[mid], end=\"\")\n    decrypt(Str, mid + 1, End)\n    decrypt(Str, Start, mid - 1)\n",
        "test": "\nN = 4\nStr = \"abcd\"\ndecrypt(Str, 0, N - 1)\nprint()\nN = 6\nStr = \"gyuitp\"\ndecrypt(Str, 0, N - 1)\n",
        "output": "bcda\nutpigy",
        "fn_call": "decrypt"
    },
    {
        "text": "stepping numbers | prints all stepping numbers reachable from num and in range [ n , m ] ; if stepping number is in the range [ n , m ] then display ; if stepping number is 0 or greater than m , then return ; get the last digit of the currently visited stepping number ; there can be 2 cases either digit to be appended is lastdigit + 1 or lastdigit - 1 ; if lastdigit is 0 then only possible digit after 0 can be 1 for a stepping number ; if lastdigit is 9 then only possible digit after 9 can be 8 for a stepping number ; method displays all the stepping numbers in range [ n , m ] ; for every single digit number ' i ' find all the stepping numbers starting with i ; ",
        "context": "",
        "code": "def dfs(n, m, stepNum):\n    if (stepNum = n):\n        print(stepNum, end=\" \")\n    if (stepNum == 0 or stepNum > m):\n        return\n    lastDigit = stepNum % 10\n    stepNumA = stepNum * 10 + (lastDigit - 1)\n    stepNumB = stepNum * 10 + (lastDigit + 1)\n    if (lastDigit == 0):\n        dfs(n, m, stepNumB)\n    elif (lastDigit == 9):\n        dfs(n, m, stepNumA)\n    else:\n        dfs(n, m, stepNumA)\n        dfs(n, m, stepNumB)\n\n\ndef displaySteppingNumbers(n, m):\n    for i in range(10):\n        dfs(n, m, i)\n",
        "test": "\nn, m = 0, 21\ndisplaySteppingNumbers(n, m)\n",
        "output": "0 1 10 12 2 21 3 4 5 6 7 8 9 ",
        "fn_call": "displaySteppingNumbers"
    },
    {
        "text": "check if stack elements are pairwise consecutive | function to check if elements are pairwise consecutive in stack ; transfer elements of s to aux . ; traverse aux and see if elements are pairwise consecutive or not . we also need to make sure that original content is retained . ; fetch current top two elements of aux and check if they are consecutive . ; append the elements to original stack . ; ",
        "context": "",
        "code": "def pairWiseConsecutive(s):\n    aux = []\n    while (len(s) != 0):\n        aux .append(s[-1])\n        s .pop()\n    result = True\n    while (len(aux) > 1):\n        x = aux[-1]\n        aux .pop()\n        y = aux[-1]\n        aux .pop()\n        if (abs(x - y) != 1):\n            result = False\n        s .append(x)\n        s .append(y)\n    if (len(aux) == 1):\n        s .append(aux[-1])\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    s = []\n    s .append(4)\n    s .append(5)\n    s .append(-2)\n    s .append(-3)\n    s .append(11)\n    s .append(10)\n    s .append(5)\n    s .append(6)\n    s .append(20)\n    if (pairWiseConsecutive(s)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    print(\"Stack content (from top)\", \"after function call\")\n    while (len(s) != 0):\n        print(s[-1], end=\" \")\n        s .pop()\n",
        "output": "Yes\nStack content (from top) after function call\n20 6 5 10 11 -3 -2 5 4 ",
        "fn_call": "pairWiseConsecutive"
    },
    {
        "text": "check if a rook can reach the given destination in a single move | function to check if it is possible to reach destination in a single move by a rook ; ",
        "context": "",
        "code": "def check(current_row, current_col, destination_row, destination_col):\n    if (current_row == destination_row):\n        return (\"POSSIBLE\")\n    elif (current_col == destination_col):\n        return (\"POSSIBLE\")\n    else:\n        return (\"NOT POSSIBLE\")\n",
        "test": "\ncurrent_row = 8\ncurrent_col = 8\ndestination_row = 8\ndestination_col = 4\noutput = check(current_row, current_col, destination_row, destination_col)\nprint(output)\n",
        "output": "POSSIBLE\n",
        "fn_call": "check"
    },
    {
        "text": "minimum k such that sum of array elements after division by k does not exceed s | function to return the minimum value of k that satisfies the given condition ; find the maximum element ; lowest answer can be 1 and the highest answer can be ( maximum + 1 ) ; binary search ; get the mid element ; calculate the sum after dividing the array by new k which is mid ; search in the second half ; first half ; ",
        "context": "",
        "code": "def findMinimumK(a, n, s):\n    maximum = a[0]\n    for i in range(n):\n        maximum = max(maximum, a[i])\n    low = 1\n    high = maximum + 1\n    ans = high\n    while (low <= high):\n        mid = (low + high) // 2\n        sum = 0\n        for i in range(n):\n            sum += (a[i] // mid)\n        if (sum > s):\n            low = mid + 1\n        else:\n            ans = min(ans, mid)\n            high = mid - 1\n    return ans\n",
        "test": "\na = [10, 7, 8, 10, 12, 19]\nn = len(a)\ns = 27\nprint(findMinimumK(a, n, s))\n",
        "output": "3\n",
        "fn_call": "findMinimumK"
    },
    {
        "text": "how to validate guid ( globally unique identifier ) using regular expression | python3 program to validate guid ( globally unique identifier ) using regular expression ; function to validate guid ( globally unique identifier ) ; regex to check valid guid ( globally unique identifier ) ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidGUID(str):\n    regex = \"^[{]?[0-9a-fA-F]{8}\" + \\\n        \"-([0-9a-fA-F]{4}-)\" + \"{3}[0-9a-fA-F]{12}[}]?$\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"123e4567-e89b-12d3\" + \"-a456-9AC7CBDCEE52\"\nprint(isValidGUID(str1))\nstr2 = \"{123e4567-e89b-12d3-\" + \"a456-9AC7CBDCEE52}\"\nprint(isValidGUID(str2))\nstr3 = \"123e4567-h89b-12d3-a456\" + \"-9AC7CBDCEE52\"\nprint(isValidGUID(str3))\nstr4 = \"123e4567-h89b-12d3-a456\"\nprint(isValidGUID(str4))\n",
        "output": "True\nTrue\nFalse\nFalse\n",
        "fn_call": "isValidGUID"
    },
    {
        "text": "last digit of sum of numbers in the given range in the fibonacci series | calculate the sum of the first n fibonacci numbers using pisano period ; the first two fibonacci numbers ; base case ; pisano period for % 10 is 60 ; checking the remainder ; the loop will range from 2 to two terms after the remainder ; ",
        "context": "",
        "code": "def fib(n):\n    f0 = 0\n    f1 = 1\n    if (n == 0):\n        return 0\n    if (n == 1):\n        return 1\n    else:\n        rem = n % 60\n        if (rem == 0):\n            return 0\n        for i in range(2, rem + 3):\n            f = (f0 + f1) % 60\n            f0 = f1\n            f1 = f\n        s = f1 - 1\n        return (s)\n",
        "test": "\nif __name__ == '__main__':\n    m = 10087887\n    n = 2983097899\n    final = fib(n) - fib(m - 1)\n    print(final % 10)\n",
        "output": "5\n",
        "fn_call": "fib"
    },
    {
        "text": "check if n is a balanced prime number or not | utility function to check if a number is prime or not ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function that returns true if n is a balanced prime ; if n is not a prime number or n is the first prime then return false ; initialize previous_prime to n - 1 and next_prime to n + 1 ; find next prime number ; find previous prime number ; arithmetic mean ; if n is a weak prime ; ",
        "context": "",
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i += 6\n    return True\n\n\ndef isBalancedPrime(n):\n    if not isPrime(n) or n == 2:\n        return False\n    previous_prime = n - 1\n    next_prime = n + 1\n    while not isPrime(next_prime):\n        next_prime += 1\n    while not isPrime(previous_prime):\n        previous_prime -= 1\n    mean = (previous_prime + next_prime) / 2\n    if n == mean:\n        return True\n    else:\n        return False\n",
        "test": "\nn = 53\nif isBalancedPrime(n):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isBalancedPrime"
    },
    {
        "text": "minimum number of operations required to reduce n to 1 | function that returns the minimum number of operations to be performed to reduce the number to 1 ; base cases ; ",
        "context": "",
        "code": "def count_minimum_operations(n):\n    if (n == 2):\n        return 1\n    elif (n == 1):\n        return 0\n    if (n % 3 == 0):\n        return 1 + count_minimum_operations(n / 3)\n    elif (n % 3 == 1):\n        return 1 + count_minimum_operations(n - 1)\n    else:\n        return 1 + count_minimum_operations(n + 1)\n",
        "test": "\nn = 4\nans = count_minimum_operations(n)\nprint(ans)\n",
        "output": "2\n",
        "fn_call": "count_minimum_operations"
    },
    {
        "text": "longest path between any pair of vertices | visited [ ] array to make nodes visited src is starting node for dfs traversal prev_len is sum of cable length till current node max_len is pointer which stores the maximum length of cable value after dfs traversal ; mark the src node visited ; curr_len is for length of cable from src city to its adjacent city ; adjacent is pair type which stores destination city and cable length ; traverse all adjacent ; adjacent element ; if node or city is not visited ; total length of cable from src city to its adjacent ; call dfs for adjacent city ; if total cable length till now greater than previous length then update it ; make curr_len = 0 for next adjacent ; n is number of cities or nodes in graph cable_lines is total cable_lines among the cities or edges in graph ; maximum length of cable among the connected cities ; call dfs for each city to find maximum length of cable ; initialize visited array with 0 ; call dfs for src vertex i ; ",
        "context": "",
        "code": "def DFS(graph, src, prev_len, max_len, visited):\n    visited[src] = 1\n    curr_len = 0\n    adjacent = None\n    for i in range(len(graph[src])):\n        adjacent = graph[src][i]\n        if (not visited[adjacent[0]]):\n            curr_len = prev_len + adjacent[1]\n            DFS(graph, adjacent[0], curr_len, max_len, visited)\n        if (max_len[0] < curr_len):\n            max_len[0] = curr_len\n        curr_len = 0\n\n\ndef longestCable(graph, n):\n    max_len = [-999999999999]\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        DFS(graph, i, 0, max_len, visited)\n    return max_len[0]\n",
        "test": "\nif __name__ == '__main__':\n    n = 6\n    graph = [[]for i in range(n + 1)]\n    graph[1].append([2, 3])\n    graph[2].append([1, 3])\n    graph[2].append([3, 4])\n    graph[3].append([2, 4])\n    graph[2].append([6, 2])\n    graph[6].append([2, 2])\n    graph[4].append([6, 6])\n    graph[6].append([4, 6])\n    graph[5].append([6, 5])\n    graph[6].append([5, 5])\n    print(\"Maximum length of cable =\", longestCable(graph, n))\n",
        "output": "Maximum length of cable = 12\n",
        "fn_call": "longestCable"
    },
    {
        "text": "find the length of the largest subset such that all elements are pairwise coprime | dynamic programming table ; function to obtain the mask for any integer ; list of prime numbers till 50 ; iterate through all prime numbers to obtain the mask ; set this prime 's bit on in the mask ; return the mask value ; function to count the number of ways ; check if subproblem has been solved ; excluding current element in the subset ; check if there are no common prime factors then only this element can be included ; calculate the new mask if this element is included ; store and return the answer ; function to find the count of subarray with all digits unique ; ",
        "context": "\ndp = [[-1] * ((1 << 10) + 5)] * 5000\n\n",
        "code": "def getmask(val):\n    mask = 0\n    prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    for i in range(1, 15):\n        if val % prime[i] == 0:\n            mask = mask | (1 << i)\n    return mask\n\n\ndef calculate(pos, mask, a, n):\n    if ((pos == n) or (mask == (1 << n - 1))):\n        return 0\n    if dp[pos][mask] != -1:\n        return dp[pos][mask]\n    size = 0\n    size = max(size, calculate(pos + 1, mask, a, n))\n    if (getmask(a[pos]) & mask) == 0:\n        new_mask = (mask | (getmask(a[pos])))\n        size = max(size, 1 + calculate(pos + 1, new_mask, a, n))\n    dp[pos][mask] = size\n    return dp[pos][mask]\n\n\ndef largestSubset(A, n):\n    return calculate(0, 0, A, n)\n",
        "test": "\nA = [2, 3, 13, 5, 14, 6, 7, 11]\nN = len(A)\nprint(largestSubset(A, N))\n",
        "output": "6\n",
        "fn_call": "largestSubset"
    },
    {
        "text": "pierpont prime | python3 program to print pierpont prime numbers smaller than n . ; finding all numbers having factor power of 2 and 3 using sieve ; storing number of the form 2 ^ i . 3 ^ k + 1. ; finding prime number using sieve of eratosthenes . reusing same array as result of above computations in v . ; printing n pierpont primes smaller than n ; ",
        "context": "",
        "code": "def printPierpont(n):\n    arr = [False] * (n + 1)\n    two = 1\n    three = 1\n    while (two + 1 < n):\n        arr[two] = True\n        while (two * three + 1 < n):\n            arr[three] = True\n            arr[two * three] = True\n            three *= 3\n        three = 1\n        two *= 2\n    v = []\n    for i in range(n):\n        if (arr[i]):\n            v .append(i + 1)\n    arr1 = [False] * (len(arr))\n    p = 2\n    while (p * p < n):\n        if (arr1[p] == False):\n            for i in range(p * 2, n, p):\n                arr1[i] = True\n        p += 1\n    for i in range(len(v)):\n        if (not arr1[v[i]]):\n            print(v[i], end=\" \")\n",
        "test": "\nn = 200\nprintPierpont(n)\n",
        "output": "2 3 5 7 13 17 19 37 73 97 109 163 193 ",
        "fn_call": "printPierpont"
    },
    {
        "text": "count distinct subsequences | returns count of distinct subsequences of str . ; iterate from 0 to length of s ; iterate from 0 to length of s ; check if i equal to 0 ; replace levelcount withe allcount + 1 ; if map is less than 0 ; return answer ; ",
        "context": "",
        "code": "def countSub(s):\n    Map = {}\n    for i in range(len(s)):\n        Map[s[i]] = -1\n    allCount = 0\n    levelCount = 0\n    for i in range(len(s)):\n        c = s[i]\n        if (i == 0):\n            allCount = 1\n            Map = 1\n            levelCount = 1\n            continue\n        levelCount = allCount + 1\n        if (Map < 0):\n            allCount = allCount + levelCount\n        else:\n            allCount = allCount + levelCount - Map\n        Map = levelCount\n    return allCount\n",
        "test": "\nList = [\"abab\", \"gfg\"]\nfor s in List:\n    cnt = countSub(s)\n    withEmptyString = cnt + 1\n    print(\"With empty string count for\", s, \"is\", withEmptyString)\n    print(\"Without empty string count for\", s, \"is\", cnt)\n",
        "output": "With empty string count for abab is 5\nWithout empty string count for abab is 4\nWith empty string count for gfg is 4\nWithout empty string count for gfg is 3\n",
        "fn_call": "countSub"
    },
    {
        "text": "find the number of strings formed using distinct characters of a given string | function to return the factorial of n ; function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; to store the distinct characters of the string str ; ",
        "context": "",
        "code": "def fact(n):\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact\n\n\ndef countStrings(string, n):\n    distinct_char = set()\n    for i in range(n):\n        distinct_char .add(string[i])\n    return fact(len(distinct_char))\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    n = len(string)\n    print(countStrings(string, n))\n",
        "output": "5040\n",
        "fn_call": "countStrings"
    },
    {
        "text": "count of integers in given range having their last k digits are equal | function to return the count of integers from 1 to x having the last k digits as equal ; stores the total count of integers ; loop to iterate over all possible values of z ; terminate the loop when z > x ; add count of integers with last k digits equal to z ; return count ; function to return the count of integers from l to r having the last k digits as equal ; ",
        "context": "",
        "code": "def intCount(X, K):\n    ans = 0\n    for z in range(0, int(pow(10, K)), int((pow(10, K) - 1) / 9)):\n        if (z > X):\n            break\n        ans += int((X - z) / int(pow(10, K)) + 1)\n    return ans\n\n\ndef intCountInRange(L, R, K):\n    return (intCount(R, K) - intCount(L - 1, K))\n",
        "test": "\nL = 49\nR = 101\nK = 2\nprint(intCountInRange(L, R, K))\n",
        "output": "6\n",
        "fn_call": "intCountInRange"
    },
    {
        "text": "maximum subsequence sum with adjacent elements having atleast k difference in index | function to find the maximum sum subsequence such that two adjacent element have atleast difference of k in their indices ; dp array to store the maximum sum obtained till now ; either select the first element or nothing ; either select the ( i - 1 ) element or let the previous best answer be the current best answer ; either select the best sum till previous_index or select the current element + best_sum till index - k ; ",
        "context": "",
        "code": "def max_sum(arr, n, k):\n    dp = [0] * n\n    dp[0] = max(0, arr[0])\n    i = 1\n    while (i < k):\n        dp[i] = max(dp[i - 1], arr[i])\n        i += 1\n    i = k\n    while (i < n):\n        dp[i] = max(dp[i - 1], arr[i] + dp[i - k])\n        i += 1\n    return dp[n - 1]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, -2, 4, 3, 1]\n    n = len(arr)\n    k = 4\n    print(max_sum(arr, n, k))\n",
        "output": "4\n",
        "fn_call": "max_sum"
    },
    {
        "text": "form smallest number using indices of numbers chosen from array with sum less than s | function to find the minimum number which have maximum length ; find maximum length of number ; find minimum number which have maximum length ; ",
        "context": "",
        "code": "def max_number(arr, sum):\n    frac = [0] * 9\n    maxi = -10 ** 9\n    pos = 0\n    for i in range(9):\n        frac[i] = sum // arr[i]\n        if (frac[i] > maxi):\n            pos = i\n            maxi = frac[i]\n    an = str((pos + 1)) * maxi\n    sum -= maxi * arr[pos]\n    ans = [i for i in an]\n    for i in range(maxi):\n        for j in range(1, 10):\n            if (sum + arr[pos] - arr[j - 1] >= 0):\n                ans[i] = str(j)\n                sum += arr[pos] - arr[j - 1]\n                break\n    if (maxi == 0):\n        return 0\n    else:\n        return \"\".join(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 4, 2, 4, 6, 5, 4, 2, 3]\n    s = 13\n    print(max_number(arr, s))\n",
        "output": "133333\n",
        "fn_call": "max_number"
    },
    {
        "text": "count half nodes in a binary tree ( iterative and recursive ) | a node structure ; iterative method to count half nodes of binary tree ; base case ; create an empty queue for level order traversal ; initialize count for half nodes ; enqueue left child ; enqueue right child ; ",
        "context": "\nclass Node:\n    def __init__(self, key):\n        self .data = key\n        self .left = None\n        self .right = None\n\n",
        "code": "def gethalfCount(root):\n    if root is None:\n        return 0\n    queue = []\n    queue .append(root)\n    count = 0\n    while (len(queue) > 0):\n        node = queue .pop(0)\n        if node .left is not None and node .right is None or node .left is None and node .right is not None:\n            count = count + 1\n        if node .left is not None:\n            queue .append(node .left)\n        if node .right is not None:\n            queue .append(node .right)\n    return count\n",
        "test": "\nroot = Node(2)\nroot .left = Node(7)\nroot .right = Node(5)\nroot .left .right = Node(6)\nroot .left .right .left = Node(1)\nroot .left .right .right = Node(11)\nroot .right .right = Node(9)\nroot .right .right .left = Node(4)\nprint(\"%d\" % (gethalfCount(root)))\n",
        "output": "3\n",
        "fn_call": "gethalfCount"
    },
    {
        "text": "minimum number of bits required to be flipped such that bitwise or of a and b is equal to c | function to count the number of bit flips required on a and b such that bitwise or of a and b is c ; stores the count of flipped bit ; iterate over the range [ 0 , 32 ] ; check if i - th bit of a is set ; check if i - th bit of b is set or not ; check if i - th bit of c is set or not ; if i - th bit of c is unset ; check if i - th bit of a is set or not ; check if i - th bit of b is set or not ; check if i - th bit of c is set or not ; check if i - th bit of both a and b is set ; return the count of bits flipped ; ",
        "context": "",
        "code": "def minimumFlips(A, B, C):\n    res = 0\n    for i in range(32):\n        x, y, z = 0, 0, 0\n        if (A & (1 << i)):\n            x = 1\n        if (B & (1 << i)):\n            y = 1\n        if (C & (1 << i)):\n            z = 1\n        if (z == 0):\n            if (x):\n                res += 1\n            if (y):\n                res += 1\n        if (z == 1):\n            if (x == 0 and y == 0):\n                res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    A, B, C = 2, 6, 5\n    print(minimumFlips(A, B, C))\n",
        "output": "3\n",
        "fn_call": "minimumFlips"
    },
    {
        "text": "count array elements whose product of digits is a composite number | python3 program for the above approach ; function to generate prime numbers using sieve of eratosthenes ; set 0 and 1 as non - prime ; if p is a prime ; set all multiples of p as non - prime ; function to calculate the product of digits of the given number ; stores the product of digits ; extract digits and add to the sum ; return the product of its digits ; function to print number of distinct values with digit product as composite ; initialize set ; initialize boolean array ; pre - compute primes ; traverse array ; of the current array element ; if product of digits is less than or equal to 1 ; if product of digits is not a prime ; print the answer ; ",
        "context": "\nfrom math import sqrt\nN = 100005\n\n",
        "code": "def SieveOfEratosthenes(prime, p_size):\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, int(sqrt(p_size)), 1):\n        if (prime[p]):\n            for i in range(p * 2, p_size + 1, p):\n                prime[i] = False\n\n\ndef digitProduct(number):\n    res = 1\n    while (number > 0):\n        res *= (number % 10)\n        number //= 10\n    return res\n\n\ndef DistinctCompositeDigitProduct(arr, n):\n    output = set()\n    prime = [True for i in range(N + 1)]\n    SieveOfEratosthenes(prime, N)\n    for i in range(n):\n        ans = digitProduct(arr[i])\n        if (ans <= 1):\n            continue\n        if (prime[ans] == False):\n            output .add(ans)\n    print(len(output))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [13, 55, 7, 13, 11, 71, 233, 233, 144, 89]\n    n = len(arr)\n    DistinctCompositeDigitProduct(arr, n)\n",
        "output": "4\n",
        "fn_call": "DistinctCompositeDigitProduct"
    },
    {
        "text": "check if a number can be represented as sum of two positive perfect cubes | function to check if n can be represented as sum of two perfect cubes or not ; stores the perfect cubes of first n natural numbers ; traverse the map ; stores first number ; stores second number ; search the pair for the first number to obtain sum n from the map ; if n cannot be represented as sum of two positive perfect cubes ; ",
        "context": "",
        "code": "def sumOfTwoPerfectCubes(N):\n    cubes = {}\n    i = 1\n    while i * i * i <= N:\n        cubes[i * i * i] = i\n        i += 1\n    for itr in cubes:\n        firstNumber = itr\n        secondNumber = N - itr\n        if secondNumber in cubes:\n            print(\"True\", end=\"\")\n            return\n    print(\"False\", end=\"\")\n",
        "test": "\nN = 28\nsumOfTwoPerfectCubes(N)\n",
        "output": "True",
        "fn_call": "sumOfTwoPerfectCubes"
    },
    {
        "text": "highly totient number | function to find euler totient number ; consider all prime factors of n and subtract their multiples from result ; check if p is a prime factor . ; if yes , then update n and result ; if n has a prime factor greater than sqrt ( n ) ( there can be at - most one such prime factor ) ; function to find first n highly totient numbers ; count of highly totient numbers and value of count of phi of previous numbers ; store all the values of phi ( x ) upto 10 ^ 5 with frequencies ; if count is greater than count of previous element ; display the number ; store the value of phi ; ",
        "context": "",
        "code": "def phi(n):\n    result = n\n    p = 2\n    while (p * p <= n):\n        if (n % p == 0):\n            while (n % p == 0):\n                n //= p\n            result -= (result // p)\n        p += 1\n    if (n > 1):\n        result -= (result // n)\n    return result\n\n\ndef Highly_Totient(n):\n    count = 0\n    p_count = -1\n    mp = dict()\n    i = 1\n    while i < 100000:\n        tmp = phi(i)\n        if tmp not in mp:\n            mp[tmp] = 0\n        mp[tmp] += 1\n        i += 1\n    i = 1\n    while (count < n):\n        if ((i in mp) and mp[i] > p_count):\n            print(i, end='')\n            if (count < n - 1):\n                print(\", \", end='')\n            p_count = mp[i]\n            count += 1\n        i += 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 20\n    Highly_Totient(n)\n",
        "output": "1, 2, 4, 8, 12, 24, 48, 72, 144, 240, 432, 480, 576, 720, 1152, 1440, 2880, 4320, 5760, 8640",
        "fn_call": "Highly_Totient"
    },
    {
        "text": "find the rotation count in rotated sorted array | returns count of rotations for an array which is first sorted in ascending order , then rotated ; this condition is needed to handle the case when array is not rotated at all ; if there is only one element left ; find mid ; check if element ( mid + 1 ) is minimum element . consider the cases like { 3 , 4 , 5 , 1 , 2 } ; check if mid itself is minimum element ; decide whether we need to go to left half or right half ; ",
        "context": "",
        "code": "def countRotations(arr, low, high):\n    if (high < low):\n        return 0\n    if (high == low):\n        return low\n    mid = low + (high - low) / 2\n    mid = int(mid)\n    if (mid < high and arr[mid + 1] < arr[mid]):\n        return (mid + 1)\n    if (mid > low and arr[mid] < arr[mid - 1]):\n        return mid\n    if (arr[high] > arr[mid]):\n        return countRotations(arr, low, mid - 1)\n    return countRotations(arr, mid + 1, high)\n",
        "test": "\narr = [15, 18, 2, 3, 6, 12]\nn = len(arr)\nprint(countRotations(arr, 0, n - 1))\n",
        "output": "2\n",
        "fn_call": "countRotations"
    },
    {
        "text": "count subarrays for every array element in which they are the minimum | set 2 | function to count subarrays for each element where it is the minimum ; for the length of strictly larger numbers on the left of a [ i ] ; storing x in result [ i ] ; for the length of strictly larger numbers on the right of a [ i ] ; store x * y in result array ; print the result ; ",
        "context": "",
        "code": "def minSubarray(arr, N):\n    result = [0] * N\n    l = []\n    r = []\n    for i in range(N):\n        count = 1\n        while (len(l) != 0 and l[-1][0] > arr[i]):\n            count += l[-1][1]\n            l .pop()\n        l .append([arr[i], count])\n        result[i] = count\n    for i in range(N - 1, -1, -1):\n        count = 1\n        while (len(r) != 0 and r[-1][0] >= arr[i]):\n            count += r[-1][1]\n            r .pop()\n        r .append([arr[i], count])\n        result[i] *= count\n    for i in range(N):\n        print(result[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 2, 1, 4]\n    N = len(arr)\n    minSubarray(arr, N)\n",
        "output": "1 2 6 1 ",
        "fn_call": "minSubarray"
    },
    {
        "text": "minimum changes required to make each path in a matrix palindrome | function for counting changes ; maximum distance possible is ( n - 1 + m - 1 ) ; stores the maximum element ; update the maximum ; stores frequencies of values for respective distances ; initialize frequencies of cells as 0 ; count frequencies of cell values in the matrix ; increment frequency of value at distance i + j ; store the most frequent value at i - th distance from ( 0 , 0 ) and ( n - 1 , m - 1 ) ; calculate max frequency and total cells at distance i ; count changes required to convert all cells at i - th distance to most frequent value ; ",
        "context": "",
        "code": "def countChanges(matrix, n, m):\n    dist = n + m - 1\n    Max_element = 0\n    for i in range(n):\n        for j in range(m):\n            Max_element = max(Max_element, matrix[i][j])\n    freq = [[0 for i in range(Max_element + 1)]for j in range(dist)]\n    for i in range(dist):\n        for j in range(Max_element + 1):\n            freq[i][j] = 0\n    for i in range(n):\n        for j in range(m):\n            freq[i + j][matrix[i][j]] += 1\n    min_changes_sum = 0\n    for i in range(dist // 2):\n        maximum = 0\n        total_values = 0\n        for j in range(Max_element + 1):\n            maximum = max(maximum, freq[i][j] + freq[n + m - 2 - i][j])\n            total_values += (freq[i][j] + freq[n + m - 2 - i][j])\n        min_changes_sum += total_values - maximum\n    return min_changes_sum\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[7, 0, 3, 1, 8, 1, 3], [0, 4, 0, 1, 0, 4, 0], [3, 1, 8, 3, 1, 0, 7]]\n    minChanges = countChanges(mat, 3, 7)\n    print(minChanges)\n",
        "output": "6\n",
        "fn_call": "countChanges"
    },
    {
        "text": "minimize cost to convert given two integers to zero using ",
        "context": "",
        "code": "def makeZero(x, y, a, b):\n    if (x > y):\n        x, y = y, x\n    tot_cost = (y - x) * a\n    cost1 = 2 * x * a\n    cost2 = x * b\n    tot_cost += min(cost1, cost2)\n    print(tot_cost)\n",
        "test": "\nif __name__ == \"__main__\":\n    X, Y = 1, 3\n    cost1, cost2 = 391, 555\n    makeZero(X, Y, cost1, cost2)\n",
        "output": "1337\n",
        "fn_call": "makeZero"
    },
    {
        "text": "find four elements that sum to a given value | set 1 ( n ^ 3 solution ) | a naive solution to print all combination of 4 elements in a [ ] with sum equal to x ; fix the first element and find other three ; fix the second element and find other two ; fix the third element and find the fourth ; find the fourth ; ",
        "context": "",
        "code": "def findFourElements(A, n, X):\n    for i in range(0, n - 3):\n        for j in range(i + 1, n - 2):\n            for k in range(j + 1, n - 1):\n                for l in range(k + 1, n):\n                    if A[i] + A[j] + A[k] + A[l] == X:\n                        print(\"%d, %d, %d, %d\" % (A[i], A[j], A[k], A[l]))\n",
        "test": "\nA = [10, 2, 3, 4, 5, 9, 7, 8]\nn = len(A)\nX = 23\nfindFourElements(A, n, X)\n",
        "output": "10, 2, 3, 8\n10, 2, 4, 7\n2, 4, 9, 8\n2, 5, 9, 7\n3, 4, 9, 7\n3, 5, 7, 8\n",
        "fn_call": "findFourElements"
    },
    {
        "text": "replace two substrings ( of a string ) with each other | function to return the resultant string ; iterate through all positions i ; current sub - string of length = len ( a ) = len ( b ) ; if current sub - string gets equal to a or b ; update s after replacing a ; update s after replacing b ; return the updated string ; ",
        "context": "",
        "code": "def updateString(S, A, B):\n    l = len(A)\n    i = 0\n    while i + l <= len(S):\n        curr = S[i:i + l]\n        if curr == A:\n            new_string = S[0:i] + B + S[i + l:len(S)]\n            S = new_string\n            i += l - 1\n        else:\n            new_string = S[0:i] + A + S[i + l:len(S)]\n            S = new_string\n            i += l - 1\n        i += 1\n    return S\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"aab\"\n    A = \"aa\"\n    B = \"bb\"\n    print(updateString(S, A, B))\n",
        "output": "bbb\n",
        "fn_call": "updateString"
    },
    {
        "text": "rearrange an array to maximize sum of bitwise and of same | function to implement recursive dp ; if i is equal to n ; if dp [ i ] [ mask ] is not equal to - 1 ; iterate over the array b [ ] ; if current element is not yet selected ; update dp [ i ] [ mask ] ; return dp [ i ] [ mask ] ; function to obtain maximum sum of bitwise and of same - indexed elements from the arrays a [ ] and b [ ] ; stores all dp - states ; returns the maximum value returned by the function maximizeand ( ) ; ",
        "context": "",
        "code": "def maximizeAnd(i, mask, A, B, N, dp):\n    if (i == N):\n        return 0\n    if (dp[i][mask] != -1):\n        return dp[i][mask]\n    for j in range(N):\n        if ((mask & (1 << j)) == 0):\n            dp[i][mask] = max(\n                dp[i][mask],\n                (A[i] & B[j]) +\n                maximizeAnd(\n                    i +\n                    1,\n                    mask | (\n                        1 << j),\n                    A,\n                    B,\n                    N,\n                    dp))\n    return dp[i][mask]\n\n\ndef maximizeAndUtil(A, B, N):\n    temp = [-1 for i in range(1 << N + 1)]\n    dp = [temp for i in range(N)]\n    return maximizeAnd(0, 0, A, B, N, dp)\n",
        "test": "\nif __name__ == '__main__':\n    A = [3, 5, 7, 11]\n    B = [2, 6, 10, 12]\n    N = len(A)\n    print(maximizeAndUtil(A, B, N))\n",
        "output": "22\n",
        "fn_call": "maximizeAndUtil"
    },
    {
        "text": "construct array with sum of product of same indexed elements in the given array equal to zero | function to generate a new array with product of same indexed elements with arr [ ] equal to 0 ; stores sum of same indexed array elements of arr and new array ; traverse the array ; if i is an even number ; insert arr [ i + 1 ] into the new array newarr [ ] ; insert - arr [ i - 1 ] into the new array newarr [ ] ; print new array elements ; ",
        "context": "",
        "code": "def constructNewArraySumZero(arr, N):\n    newArr = [0] * N\n    for i in range(N):\n        if (i % 2 == 0):\n            newArr[i] = arr[i + 1]\n        else:\n            newArr[i] = -arr[i - 1]\n    for i in range(N):\n        print(newArr[i], end=\" \")\n",
        "test": "\narr = [1, 2, 3, -5, -6, 8]\nN = len(arr)\nconstructNewArraySumZero(arr, N)\n",
        "output": "2 -1 -5 -3 8 6 ",
        "fn_call": "constructNewArraySumZero"
    },
    {
        "text": "convert 0 to n by adding 1 or multiplying by 2 in minimum steps | function to count number of set bits in n ; stores the count of set bits ; if n is odd , then it a set bit ; return the result ; ",
        "context": "",
        "code": "def minimumAdditionOperation(N):\n    count = 0\n    while (N):\n        if (N & 1 == 1):\n            count += 1\n        N = N >> 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    print(minimumAdditionOperation(N))\n",
        "output": "2\n",
        "fn_call": "minimumAdditionOperation"
    },
    {
        "text": "rearrange the array to maximize the elements which is smaller than both its adjacent elements | function to rearrange array such that count of element that are smaller than their adjacent elements is maximum ; stores the rearranged array ; stores the maximum count of elements ; sort the ",
        "context": "",
        "code": "def maximumIndices(arr, N):\n    temp = [0] * N\n    maxIndices = (N - 1) // 2\n    arr .sort()\n    for i in range(maxIndices):\n        temp[2 * i + 1] = arr[i]\n    j = 0\n    i = maxIndices\n    while (i < N):\n        if (temp[j] == 0):\n            temp[j] = arr[i]\n            i += 1\n        j += 1\n    for i in range(N):\n        print(temp[i], end=\" \")\n",
        "test": "\narr = [1, 2, 3, 4]\nN = len(arr)\nmaximumIndices(arr, N)\n",
        "output": "2 1 3 4 ",
        "fn_call": "maximumIndices"
    },
    {
        "text": "find the string present at the middle of a lexicographically increasing sequence of strings from s to t | function to print the string at the middle of lexicographically increasing sequence of strings from s to t ; stores the base 26 digits after addition ; iterete from right to left and add carry to next position ; reduce the number to find the middle string by dividing each position by 2 ; if current value is odd , carry 26 to the next index value ; ",
        "context": "",
        "code": "def printMiddleString(S, T, N):\n    a1 = [0] * (N + 1)\n    for i in range(N):\n        a1[i + 1] = ord(S[i]) - ord(\"a\") + ord(T[i]) - ord(\"a\")\n    for i in range(N, 1, -1):\n        a1[i - 1] += a1[i] // 26\n        a1[i] %= 26\n    for i in range(N + 1):\n        if (a1[i] & 1):\n            if (i + 1 <= N):\n                a1[i + 1] += 26\n        a1[i] = a1[i] // 2\n    for i in range(1, N + 1):\n        print(chr(a1[i] + ord(\"a\")), end=\"\")\n    return 0\n",
        "test": "\nN = 5\nS = \"afogk\"\nT = \"asdji\"\nprintMiddleString(S, T, N)\n",
        "output": "alvuw",
        "fn_call": "printMiddleString"
    },
    {
        "text": "count numbers from a given range that can be visited moving any number of steps from the range [ l , r ] | function to count points from the range [ x , y ] that can be reached by moving by l or r steps ; initialize difference array ; initialize count ; marking starting point ; iterating from x to y ; accumulate difference array ; if diff_arr [ i ] is greater than 1 ; updating difference array ; visited point found ; ",
        "context": "",
        "code": "def countReachablePoints(X, Y, L, R):\n    diff_arr = [0 for i in range(100000)]\n    count = 0\n    diff_arr[X] = 1\n    diff_arr[X + 1] = -1\n    for i in range(X, Y + 1, 1):\n        diff_arr[i] += diff_arr[i - 1]\n        if (diff_arr[i] >= 1):\n            diff_arr[i + L] += 1\n            diff_arr[i + R + 1] -= 1\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    X = 3\n    Y = 12\n    L = 2\n    R = 3\n    print(countReachablePoints(X, Y, L, R))\n",
        "output": "9\n",
        "fn_call": "countReachablePoints"
    },
    {
        "text": "closest perfect square and its distance | function to check if a number is perfect square or not ; function to find the closest perfect square taking minimum steps to reach from a number ; variables to store first perfect square number above and below n ; finding first perfect square number greater than n ; finding first perfect square number less than n ; variables to store the differences ; ",
        "context": "\nfrom math import sqrt, floor\n\n",
        "code": "def isPerfect(N):\n    if (sqrt(N) - floor(sqrt(N)) != 0):\n        return False\n    return True\n\n\ndef getClosestPerfectSquare(N):\n    if (isPerfect(N)):\n        print(N, \"0\")\n        return\n    aboveN = -1\n    belowN = -1\n    n1 = 0\n    n1 = N + 1\n    while (True):\n        if (isPerfect(n1)):\n            aboveN = n1\n            break\n        else:\n            n1 += 1\n    n1 = N - 1\n    while (True):\n        if (isPerfect(n1)):\n            belowN = n1\n            break\n        else:\n            n1 -= 1\n    diff1 = aboveN - N\n    diff2 = N - belowN\n    if (diff1 > diff2):\n        print(belowN, diff2)\n    else:\n        print(aboveN, diff1)\n",
        "test": "\nN = 1500\ngetClosestPerfectSquare(N)\n",
        "output": "1521 21\n",
        "fn_call": "getClosestPerfectSquare"
    },
    {
        "text": "painting fence algorithm | returns count of ways to color k posts using k colors ; there are k ways to color first post ; there are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; fill for 2 posts onwards ; current same is same as previous diff ; we always have k - 1 choices for next post ; total choices till i . ; ",
        "context": "",
        "code": "def countWays(n, k):\n    total = k\n    mod = 1000000007\n    same, diff = 0, k\n    for i in range(2, n + 1):\n        same = diff\n        diff = total * (k - 1)\n        diff = diff % mod\n        total = (same + diff) % mod\n    return total\n",
        "test": "\nif __name__ == \"__main__\":\n    n, k = 3, 2\n    print(countWays(n, k))\n",
        "output": "6\n",
        "fn_call": "countWays"
    },
    {
        "text": "program to find last two digits of 2 ^ n | iterative function to calculate ( x ^ y ) % p in o ( log y ) ; x = x % p update x if it is more than or equal to p ; if y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; function to calculate number of digits in x ; function to print last 2 digits of 2 ^ n ; generating 10 ^ 2 ; calling modular exponentiation ; printing leftmost zeros . since ( 2 ^ n ) % 2 can have digits less then 2. in that case we need to print zeros ; if temp is not zero then print temp if temp is zero then already printed ; ",
        "context": "",
        "code": "def power(x, y, p):\n\n    res = 1\n\n    x = x % p\n\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\n\n\ndef numberOfDigits(x):\n\n    i = 0\n    while (x):\n        x //= 10\n        i += 1\n\n    return i\n\n\ndef LastTwoDigit(n):\n\n    print(\"Last \" + str(2) +\n          \" digits of \" + str(2), end=\"\")\n    print(\"^\" + str(n) + \" = \", end=\"\")\n    temp = 1\n    for i in range(1, 3):\n        temp *= 10\n    temp = power(2, n, temp)\n    for i in range(2 - numberOfDigits(temp)):\n        print(0, end=\"\")\n    if temp:\n        print(temp)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 72\n    LastTwoDigit(n)\n",
        "output": "Last 2 digits of 2^72 = 96\n",
        "fn_call": "LastTwoDigit"
    },
    {
        "text": "maximum cost path in an undirected graph such that no edge is visited twice in a row | python3 program for the above approach ; to store the resulting sum of the cost ; to store largest cost leaf vertex ; dfs traversal to find the update the maximum cost of from any node to leaf ; mark vertex as visited ; store vertex initial cost ; initially assuming edge not to be traversed ; back edge found so , edge can be part of traversal ; new vertex is found ; bitwise and the current check with the returned check by the previous dfs call ; adds parent and its children cost ; updates total cost of parent including child nodes ; edge is part of the cycle ; add cost of vertex to the answer ; updates the largest cost leaf vertex ; function to find the maximum cost from source vertex such that no two edges is traversed twice ; dfs call ; print the maximum cost ; ",
        "context": "\nN = 100000\ncanTake = 0\nbest = 0\ndp = [0 for i in range(N)]\nvis = [0 for i in range(N)]\n\n",
        "code": "def dfs(g, cost, u, pre):\n    global canTake, best\n    vis[u] = True\n    dp[u] = cost[u]\n    check = 1\n    cur = cost[u]\n    for x in g[u]:\n        if (vis[x] and x != pre):\n            check = 0\n        elif (not vis[x]):\n            check &= dfs(g, cost, x, u)\n            cur = max(cur, cost[u] + dp[x])\n    dp[u] = cur\n    if (not check):\n        canTake += cost[u]\n    else:\n        best = max(best, dp[u])\n    return check\n\n\ndef FindMaxCost(g, cost, source):\n    dfs(g, cost, source, -1)\n    print(canTake + best)\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    m = 5\n    cost = [2, 2, 8, 6, 9]\n    g = [[]for i in range(n)]\n    g[0].append(1)\n    g[1].append(0)\n    g[0].append(2)\n    g[2].append(0)\n    g[0].append(3)\n    g[3].append(0)\n    g[1].append(2)\n    g[2].append(1)\n    g[1].append(4)\n    g[4].append(1)\n    source = 1\n    FindMaxCost(g, cost, source)\n",
        "output": "21\n",
        "fn_call": "FindMaxCost"
    },
    {
        "text": "minimize count of array elements to be removed to maximize difference between any pair up to k | python3 program to implement the above approach ; function to count the number of elements to be removed from the array based on the given condition ; sort the array ; initialize the variable ; iterate for all possible pairs ; check the difference between the numbers ; update the minimum removals ; return the answer ; ",
        "context": "\nimport sys\n\n",
        "code": "def min_remove(arr, n, k):\n    arr .sort()\n    ans = sys .maxsize\n    for i in range(n):\n        for j in range(i, n):\n            if (arr[j] - arr[i] <= k):\n                ans = min(ans, n - j + i - 1)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    k = 3\n    arr = [1, 2, 3, 4, 5]\n    n = len(arr)\n    print(min_remove(arr, n, k))\n",
        "output": "1\n",
        "fn_call": "min_remove"
    },
    {
        "text": "maximum length of strictly increasing sub | function to return the maximum length of strictly increasing subarray after removing atmost one element ; create two arrays pre and pos ; find out the contribution of the current element in array [ 0 , i ] and update pre [ i ] ; find out the contribution of the current element in array [ n - 1 , i ] and update pos [ i ] ; calculate the maximum length of the stricly increasing subarray without removing any element ; calculate the maximum length of the strictly increasing subarray after removing the current element ; ",
        "context": "",
        "code": "def maxIncSubarr(a, n):\n    pre = [0] * n\n    pos = [0] * n\n    pre[0] = 1\n    pos[n - 1] = 1\n    l = 0\n    for i in range(1, n):\n        if (a[i] > a[i - 1]):\n            pre[i] = pre[i - 1] + 1\n        else:\n            pre[i] = 1\n    l = 1\n    for i in range(n - 2, -1, -1):\n        if (a[i] < a[i + 1]):\n            pos[i] = pos[i + 1] + 1\n        else:\n            pos[i] = 1\n    ans = 0\n    l = 1\n    for i in range(1, n):\n        if (a[i] > a[i - 1]):\n            l += 1\n        else:\n            l = 1\n        ans = max(ans, l)\n    for i in range(1, n - 1):\n        if (a[i - 1] < a[i + 1]):\n            ans = max(pre[i - 1] + pos[i + 1], ans)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2]\n    n = len(arr)\n    print(maxIncSubarr(arr, n))\n",
        "output": "2\n",
        "fn_call": "maxIncSubarr"
    },
    {
        "text": "count all distinct pairs with difference equal to k | a simple program to count pairs with difference k ; pick all elements one by one ; see if there is a pair of this picked element ; ",
        "context": "",
        "code": "def countPairsWithDiffK(arr, n, k):\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\n                count += 1\n    return count\n",
        "test": "\narr = [1, 5, 3, 4, 2]\nn = len(arr)\nk = 3\nprint(\"Count of pairs with given diff is \", countPairsWithDiffK(arr, n, k))\n",
        "output": "Count of pairs with given diff is  2\n",
        "fn_call": "countPairsWithDiffK"
    },
    {
        "text": "positive elements at even and negative at odd positions ( relative order not maintained ) | python 3 program to rearrange positive and negative numbers ; move forward the positive pointer till negative number number not encountered ; move forward the negative pointer till positive number number not encountered ; swap array elements to fix their position . ; break from the while loop when any index exceeds the size of the array ; ",
        "context": "",
        "code": "def rearrange(a, size):\n    positive = 0\n    negative = 1\n    while (True):\n        while (positive = 0):\n            positive = positive + 2\n        while (negative < size and a[negative] <= 0):\n            negative = negative + 2\n        if (positive < size and negative < size):\n            temp = a[positive]\n            a[positive] = a[negative]\n            a[negative] = temp\n        else:\n            break\n",
        "test": "\narr = [1, -3, 5, 6, -3, 6, 7, -4, 9, 10]\nn = len(arr)\nrearrange(arr, n)\nfor i in range(0, n):\n    print(arr[i], end=\" \")\n",
        "output": "1 -3 5 -3 6 6 7 -4 9 10 ",
        "fn_call": "rearrange"
    },
    {
        "text": "minimize the maximum element in constructed array with sum divisible by k | function to find smallest maximum number in an array whose sum is divisible by k . ; minimum possible sum possible for an array of size n such that its sum is divisible by k ; if sum is not divisible by n ; if sum is divisible by n ; ",
        "context": "",
        "code": "def smallestMaximum(N, K):\n    sum = ((N + K - 1) // K) * K\n    if (sum % N != 0):\n        return (sum // N) + 1\n    else:\n        return sum // N\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    K = 3\n    print(smallestMaximum(N, K))\n",
        "output": "2\n",
        "fn_call": "smallestMaximum"
    },
    {
        "text": "third largest element in an array of distinct elements | python 3 program to find third largest element in an array of distinct elements ; there should be atleast three elements ; find first largest element ; find second largest element ; find third largest element ; ",
        "context": "\nimport sys\n\n",
        "code": "def thirdLargest(arr, arr_size):\n    if (arr_size < 3):\n        print(\" Invalid Input \")\n        return\n    first = arr[0]\n    for i in range(1, arr_size):\n        if (arr[i] > first):\n            first = arr[i]\n    second = -sys .maxsize\n    for i in range(0, arr_size):\n        if (arr[i] > second and arr[i] < first):\n            second = arr[i]\n    third = -sys .maxsize\n    for i in range(0, arr_size):\n        if (arr[i] > third and arr[i] < second):\n            third = arr[i]\n    print(\"The Third Largest\", \"element is\", third)\n",
        "test": "\narr = [12, 13, 1, 10, 34, 16]\nn = len(arr)\nthirdLargest(arr, n)\n",
        "output": "The Third Largest element is 13\n",
        "fn_call": "thirdLargest"
    },
    {
        "text": "check if a large number is divisible by 9 or not | function to find that number divisible by 9 or not ; compute sum of digits ; check if sum of digits is divisible by 9. ; ",
        "context": "",
        "code": "def check(st):\n    n = len(st)\n    digitSum = 0\n    for i in range(0, n):\n        digitSum = digitSum + (int)(st[i])\n    return (digitSum % 9 == 0)\n",
        "test": "\nst = \"99333\"\nif (check(st)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "sum of minimum value of x and y satisfying the equation ax + by = c | python3 program for the above approach ; x and y store solution of equation ax + by = g ; euclidean algorithm ; store_gcd returns the gcd of a and b ; function to find any possible solution ; condition if solution does not exists ; adjusting the sign of x0 and y0 ; function to shift solution ; shifting to obtain another solution ; function to find minimum value of x and y ; g is the gcd of a and b ; store sign of a and b ; if x is less than 0 , then shift solution ; if y is less than 0 , then shift solution ; find intersection such that both x and y are positive ; miny is value of y corresponding to minx ; returns minimum value of x + y ; ",
        "context": "\nx, y, x1, y1 = 0, 0, 0, 0\nx0, y0, g = 0, 0, 0\n\n",
        "code": "def gcd(a, b):\n    global x, y, x1, y1\n    if (b == 0):\n        x = 1\n        y = 0\n        return a\n    store_gcd = gcd(b, a % b)\n    x = y1\n    y = x1 - y1 * (a // b)\n    return store_gcd\n\n\ndef possible_solution(a, b, c):\n    global x0, y0, g\n    g = gcd(abs(a), abs(b))\n    if (c % g != 0):\n        return 0\n    x0 *= c // g\n    y0 *= c // g\n    if (a < 0):\n        x0 *= -1\n    if (b < 0):\n        y0 *= -1\n    return 1\n\n\ndef shift_solution(a, b, shift_var):\n    global x, y\n    x += shift_var * b\n    y -= shift_var * a\n\n\ndef find_min_sum(a, b, c):\n    global x, y, g\n    x, y, g = 0, 0, 0\n    if (possible_solution(a, b, c) == 0):\n        return -1\n    if (g != 0):\n        a //= g\n        b //= g\n    if a > 0:\n        sign_a = 1\n    else:\n        sign_a = -1\n    if b > 0:\n        sign_b = 1\n    else:\n        sign_b = -1\n    shift_solution(a, b, -x // b)\n    if (x < 0):\n        shift_solution(a, b, sign_b)\n    minx1 = x\n    shift_solution(a, b, y // a)\n    if (y < 0):\n        shift_solution(a, b, -sign_a)\n    minx2 = x\n    if (minx2 > x):\n        temp = minx2\n        minx2 = x\n        x = temp\n    minx = max(minx1, minx2)\n    if (minx > x):\n        return -1\n    miny = (c - a * x) // b\n    return (miny + minx)\n",
        "test": "\na, b, c = 2, 2, 0\nprint(find_min_sum(a, b, c))\n",
        "output": "0\n",
        "fn_call": "find_min_sum"
    },
    {
        "text": "find the kth pair in ordered list of all possible sorted pairs of the array | function to find the k - th pair ; sorting the array ; iterating through the array ; finding the number of same elements ; checking if n * t is less than the remaining k . if it is , then arr [ i ] is the first element in the required pair ; printing the k - th pair ; ",
        "context": "",
        "code": "def kthpair(n, k, arr):\n    arr .sort()\n    k -= 1\n    i = 0\n    while (i < n):\n        t = 1\n        while (arr[i] == arr[i + t]):\n            t += 1\n        if (t * n > k):\n            break\n        k = k - t * n\n        i += t\n    print(arr[i], \" \", arr[k // t])\n",
        "test": "\nif __name__ == \"__main__\":\n    n, k = 3, 2\n    arr = [3, 1, 5]\n    kthpair(n, k, arr)\n",
        "output": "1   3\n",
        "fn_call": "kthpair"
    },
    {
        "text": "count of k | to store the frequency array ; function to check palindromic of of any substring using frequency array ; initialise the odd count ; traversing frequency array to compute the count of characters having odd frequency ; returns true if odd count is atmost 1 ; function to count the total number substring whose any permutations are palindromic ; computing the frequency of first k character of the string ; to store the count of palindromic permutations ; checking for the current window if it has any palindromic permutation ; start and end poof window ; decrementing count of first element of the window ; incrementing count of next element of the window ; checking current window character frequency count ; return the final count ; ",
        "context": "\nfreq = [0] * 26\n\n",
        "code": "def checkPalindrome():\n    oddCnt = 0\n    for x in freq:\n        if (x % 2 == 1):\n            oddCnt += 1\n    return oddCnt <= 1\n\n\ndef countPalindromePermutation(s, k):\n    for i in range(k):\n        freq[ord(s[i]) - 97] += 1\n    ans = 0\n    if (checkPalindrome()):\n        ans += 1\n    i = 0\n    j = k\n    while (j < len(s)):\n        freq[ord(s[i]) - 97] -= 1\n        i += 1\n        freq[ord(s[j]) - 97] += 1\n        j += 1\n        if (checkPalindrome()):\n            ans += 1\n    return ans\n",
        "test": "\nstr = \"abbaca\"\nK = 3\nprint(countPalindromePermutation(str, K))\n",
        "output": "3\n",
        "fn_call": "countPalindromePermutation"
    },
    {
        "text": "build a dfa to accept binary strings that starts or ends with \"01\" | function for transition state a ; state transition to b if the character is 0 ; state transition to d if the character is 1 ; function for transition state b ; check if the string has ended ; state transition to c if the character is 1 ; state transition to d if the character is 0 ; function for transition state c ; function for transition state d ; state transition to d if the character is 1 ; state transition to e if the character is 0 ; function for transition state e ; state transition to e if the character is 0 ; state transition to f if the character is 1 ; function for transition state f ; state transition to d if the character is 1 ; state transition to e if the character is 0 ; ",
        "context": "",
        "code": "def stateB(n):\n    if (len(n) == 0):\n        print(\"string not accepted\")\n    else:\n        if (n[0] == '1'):\n            stateC(n[1:])\n        else:\n            stateD(n[1:])\n\n\ndef stateC(n):\n    print(\"String accepted\")\n\n\ndef stateD(n):\n    if (len(n) == 0):\n        print(\"string not accepted\")\n    else:\n        if (n[0] == '1'):\n            stateD(n[1:])\n        else:\n            stateE(n[1:])\n\n\ndef stateE(n):\n    if (len(n) == 0):\n        print(\"string not accepted\")\n    else:\n        if (n[0] == '0'):\n            stateE(n[1:])\n        else:\n            stateF(n[1:])\n\n\ndef stateF(n):\n    if (len(n) == 0):\n        print(\"string accepred\")\n    else:\n        if (n[0] == '1'):\n            stateD(n[1:])\n        else:\n            stateE(n[1:])\n\ndef checkstateA(n):\n    if (n[0] == '0'):\n        stateB(n[1:])\n    else:\n        stateD(n[1:])\n",
        "test": "\nif __name__ == \"__main__\":\n    n = \"0100101\"\n    checkstateA(n)\n",
        "output": "String accepted\n",
        "fn_call": "checkstateA"
    },
    {
        "text": "program to find the profit or loss when cp of n items is equal to sp of m items | function to calculate profit or loss ; ",
        "context": "",
        "code": "def profitLoss(N, M):\n    if (N == M):\n        print(\"No Profit nor Loss\")\n    else:\n        result = 0.0\n        result = float(abs(N - M)) / M\n        if (N - M < 0):\n            print(\"Loss = -\", '{0:.6}'.format(result * 100), \"%\")\n        else:\n            print(\"Profit = \", '{0:.6}'.format(result * 100), \"%\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 8\n    M = 9\n    profitLoss(N, M)\n",
        "output": "Loss = - 11.1111 %\n",
        "fn_call": "profitLoss"
    },
    {
        "text": "dual pivot quicksort | python3 program to implement dual pivot quicksort ; lp means left pivot and rp means right pivot ; p is the left pivot , and q is the right pivot . ; if elements are less than the left pivot ; if elements are greater than or equal to the right pivot ; bring pivots to their appropriate positions . ; returning the indices of the pivots ; ",
        "context": "",
        "code": "def partition(arr, low, high):\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    j = k = low + 1\n    g, p, q = high - 1, arr[low], arr[high]\n    while k <= g:\n        if arr[k] < p:\n            arr[k], arr[j] = arr[j], arr[k]\n            j += 1\n        elif arr[k] >= q:\n            while arr[g] > q and k < g:\n                g -= 1\n            arr[k], arr[g] = arr[g], arr[k]\n            g -= 1\n            if arr[k] < p:\n                arr[k], arr[j] = arr[j], arr[k]\n                j += 1\n        k += 1\n    j -= 1\n    g += 1\n    arr[low], arr[j] = arr[j], arr[low]\n    arr[high], arr[g] = arr[g], arr[high]\n    return j, g\n\n\ndef dualPivotQuickSort(arr, low, high):\n    if low < high:\n        lp, rp = partition(arr, low, high)\n        dualPivotQuickSort(arr, low, lp - 1)\n        dualPivotQuickSort(arr, lp + 1, rp - 1)\n        dualPivotQuickSort(arr, rp + 1, high)\n",
        "test": "\narr = [24, 8, 42, 75, 29, 77, 38, 57]\ndualPivotQuickSort(arr, 0, 7)\nprint('Sorted array: ', end='')\nfor i in arr:\n    print(i, end=' ')\nprint()\n",
        "output": "Sorted array: 8 24 29 38 42 57 75 77 \n",
        "fn_call": "dualPivotQuickSort"
    },
    {
        "text": "count of vessels completely filled after a ",
        "context": "",
        "code": "def FindNoOfFullVessels(n, t):\n    Matrix = [[0 for i in range(n)]for j in range(n)]\n    Matrix[0][0] = t * 1.0\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1):\n            exceededwater = Matrix[i][j] - 1.0\n            if (exceededwater < 0):\n                continue\n            ans += 1\n            if (i + 1 < n):\n                Matrix[i + 1][j] += exceededwater / 2\n            if (i + 1 < n and j + 1 < n):\n                Matrix[i + 1][j + 1] += exceededwater / 2\n    return ans\n",
        "test": "\nN = 3\nT = 4\nprint(FindNoOfFullVessels(N, T))\n",
        "output": "3\n",
        "fn_call": "FindNoOfFullVessels"
    },
    {
        "text": "number of strings of length n with no palindromic sub string | return the count of strings with no palindromic substring . ; ",
        "context": "",
        "code": "def numofstring(n, m):\n    if n == 1:\n        return m\n    if n == 2:\n        return m * (m - 1)\n    return m * (m - 1) * pow(m - 2, n - 2)\n",
        "test": "\nn = 2\nm = 3\nprint(numofstring(n, m))\n",
        "output": "6\n",
        "fn_call": "numofstring"
    },
    {
        "text": "find the closest fraction to given fraction having minimum absolute difference | function to find the absolute value of x ; function to find the fraction with minimum absolute difference ; initialize the answer variables ; iterate over the range ; nearest fraction ; x / y - d / i  ( i * x - y * d ) * ( b * y ) ; check for d + 1 ; print the answer ; ",
        "context": "",
        "code": "def ABS(x):\n    return max(x, -x)\n\n\ndef findFraction(x, y, n):\n    A = -1\n    B = -1\n    for i in range(1, n + 1):\n        d = (i * x) // y\n        if (d >= 0 and (A == -1 or ABS(B * x - y * A) *\n                        ABS(i * y) > ABS(i * x - y * d) * ABS(B * y))):\n            A = d\n            B = i\n        d += 1\n        if (d >= 0 and (A == -1 or ABS(B * x - y * A) *\n                        ABS(i * y) > ABS(i * x - y * d) * ABS(B * y))):\n            A = d\n            B = i\n    print(str(A) + \"/\" + str(B))\n",
        "test": "\nif __name__ == '__main__':\n    x = 3\n    y = 7\n    n = 6\n    findFraction(x, y, n)\n",
        "output": "2/5\n",
        "fn_call": "findFraction"
    },
    {
        "text": "find pairs in array whose sums already exist in array | function to find pair whose sum exists in arr [ ] ; ",
        "context": "",
        "code": "def findPair(arr, n):\n    found = False\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            for k in range(0, n):\n                if (arr[i] + arr[j] == arr[k]):\n                    print(arr[i], arr[j])\n                    found = True\n    if (found == False):\n        print(\"Not exist\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 4, 8, 13, 5]\n    n = len(arr)\n    findPair(arr, n)\n",
        "output": "8 5\n",
        "fn_call": "findPair"
    },
    {
        "text": "master theorem for subtract and conquer recurrences | ''python3 code for the above approach ; ''",
        "context": "",
        "code": "def fib(n):\n    if (n <= 1):\n        return n\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "\nn = 9\nprint(fib(n))\n",
        "output": "34\n",
        "fn_call": "fib"
    },
    {
        "text": "centered triangular number | function for centered triangular number ; formula to calculate nth centered triangular number ; ",
        "context": "",
        "code": "def Centered_Triangular_num(n):\n    return (3 * n * n + 3 * n + 2) // 2\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    print(Centered_Triangular_num(n))\n    n = 12\n    print(Centered_Triangular_num(n))\n",
        "output": "19\n235\n",
        "fn_call": "Centered_Triangular_num"
    },
    {
        "text": "check if n is divisible by a number which is composed of the digits from the set { a , b } | function to check whether n is divisible by a number whose digits are either a or b ; base condition ; recursive call ; check for all numbers beginning with ' a ' or 'b ; ",
        "context": "",
        "code": "def isDivisibleRec(x, a, b, n):\n    if (x > n):\n        return False\n\n    if (n % x == 0):\n        return True\n    return (isDivisibleRec(x * 10 + a, a, b, n) or\n            isDivisibleRec(x * 10 + b, a, b, n))\n\n\ndef isDivisible(a, b, n):\n    return (isDivisibleRec(a, a, b, n) or\n            isDivisibleRec(b, a, b, n))\n",
        "test": "\na = 3\nb = 5\nn = 53\n\nif (isDivisible(a, b, n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isDivisible"
    },
    {
        "text": "minimum distance between any special pair in the given array | ''python3 program for the above approach ; ''function that finds the minimum difference between two vectors ; '' find lower bound of the index ; '' find two adjacent indices  to take difference ; '' return the result ; ''function to find the minimum distance between index of special pairs ; '' stores the index of each element  in the array arr[] ; store the indexes ; get the unique values in list ; '' take adjacent difference  of same values ; '' left index array ; '' right index array ; '' find the minimum gap between  the two adjacent different  values ; ''",
        "context": "\nimport sys\n\n",
        "code": "def mindist(left, right):\n    res = sys .maxsize\n    for i in range(len(left)):\n        num = left[i]\n        index = right .index(min([i for i in right if num >= i]))\n        if (index == 0):\n            res = min(res, abs(num - right[index]))\n        elif (index == len(right)):\n            res = min(res,\n                      min(abs(num - right[index - 1]),\n                          abs(num - right[index])))\n    return res\n\n\ndef specialPairs(nums):\n    m = {}\n    vals = []\n    for i in range(len(nums)):\n        m[nums[i]] = i\n    for p in m:\n        vals .append(p)\n    res = sys .maxsize\n    for i in range(1, len(vals)):\n        vec = [m[vals[i]]]\n        for i in range(1, len(vec)):\n            res = min(res, abs(vec[i] - vec[i - 1]))\n        if (i):\n            a = vals[i]\n            left = [m[a]]\n            b = vals[i - 1]\n            right = [m[b]]\n            res = min(res, mindist(left, right)) + 1\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [0, -10, 5, -5, 1]\n    print(specialPairs(arr))\n",
        "output": "2\n",
        "fn_call": "specialPairs"
    },
    {
        "text": "maximum number of customers that can be satisfied with given quantity | python3 program to find maximum number of customers that can be satisfied ; print maximum number of satisfied customers and their indexes ; creating an vector of pair of total demand and customer number ; sorting the customers according to their total demand ; taking the first k customers that can be satisfied by total amount d ; ",
        "context": "\nv = []\n\n",
        "code": "def solve(n, d, a, b, arr):\n    first, second = 0, 1\n    for i in range(n):\n        m = arr[i][0]\n        t = arr[i][1]\n        v .append([a * m + b * t, i + 1])\n    v .sort()\n    ans = []\n    for i in range(n):\n        if v[i][first] <= d:\n            ans .append(v[i][second])\n            d -= v[i][first]\n    print(len(ans))\n    for i in range(len(ans)):\n        print(ans[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    d = 5\n    a = 1\n    b = 1\n    arr = [[2, 0], [3, 2], [4, 4], [10, 0], [0, 1]]\n    solve(n, d, a, b, arr)\n",
        "output": "2\n5 1 ",
        "fn_call": "solve"
    },
    {
        "text": "min number of operations to reduce n to 0 by subtracting any digits from n | function to reduce an integer n to zero in minimum operations by removing digits from n ; initialise dp [ ] to steps ; iterate for all elements ; for each digit in number i ; either select the number or do not select it ; dp [ n ] will give minimum step for n ; ",
        "context": "",
        "code": "def reduceZero(N):\n    dp = [1e9 for i in range(N + 1)]\n    dp[0] = 0\n    for i in range(N + 1):\n        for c in str(i):\n            dp[i] = min(dp[i], dp[i - (ord(c) - 48)] + 1)\n    return dp[N]\n",
        "test": "\nN = 25\nprint(reduceZero(N))\n",
        "output": "5\n",
        "fn_call": "reduceZero"
    },
    {
        "text": "all pairs whose xor gives unique prime | function that returns true if n is prime ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to return the count of valid pairs ; if xor ( a [ i ] , a [ j ] ) is prime and unique ; ",
        "context": "",
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef countPairs(a, n):\n    count = 0\n    m = dict()\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if isPrime(a[i] ^ a[j]) and m .get(a[i] ^ a[j], 0) == 0:\n                m[(a[i] ^ a[j])] = 1\n                count += 1\n    return count\n",
        "test": "\na = [10, 12, 23, 45, 5, 6]\nn = len(a)\nprint(countPairs(a, n))\n",
        "output": "4\n",
        "fn_call": "countPairs"
    },
    {
        "text": "add n digits to a such that it is divisible by b after each addition | python3 implementation of the approach ; try all digits from ( 0 to 9 ) ; fails in the first move itself ; add ( n - 1 ) 0 's ; ",
        "context": "",
        "code": "def addNDigits(a, b, n):\n    num = a\n    for i in range(10):\n        tmp = a * 10 + i\n        if (tmp % b == 0):\n            a = tmp\n            break\n    if (num == a):\n        return -1\n    for j in range(n - 1):\n        a *= 10\n    return a\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 5\n    b = 3\n    n = 3\n    print(addNDigits(a, b, n))\n",
        "output": "5100\n",
        "fn_call": "addNDigits"
    },
    {
        "text": "counting numbers whose difference from reverse is a product of k | python 3 program to count the numbers within a given range in which when you subtract a number from its reverse , the difference is a product of k ; function to check if the number and its reverse have their absolute difference divisible by k ; reverse the number ; ",
        "context": "",
        "code": "def isRevDiffDivisible(x, k):\n    n = x\n    m = 0\n    while (x > 0):\n        m = m * 10 + x % 10\n        x = x // 10\n    return (abs(n - m) % k == 0)\n\n\ndef countNumbers(l, r, k):\n    count = 0\n    for i in range(l, r + 1):\n        if (isRevDiffDivisible(i, k)):\n            count = count + 1\n    return count\n",
        "test": "\nl = 20\nr = 23\nk = 6\nprint(countNumbers(l, r, k))\n",
        "output": "2\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "count unset bits in a range | function to get no of set bits in the binary representation of 'n ; function to count unset bits in the given range ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; returns number of unset bits in the range ' l ' to ' r ' in 'n ; ",
        "context": "",
        "code": "def countSetBits(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count\n\n\ndef countUnsetBitsInGivenRange(n, l, r):\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n    return (r - l + 1) - countSetBits(n & num)\n",
        "test": "\nn = 80\nl = 1\nr = 4\nprint(countUnsetBitsInGivenRange(n, l, r))\n",
        "output": "4\n",
        "fn_call": "countUnsetBitsInGivenRange"
    },
    {
        "text": "check if a ",
        "context": "\nimport math\n\n",
        "code": "def checkcircle(r, R, r1, x1, y1):\n    dis = int(math .sqrt(x1 * x1 + y1 * y1))\n    return (dis - r1 >= R and dis + r1 <= r)\n",
        "test": "\nr = 8\nR = 4\nr1 = 2\nx1 = 6\ny1 = 0\nif (checkcircle(r, R, r1, x1, y1)):\n    print(\"yes\")\nelse:\n    print(\"no\")\n",
        "output": "yes\n",
        "fn_call": "checkcircle"
    },
    {
        "text": "print string after removing all ( \u201c 10 \u201d or \u201c 01 \u201d ) from the binary string | function to print the final string after removing all the occurrences of \"10\" and \"01\" from the given binary string ; variables to store the count of 1 ' s \u2581 and \u2581 0' s ; length of the string ; for loop to count the occurrences of 1 ' s \u2581 and \u2581 0' s in the string ; to check if the count of 1 ' s \u2581 is \u2581 \u2581 greater \u2581 than \u2581 the \u2581 count \u2581 of \u2581 0' s or not . if x is greater , then those many 1 's  are printed. ; length of the final remaining string after removing all the occurrences ; printing the final string ; ",
        "context": "",
        "code": "def finalString(st):\n    x, y = 0, 0\n    n = len(st)\n    for i in range(n):\n        if (st[i] == '1'):\n            x += 1\n        else:\n            y += 1\n    if (x > y):\n        left = 1\n    else:\n        left = 0\n    length = n - 2 * min(x, y)\n    for i in range(length):\n        print(left, end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"010110100100000\"\n    finalString(st)\n",
        "output": "00000",
        "fn_call": "finalString"
    },
    {
        "text": "minimum number of 1 's to be replaced in a binary array | function to find minimum number of 1 ' s \u2581 to \u2581 be \u2581 replaced \u2581 to \u2581 0' s ; return final answer ; ",
        "context": "",
        "code": "def minChanges(A, n):\n    cnt = 0\n    for i in range(n - 2):\n        if ((i - 1 >= 0) and A[i - 1] == 1 and A[i + 1] == 1 and A[i] == 0):\n            A[i + 1] = 0\n            cnt = cnt + 1\n    return cnt\n",
        "test": "\nA = [1, 1, 0, 1, 1, 0, 1, 0, 1, 0]\nn = len(A)\nprint(minChanges(A, n))\n",
        "output": "2\n",
        "fn_call": "minChanges"
    },
    {
        "text": "count pairs of characters in a string whose ascii value difference is k | python3 implementation of the approach ; function to return the count of required pairs of characters ; length of the string ; to store the frequency of each character ; update the frequency of each character ; to store the required count of pairs ; if ascii value difference is zero ; if there exists similar characters more than once ; if there exits characters with ascii value difference as k ; return the required count ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def countPairs(string, k):\n    n = len(string)\n    freq = [0] * MAX\n    for i in range(n):\n        freq[ord(string[i]) - ord('a')] += 1\n    cnt = 0\n    if (k == 0):\n        for i in range(MAX):\n            if (freq[i] > 1):\n                cnt += ((freq[i] * (freq[i] - 1)) // 2)\n    else:\n        for i in range(MAX):\n            if (freq[i] > 0 and i + k  0):\n                cnt += (freq[i] * freq[i + k])\n    return cnt\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"abcdab\"\n    k = 0\n    print(countPairs(string, k))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "program to implement simpson 's 3/8 rule | given function to be integrated ; function to perform calculations ; calculates value till integral limit ; ",
        "context": "",
        "code": "def func(x):\n    return (float(1) / (1 + x * x))\n\n\ndef calculate(lower_limit, upper_limit, interval_limit):\n    interval_size = (float(upper_limit - lower_limit) / interval_limit)\n    sum = func(lower_limit) + func(upper_limit)\n    for i in range(1, interval_limit):\n        if (i % 3 == 0):\n            sum = sum + 2 * func(lower_limit + i * interval_size)\n        else:\n            sum = sum + 3 * func(lower_limit + i * interval_size)\n    return ((float(3 * interval_size) / 8) * sum)\n",
        "test": "\ninterval_limit = 10\nlower_limit = 1\nupper_limit = 10\nintegral_res = calculate(lower_limit, upper_limit, interval_limit)\nprint(round(integral_res, 6))\n",
        "output": "0.687927\n",
        "fn_call": "calculate"
    },
    {
        "text": "build original array from the given sub | python3 implementation of the approach ; function to add edge to graph ; function to calculate indegrees of all the vertices ; if there is an edge from i to x then increment indegree of x ; function to perform topological sort ; push every node to the queue which has no incoming edge ; since edge u is removed , update the indegrees of all the nodes which had an incoming edge from u ; function to generate the array from the given sub - sequences ; create the graph from the input sub - sequences ; add edge between every two consecutive elements of the given sub - sequences ; get the indegrees for all the vertices ; get the topological order of the created graph ; size of the required array ; ",
        "context": "\nfrom collections import deque\nadj = [[]for i in range(100)]\n\n",
        "code": "def addEdge(u, v):\n    adj[u].append(v)\n\n\ndef getindeg(V, indeg):\n    for i in range(V):\n        for x in adj[i]:\n            indeg[x] += 1\n\n\ndef topo(V, indeg):\n    q = deque()\n    for i in range(V):\n        if (indeg[i] == 0):\n            q .appendleft(i)\n    res = []\n    while (len(q) > 0):\n        u = q .popleft()\n        res .append(u)\n        for x in adj[u]:\n            indeg[x] -= 1\n            if (indeg[x] == 0):\n                q .appendleft(x)\n    return res\n\n\ndef makearray(v, V):\n    for i in range(len(v)):\n        for j in range(len(v[i]) - 1):\n            addEdge(v[i][j], v[i][j + 1])\n    indeg = [0 for i in range(V)]\n    getindeg(V, indeg)\n    res = topo(V, indeg)\n    return res\n",
        "test": "\nn = 10\nsubseqs = [[9, 1, 2, 8, 3], [6, 1, 2], [9, 6, 3, 4], [5, 2, 7], [0, 9, 5, 4]]\nres = makearray(subseqs, n)\nfor x in res:\n    print(x, end=\" \")\n",
        "output": "0 9 5 6 1 2 7 8 3 4 ",
        "fn_call": "makearray"
    },
    {
        "text": "count elements in first array with absolute difference greater than k with an element in second array | function to count the such elements ; store count of required elements in arr1 ; initialise the smallest and the largest value from the second array arr2 [ ] ; find the smallest and the largest element in arr2 ; check if absolute difference of smallest and arr1 [ i ] or largest and arr1 [ i ] is > k then arr [ i ] is a required element ; print final result ; ",
        "context": "",
        "code": "def countDist(arr1, n, arr2, m, k):\n    count = 0\n    smallest = arr2[0]\n    largest = arr2[0]\n    for i in range(m):\n        smallest = max(smallest, arr2[i])\n        largest = min(largest, arr1[i])\n    for i in range(n):\n        if (abs(arr1[i] - smallest) > k or abs(arr1[i] - largest) > k):\n            count += 1\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    arr1 = [3, 1, 4]\n    n = len(arr1)\n    arr2 = [5, 1, 2]\n    m = len(arr2)\n    k = 2\n    countDist(arr1, n, arr2, m, k)\n",
        "output": "2\n",
        "fn_call": "countDist"
    },
    {
        "text": "longest common subsequence with at most k changes allowed | python3 program to find lcs of two arrays with k changes allowed in the first array . ; return lcs with at most k changes allowed . ; if at most changes is less than 0. ; if any of two array is over . ; making a reference variable to dp [ n ] [ m ] [ k ] ; if value is already calculated , return that value . ; calculating lcs with no changes made . ; calculating lcs when array element are same . ; calculating lcs with changes made . ; ",
        "context": "\nMAX = 10\n\n",
        "code": "def lcs(dp, arr1, n, arr2, m, k):\n    if k < 0:\n        return -(10 ** 7)\n    if n < 0 or m < 0:\n        return 0\n    ans = dp[n][m][k]\n    if ans != -1:\n        return ans\n    ans = max(lcs(dp, arr1, n - 1, arr2, m, k),\n              lcs(dp, arr1, n, arr2, m - 1, k))\n    if arr1[n - 1] == arr2[m - 1]:\n        ans = max(ans, 1 + lcs(dp, arr1, n - 1, arr2, m - 1, k))\n    ans = max(ans, lcs(dp, arr1, n - 1, arr2, m - 1, k - 1))\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    k = 1\n    arr1 = [1, 2, 3, 4, 5]\n    arr2 = [5, 3, 1, 4, 2]\n    n = len(arr1)\n    m = len(arr2)\n    dp = [[[-1 for i in range(MAX)]for j in range(MAX)]for k in range(MAX)]\n    print(lcs(dp, arr1, n, arr2, m, k))\n",
        "output": "3\n",
        "fn_call": "lcs"
    },
    {
        "text": "count number of steps to cover a distance if steps can be taken in powers of 2 | function to count the minimum number of steps ; bin ( k ) . count ( \"1\" ) is a python3 function to count the number of set bits in a number ; ",
        "context": "",
        "code": "def getMinSteps(K):\n    return bin(K).count(\"1\")\n",
        "test": "\nn = 343\nprint(getMinSteps(n))\n",
        "output": "6\n",
        "fn_call": "getMinSteps"
    },
    {
        "text": "minimum cost to empty array where cost of removing an element is 2 ^ ( removed_count ) * arr [ i ] | function to find the minimum cost of removing elements from the array ; sorting in increasing order ; loop to find the minimum cost of removing elements ; ",
        "context": "",
        "code": "def removeElements(arr, n):\n    arr .sort(reverse=True)\n    ans = 0\n    for i in range(n):\n        ans += arr[i] * pow(2, i)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    arr = [3, 1, 2, 3]\n    print(removeElements(arr, n))\n",
        "output": "25\n",
        "fn_call": "removeElements"
    },
    {
        "text": "minimum swaps to group similar characters side by side ? | checks whether a string has similar characters side by side ; if similar chars side by side , continue ; if we have found a char equal to current char and does not exist side to it , return false ; counts min swap operations to convert a string that has similar characters side by side ; base case ; considering swapping of i and l chars ; backtrack ; not considering swapping of i and l chars ; taking min of above two ; ",
        "context": "\nfrom sys import maxsize\n\n",
        "code": "def sameCharAdj(string):\n    n = len(string)\n    st = set()\n    st .add(string[0])\n    for i in range(1, n):\n        if string[i] == string[i - 1]:\n            continue\n        if string[i] in st:\n            return False\n        st .add(string[i])\n    return True\n\n\ndef minSwaps(string, l, r, cnt, minm):\n    if l == r:\n        if sameCharAdj(string):\n            return cnt\n        else:\n            return maxsize\n    for i in range(l + 1, r + 1, 1):\n        string[i], string[l] = string[l], string[i]\n        cnt += 1\n        x = minSwaps(string, l + 1, r, cnt, minm)\n        string[i], string[l] = string[l], string[i]\n        cnt -= 1\n        y = minSwaps(string, l + 1, r, cnt, minm)\n        minm = min(minm, min(x, y))\n    return minm\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"abbaacb\"\n    string = list(string)\n    n = len(string)\n    cnt = 0\n    minm = maxsize\n    print(minSwaps(string, 0, n - 1, cnt, minm))\n",
        "output": "2\n",
        "fn_call": "minSwaps"
    },
    {
        "text": "maximum number of given operations to remove the entire string | function to return the maximum number of given operations required to remove the given entirely ; if length of the is zero ; single operation can delete the entire string ; to store the prefix of the string which is to be deleted ; prefix s [ 0. . i ] ; to store the subs [ i + 1. . .2 * i + 1 ] ; if the prefix s [ 0. . . i ] can be deleted ; 1 operation to remove the current prefix and then recursively find the count of operations for the subs [ i + 1. . . n - 1 ] ; entire has to be deleted ; ",
        "context": "",
        "code": "def find(s):\n    if (len(s) == 0):\n        return 0\n    c = 1\n    d = \"\"\n    for i in range(len(s)):\n        d += s[i]\n        s2 = s[i + 1:i + 1 + len(d)]\n        if (s2 == d):\n            c = 1 + find(s[i + 1:])\n            break\n    return c\n",
        "test": "\ns = \"abababab\"\nprint(find(s))\n",
        "output": "4\n",
        "fn_call": "find"
    },
    {
        "text": "sum of bitwise xor of each array element with all other array elements | function to calculate for each array element , sum of its bitwise xor with all other array elements ; declare an array of size 64 to store count of each bit ; traversing the array ; check if bit is present of not ; increase the bit position ; reduce the number to half ; traverse the array ; stores the bit position ; stores the sum of bitwise xor ; check if bit is present of not ; reduce the number to its half ; print the sum for a [ i ] ; ",
        "context": "",
        "code": "def XOR_for_every_i(A, N):\n    frequency_of_bits = [0] * 32\n    for i in range(N):\n        bit_position = 0\n        M = A[i]\n        while (M):\n            if (M & 1 != 0):\n                frequency_of_bits[bit_position] += 1\n            bit_position += 1\n            M >>= 1\n    for i in range(N):\n        M = A[i]\n        value_at_that_bit = 1\n        XOR_sum = 0\n        for bit_position in range(32):\n            if (M & 1 != 0):\n                XOR_sum += ((N -\n                             frequency_of_bits[bit_position]) *\n                            value_at_that_bit)\n            else:\n                XOR_sum += ((frequency_of_bits[bit_position])\n                            * value_at_that_bit)\n            M >>= 1\n            value_at_that_bit <<= 1\n        print(XOR_sum, end=\" \")\n    return\n",
        "test": "\nA = [1, 2, 3]\nN = len(A)\nXOR_for_every_i(A, N)\n",
        "output": "5 4 3 ",
        "fn_call": "XOR_for_every_i"
    },
    {
        "text": "minimize the sum of differences of consecutive elements after removing exactly k elements | function to find minimum sum ; variable to store final answer and initialising it with the values when 0 elements is removed from the left and k from the right . ; loop to simulate removal of elements ; removing i elements from the left and and k - i elements from the right and updating the answer correspondingly ; returning final answer ; ",
        "context": "",
        "code": "def findSum(arr, n, k):\n    ans = arr[n - k - 1] - arr[0]\n    for i in range(1, k + 1):\n        ans = min(arr[n - 1 - (k - i)] - arr[i], ans)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 100, 120, 140]\n    k = 2\n    n = len(arr)\n    print(findSum(arr, n, k))\n",
        "output": "40\n",
        "fn_call": "findSum"
    },
    {
        "text": "finding n | python3 program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; ",
        "context": "",
        "code": "def nthprimedigitsnumber(number):\n    num = \"\"\n    while (number > 0):\n        rem = number % 4\n        if (rem == 1):\n            num += '2'\n        if (rem == 2):\n            num += '3'\n        if (rem == 3):\n            num += '5'\n        if (rem == 0):\n            num += '7'\n        if (number % 4 == 0):\n            number = number - 1\n        number = number // 4\n    return num[::-1]\n",
        "test": "\nnumber = 21\nprint(nthprimedigitsnumber(10))\nprint(nthprimedigitsnumber(number))\n",
        "output": "33\n222\n",
        "fn_call": "nthprimedigitsnumber"
    },
    {
        "text": "program for harmonic mean of numbers | function that returns harmonic mean . ; ",
        "context": "",
        "code": "def harmonicMean(arr, freq, n):\n    sm = 0\n    frequency_sum = 0\n    for i in range(0, n):\n        sm = sm + freq[i] / arr[i]\n        frequency_sum = frequency_sum + freq[i]\n    return (round(frequency_sum / sm, 4))\n",
        "test": "\nnum = [13, 14, 15, 16, 17]\nfreq = [2, 5, 13, 7, 3]\nn = len(num)\nprint(harmonicMean(num, freq, n))\n",
        "output": "15.0631\n",
        "fn_call": "harmonicMean"
    },
    {
        "text": "longest ordered subsequence of vowels | python3 program to find the longest subsequence of vowels in the specified order ; mapping values for vowels ; function to check if given subsequence contains all the vowels or not ; not contain vowel ; function to find the longest subsequence of vowels in the given string in specified order ; if we have reached the end of the string , return the subsequence if it is valid , else return an empty list ; if there is no vowel in the subsequence yet , add vowel at current index if it is ' a ' , else move on to the next character in the string ; if the last vowel in the subsequence until now is same as the vowel at current index , add it to the subsequence ; if the vowel at the current index comes right after the last vowel in the subsequence , we have two options : either to add the vowel in the subsequence , or move on to next character . we choose the one which gives the longest subsequence . ; ",
        "context": "\nvowels = ['a', 'e', 'i', 'o', 'u']\nmapping = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n\n",
        "code": "def isValidSequence(subList):\n    for vowel in vowels:\n        if vowel not in subList:\n            return False\n    return True\n\n\ndef longestSubsequence(string, subList, index):\n    if index == len(string):\n        if isValidSequence(subList):\n            return subList\n        else:\n            return []\n    else:\n        if len(subList) == 0:\n            if string[index] != 'a':\n                return longestSubsequence(string, subList, index + 1)\n            else:\n                return longestSubsequence(string, subList + [string[index]], index + 1)\n        elif mapping[subList[-1]] == mapping[string[index]]:\n            return longestSubsequence(string, subList + [string[index]], index + 1)\n        elif (mapping[subList[-1]] + 1) == mapping[string[index]]:\n            sub1 = longestSubsequence(\n                string, subList + [string[index]], index + 1)\n            sub2 = longestSubsequence(string, subList, index + 1)\n            if len(sub1) > len(sub2):\n                return sub1\n            else:\n                return sub2\n        else:\n            return longestSubsequence(string, subList, index + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"aeiaaioooauuaeiou\"\n    subsequence = longestSubsequence(string, [], 0)\n    if len(subsequence) == 0:\n        print(\"No subsequence possible\")\n    else:\n        print(subsequence)\n",
        "output": "['a', 'e', 'i', 'i', 'o', 'o', 'o', 'u', 'u', 'u']\n",
        "fn_call": "longestSubsequence"
    },
    {
        "text": "count of numbers having only one unset bit in a range [ l , r ] | python3 program for the above approach ; function to count numbers in the range [ l , r ] having exactly one unset bit ; stores the count elements having one zero in binary ; stores the maximum number of bits needed to represent number ; loop over for zero bit position ; number having zero_bit as unset and remaining bits set ; sets all bits before zero_bit ; set the bit at position j ; set the bit position at j ; if cur is in the range [ l , r ] , then increment ans ; return ans ; ",
        "context": "\nimport math\n\n",
        "code": "def count_numbers(L, R):\n    ans = 0\n    LogR = (int)(math .log(R) + 1)\n    for zero_bit in range(LogR):\n        cur = 0\n        for j in range(zero_bit):\n            cur |= (1 << j)\n        for j in range(zero_bit + 1, LogR):\n            cur |= (1 << j)\n            if (cur >= L and cur <= R):\n                ans += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    L = 4\n    R = 9\n    print(count_numbers(L, R))\n",
        "output": "2\n",
        "fn_call": "count_numbers"
    },
    {
        "text": "minimum moves required to come out of a grid safely | ''stores size of the grid ; ''function to check valid cells of the grid ; ''checks for the border sides ; ''function to find shortest distance between two cells of the grid ; '' rows of the grid ; '' column of the grid ; '' stores possible move  of the person ; '' store possible cells visited  by the person ; '' store possible cells which  are burning ; '' traverse the grid ; '' if current cell is  burning ; '' if person is in  the current cell ; '' stores shortest distance  between two cells ; '' check if a cell is visited  by the person or not ; '' while pq is not empty ; '' update depth ; '' popped all the cells from  pq and mark all adjacent cells  of as visited ; '' front element of  the queue pq ; '' remove front element of  the queue pq ; '' if current cell is burning ; '' find all adjacent cells ; '' stores row number of  adjacent cell ; '' stores column number  of adjacent cell ; '' checks if current cell  is valid ; '' mark the cell as visited ; '' enqueue the cell ; '' checks the escape condition ; '' burn all the adjacent cells  of burning cells ; '' front element of  the queue fq ; '' delete front element of  the queue fq ; '' find adjacent cells of  burning cell ; '' stores row number of  adjacent cell ; '' stores column number  of adjacent cell ; '' checks if current  cell is valid ; '' burn all the adjacent  cells of current cell ; ''",
        "context": "\nm = 0\nn = 0\n\n",
        "code": "def valid(x, y):\n    global n\n    global m\n    return (x >= 0 and x = 0 and y < n)\n\n\ndef border(x, y):\n    global n\n    global m\n    return (x == 0 or x == m - 1 or y == 0 or y == n - 1)\n\n\ndef minStep(mat):\n    global n\n    global m\n    m = len(mat)\n    n = len(mat[0])\n    dx = [1, -1, 0, 0]\n    dy = [0, 0, 1, -1]\n    pQ = []\n    fQ = []\n    for i in range(m):\n        for j in range(n):\n            if (mat[i][j] == 2):\n                fQ .append([i, j])\n            elif (mat[i][j] == 1):\n                if (border(i, j)):\n                    return 0\n                pQ .append([i, j])\n    depth = 0\n    visited = [[0 for i in range(m)]for j in range(n)]\n    while (len(pQ) > 0):\n        depth += 1\n        i = len(pQ)\n        while (i > 0):\n            pos = pQ[0]\n            pQ .remove(pQ[0])\n            if (mat[pos[0]][pos[1]] == 2):\n                continue\n            for j in range(4):\n                x = pos[0] + dx[j]\n                y = pos[1] + dy[j]\n                if (valid(x, y) and mat[x][y] != 2 and visited[x][y] == 0):\n                    visited[x][y] = 1\n                    pQ .append([x, y])\n                    if (border(x, y)):\n                        return depth\n            i -= 1\n        i = len(fQ)\n        while (i > 0):\n            pos = fQ[0]\n            fQ .remove(fQ[0])\n            for j in range(4):\n                x = pos[0] + dx[j]\n                y = pos[1] + dy[j]\n                if (valid(x, y) and mat[x][y] != 2):\n                    mat[x][y] = 2\n                    fQ .append([x, y])\n            i -= 1\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    grid = [[0, 0, 0, 0], [2, 0, 0, 0], [2, 1, 0, 0], [2, 2, 0, 0]]\n    print(minStep(grid))\n",
        "output": "2\n",
        "fn_call": "minStep"
    },
    {
        "text": "minimize the sum of product of two arrays with permutations allowed | returns minimum sum of product of two arrays with permutations allowed ; sort a and b so that minimum and maximum value can easily be fetched . ; multiplying minimum value of a and maximum value of b ; ",
        "context": "",
        "code": "def minValue(A, B, n):\n    A .sort()\n    B .sort()\n    result = 0\n    for i in range(n):\n        result += (A[i] * B[n - i - 1])\n    return result\n",
        "test": "\nA = [3, 1, 1]\nB = [6, 5, 4]\nn = len(A)\nprint(minValue(A, B, n))\n",
        "output": "23\n",
        "fn_call": "minValue"
    },
    {
        "text": "cost to make a string panagram | function to return the total cost required to make the string pangram ; mark all the alphabets that occurred in the string ; calculate the total cost for the missing alphabets ; ",
        "context": "",
        "code": "def pangramCost(arr, string):\n    cost = 0\n    occurred = [False] * 26\n    for i in range(len(string)):\n        occurred[ord(string[i]) - ord('a')] = True\n    for i in range(26):\n        if (not occurred[i]):\n            cost += arr[i]\n    return cost\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n           15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]\n    string = \"abcdefghijklmopqrstuvwz\"\n    print(pangramCost(arr, string))\n",
        "output": "63\n",
        "fn_call": "pangramCost"
    },
    {
        "text": "length of smallest subarray to be removed to make sum of remaining elements divisible by k | python3 program for the above approach ; function to find the length of the smallest subarray to be removed such that sum of elements is divisible by k ; stores the remainder of each arr [ i ] when divided by k ; stores total sum of elements ; k has been added to each arr [ i ] to handle - ve integers ; update the total sum ; remainder when total_sum is divided by k ; if given array is already divisible by k ; stores curr_remainder and the most recent index at which curr_remainder has occurred ; stores required answer ; add current element to curr_sum and take mod ; update current remainder index ; if mod already exists in map the subarray exists ; if not possible ; print the result ; given array arr [ ] ; size of array ; ",
        "context": "\nimport sys\n\n",
        "code": "def removeSmallestSubarray(arr, n, k):\n    mod_arr = [0] * n\n    total_sum = 0\n    for i in range(n):\n        mod_arr[i] = (arr[i] + k) % k\n        total_sum += arr[i]\n    target_remainder = total_sum % k\n    if (target_remainder == 0):\n        print(\"0\")\n        return\n    map1 = {}\n    map1[0] = -1\n    curr_remainder = 0\n    res = sys .maxsize\n    for i in range(n):\n        curr_remainder = (curr_remainder + arr[i] + k) % k\n        map1[curr_remainder] = i\n        mod = (curr_remainder - target_remainder + k) % k\n        if (mod in map1 .keys()):\n            res = min(res, i - map1[mod])\n    if (res == sys .maxsize or res == n):\n        res = -1\n    print(res)\n",
        "test": "\narr = [3, 1, 4, 2]\nN = len(arr)\nK = 6\nremoveSmallestSubarray(arr, N, K)\n",
        "output": "1\n",
        "fn_call": "removeSmallestSubarray"
    },
    {
        "text": "program to find the nth term of the series 0 , 3 / 1 , 8 / 3 , 15 / 5. . ... ... | function to return the nth term of the given series ; nth term ; ",
        "context": "",
        "code": "def Nthterm(n):\n    numerator = n ** 2 - 1\n    denomenator = 2 * n - 3\n    print(numerator, \"/\", denomenator)\n",
        "test": "\nn = 3\nNthterm(n)\n",
        "output": "8 / 3\n",
        "fn_call": "Nthterm"
    },
    {
        "text": "maximum even length sub | python3 code to find the maximum length of sub - string ( of even length ) which can be arranged into a palindrome ; function that returns true if the given sub - string can be arranged into a palindrome ; this function returns the maximum length of the sub - string ( of even length ) which can be arranged into a palindrome ; if we reach end of the string ; if string is of even length ; if string can be arranged into a palindrome ; even length sub - string ; check if current sub - string can be arranged into a palindrome ; odd length sub - string ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def canBePalindrome(count):\n    for key in count:\n        if count[key] % 2 != 0:\n            return False\n    return True\n\n\ndef maxPal(string, count, start, end):\n    if end == len(string):\n        if (end - start) % 2 == 0:\n            if canBePalindrome(count):\n                return end - start\n        return 0\n    else:\n        if (end - start) % 2 == 0:\n            if canBePalindrome(count):\n                count[string[end]] += 1\n                return max(end - start, maxPal(string, count, start, end + 1))\n            else:\n                count[string[end]] += 1\n                return maxPal(string, count, start, end + 1)\n        else:\n            count[string[end]] += 1\n            length = maxPal(string, count .copy(), start, end + 1)\n            count[string[end]] -= 1\n            count[string[start]] -= 1\n            return max(length, maxPal(string, count, start + 1, end))\n",
        "test": "\nstring = '124565463'\nstart, end = 0, 0\ncount = defaultdict(lambda: 0)\nprint(maxPal(string, count, start, end))\n",
        "output": "6\n",
        "fn_call": "maxPal"
    },
    {
        "text": "length of longest powerful number subsequence in an array | python3 program to find the length of longest powerful subsequence in an array ; function to check if the number is powerful ; first divide the number repeatedly by 2 ; check if only 2 ^ 1 divides n , then return false ; check if n is not a power of 2 then this loop will execute repeat above process ; find highest power of \" factor \" that divides n ; if only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . since prime numbers are not powerful , we return false if n is not 1. ; function to find the longest subsequence which contain all powerful numbers ; ",
        "context": "\nimport math\n\n",
        "code": "def isPowerful(n):\n    while (n % 2 == 0):\n        power = 0\n        while (n % 2 == 0):\n            n //= 2\n            power += 1\n        if (power == 1):\n            return False\n    for factor in range(3, int(math .sqrt(n)) + 1, 2):\n        power = 0\n        while (n % factor == 0):\n            n = n // factor\n            power += 1\n        if (power == 1):\n            return False\n    return (n == 1)\n\n\ndef longestPowerfulSubsequence(arr, n):\n    answer = 0\n    for i in range(n):\n        if (isPowerful(arr[i])):\n            answer += 1\n    return answer\n",
        "test": "\narr = [6, 4, 10, 13, 9, 25]\nn = len(arr)\nprint(longestPowerfulSubsequence(arr, n))\n",
        "output": "3\n",
        "fn_call": "longestPowerfulSubsequence"
    },
    {
        "text": "sum of all proper divisors from 1 to n | utility function to find sum of all proper divisor of number up to n ; loop to find the proper divisor of every number from 1 to n ; ",
        "context": "",
        "code": "def properDivisorSum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += (n // i) * i\n    return sum - n * (n + 1) // 2\n",
        "test": "\nn = 4\nprint(properDivisorSum(n))\nn = 5\nprint(properDivisorSum(n))\n",
        "output": "5\n6\n",
        "fn_call": "properDivisorSum"
    },
    {
        "text": "check whether the triangle is valid or not if angles are given | function to check if sum of the three angles is 180 or not ; check condition ; ",
        "context": "",
        "code": "def Valid(a, b, c):\n    if ((a + b + c == 180) and a != 0 and b != 0 and c != 0):\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 60\n    b = 40\n    c = 80\n    if (Valid(a, b, c)):\n        print(\"Valid\")\n    else:\n        print(\"Invalid\")\n",
        "output": "Valid\n",
        "fn_call": "Valid"
    },
    {
        "text": "divide array into increasing and decreasing subsequence without changing the order | function to print strictly increasing and strictly decreasing sequence if possible ; arrays to store strictly increasing and decreasing sequence ; initializing last element of both sequence ; iterating through the array ; if current element can be appended to both the sequences ; if next element is greater than the current element then append it to the strictly increasing array ; otherwise append it to the strictly decreasing array ; if current element can be appended to the increasing sequence only ; if current element can be appended to the decreasing sequence only ; else we can not make such sequences from the given array ; print the required sequences ; ",
        "context": "",
        "code": "def Find_Sequence(array, n):\n    inc_arr, dec_arr = [], []\n    inc, dec = -1, 1e7\n    for i in range(n):\n        if inc < array[i] < dec:\n            if array[i] < array[i + 1]:\n                inc = array[i]\n                inc_arr .append(array[i])\n            else:\n                dec = array[i]\n                dec_arr .append(array[i])\n        elif inc < array[i]:\n            inc = array[i]\n            inc_arr .append(array[i])\n        elif dec > array[i]:\n            dec = array[i]\n            dec_arr .append(array[i])\n        else:\n            print('-1')\n            break\n    else:\n        print(inc_arr, dec_arr)\n",
        "test": "\narr = [5, 1, 3, 6, 8, 2, 9, 0, 10]\nn = len(arr)\nFind_Sequence(arr, n)\n",
        "output": "[1, 3, 6, 8, 9, 10] [5, 2, 0]\n",
        "fn_call": "Find_Sequence"
    },
    {
        "text": "program to print an array in pendulum arrangement | prints pendulam arrangement of arr [ ] ; sorting the elements ; auxiliary array to store output ; calculating the middle index ; storing the minimum element in the middle i is index for output array and j is for input array . ; adjustment for when no . of elements is even ; printing the pendulum arrangement ; ",
        "context": "",
        "code": "def pendulumArrangement(arr, n):\n    arr .sort()\n    op = [0] * n\n    mid = int((n - 1) / 2)\n    j = 1\n    i = 1\n    op[mid] = arr[0]\n    for i in range(1, mid + 1):\n        op[mid + i] = arr[j]\n        j += 1\n        op[mid - i] = arr[j]\n        j += 1\n    if (int(n % 2) == 0):\n        op[mid + i] = arr[j]\n    print(\"Pendulum arrangement:\")\n    for i in range(0, n):\n        print(op[i], end=\" \")\n",
        "test": "\narr = [14, 6, 19, 21, 12]\nn = len(arr)\npendulumArrangement(arr, n)\n",
        "output": "Pendulum arrangement:\n21 14 6 12 19 ",
        "fn_call": "pendulumArrangement"
    },
    {
        "text": "remove minimum elements from either side such that 2 * min becomes more than max | a o ( n * n ) solution to find the minimum of elements to be removed ; returns the minimum number of removals from either end in arr [ l . . h ] so that 2 * min becomes greater than max . ; initialize starting and ending indexes of the maximum sized subarray with property 2 * min > max ; choose different elements as starting point ; initialize min and max for the current start ; choose different ending points for current start ; update min and max if necessary ; if the property is violated , then no point to continue for a bigger array ; update longest_start and longest_end if needed ; if not even a single element follow the property , then return n ; return the number of elements to be removed ; ",
        "context": "\nimport sys\n\n",
        "code": "def minRemovalsDP(arr, n):\n    longest_start = -1\n    longest_end = 0\n    for start in range(n):\n        min = sys .maxsize\n        max = -sys .maxsize\n        for end in range(start, n):\n            val = arr[end]\n            if (val < min):\n                min = val\n            if (val > max):\n                max = val\n            if (2 * min <= max):\n                break\n            if (end - start > longest_end - longest_start or longest_start == -1):\n                longest_start = start\n                longest_end = end\n    if (longest_start == -1):\n        return n\n    return (n - (longest_end - longest_start + 1))\n",
        "test": "\narr = [4, 5, 100, 9, 10, 11, 12, 15, 200]\nn = len(arr)\nprint(minRemovalsDP(arr, n))\n",
        "output": "4\n",
        "fn_call": "minRemovalsDP"
    },
    {
        "text": "find the point where maximum intervals overlap | program to find maximum guest at any time in a party ; sort arrival and exit arrays ; guests_in indicates number of guests at a time ; similar to merge in merge sort to process all events in sorted order ; if next event in sorted order is arrival , increment count of guests ; update max_guests if needed ; increment index of arrival array ; if event is exit , decrement count ; of guests . ; ",
        "context": "",
        "code": "def findMaxGuests(arrl, exit, n):\n    arrl .sort()\n    exit .sort()\n    guests_in = 1\n    max_guests = 1\n    time = arrl[0]\n    i = 1\n    j = 0\n    while (i < n and j < n):\n        if (arrl[i] <= exit[j]):\n            guests_in = guests_in + 1\n            if (guests_in > max_guests):\n                max_guests = guests_in\n                time = arrl[i]\n            i = i + 1\n        else:\n            guests_in = guests_in - 1\n            j = j + 1\n    print(\"Maximum Number of Guests =\", max_guests, \"at time\", time)\n",
        "test": "\narrl = [1, 2, 10, 5, 5]\nexit = [4, 5, 12, 9, 12]\nn = len(arrl)\nfindMaxGuests(arrl, exit, n)\n",
        "output": "Maximum Number of Guests = 3 at time 5\n",
        "fn_call": "findMaxGuests"
    },
    {
        "text": "find the values of x and y in the given equations | function to find the values of x and y ; base condition ; required answer ; ",
        "context": "",
        "code": "def findValues(a, b):\n    if ((a - b) % 2 == 1):\n        print(\"-1\")\n        return\n    print((a - b) // 2, (a + b) // 2)\n",
        "test": "\na = 12\nb = 8\nfindValues(a, b)\n",
        "output": "2 10\n",
        "fn_call": "findValues"
    },
    {
        "text": "count number of animals in a zoo from given number of head and legs | function that calculates rabbits ; ",
        "context": "",
        "code": "def countRabbits(Heads, Legs):\n    count = 0\n    count = (Legs) - 2 * (Heads)\n    count = count / 2\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    Heads = 100\n    Legs = 300\n    Rabbits = countRabbits(Heads, Legs)\n    print(\"Rabbits =\", Rabbits)\n    print(\"Pigeons =\", Heads - Rabbits)\n",
        "output": "Rabbits = 50.0\nPigeons = 50.0\n",
        "fn_call": "countRabbits"
    },
    {
        "text": "program to find the maximum difference between the index of any two different numbers | function to return the maximum difference ; iteratively check from back ; different numbers ; iteratively check from the beginning ; different numbers ; ",
        "context": "",
        "code": "def findMaximumDiff(a, n):\n    ind1 = 0\n    for i in range(n - 1, -1, -1):\n        if (a[0] != a[i]):\n            ind1 = i\n            break\n    ind2 = 0\n    for i in range(n - 1):\n        if (a[n - 1] != a[i]):\n            ind2 = (n - 1 - i)\n            break\n    return max(ind1, ind2)\n",
        "test": "\na = [1, 2, 3, 2, 3]\nn = len(a)\nprint(findMaximumDiff(a, n))\n",
        "output": "4\n",
        "fn_call": "findMaximumDiff"
    },
    {
        "text": "numbers of pairs from an array whose average is also present in the array | function to count the number of pairs from the array having sum s ; stores the total count of pairs whose sum is 2 * s ; generate all possible pairs and check their sums ; if the sum is s , then increment the count ; return the total count of pairs ; function to count of pairs having whose average exists in the array ; initialize the count ; use set to remove duplicates ; add elements in the set ; for every sum , count all possible pairs ; return the total count ; ",
        "context": "",
        "code": "def getCountPairs(arr, N, S):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if ((arr[i] + arr[j]) == S):\n                count += 1\n    return count\n\n\ndef countPairs(arr, N):\n    count = 0\n    S = set([])\n    for i in range(N):\n        S .add(arr[i])\n    for ele in S:\n        sum = 2 * ele\n        count += getCountPairs(arr, N, sum)\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 2, 5, 1, 3, 5]\n    N = len(arr)\n    print(countPairs(arr, N))\n",
        "output": "7\n",
        "fn_call": "countPairs"
    },
    {
        "text": "check if frequency of each digit is less than the digit | function to validate number ( check iffrequency of a digit is less than thedigit itself or not ) ; if current digit of temp is same as i ; if frequency is greater than digit value , return false ; ",
        "context": "",
        "code": "def validate(n):\n    for i in range(10):\n        temp = n\n        count = 0\n        while (temp):\n            if (temp % 10 == i):\n                count += 1\n            if (count > i):\n                return -1\n            temp //= 10\n    return 1\n",
        "test": "\nn = 1552793\ngeek = \"True\"if validate(n)else \"False\"\nprint(geek)\n",
        "output": "True\n",
        "fn_call": "validate"
    },
    {
        "text": "make n pairs from array as ( x , y ) coordinate point that are enclosed inside a minimum area rectangle | function to make n pairs of coordinates such that they are enclosed in a minimum area rectangle with sides parallel to the x and y axes ; a variable to store the answer ; for the case where the maximum and minimum are in different partitions ; for the case where the maximum and minimum are in the same partition ; return the answer ; ",
        "context": "",
        "code": "def minimumRectangleArea(A, N):\n    ans = 0\n    A .sort()\n    ans = (A[N - 1] - A[0]) * (A[2 * N - 1] - A[N])\n    for i in range(1, N, 1):\n        ans = min(ans, (A[2 * N - 1] - A[0]) * (A[i + N - 1] - A[i]))\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    A = [2, 4, 1, 5, 3, 6, 7, 8]\n    N = len(A)\n    N //= 2\n    print(minimumRectangleArea(A, N))\n",
        "output": "9\n",
        "fn_call": "minimumRectangleArea"
    },
    {
        "text": "longest palindromic substring | set 1 | python program ; a utility function to print a substring str [ low . . high ] ; this function prints the longest palindrome substring of st [ ] . it also returns the length of the longest palindrome ; get length of input string ; table [ i ] [ j ] will be false if substring str [ i . . j ] is not palindrome . else table [ i ] [ j ] will be true ; all substrings of length 1 are palindromes ; check for sub - string of length 2. ; check for lengths greater than 2. k is length of substring ; fix the starting index ; get the ending index of substring from starting index i and length k ; checking for sub - string from ith index to jth index iff st [ i + 1 ] to st [ ( j - 1 ) ] is a palindrome ; return length of lps ; ",
        "context": "\nimport sys\n\n",
        "code": "def printSubStr(st, low, high):\n    sys .stdout .write(st[low:high + 1])\n    sys .stdout .flush()\n    return ''\n\n\ndef longestPalSubstr(st):\n    n = len(st)\n    table = [[0 for x in range(n)]for y in range(n)]\n    maxLength = 1\n    i = 0\n    while (i < n):\n        table[i][i] = True\n        i = i + 1\n    start = 0\n    i = 0\n    while i < n - 1:\n        if (st[i] == st[i + 1]):\n            table[i][i + 1] = True\n            start = i\n            maxLength = 2\n        i = i + 1\n    k = 3\n    while k <= n:\n        i = 0\n        while i < (n - k + 1):\n            j = i + k - 1\n            if (table[i + 1][j - 1] and st[i] == st[j]):\n                table[i][j] = True\n                if (k > maxLength):\n                    start = i\n                    maxLength = k\n            i = i + 1\n        k = k + 1\n    print(\"Longest palindrome substring is: \",\n          printSubStr(st, start, start + maxLength - 1))\n    return maxLength\n",
        "test": "\nst = \"forgeeksskeegfor\"\nl = longestPalSubstr(st)\nprint(\"Length is:\", l)\n",
        "output": "geeksskeegLongest palindrome substring is:  \nLength is: 10\n",
        "fn_call": "longestPalSubstr"
    },
    {
        "text": "giuga numbers | python program for the above approach ; function to check if n is a composite number ; corner cases ; this is checked to skip middle 5 numbers ; function to check if n is a giuga number ; n should be composite to be a giuga number ; print the number of 2 s that divide n ; n must be odd at this point . so we can skip one element ; while i divides n , print i and divide n ; this condition is to handle the case when n is a prime number > 2 ; ",
        "context": "\nimport math\n\n",
        "code": "def isComposite(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return False\n    if (n % 2 == 0 or n % 3 == 0):\n        return True\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return True\n        i += 6\n    return False\n\n\ndef isGiugaNum(n):\n    if (not (isComposite(n))):\n        return False\n    N = n\n    while (n % 2 == 0):\n        if ((int(N / 2) - 1) % 2 != 0):\n            return False\n        n = int(n / 2)\n    for i in range(3, int(math .sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            if ((int(N / i) - 1) % i != 0):\n                return False\n            n = int(n / i)\n    if (n > 2):\n        if ((int(N / n) - 1) % n != 0):\n            return False\n    return True\n",
        "test": "\nn = 30\nif (isGiugaNum(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isGiugaNum"
    },
    {
        "text": "kth largest node among all directly connected nodes to the given node in an undirected graph | function to print kth node for each node ; vector to store nodes directly connected to ith node along with their values ; add edges to the vector along with the values of the node ; sort neighbors of every node and find the kth node ; get the kth node ; if total nodes are < k ; ",
        "context": "",
        "code": "def findKthNode(u, v, n, val, V, k):\n    g = [[]for i in range(V)]\n    for i in range(0, n):\n        g[u[i]].append((val[v[i]], v[i]))\n        g[v[i]].append((val[u[i]], u[i]))\n    for i in range(0, V):\n        if len(g[i]) > 0:\n            g[i].sort()\n        if k <= len(g[i]):\n            print(g[i][-k][1])\n        else:\n            print(\"-1\")\n    return\n",
        "test": "\nif __name__ == \"__main__\":\n    V = 3\n    val = [2, 4, 3]\n    u = [0, 0, 1]\n    v = [2, 1, 2]\n    n, k = len(u), 2\n    findKthNode(u, v, n, val, V, k)\n",
        "output": "2\n0\n0\n",
        "fn_call": "findKthNode"
    },
    {
        "text": "aliquot sequence | python implementation of optimized approach to generate aliquot sequence ; function to calculate sum of all proper divisors ; note that this loop runs till square root of n ; if divisors are equal , take only one of them ; otherwise take both ; calculate sum of all proper divisors only ; function to print aliquot sequence for an input n . ; print the first term ; calculate next term from previous term ; print next term ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def getSum(n):\n    summ = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:\n                summ += i\n            else:\n                summ += i\n                summ += n // i\n    return summ - n\n\n\ndef printAliquot(n):\n    print(n, end=\" \")\n    s = set()\n    s .add(n)\n    nextt = 0\n    while n > 0:\n        n = getSum(n)\n        if n in s:\n            print(\"Repeats with\", n)\n            break\n        print(n, end=\" \")\n        s .add(n)\n",
        "test": "\nif __name__ == \"__main__\":\n    printAliquot(12)\n",
        "output": "12 16 15 9 4 3 1 0 ",
        "fn_call": "printAliquot"
    },
    {
        "text": "sum of first n terms of a ",
        "context": "",
        "code": "def calculateSum(n):\n    a1 = 1\n    a2 = 2\n    r = 2\n    d = 1\n    return ((n) * (2 * a1 + (n - 1) * d) / 2 + a2 * (pow(r, n) - 1) / (r - 1))\n",
        "test": "\nn = 5\nprint(\"Sum =\", int(calculateSum(n)))\n",
        "output": "Sum = 77\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "mode of frequencies of given array elements | python3 program of the above approach ; function to find the mode of the frequency of the array ; stores the frequencies of array elements ; traverse through array elements and count frequencies ; stores the frequencies 's of  frequencies of array elements ; stores the minimum value ; find the mode in 2 nd map ; search for this mode ; when mode is find then return to main function . ; if mode is not found ; ",
        "context": "\nfrom collections import defaultdict\nimport sys\n\n",
        "code": "def countFreq(arr, n):\n    mp1 = defaultdict(int)\n    for i in range(n):\n        mp1[arr[i]] += 1\n        mp2 = defaultdict(int)\n        for it in mp1:\n            mp2[mp1[it]] += 1\n        M = -sys .maxsize - 1\n        for it in mp2:\n            M = max(M, mp2[it])\n            for it in mp2:\n                if (M == mp2[it]):\n                    return it\n            return 0\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 10, 3, 10, 8, 3, 6, 4]\n    n = len(arr)\n    print(countFreq(arr, n))\n",
        "output": "1\n",
        "fn_call": "countFreq"
    },
    {
        "text": "number of cells in a matrix that satisfy the given condition | python3 implementation of the approach ; function to return the number of cells in which mirror can be placed ; update the row array where row [ i ] [ j ] will store whether the current row i contains all 1 s in the columns starting from j ; update the column array where col [ i ] [ j ] will store whether the current column j contains all 1 s in the rows starting from i ; to store the required result ; for every cell except the last row and the last column ; if the current cell is not blocked and the light can travel from the next row and the next column then the current cell is valid ; for the last column ; for the last row , note that the last column is not taken into consideration as the bottom right element has already been considered in the last column previously ; ",
        "context": "\nN = 3\n\n",
        "code": "def numberOfCells(mat):\n    row = [[False for i in range(N)]for i in range(N)]\n    col = [[False for i in range(N)]for i in range(N)]\n    for i in range(N):\n        for j in range(N - 1, -1, -1):\n            if (mat[i][j] == 1):\n                if j + 1 < N:\n                    row[i][j] = row[i][j + 1]\n                else:\n                    row[i][j] = True\n            else:\n                row[i][j] = False\n    for j in range(N):\n        for i in range(N - 1, -1, -1):\n            if (mat[i][j] == 1):\n                if i + 1 < N:\n                    col[i][j] = col[i + 1][j]\n                else:\n                    col[i][j] = True\n            else:\n                col[i][j] = False\n    cnt = 0\n    for i in range(N - 1):\n        for j in range(N - 1):\n            if (row[i][j] and col[i][j]):\n                cnt += 1\n    for i in range(N):\n        if (col[i][N - 1]):\n            cnt += 1\n    for j in range(N - 1):\n        if (row[N - 1][j]):\n            cnt += 1\n    return cnt\n",
        "test": "\nmat = [[0, 1, 1], [0, 1, 1], [0, 1, 1]]\nprint(numberOfCells(mat))\n",
        "output": "6\n",
        "fn_call": "numberOfCells"
    },
    {
        "text": "minimum distance between the maximum and minimum element of a given array | python3 program to implement the above approach ; function to find the minimum distance between the minimum and the maximum element ; stores the minimum and maximum array element ; stores the most recently traversed indices of the minimum and the maximum element ; stores the minimum distance between the minimum and the maximium ; find the maximum and the minimum element from the given array ; find the minimum distance ; check if current element is equal to minimum ; check if current element is equal to maximum ; if both the minimum and the maximum element has occurred at least once ; ",
        "context": "\nimport sys\n\n",
        "code": "def minDistance(a, n):\n    maximum = -1\n    minimum = sys .maxsize\n    min_index = -1\n    max_index = -1\n    min_dist = n + 1\n    for i in range(n):\n        if (a[i] > maximum):\n            maximum = a[i]\n        if (a[i] < minimum):\n            minimum = a[i]\n    for i in range(n):\n        if (a[i] == minimum):\n            min_index = i\n        if (a[i] == maximum):\n            max_index = i\n        if (min_index != -1 and max_index != -1):\n            min_dist = (min(min_dist, abs(min_index - max_index)))\n    return min_dist\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 8, 2]\n    n = len(a)\n    print(minDistance(a, n))\n",
        "output": "3\n",
        "fn_call": "minDistance"
    },
    {
        "text": "count of sub | function to return the count of valid sub - strings ; variable ans to store all the possible substrings initialize its value as total number of substrings that can be formed from the given string ; stores recent index of the characters ; if character is a update a 's index  and the variable ans ; if character is b update b 's index  and the variable ans ; if character is c update c 's index  and the variable ans ; ",
        "context": "",
        "code": "def CountSubString(Str, n):\n    ans = (n * (n + 1)) // 2\n    a_index = 0\n    b_index = 0\n    c_index = 0\n    for i in range(n):\n        if (Str[i] == 'a'):\n            a_index = i + 1\n            ans -= min(b_index, c_index)\n        elif (Str[i] == 'b'):\n            b_index = i + 1\n            ans -= min(a_index, c_index)\n        else:\n            c_index = i + 1\n            ans -= min(a_index, b_index)\n    return ans\n",
        "test": "\nStr = \"babac\"\nn = len(Str)\nprint(CountSubString(Str, n))\n",
        "output": "12\n",
        "fn_call": "CountSubString"
    },
    {
        "text": "count pairs up to n having sum equal to their xor | 2d array for memoization ; recursive function to count pairs ( x , y ) such that x + y = x ^ y ; if the string is traversed completely ; if the current subproblem is already calculated ; if bound = 1 and s [ i ] = = '0' , only ( 0 , 0 ) can be placed ; otherwise ; placing ( 0 , 1 ) and ( 1 , 0 ) are equivalent . hence , multiply by 2. ; place ( 0 , 0 ) at the current position . ; return the answer ; utility function to convert n to its binary representation ; function to count pairs ( x , y ) such that x + y = x ^ y ; convert the number to equivalent binary representation ; print answer returned by recursive function ; ",
        "context": "\ndp = [[-1 for i in range(2)]for j in range(1000)]\n\n",
        "code": "def IsSumEqualsXor(i, n, bound, s):\n    if (i == n):\n        return 1\n    if (dp[i][bound] != -1):\n        return dp[i][bound]\n    ans = 0\n    if (bound and s[i] == '0'):\n        ans = IsSumEqualsXor(i + 1, n, 1, s)\n    else:\n        ans = 2 * IsSumEqualsXor(i + 1, n, bound & (s[i] == '1'), s)\n        ans += IsSumEqualsXor(i + 1, n, 0, s)\n    dp[i][bound] = ans\n    return ans\n\n\ndef convertToBinary(n):\n    ans = []\n    while (n):\n        rem = chr(n % 2 + 48)\n        ans .append(rem)\n        n //= 2\n    ans = ans[::-1]\n    return ans\n\n\ndef IsSumEqualsXorUtil(N):\n    s = convertToBinary(N)\n    print(IsSumEqualsXor(0, len(s), 1, s))\n",
        "test": "\nif __name__ == '__main__':\n    N = 10\n    IsSumEqualsXorUtil(N)\n",
        "output": "37\n",
        "fn_call": "IsSumEqualsXorUtil"
    },
    {
        "text": "lexicographically largest string formed from the characters in range l and r | function to return the lexicographically largest string ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans string ; iterate in frequency array ; add til all characters are added ; ",
        "context": "",
        "code": "def printLargestString(s, l, r):\n    freq = [0] * 26\n    l -= 1\n    r -= 1\n    for i in range(min(l, r), max(l, r) + 1):\n        freq[ord(s[i]) - ord('a')] += 1\n    ans = \"\"\n    for i in range(25, -1, -1):\n        while (freq[i]):\n            ans += chr(ord('a') + i)\n            freq[i] -= 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"striver\"\n    l = 3\n    r = 5\n    print(printLargestString(s, l, r))\n",
        "output": "vri\n",
        "fn_call": "printLargestString"
    },
    {
        "text": "convert all substrings of length ' k ' from base ' b ' to decimal | simple python3 program to convert all substrings from decimal to given base . ; saving substring in sub ; evaluating decimal for current substring and printing it . ; ",
        "context": "\nimport math\n\n",
        "code": "def substringConversions(s, k, b):\n    l = len(s)\n    for i in range(l):\n        if ((i + k) < l + 1):\n            sub = s[i:i + k]\n            sum, counter = 0, 0\n            for i in range(len(sub) - 1, -1, -1):\n                sum = sum + ((ord(sub[i]) - ord('0')) * pow(b, counter))\n                counter += 1\n            print(sum, end=\" \")\n",
        "test": "\ns = \"12212\"\nb, k = 3, 3\nsubstringConversions(s, b, k)\n",
        "output": "17 25 23 ",
        "fn_call": "substringConversions"
    },
    {
        "text": "probability that a n digit number is palindrome | find the probability that a n digit number is palindrome ; denominator ; assign 10 ^ ( floor ( n / 2 ) ) to denominator ; display the answer ; ",
        "context": "",
        "code": "def solve(n):\n    n_2 = n // 2\n    den = \"1\"\n    while (n_2):\n        den += '0'\n        n_2 -= 1\n    print(str(1) + \"/\" + str(den))\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    solve(N)\n",
        "output": "1/100\n",
        "fn_call": "solve"
    },
    {
        "text": "find all distinct subset ( or subsequence ) sums of an array | uses dynamic programming to find distinct subset sums ; dp [ i ] [ j ] would be true if arr [ 0. . i - 1 ] has a subset with sum equal to j . ; there is always a subset with 0 sum ; fill dp [ ] [ ] in bottom up manner ; sums that were achievable without current array element ; print last row elements ; ",
        "context": "",
        "code": "def printDistSum(arr, n):\n    Sum = sum(arr)\n    dp = [[False for i in range(Sum + 1)]for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        dp[i][arr[i - 1]] = True\n        for j in range(1, Sum + 1):\n            if (dp[i - 1][j]):\n                dp[i][j] = True\n                dp[i][j + arr[i - 1]] = True\n    for j in range(Sum + 1):\n        if (dp[n][j]):\n            print(j, end=\" \")\n",
        "test": "\narr = [2, 3, 4, 5, 6]\nn = len(arr)\nprintDistSum(arr, n)\n",
        "output": "0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 20 ",
        "fn_call": "printDistSum"
    },
    {
        "text": "find two non | function to find two non - overlapping with same sum in an array ; first create an empty map key -> which is sum of a pair of elements in the array value -> vector storing index of every pair having that sum ; consider every pair ( arr [ i ] , arr [ j ] ) and where ( j > i ) ; calculate sum of current pair ; if sum is already present in the map ; check every pair having equal sum ; if pairs don 't overlap,  print them and return ; insert current pair into the map ; if no such pair found ; ",
        "context": "",
        "code": "def findPairs(arr, size):\n    Map = {}\n    for i in range(0, size - 1):\n        for j in range(i + 1, size):\n            Sum = arr[i] + arr[j]\n            if Sum in Map:\n                for pair in Map[Sum]:\n                    m, n = pair\n                    if ((m != i and m != j) and (n != i and n != j)):\n                        print(\"Pair First ({}, {})\".format(arr[i], arr[j]))\n                        print(\"Pair Second ({}, {})\".format(arr[m], arr[n]))\n                        return\n            if Sum not in Map:\n                Map[Sum] = []\n            Map[Sum].append((i, j))\n    print(\"No such non-overlapping pairs present\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [8, 4, 7, 8, 4]\n    size = len(arr)\n    findPairs(arr, size)\n",
        "output": "Pair First (4, 8)\nPair Second (8, 4)\n",
        "fn_call": "findPairs"
    },
    {
        "text": "count occurrences of a substring recursively | recursive function to count the number of occurrences of \" hi \" in str . ; base case ; recursive case checking if the first substring matches ; otherwise , return the count from the remaining index ; ",
        "context": "",
        "code": "def countSubstrig(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if (n1 == 0 or n1 < n2):\n        return 0\n    if (str1[0:n2] == str2):\n        return countSubstrig(str1[n2 - 1:], str2) + 1\n    return countSubstrig(str1[n2 - 1:], str2)\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"geeksforgeeks\"\n    str2 = \"geeks\"\n    print(countSubstrig(str1, str2))\n    str1 = \"hikakashi\"\n    str2 = \"hi\"\n    print(countSubstrig(str1, str2))\n",
        "output": "2\n2\n",
        "fn_call": "countSubstrig"
    },
    {
        "text": "program to build a dfa to accept strings that start and end with same character | function for the state q1 ; condition to check end of string ; state transitions ' a ' takes to q1 , and ' b ' takes to q2 ; function for the state q2 ; condition to check end of string ; state transitions ' a ' takes to q1 , and ' b ' takes to q2 ; function for the state q3 ; condition to check end of string ; state transitions ' a ' takes to q4 , and ' b ' takes to q3 ; function for the state q4 ; condition to check end of string ; state transitions ' a ' takes to q4 , and ' b ' takes to q3 ; function for the state q0 ; condition to check end of string ; state transitions ' a ' takes to q1 , and ' b ' takes to q3 ; ",
        "context": "",
        "code": "def q1(s, i):\n    if (i == len(s)):\n        print(\"Yes\")\n        return\n    if (s[i] == 'a'):\n        q1(s, i + 1)\n    else:\n        q2(s, i + 1)\n\n\ndef q2(s, i):\n    if (i == len(s)):\n        print(\"No\")\n        return\n    if (s[i] == 'a'):\n        q1(s, i + 1)\n    else:\n        q2(s, i + 1)\n\n\ndef q3(s, i):\n    if (i == len(s)):\n        print(\"Yes\")\n        return\n    if (s[i] == 'a'):\n        q4(s, i + 1)\n    else:\n        q3(s, i + 1)\n\n\ndef q4(s, i):\n    if (i == s .length()):\n        print(\"No\")\n        return\n    if (s[i] == 'a'):\n        q4(s, i + 1)\n    else:\n        q3(s, i + 1)\n\n\ndef q0(s, i):\n    if (i == len(s)):\n        print(\"No\")\n        return\n    if (s[i] == 'a'):\n        q1(s, i + 1)\n    else:\n        q3(s, i + 1)\n",
        "test": "\nif __name__ == '__main__':\n    s = \"abbaabb\"\n    q0(s, 0)\n",
        "output": "No\n",
        "fn_call": "q0"
    },
    {
        "text": "count subsequences having odd bitwise xor values from an array | function to count the subsequences having odd bitwise xor value ; stores count of odd elements ; stores count of even elements ; traverse the array a [ ] ; if el is odd ; if count of odd elements is 0 ; ",
        "context": "",
        "code": "def countSubsequences(A):\n    odd = 0\n    even = 0\n    for el in A:\n        if (el % 2 == 1):\n            odd += 1\n        else:\n            even += 1\n    if (odd == 0):\n        print(0)\n    else:\n        print(1 << len(A) - 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 3, 4]\n    countSubsequences(A)\n",
        "output": "4\n",
        "fn_call": "countSubsequences"
    },
    {
        "text": "last two digits of powers of 7 | function to find the last two digits of 7 ^ n ; case 4 ; case 3 ; case 2 ; case 1 ; ",
        "context": "",
        "code": "def get_last_two_digit(N):\n    if (N % 4 == 0):\n        return \"01\"\n    elif (N % 4 == 1):\n        return \"07\"\n    elif (N % 4 == 2):\n        return \"49\"\n    return \"43\"\n",
        "test": "\nN = 12\nprint(get_last_two_digit(N))\n",
        "output": "01\n",
        "fn_call": "get_last_two_digit"
    },
    {
        "text": "number of k 's such that the given array can be divided into two sets satisfying the given conditions | function to return the count of k 's such that the array can be divided into two sets containing equal number of elements when all the elements less than k are in one set and the rest of the elements are in the other set ; sort the given array ; return number of such ks ; ",
        "context": "",
        "code": "def two_sets(a, n):\n    a .sort()\n    return (a[n // 2] - a[(n // 2) - 1])\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 4, 4, 6, 7, 9]\n    n = len(a)\n    print(two_sets(a, n))\n",
        "output": "2\n",
        "fn_call": "two_sets"
    },
    {
        "text": "maximum profit by selling n items at two markets | python3 implementation of the approach ; max profit will be saved here ; loop to check all possible combinations of sales ; the sum of the profit after the sale for products 0 to i in market a ; the sum of the profit after the sale for products i to n in market b ; replace the value of max profit with a bigger value among maxp and suma + sumb ; return the value of max profit ; ",
        "context": "",
        "code": "def maxProfit(a, b, n):\n    maxP = -1\n    for i in range(0, n + 1):\n        sumA = sum(a[:i])\n        sumB = sum(b[i:])\n        maxP = max(maxP, sumA + sumB)\n    return maxP\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 3, 2]\n    b = [10, 30, 40]\n    print(maxProfit(a, b, 4))\n",
        "output": "80\n",
        "fn_call": "maxProfit"
    },
    {
        "text": "sum of multiples of a and b less than n | python 3 program to find the sum of all multiples of a and b below n ; function to find sum of ap series ; number of terms ; function to find the sum of all multiples of a and b below n ; since , we need the sum of multiples less than n ; common factors of a and b ; ",
        "context": "\nfrom math import gcd, sqrt\n\n",
        "code": "def sumAP(n, d):\n    n = int(n / d)\n    return (n) * (1 + n) * d / 2\n\n\ndef sumMultiples(A, B, n):\n    n -= 1\n    common = int((A * B) / gcd(A, B))\n    return (sumAP(n, A) + sumAP(n, B) - sumAP(n, common))\n",
        "test": "\nif __name__ == '__main__':\n    n = 100\n    A = 5\n    B = 10\n    print(\"Sum =\", int(sumMultiples(A, B, n)))\n",
        "output": "Sum = 950\n",
        "fn_call": "sumMultiples"
    },
    {
        "text": "lagrange 's four square theorem | prints all the possible combinations 4 numbers whose sum of squares is equal to the given no . ; loops checking the sum of squares ; if sum of four squares equals the given no . ; printing the numbers ; ",
        "context": "",
        "code": "def printFourSquares(a):\n    i = 0\n    while (i * i <= a):\n        j = i\n        while (j * j <= a):\n            k = j\n            while (k * k <= a):\n                l = k\n                while (l * l <= a):\n                    if (i * i + j * j + k * k + l * l == a):\n                        print(\"{} = {}*{} + {}*{} +\".format(a, i, i, j, j), end=\" \")\n                        print(\"{}*{} + {}*{}\".format(k, k, l, l), end=\"\")\n                    l = l + 1\n                k = k + 1\n            j = j + 1\n        i = i + 1\n",
        "test": "\na = 74\nprintFourSquares(a)\n",
        "output": "74 = 0*0 + 0*0 + 5*5 + 7*774 = 0*0 + 1*1 + 3*3 + 8*874 = 0*0 + 3*3 + 4*4 + 7*774 = 1*1 + 1*1 + 6*6 + 6*674 = 2*2 + 3*3 + 5*5 + 6*6",
        "fn_call": "printFourSquares"
    },
    {
        "text": "search an element in a sorted array formed by reversing subarrays from a random index | function to search an element in a sorted array formed by reversing subarrays from a random index ; set the boundaries for binary search ; apply binary search ; initialize the middle element ; if element found ; random point is on right side of mid ; from l to mid arr is reverse sorted ; random point is on the left side of mid ; from mid to h arr is reverse sorted ; return not found ; ",
        "context": "",
        "code": "def find(arr, N, key):\n    l = 0\n    h = N - 1\n    while l <= h:\n        mid = (l + h) // 2\n        if arr[mid] == key:\n            return mid\n        if arr[l] >= arr[mid]:\n            if arr[l] >= key >= arr[mid]:\n                h = mid - 1\n            else:\n                l = mid + 1\n        else:\n            if arr[mid] >= key >= arr[h]:\n                l = mid + 1\n            else:\n                h = mid - 1\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 8, 6, 5, 2, 1, 13, 12]\n    N = len(arr)\n    key = 8\n    ans = find(arr, N, key)\n    print(ans)\n",
        "output": "1\n",
        "fn_call": "find"
    },
    {
        "text": "find the subarray of size k with minimum xor | function to find the minimum xor of the subarray of size k ; k must be smaller than or equal to n ; initialize beginning index of result ; compute xor sum of first subarray of size k ; initialize minimum xor sum as current xor ; traverse from ( k + 1 ) ' th \u2581 \u2581 element \u2581 to \u2581 n ' th element ; xor with current item and first item of previous subarray ; update result if needed ; ",
        "context": "",
        "code": "def findMinXORSubarray(arr, n, k):\n    if (n < k):\n        return\n    res_index = 0\n    curr_xor = 0\n    for i in range(0, k):\n        curr_xor = curr_xor ^ arr[i]\n    min_xor = curr_xor\n    for i in range(k, n):\n        curr_xor ^= (arr[i] ^ arr[i - k])\n        if (curr_xor < min_xor):\n            min_xor = curr_xor\n            res_index = (i - k + 1)\n    print(min_xor, end='')\n",
        "test": "\narr = [3, 7, 90, 20, 10, 50, 40]\nk = 3\nn = len(arr)\nfindMinXORSubarray(arr, n, k)\n",
        "output": "16",
        "fn_call": "findMinXORSubarray"
    },
    {
        "text": "minimize remaining array element by removing pairs and replacing them by their absolute difference | function to find minimize the remaining array element by removing pairs and replacing them by their absolute difference ; stores sum of array elements ; traverse the array ; update totalsum ; stores half of totalsum ; dp [ i ] : true if sum i can be obtained as a subset sum ; base case ; stores closest sum that can be obtained as a subset sum ; traverse the array ; iterate over all possible value of sum ; update dp [ j ] ; if sum i can be obtained from array elements ; update reach ; ",
        "context": "",
        "code": "def SmallestElementLeft(arr, N):\n    totalSum = 0\n    for i in range(N):\n        totalSum += arr[i]\n    req = totalSum // 2\n    dp = [False for i in range(req + 1)]\n    dp[0] = True\n    reach = 0\n    for i in range(N):\n        j = req\n        while j >= arr[i]:\n            dp[j] = dp[j] or dp[j - arr[i]]\n            if (dp[j]):\n                reach = max(reach, j)\n            j -= 1\n    return totalSum - (2 * reach)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 2, 2]\n    N = len(arr)\n    print(SmallestElementLeft(arr, N))\n",
        "output": "2\n",
        "fn_call": "SmallestElementLeft"
    },
    {
        "text": "recursive program for prime number | returns true if n is prime , else return false . i is current divisor to check . ; base cases ; check for next divisor ; ",
        "context": "",
        "code": "def isPrime(n, i=2):\n    if (n <= 2):\n        return True if (n == 2)else False\n    if (n % i == 0):\n        return False\n    if (i * i > n):\n        return true\n    return isPrime(n, i + 1)\n",
        "test": "\nn = 15\nif (isPrime(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isPrime"
    },
    {
        "text": "shortest common supersequence | a naive recursive python program to find length of the shortest supersequence ; ",
        "context": "",
        "code": "def superSeq(X, Y, m, n):\n    if (not m):\n        return n\n    if (not n):\n        return m\n    if (X[m - 1] == Y[n - 1]):\n        return 1 + superSeq(X, Y, m - 1, n - 1)\n    return 1 + min(superSeq(X, Y, m - 1, n), superSeq(X, Y, m, n - 1))\n",
        "test": "\nX = \"AGGTAB\"\nY = \"GXTXAYB\"\nprint(\n    \"Length of the shortest supersequence is %d\" %\n    superSeq(\n        X,\n        Y,\n        len(X),\n        len(Y)))\n",
        "output": "Length of the shortest supersequence is 9\n",
        "fn_call": "superSeq"
    },
    {
        "text": "smallest index that splits an array into two subarrays with equal product | function to find the smallest index that splits the array into two subarrays with equal product ; stores the product of the array ; traverse the given array ; stores the product of left and the right subarrays ; traverse the given array ; update the products ; check if product is equal ; print resultant index ; if no partition exists , then print - 1. ; ",
        "context": "",
        "code": "def prodEquilibrium(arr, N):\n    product = 1\n    for i in range(N):\n        product *= arr[i]\n    left = 1\n    right = product\n    for i in range(N):\n        left = left * arr[i]\n        right = right // arr[i]\n        if (left == right):\n            print(i + 1)\n            return\n    print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 3, 2, 1]\n    N = len(arr)\n    prodEquilibrium(arr, N)\n",
        "output": "3\n",
        "fn_call": "prodEquilibrium"
    },
    {
        "text": "find first element in ap which is multiple of given prime | iterative function to calculate ( x ^ y ) % p in o ( log y ) ; initialize result ; update x if it is more than or equal to p ; if y is odd , multiply x with result ; y must be even now y = y / 2 ; function to find nearest element in common ; base conditions ; ",
        "context": "",
        "code": "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef NearestElement(A, D, P):\n    if A == 0:\n        return 0\n    elif D == 0:\n        return -1\n    else:\n        X = power(D, P - 2, P)\n        return (X * (P - A)) % P\n",
        "test": "\nif __name__ == \"__main__\":\n    A, D, P = 4, 9, 11\n    A %= P\n    D %= P\n    print(NearestElement(A, D, P))\n",
        "output": "2\n",
        "fn_call": "NearestElement"
    },
    {
        "text": "largest subsequence such that all indices and all values are multiples individually | python3 program for the above approach ; function that print maximum length of array ; dp [ ] array to store the maximum length ; find all divisors of i ; if the current value is greater than the divisor 's value ; if current value is greater than the divisor 's value  and s is not equal  to current index ; condition if current value is greater than the divisor 's value ; computing the greatest value ; printing maximum length of array ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def maxLength(arr, n):\n    dp = [1] * n\n    for i in range(n - 1, 1, -1):\n        for j in range(1, int(sqrt(i)) + 1):\n            if (i % j == 0):\n                s = i // j\n                if (s == j):\n                    if (arr[i] > arr[s]):\n                        dp[s] = max(dp[i] + 1, dp[s])\n                else:\n                    if (s != i and arr[i] > arr[s]):\n                        dp[s] = max(dp[i] + 1, dp[s])\n                    if (arr[i] > arr[j]):\n                        dp[j] = max(dp[i] + 1, dp[j])\n    Max = 0\n    for i in range(1, n):\n        if (dp[i] > Max):\n            Max = dp[i]\n    print(Max)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 1, 4, 2, 3, 6, 4, 9]\n    size = len(arr)\n    maxLength(arr, size)\n",
        "output": "3\n",
        "fn_call": "maxLength"
    },
    {
        "text": "count distinct possible bitwise xor values of subsets of an array | stores the mask of the vector ; stores the current 20 of dp [ ] ; function to store the mask of given integer ; iterate over the range [ 0 , 20 ] ; if i - th bit 0 ; if dp [ i ] is zero ; store the position in dp ; increment the answer ; return from the loop ; mask = mask xor dp [ i ] ; function to find the 20 of the set having bitwise xor of all the subset of the given array ; traverse the array ; prthe answer ; ",
        "context": "\ndp = [0] * 20\nans = 0\n\n",
        "code": "def insertVector(mask):\n    global dp, ans\n    for i in range(20):\n        if ((mask & 1 << i) == 0):\n            continue\n        if (not dp[i]):\n            dp[i] = mask\n            ans += 1\n            return\n        mask ^= dp[i]\n\n\ndef maxSizeSet(arr, N):\n    for i in range(N):\n        insertVector(arr[i])\n    print((1 << ans))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5]\n    N = len(arr)\n    maxSizeSet(arr, N)\n",
        "output": "8\n",
        "fn_call": "maxSizeSet"
    },
    {
        "text": "minimum operation required to make a balanced sequence | python3 implementation of the approach ; function to return the minimum operations required ; condition where we got only one closing bracket instead of 2 , here we have to add one more closing bracket to make the sequence balanced ; add closing bracket that costs us one operation ; remove the top opening bracket because we got the 1 opening and 2 continuous closing brackets ; inserting the opening bracket to stack ; after making the sequence balanced closing is now set to 0 ; case when there is no opening bracket the sequence starts with a closing bracket and one opening bracket is required now we have one opening and one closing bracket ; add opening bracket that costs us one operation ; assigning 1 to cntclosing because we have one closing bracket ; case where we got two continuous closing brackets need to pop one opening bracket from stack top ; condition where stack is not empty this is the case where we have only opening brackets ( st . size ( ) * 2 ) will give us the total closing bracket needed cntclosing is the count of closing bracket that we already have ; ",
        "context": "\nfrom queue import LifoQueue\n\n",
        "code": "def minOperations(s, len):\n    operationCnt = 0\n    st = LifoQueue()\n    cntClosing = 0\n    for i in range(0, len):\n        if (s[i] == '{'):\n            if (cntClosing > 0):\n                operationCnt += 1\n                st .pop()\n            st .put(s[i])\n            cntClosing = 0\n        elif (st .empty()):\n            st .put('{')\n            operationCnt += 1\n            cntClosing = 1\n        else:\n            cntClosing = (cntClosing + 1) % 2\n            if (cntClosing == 0):\n                st .pop()\n    operationCnt += st .qsize() * 2 - cntClosing + 1\n    return operationCnt\n",
        "test": "\nif __name__ == '__main__':\n    str = \"{\"\n    print(minOperations(str, 1))\n",
        "output": "3\n",
        "fn_call": "minOperations"
    },
    {
        "text": "min cost path | dp | dynamic programming python implementation of min cost path problem ; instead of following line , we can use int tc [ m + 1 ] [ n + 1 ] or dynamically allocate memoery to save space . the following line is used to keep te program simple and make it working on all compilers . ; initialize first column of total cost ( tc ) array ; initialize first row of tc array ; construct rest of the tc array ; ",
        "context": "\nR = 3\nC = 3\n\n",
        "code": "def minCost(cost, m, n):\n    tc = [[0 for x in range(C)]for x in range(R)]\n    tc[0][0] = cost[0][0]\n    for i in range(1, m + 1):\n        tc[i][0] = tc[i - 1][0] + cost[i][0]\n    for j in range(1, n + 1):\n        tc[0][j] = tc[0][j - 1] + cost[0][j]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            tc[i][j] = min(tc[i - 1][j - 1], tc[i - 1]\n                           [j], tc[i][j - 1]) + cost[i][j]\n    return tc[m][n]\n",
        "test": "\ncost = [[1, 2, 3], [4, 8, 2], [1, 5, 3]]\nprint(minCost(cost, 2, 2))\n",
        "output": "8\n",
        "fn_call": "minCost"
    },
    {
        "text": "optimized naive algorithm for pattern searching | a modified naive pattern searching algorithm that is optimized for the cases when all characters of pattern are different ; for current index i , check for pattern match ; if j == m : if pat [ 0. . . m - 1 ] = txt [ i , i + 1 , ... i + m - 1 ] ; slide the pattern by j ; ",
        "context": "",
        "code": "def search(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    i = 0\n\n    while i <= N-M:\n        for j in range(M):\n            if txt[i + j] != pat[j]:\n                break\n            j += 1\n\n        if j == M:\n            print((\"Pattern found at index \" + str(i)))\n            i = i + M\n        elif j == 0:\n            i = i + 1\n        else:\n            i = i + j\n",
        "test": "\ntxt = \"ABCEABCDABCEABCD\"\npat = \"ABCD\"\nsearch(pat, txt)\n",
        "output": "Pattern found at index 4\nPattern found at index 12\n",
        "fn_call": "search"
    },
    {
        "text": "program to find the length of latus rectum of a hyperbola | function to calculate the length of the latus rectum of a hyperbola ; store the length of major axis ; store the length of minor axis ; store the length of the latus rectum ; return the length of the latus rectum ; ",
        "context": "",
        "code": "def lengthOfLatusRectum(A, B):\n    major = 2.0 * A\n    minor = 2.0 * B\n    latus_rectum = (minor * minor) / major\n    return latus_rectum\n",
        "test": "\nA = 3.0\nB = 2.0\nprint(round(lengthOfLatusRectum(A, B), 5))\n",
        "output": "2.66667\n",
        "fn_call": "lengthOfLatusRectum"
    },
    {
        "text": "find first k natural numbers missing in given array | program to print first k missing number ; creating a hashmap ; iterate over array ; iterate to find missing element ; ",
        "context": "",
        "code": "def printmissingk(arr, n, k):\n    d = {}\n    for i in range(len(arr)):\n        d[arr[i]] = arr[i]\n    cnt = 1\n    fl = 0\n    for i in range(n + k):\n        if cnt not in d:\n            fl += 1\n            print(cnt, end=\" \")\n            if fl == k:\n                break\n        cnt += 1\n    print()\n",
        "test": "\narr = [1, 4, 3]\nn = len(arr)\nk = 3\nprintmissingk(arr, n, k)\n",
        "output": "2 5 6 \n",
        "fn_call": "printmissingk"
    },
    {
        "text": "cost to make a string panagram | set 2 | function to return the cost to make string a panagram ; count the occurrences of each lowercase character ; to store the total gain ; if some character is missing , it has to be added at twice the cost ; if some character appears more than once all of its occurrences except 1 can be traded for some gain ; if gain is more than the cost ; return the total cost if gain < 0 ; ",
        "context": "",
        "code": "def costToPanagram(string, cost):\n    n = len(string)\n    occurrences = [0] * 26\n    for i in range(n):\n        occurrences[ord(string[i]) - ord('a')] += 1\n    gain = 0\n    for i in range(26):\n        if occurrences[i] == 0:\n            gain -= 2 * cost[i]\n        elif occurrences[i] > 1:\n            gain += cost[i] * (occurrences[i] - 1)\n    if gain >= 0:\n        return 0\n    return gain * -1\n",
        "test": "\nif __name__ == \"__main__\":\n    cost = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    string = \"geeksforgeeks\"\n    print(costToPanagram(string, cost))\n",
        "output": "32\n",
        "fn_call": "costToPanagram"
    },
    {
        "text": "minimum decrements to make integer a divisible by integer b | function that print number of moves required ; calculate modulo ; print the required answer ; ",
        "context": "",
        "code": "def movesRequired(a, b):\n    total_moves = a % b\n    print(total_moves)\n",
        "test": "\nif __name__ == '__main__':\n    A = 10\n    B = 3\n    movesRequired(A, B)\n",
        "output": "1\n",
        "fn_call": "movesRequired"
    },
    {
        "text": "find the number which contain the digit d | python 3 program to print the number which contain the digit d from 0 to n ; function to display the values ; converting d to character ; loop to check each digit one by one . ; initialize the string ; checking for digit ; ",
        "context": "",
        "code": "def index(st, ch):\n    for i in range(len(st)):\n        if (st[i] == ch):\n            return i\n    return -1\n\n\ndef printNumbers(n, d):\n    st = \"\" + str(d)\n    ch = st[0]\n    for i in range(0, n + 1, 1):\n        st = \"\"\n        st = st + str(i)\n        if (i == d or index(st, ch) >= 0):\n            print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    n = 100\n    d = 5\n    printNumbers(n, d)\n",
        "output": "5 15 25 35 45 50 51 52 53 54 55 56 57 58 59 65 75 85 95 ",
        "fn_call": "printNumbers"
    },
    {
        "text": "find count of numbers from 0 to n which satisfies the given equation for a value k | function to find the values ; calculate the lcm ; calculate the multiples of lcm ; find the values which satisfies the given condition ; subtract the extra values ; return the final result ; ",
        "context": "",
        "code": "def __gcd(a, b):\n    if (b == 0):\n        return a\n    else:\n        return __gcd(b, a % b)\n\ndef findAns(a, b, n):\n    lcm = (a * b) // __gcd(a, b)\n    multiples = (n // lcm) + 1\n    answer = max(a, b) * multiples\n    lastvalue = lcm * (n // lcm) + max(a, b)\n    if (lastvalue > n):\n        answer = answer - (lastvalue - n - 1)\n    return answer\n",
        "test": "\nif __name__ == '__main__':\n    a = 1\n    b = 13\n    n = 500\n    print(findAns(a, b, n))\n",
        "output": "501\n",
        "fn_call": "findAns"
    },
    {
        "text": "find the maximum angle at which we can tilt the bottle without spilling any water | python3 program to find the maximum angle at which we can tilt the bottle without spilling any water ; now we have the volume of rectangular prism a * a * b ; now we have 2 cases ! ; taking the tangent inverse of value d as we want to take out the required angle ; taking the tangent inverse of value d as we want to take out the required angle ; as of now the angle is in radian . so we have to convert it in degree . ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def find_angle(x, y, z):\n    volume = x * x * y\n    ans = 0\n    if (z < volume // 2):\n        d = (x * y * y) / (2.0 * z)\n        ans = atan(d)\n    else:\n        z = volume - z\n        d = (2 * z) / (float)(x * x * x)\n        ans = atan(d)\n    ans = (ans * 180) / 3.14159265\n    return round(ans, 4)\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 12\n    y = 21\n    z = 10\n    print(find_angle(x, y, z))\n",
        "output": "89.7835\n",
        "fn_call": "find_angle"
    },
    {
        "text": "smallest x such that 1 * n , 2 * n , ... x * n have all digits from 1 to 9 | returns smallest value x such that 1 * n , 2 * n , 3 * n ... x * n have all digits from 1 to 9 at least once ; taking temporary array and variable . ; iterate till we get all the 10 digits at least once ; checking all the digits ; ",
        "context": "",
        "code": "def smallestX(n):\n    temp = [0] * 10\n    if (n == 0):\n        return -1\n    count = 0\n    x = 1\n    while (count < 10):\n        y = x * n\n        while (y > 0):\n            if (temp[y % 10] == 0):\n                count += 1\n                temp[y % 10] = 1\n            y = int(y / 10)\n        x += 1\n    return x - 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    print(smallestX(n))\n",
        "output": "18\n",
        "fn_call": "smallestX"
    },
    {
        "text": "percentage increase in the cylinder if the height is increased by given percentage but radius remains constant | python3 program to find percentage increase in the cylinder if the height is increased by given percentage but radius remains constant ; ",
        "context": "",
        "code": "def newvol(x):\n    print(\"percentage increase in the volume of the cylinder is \", x, \"%\")\n",
        "test": "\nx = 10.0\nnewvol(x)\n",
        "output": "percentage increase in the volume of the cylinder is  10.0 %\n",
        "fn_call": "newvol"
    },
    {
        "text": "move spaces to front of string in single traversal | function to find spaces and move to beginning ; traverse from end and swap spaces ; ",
        "context": "",
        "code": "def swap(c, i, j):\n    c = list(c)\n    c[i], c[j] = c[j], c[i]\n    return ''.join(c)\n\ndef moveSpaceInFront(s):\n    i = len(s) - 1\n    for j in range(i, -1, -1):\n        if (s[j] != ' '):\n            s = swap(s, i, j)\n            i -= 1\n    return s\n",
        "test": "\ns = \"Hey there, it's GeeksforGeeks\"\ns = moveSpaceInFront(s)\nprint(s)\n",
        "output": "   Heythere,it'sGeeksforGeeks\n",
        "fn_call": "moveSpaceInFront"
    },
    {
        "text": "maximum difference between two elements such that larger element appears after the smaller number | the function assumes that there are at least two elements in array . the function returns a negative value if the array is sorted in decreasing order and returns 0 if elements are equal ; initialize diff , current sum and max sum ; calculate current diff ; calculate current sum ; update max sum , if needed ; ",
        "context": "",
        "code": "def maxDiff(arr, n):\n    diff = arr[1] - arr[0]\n    curr_sum = diff\n    max_sum = curr_sum\n    for i in range(1, n - 1):\n        diff = arr[i + 1] - arr[i]\n        if (curr_sum > 0):\n            curr_sum += diff\n        else:\n            curr_sum = diff\n        if (curr_sum > max_sum):\n            max_sum = curr_sum\n    return max_sum\n",
        "test": "\nif __name__ == '__main__':\n    arr = [80, 2, 6, 3, 100]\n    n = len(arr)\n    print(\"Maximum difference is\", maxDiff(arr, n))\n",
        "output": "Maximum difference is 98\n",
        "fn_call": "maxDiff"
    },
    {
        "text": "find the sum of the first n centered dodecagonal number | function to find the n - th centered dodecagonal number ; formula to calculate nth centered_dodecagonal number ; function to find the sum of the first n centered_dodecagonal number ; variable to store the sum ; iterating from 1 to n ; finding the sum ; ",
        "context": "",
        "code": "def Centered_Dodecagonal_num(n):\n    return 6 * n * (n - 1) + 1\n\n\ndef sum_Centered_Dodecagonal_num(n):\n    summ = 0\n    for i in range(1, n + 1):\n        summ += Centered_Dodecagonal_num(i)\n    return summ\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    print(sum_Centered_Dodecagonal_num(n))\n",
        "output": "245\n",
        "fn_call": "sum_Centered_Dodecagonal_num"
    },
    {
        "text": "program to check if n is a centered cubic number | function to check if n is a centered cubic number ; iterating from 1 ; infinite loop ; finding ith_term ; checking if the number n is a centered cube number ; if ith_term > n then n is not a centered cube number ; incrementing i ; ",
        "context": "",
        "code": "def isCenteredcube(N):\n    i = 1\n    while (True):\n        ith_term = ((2 * i + 1) * (i * i + i + 1))\n        if (ith_term == N):\n            return True\n        if (ith_term > N):\n            return False\n        i += 1\n",
        "test": "\nN = 9\nif (isCenteredcube(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isCenteredcube"
    },
    {
        "text": "program to print the pattern 1020304017018019020 * * 50607014015016 * * * * 809012013 * * * * * * 10011. . . | function to find the sum of n integers from 1 to n ; function to print the given pattern ; iterate over [ 0 , n - 1 ] ; sub - pattern - 1 ; sub - pattern - 2 ; count the number of element in rows and sub - pattern 2 and 3 will have same rows ; increment val to print the series 1 , 2 , 3 , 4 , 5 ... ; finally , add the ( n - 1 ) th element i . e . , 5 and increment it by 1 ; initial is used to give the initial value of the row in sub - pattern 3 ; sub - pattern 3 ; skip printing zero at the last ; ",
        "context": "",
        "code": "def sum(n):\n    return n * (n - 1) // 2\n\n\ndef BSpattern(N):\n    Val = 0\n    Pthree = 0,\n    cnt = 0\n    initial = -1\n    s = \"**\"\n    for i in range(N):\n        cnt = 0\n        if (i > 0):\n            print(s, end=\"\")\n            s += \"**\"\n        for j in range(i, N):\n            if (i > 0):\n                cnt += 1\n            Val += 1\n            print(Val, end=\"\")\n            print(0, end=\"\")\n        if (i == 0):\n            Sumbeforelast = sum(Val) * 2\n            Pthree = Val + Sumbeforelast + 1\n            initial = Pthree\n        initial = initial - cnt\n        Pthree = initial\n        for k in range(i, N):\n            print(Pthree, end=\"\")\n            Pthree += 1\n            if (k != N - 1):\n                print(0, end=\"\")\n        print()\n",
        "test": "\nN = 5\nBSpattern(N)\n",
        "output": "102030405026027028029030\n**6070809022023024025\n****10011012019020021\n******13014017018\n********15016\n",
        "fn_call": "BSpattern"
    },
    {
        "text": "repeated sum of first n natural numbers | function to return the sum of the first n natural numbers ; function to return the repeated sum ; perform the operation exactly k times ; update n with the sum of first n natural numbers ; ",
        "context": "",
        "code": "def sum(n):\n    sum = (n * (n + 1)) // 2\n    return sum\n\n\ndef repeatedSum(n, k):\n    for i in range(k):\n        n = sum(n)\n    return n\n",
        "test": "\nn = 2\nk = 2\nprint(repeatedSum(n, k))\n",
        "output": "6\n",
        "fn_call": "repeatedSum"
    },
    {
        "text": "maximize count of set bits in a root to leaf path in a binary tree | python3 program to implement the above approach ; node class ; initialise constructor ; function to count the number of 1 in number ; function to find the maximum count of setbits in a root to leaf ; check if root is null ; update the maximum count of setbits ; traverse left of binary tree ; traverse right of the binary tree ; ",
        "context": "\nmaxm = 0\n\n\nclass Node:\n    def __init__(self, x):\n        self .val = x\n        self .left = None\n        self .right = None\n\n",
        "code": "def count_1(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n\n\ndef maxm_setbits(root, ans):\n    global maxm\n    if not root:\n        return\n    if (root .left is None and root .right is None):\n        ans += count_1(root .val)\n        maxm = max(ans, maxm)\n        return\n    maxm_setbits(root .left, ans + count_1(root .val))\n    maxm_setbits(root .right, ans + count_1(root .val))\n",
        "test": "\nroot = Node(15)\nroot .left = Node(3)\nroot .right = Node(7)\nroot .left .left = Node(5)\nroot .left .right = Node(1)\nroot .right .left = Node(31)\nroot .right .right = Node(9)\nmaxm_setbits(root, 0)\nprint(maxm)\n",
        "output": "12\n",
        "fn_call": "maxm_setbits"
    },
    {
        "text": "divide array into two parts with equal sum according to the given constraints | function that checks if the given conditions are satisfied ; to store the prefix sum of the array elements ; sort the array ; compute the prefix sum array ; maximum element in the array ; variable to check if there exists any number ; stores the index of the largest number present in the array smaller than i ; stores the index of the smallest number present in the array greater than i ; find index of smallest number greater than i ; find index of smallest number greater than i ; if there exists a number ; if no such number exists print no ; ",
        "context": "",
        "code": "def IfExists(arr, n):\n    sum = [0] * n\n    arr .sort()\n    sum[0] = arr[0]\n    for i in range(1, n):\n        sum[i] = sum[i - 1] + arr[i]\n    max = arr[n - 1]\n    flag = False\n    for i in range(1, max + 1):\n        findex = 0\n        lindex = 0\n        l = 0\n        r = n - 1\n        while (l <= r):\n            m = (l + r) // 2\n            if (arr[m] < i):\n                findex = m\n                l = m + 1\n            else:\n                r = m - 1\n        l = 1\n        r = n\n        flag = False\n        while (l <= r):\n            m = (r + l) // 2\n            if (arr[m] > i):\n                lindex = m\n                r = m - 1\n            else:\n                l = m + 1\n        if (sum[findex] == sum[n - 1] - sum[lindex - 1]):\n            flag = True\n            break\n    if (flag):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 2, 5]\n    n = len(arr)\n    IfExists(arr, n)\n",
        "output": "Yes\n",
        "fn_call": "IfExists"
    },
    {
        "text": "count number of substrings with numeric value greater than x | function that counts valid sub - strings ; only take those numbers that do not start with '0' . ; converting the sub - string starting from index ' i ' and having length ' len ' to int and checking if it is greater than x or not ; ",
        "context": "",
        "code": "def countSubStr(S, X):\n    cnt = 0\n    N = len(S)\n    for i in range(0, N):\n        if (S[i] != '0'):\n            j = 1\n            while ((j + i) <= N):\n                num = int(S[i:i + j])\n                if (num > X):\n                    cnt = cnt + 1\n                j = j + 1\n    return cnt\n",
        "test": "\nS = \"2222\"\nX = 97\nprint(countSubStr(S, X))\n",
        "output": "3\n",
        "fn_call": "countSubStr"
    },
    {
        "text": "representation of a number in powers of other | python3 program to check if m can be represented as powers of w . ; if m is not zero means , it can 't be  represented in terms of powers of w. ; ",
        "context": "",
        "code": "def asPowerSum(w, m):\n    while (m > 0):\n        if ((m - 1) % w == 0):\n            m = (m - 1) / w\n        elif ((m + 1) % w == 0):\n            m = (m + 1) / w\n        elif (m % w == 0):\n            m = m / w\n        else:\n            return (m == 0)\n",
        "test": "\nw = 3\nm = 7\nif (asPowerSum(w, m)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "asPowerSum"
    },
    {
        "text": "find the value of n when f ( n ) = f ( a ) + f ( b ) where a + b is the minimum possible and a * b = n | function to return the value of f ( n ) ; base cases ; count the number of times a number if divisible by 2 ; return the summation ; ",
        "context": "",
        "code": "def getValueOfF(n):\n    if (n == 1):\n        return 0\n    if (n == 2):\n        return 1\n    cnt = 0\n    while (n % 2 == 0):\n        cnt += 1\n        n /= 2\n    return 2 * cnt\n",
        "test": "\nn = 20\nprint(getValueOfF(n))\n",
        "output": "4\n",
        "fn_call": "getValueOfF"
    },
    {
        "text": "number of subarrays have bitwise or >= k | function to return the count of required sub - arrays ; traverse sub - array [ i . . j ] ; ",
        "context": "",
        "code": "def countSubArrays(arr, n, K):\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            bitwise_or = 0\n            for k in range(i, j + 1):\n                bitwise_or = bitwise_or | arr[k]\n            if (bitwise_or >= K):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 4, 5]\n    n = len(arr)\n    k = 6\n    print(countSubArrays(arr, n, k))\n",
        "output": "2\n",
        "fn_call": "countSubArrays"
    },
    {
        "text": "find gcd ( a ^ n , c ) where a , n and c can vary from 1 to 10 ^ 9 | iterative function to calculate ( x ^ y ) % p in o ( log y ) ; x = x % p update x if it is more than or equal to p ; if y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; finds gcd of a and b ; finds gcd of a ^ n and c ; check if c is a divisor of a ; first compute ( a ^ n ) % c ; now simply return gcd of modulo power and c . ; ",
        "context": "",
        "code": "def modPower(x, y, p):\n\n    res = 1\n\n    x = x % p\n\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n\n    return res\n\n\ndef gcd(a, b):\n\n    if (b == 0):\n        return a\n    return gcd(b, a % b)\n\n\ndef gcdPow(a, n, c):\n    if (a % c == 0):\n        return c\n    modexpo = modPower(a, n, c)\n    return gcd(modexpo, c)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 10248585\n    n = 1000000\n    c = 12564\n    print(gcdPow(a, n, c))\n",
        "output": "9\n",
        "fn_call": "gcdPow"
    },
    {
        "text": "largest number in an array that is not a perfect cube | python 3 program to find the largest non - perfect cube number among n numbers ; function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; traverse all elements in the array ; store the maximum if current element is a non perfect cube ; ",
        "context": "\nimport math\n\n",
        "code": "def checkPerfectcube(n):\n    cube_root = n ** (1. / 3.)\n    if round(cube_root)**3 == n:\n        return True\n    else:\n        return False\n\n\ndef largestNonPerfectcubeNumber(a, n):\n    maxi = -1\n    for i in range(0, n, 1):\n        if (checkPerfectcube(a[i]) == False):\n            maxi = max(a[i], maxi)\n    return maxi\n",
        "test": "\nif __name__ == '__main__':\n    a = [16, 64, 25, 2, 3, 10]\n    n = len(a)\n    print(largestNonPerfectcubeNumber(a, n))\n",
        "output": "25\n",
        "fn_call": "largestNonPerfectcubeNumber"
    },
    {
        "text": "centered nonadecagonal number | centered nonadecagonal function ; formula to calculate nth centered nonadecagonal number & return it into main function . ; ",
        "context": "",
        "code": "def center_nonadecagon_num(n):\n    return (19 * n * n - 19 * n + 2) // 2\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    print(n, \"nd centered nonadecagonal \" +\n          \"number : \", center_nonadecagon_num(n))\n    n = 7\n    print(n, \"nd centered nonadecagonal \" +\n          \"number : \", center_nonadecagon_num(n))\n",
        "output": "2 nd centered nonadecagonal number :  20\n7 nd centered nonadecagonal number :  400\n",
        "fn_call": "center_nonadecagon_num"
    },
    {
        "text": "count of numbers below n whose sum of prime divisors is k | python3 implementation of the approach ; function to return the count of numbers below n whose sum of prime factors is k ; to store the sum of prime factors for all the numbers ; if i is prime ; add i to all the numbers which are divisible by i ; to store the count of required numbers ; return the required count ; ",
        "context": "\nMAX = 1000001\n\n",
        "code": "def countNum(N, K):\n    sumPF = [0] * MAX\n    for i in range(2, N):\n        if (sumPF[i] == 0):\n            for j in range(i, N, i):\n                sumPF[j] += i\n    count = 0\n    for i in range(2, N):\n        if (sumPF[i] == K):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 20\n    K = 7\n    print(countNum(N, K))\n",
        "output": "2\n",
        "fn_call": "countNum"
    },
    {
        "text": "number of digits before the decimal point in the division of two numbers | function to return the number of digits before the decimal in a / b ; absolute value of a / b ; if result is 0 ; count number of digits in the result ; return the required count of digits ; ",
        "context": "",
        "code": "def countDigits(a, b):\n    count = 0\n    p = abs(a // b)\n    if (p == 0):\n        return 1\n    while (p > 0):\n        count = count + 1\n        p = p // 10\n    return count\n",
        "test": "\na = 100\nb = 10\nprint(countDigits(a, b))\n",
        "output": "2\n",
        "fn_call": "countDigits"
    },
    {
        "text": "find subarray with given sum | set 2 ( handles negative numbers ) | function to print subarray with sum as given sum ; create an empty map ; if curr_sum is equal to target sum we found a subarray starting from index 0 and ending at index i ; if curr_sum - sum already exists in map we have found a subarray with target sum ; if value is not present then add to hashmap ; if we reach here , then no subarray exists ; ",
        "context": "",
        "code": "def subArraySum(arr, n, Sum):\n    Map = {}\n    curr_sum = 0\n    for i in range(0, n):\n        curr_sum = curr_sum + arr[i]\n        if curr_sum == Sum:\n            print(\"Sum found between indexes 0 to\", i)\n            return\n        if (curr_sum - Sum) in Map:\n            print(\"Sum found between indexes\",\n                  Map[curr_sum - Sum] + 1, \"to\", i)\n            return\n        Map[curr_sum] = i\n    print(\"No subarray with given sum exists\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 2, -2, -20, 10]\n    n = len(arr)\n    Sum = -10\n    subArraySum(arr, n, Sum)\n",
        "output": "Sum found between indexes 0 to 3\n",
        "fn_call": "subArraySum"
    },
    {
        "text": "last seen array element ( last appearance is earliest ) | python3 program to find last seen element in an array . ; returns last seen element in arr [ ] ; store last occurrence index of every element ; find an element in hash with minimum index value ; ",
        "context": "\nimport sys\n\n",
        "code": "def lastSeenElement(a, n):\n    hash = {}\n    for i in range(n):\n        hash[a[i]] = i\n    res_ind = sys .maxsize\n    res = 0\n    for x, y in hash .items():\n        if y < res_ind:\n            res_ind = y\n            res = x\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 1, 2, 2, 4, 1]\n    n = len(a)\n    print(lastSeenElement(a, n))\n",
        "output": "2\n",
        "fn_call": "lastSeenElement"
    },
    {
        "text": "check if the given two numbers are friendly pair or not | check if the given two number are friendly pair or not . ; returns sum of all factors of n . ; traversing through all prime factors . ; the below statement makes it better than above method as we reduce value of n . ; this condition is to handle the case when n is a prime number greater than 2. ; function to return gcd of a and b ; function to check if the given two number are friendly pair or not . ; finding the sum of factors of n and m ; finding gcd of n and sum of its factors . ; finding gcd of m and sum of its factors . ; checking is numerator and denominator of abundancy index of both number are equal or not . ; ",
        "context": "\nimport math\n\n",
        "code": "def sumofFactors(n):\n    res = 1\n    for i in range(2, int(math .sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0):\n            count += 1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n    if (n >= 2):\n        res *= (1 + n)\n    return res\n\n\ndef gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef checkFriendly(n, m):\n    sumFactors_n = sumofFactors(n)\n    sumFactors_m = sumofFactors(m)\n    gcd_n = gcd(n, sumFactors_n)\n    gcd_m = gcd(m, sumFactors_m)\n    if (n // gcd_n == m // gcd_m and sumFactors_n //\n            gcd_n == sumFactors_m // gcd_m):\n        return True\n    else:\n        return False\n",
        "test": "\nn = 6\nm = 28\nif (checkFriendly(n, m)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkFriendly"
    },
    {
        "text": "find pair with greatest product in array | function to find greatest number ; ",
        "context": "",
        "code": "def findGreatest(arr, n):\n    result = -1\n    for i in range(n):\n        for j in range(n - 1):\n            for k in range(j + 1, n):\n                if (arr[j] * arr[k] == arr[i]):\n                    result = max(result, arr[i])\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [30, 10, 9, 3, 35]\n    n = len(arr)\n    print(findGreatest(arr, n))\n",
        "output": "30\n",
        "fn_call": "findGreatest"
    },
    {
        "text": "print a matrix in a spiral form starting from a point | python3 program to print a matrix in spiral form . ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def printSpiral(mat, r, c):\n    a = 0\n    b = 2\n    low_row = 0 if (0 > a)else a\n    low_column = 0 if (0 > b)else b - 1\n    high_row = r - 1 if ((a + 1) >= r)else a + 1\n    high_column = c - 1 if ((b + 1) >= c)else b + 1\n    while ((low_row > 0 - r and low_column > 0 - c)):\n        i = low_column + 1\n        while (i = 0):\n            print(mat[low_row][i], end=\" \")\n            i += 1\n        low_row -= 1\n        i = low_row + 2\n        while (i <= high_row and i < r and high_column < c):\n            print(mat[i][high_column], end=\" \")\n            i += 1\n        high_column += 1\n        i = high_column - 2\n        while (i >= low_column and i >= 0 and high_row < r):\n            print(mat[high_row][i], end=\" \")\n            i -= 1\n        high_row += 1\n        i = high_row - 2\n        while (i > low_row and i >= 0 and low_column >= 0):\n            print(mat[i][low_column], end=\" \")\n            i -= 1\n        low_column -= 1\n    print()\n",
        "test": "\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    r = 3\n    c = 3\n    printSpiral(mat, r, c)\n",
        "output": "3 6 5 2 9 8 7 4 1 \n",
        "fn_call": "printSpiral"
    },
    {
        "text": "row wise sorting in 2d array | python3 code to sort 2d matrix row - wise ; one by one sort individual rows . ; printing the sorted matrix ; ",
        "context": "",
        "code": "def sortRowWise(m):\n    for i in range(len(m)):\n        m[i].sort()\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            print(m[i][j], end=\" \")\n        print()\n    return 0\n",
        "test": "\nm = [[9, 8, 7, 1], [7, 3, 0, 2], [9, 5, 3, 2], [6, 3, 1, 2]]\nsortRowWise(m)\n",
        "output": "1 7 8 9 \n0 2 3 7 \n2 3 5 9 \n1 2 3 6 \n",
        "fn_call": "sortRowWise"
    },
    {
        "text": "minimum number using set bits of a given number | returns minimum number formed by bits of a given number . ; _popcnt32 ( a ) gives number of 1 's  present in binary representation  of a. ; ",
        "context": "",
        "code": "def minimize(a):\n    n = bin(a).count(\"1\")\n    return (pow(2, n) - 1)\n",
        "test": "\na = 11\nprint(minimize(a))\n",
        "output": "7\n",
        "fn_call": "minimize"
    },
    {
        "text": "lexicographic smallest permutation of a string containing the second string as a substring | function to print the desired lexicographic smaller string ; calculate length of the string ; stores the frequencies of characters of string str1 ; stores the frequencies of characters of string str2 ; decrease the frequency of second string from that of of the first string ; to store the resultant string ; to find the index of first character of the string str2 ; append the characters in lexicographical order ; append all the current character ( i + ' a ' ) ; if we reach first character of string str2 append str2 ; return the resultant string ; ",
        "context": "",
        "code": "def findSmallestString(str1, str2):\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    n1 = len(str1)\n    n2 = len(str2)\n    for i in range(n1):\n        freq1[ord(str1[i]) - ord('a')] += 1\n    for i in range(n2):\n        freq2[ord(str2[i]) - ord('a')] += 1\n    for i in range(26):\n        freq1[i] -= freq2[i]\n    res = \"\"\n    minIndex = ord(str2[0]) - ord('a')\n    for i in range(26):\n        for j in range(freq1[i]):\n            res += chr(i + ord('a'))\n        if i == minIndex:\n            res += str2\n    return res\n",
        "test": "\nstr1 = \"geeksforgeeksfor\"\nstr2 = \"for\"\nprint(findSmallestString(str1, str2))\n",
        "output": "eeeefforggkkorss\n",
        "fn_call": "findSmallestString"
    },
    {
        "text": "number of substrings of a string | python3 program to count number of substrings of a string ; ",
        "context": "",
        "code": "def countNonEmptySubstr(str):\n    n = len(str)\n    return int(n * (n + 1) / 2)\n",
        "test": "\ns = \"abcde\"\nprint(countNonEmptySubstr(s))\n",
        "output": "15\n",
        "fn_call": "countNonEmptySubstr"
    },
    {
        "text": "check if a can be converted to b by reducing with a prime number | function to find if it is possible to make a equal to b ; ",
        "context": "",
        "code": "def isPossible(A, B):\n    return (A - B > 1)\n",
        "test": "\nA = 10\nB = 4\nif (isPossible(A, B)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "longest subarray such that the difference of max and min is at | python 3 code to find longest subarray with difference between max and min as at - most 1. ; longest constant range length ; first number ; if we see same number ; if we see different number , but same as previous . ; if number is neither same as previous nor as current . ; ",
        "context": "",
        "code": "def longestSubarray(input, length):\n    prev = -1\n    prevCount = 0\n    currentCount = 1\n    longest = 1\n    current = input[0]\n    for i in range(1, length):\n        next = input[i]\n        if next == current:\n            currentCount += 1\n        elif next == prev:\n            prevCount += currentCount\n            prev = current\n            current = next\n            currentCount = 1\n        else:\n            longest = max(longest, currentCount + prevCount)\n            prev = current\n            prevCount = currentCount\n            current = next\n            currentCount = 1\n    return max(longest, currentCount + prevCount)\n",
        "test": "\nif __name__ == \"__main__\":\n    input = [5, 5, 6, 7, 6]\n    n = len(input)\n    print(longestSubarray(input, n))\n",
        "output": "3\n",
        "fn_call": "longestSubarray"
    },
    {
        "text": "find smallest value of k such that bitwise and of numbers in range [ n , n | function is to find the largest no which gives the sequence n & ( n - 1 ) & ( n - 2 ) & ... . . & ( n - k ) = 0. ; since , we need the largest no , we start from n itself , till 0 ; ",
        "context": "",
        "code": "def findSmallestNumK(n):\n    cummAnd = n\n    i = n - 1\n    while (cummAnd != 0):\n        cummAnd = cummAnd & i\n        if (cummAnd == 0):\n            return i\n        i -= 1\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    N = 17\n    lastNum = findSmallestNumK(N)\n    K = lastNum if lastNum == -1 else N - lastNum\n    print(K)\n",
        "output": "2\n",
        "fn_call": "findSmallestNumK"
    },
    {
        "text": "number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | returns value of binomial coefficient c ( n , k ) ; since c ( n , k ) = c ( n , n - k ) ; calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; a binomial coefficient based function to find nth catalan number in o ( n ) time ; calculate value of 2 ncn ; return 2 ncn / ( n + 1 ) ; ",
        "context": "",
        "code": "def binomialCoeff(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(k):\n        res *= (n - i)\n        res /= (i + 1)\n    return res\n\n\ndef catalan(n):\n    c = binomialCoeff(2 * n, n)\n    return int(c / (n + 1))\n",
        "test": "\nn = 3\nprint(catalan(n))\n",
        "output": "5\n",
        "fn_call": "catalan"
    },
    {
        "text": "number of pairs such that path between pairs has the two vertices a and b | python 3 program to find the number of pairs such that the path between every pair contains two given vertices ; function to perform dfs on the given graph by fixing the a vertex ; to mark a particular vertex as visited ; variable to store the count of the vertices which can be reached from a ; performing the dfs by iterating over the visited array ; if the vertex is not visited and removing the vertex b ; function to return the number of pairs such that path between any two pairs consists of the given two vertices a and b ; initializing the visited array and assigning it with 0 's ; initially , the count of vertices is 0 ; performing dfs by removing the vertex b ; count the vertices which cannot be reached after removing the vertex b ; again reinitializing the visited array ; setting the count of vertices to 0 to perform the dfs again ; performing the dfs by removing the vertex a ; count the vertices which cannot be reached after removing the vertex a ; multiplying both the vertices set ; ",
        "context": "\nN = 1000001\nc = 0\nn = 0\nm = 0\na = 0\nb = 0\n\n",
        "code": "def dfs(a, b, v, vis):\n    global c\n    vis[a] = 1\n    c += 1\n    for i in v[a]:\n        if (vis[i] == 0 and i != b):\n            dfs(i, b, v, vis)\n\n\ndef Calculate(v):\n    global c\n    vis = [0 for i in range(n + 1)]\n    c = 0\n    dfs(a, b, v, vis)\n    ans1 = n - c - 1\n    vis = [0 for i in range(len(vis))]\n    c = 0\n    dfs(b, a, v, vis)\n    ans2 = n - c - 1\n    print(ans1 * ans2)\n",
        "test": "\nif __name__ == '__main__':\n    n = 7\n    m = 7\n    a = 3\n    b = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 5]]\n    v = [[]for i in range(n + 1)]\n    for i in range(m):\n        v[edges[i][0]].append(edges[i][1])\n        v[edges[i][1]].append(edges[i][0])\n    Calculate(v)\n",
        "output": "4\n",
        "fn_call": "Calculate"
    },
    {
        "text": "longest substring of vowels with no two adjacent alphabets same | function to check a character is vowel or not ; function to check a substring is valid or not ; if size is 1 then check only first character ; if 0 'th character is  not vowel then invalid ; if two adjacent characters are same or i 'th char is  not vowel then invalid ; function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; stores max length of valid substring ; for current substring ; check if substring is valid ; size of substring is ( j - i + 1 ) ; ",
        "context": "",
        "code": "def isVowel(c):\n    return (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u')\n\n\ndef isValid(s):\n    n = len(s)\n    if (n == 1):\n        return (isVowel(s[0]))\n    if (isVowel(s[0]) == False):\n        return False\n    for i in range(1, n):\n        if (s[i] == s[i - 1] or not isVowel(s[i])):\n            return False\n    return True\n\n\ndef findMaxLen(s):\n    maxLen = 0\n    n = len(s)\n    for i in range(n):\n        temp = \"\"\n        for j in range(i, n):\n            temp = temp + s[j]\n            if (isValid(temp)):\n                maxLen = (max(maxLen, (j - i + 1)))\n    return maxLen\n",
        "test": "\nif __name__ == \"__main__\":\n    Str = \"aeoibsddaeiouudb\"\n    print(findMaxLen(Str))\n",
        "output": "5\n",
        "fn_call": "findMaxLen"
    },
    {
        "text": "check if bits of a number has count of consecutive set bits in increasing order | returns true if n has increasing count of continuous - 1 else false ; store the bit - pattern of n into bit bitset - bp ; set prev_count = 0 and curr_count = 0. ; increment current count of continuous - 1 ; traverse all continuous - 0 ; check prev_count and curr_count on encounter of first zero after continuous - 1 s ; check for last sequence of continuous - 1 ; ",
        "context": "",
        "code": "def findContinuous1(n):\n    bp = list(bin(n))\n    bits = len(bp)\n    prev_count = 0\n    curr_count = 0\n    i = 0\n    while (i < bits):\n        if (bp[i] == '1'):\n            curr_count += 1\n            i += 1\n        elif (bp[i - 1] == '0'):\n            i += 1\n            curr_count = 0\n            continue\n        else:\n            if (curr_count < prev_count):\n                return 0\n            i += 1\n            prev_count = curr_count\n            curr_count = 0\n    if (prev_count > curr_count and (curr_count != 0)):\n        return 0\n    return 1\n",
        "test": "\nn = 179\nif (findContinuous1(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "findContinuous1"
    },
    {
        "text": "number formed by the rightmost set bit in n | function to return the integer formed by taking the rightmost set bit in n ; n & ( n - 1 ) unsets the first set bit from the right in n ; take xor with the original number the position of the ' changed \u2581 bit ' will be set and rest will be unset ; ",
        "context": "",
        "code": "def firstSetBit(n):\n    x = n & (n - 1)\n    return (n ^ x)\n",
        "test": "\nn = 12\nprint(firstSetBit(n))\n",
        "output": "4\n",
        "fn_call": "firstSetBit"
    },
    {
        "text": "program to calculate e ^ x by recursion ( using taylor series ) | recursive function global variables p and f ; termination condition ; recursive call ; update the power of x ; factorial ; ",
        "context": "\np = 1.0\nf = 1.0\n\n",
        "code": "def e(x, n):\n    global p, f\n    if (n == 0):\n        return 1\n    r = e(x, n - 1)\n    p = p * x\n    f = f * n\n    return (r + p / f)\n",
        "test": "\nx = 4\nn = 15\nprint(e(x, n))\n",
        "output": "54.5978829056501\n",
        "fn_call": "e"
    },
    {
        "text": "find the sum of power of bit count raised to the power b | function to calculate a ^ b mod m using fast - exponentiation method ; function to calculate sum ; itereate for all values of array a ; calling fast - exponentiation and appending ans to sum ; ",
        "context": "",
        "code": "def fastmod(base, exp, mod):\n    if (exp == 0):\n        return 1\n    elif (exp % 2 == 0):\n        ans = fastmod(base, exp / 2, mod)\n        return (ans % mod * ans % mod) % mod\n    else:\n        return (fastmod(base, exp - 1, mod) % mod * base % mod) % mod\n\n\ndef findPowerSum(n, ar):\n    mod = int(1e9) + 7\n    sum = 0\n    for i in range(n):\n        base = bin(ar[i]).count('1')\n        exp = ar[i]\n        sum += fastmod(base, exp, mod)\n        sum %= mod\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    ar = [1, 2, 3]\n    print(findPowerSum(n, ar))\n",
        "output": "10\n",
        "fn_call": "findPowerSum"
    },
    {
        "text": "maximum bitwise and pair ( x , y ) from given range such that x and y can be same | function to return the maximum bitwise and ; ",
        "context": "",
        "code": "def maximumAND(L, R):\n    return R\n",
        "test": "\nif __name__ == '__main__':\n    l = 3\n    r = 7\n    print(maximumAND(l, r))\n",
        "output": "7\n",
        "fn_call": "maximumAND"
    },
    {
        "text": "print the kth common factor of two numbers | returns k 'th common factor of x and y. ; find smaller of two numbers ; count common factors until we either reach small or count becomes k . ; if we reached small ; ",
        "context": "",
        "code": "def findKHCF(x, y, k):\n    small = min(x, y)\n    count = 1\n    for i in range(2, small + 1):\n        if (x % i == 0 and y % i == 0):\n            count = count + 1\n        if (count == k):\n            return i\n    return -1\n",
        "test": "\nx = 4\ny = 24\nk = 3\nprint(findKHCF(x, y, k))\n",
        "output": "4\n",
        "fn_call": "findKHCF"
    },
    {
        "text": "next higher number with same number of set bits | this function returns next higher number with same number of set bits as x . ; right most set bit ; reset the pattern and set next higher bit left part of x will be here ; nexthigheronebit is now part [ d ] of the above explanation . isolate the pattern ; right adjust pattern ; correction factor ; rightonespattern is now part [ a ] of the above explanation . integrate new pattern ( add [ d ] and [ a ] ) ; ",
        "context": "",
        "code": "def snoob(x):\n    next = 0\n    if (x):\n        rightOne = x & -(x)\n        nextHigherOneBit = x + int(rightOne)\n        rightOnesPattern = x ^ int(nextHigherOneBit)\n        rightOnesPattern = (int(rightOnesPattern) / int(rightOne))\n        rightOnesPattern = int(rightOnesPattern) >> 2\n        next = nextHigherOneBit | rightOnesPattern\n    return next\n",
        "test": "\nx = 156\nprint(\"Next higher number with \" + \"same number of set bits is\", snoob(x))\n",
        "output": "Next higher number with same number of set bits is 163\n",
        "fn_call": "snoob"
    },
    {
        "text": "minimum minutes needed to make the time palindromic | function to get the required minutes ; storing hour and minute value in integral form ; keep iterating till first digit hour becomes equal to second digit of minute and second digit of hour becomes equal to first digit of minute ; if mins is 60 , increase hour , and reinitilialized to 0 ; if hours is 60 , reinitialized to 0 ; return the required time ; ",
        "context": "",
        "code": "def get_palindrome_time(str):\n    hh = ((ord(str[0]) - 48) * 10 + (ord(str[1]) - 48))\n    mm = ((ord(str[3]) - 48) * 10 + (ord(str[4]) - 48))\n    requiredTime = 0\n    while (hh % 10 != mm // 10 or hh // 10 != mm % 10):\n        mm += 1\n        if (mm == 60):\n            mm = 0\n            hh += 1\n        if (hh == 24):\n            hh = 0\n        requiredTime += 1\n    return requiredTime\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"05:39\"\n    print(get_palindrome_time(str))\n",
        "output": "11\n",
        "fn_call": "get_palindrome_time"
    },
    {
        "text": "find index of the element differing in parity with all other array elements | function to prthe element which differs in parity ; stores the count of odd and even array elements encountered ; stores the indices of the last odd and even array elements encountered ; traverse the array ; if array element is even ; otherwise ; if only one odd element is present in the array ; if only one even element is present in the array ; ",
        "context": "",
        "code": "def oddOneOut(arr, N):\n    odd = 0\n    even = 0\n    lastOdd = 0\n    lastEven = 0\n    for i in range(N):\n        if (arr[i] % 2 == 0):\n            even += 1\n            lastEven = i\n        else:\n            odd += 1\n            lastOdd = i\n    if (odd == 1):\n        print(lastOdd)\n    else:\n        print(lastEven)\n",
        "test": "\narr = [2, 4, 7, 8, 10]\nN = len(arr)\noddOneOut(arr, N)\n",
        "output": "2\n",
        "fn_call": "oddOneOut"
    },
    {
        "text": "queries to find whether a number has exactly four distinct factors or not | initialize global variable according to given condition so that it can be accessible to all function ; function to calculate all number having four distinct factors ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; initialize prime [ ] array which will contain all the primes from 1 - n ; iterate over all the prime numbers ; mark cube root of prime numbers ; mark product of prime numbers ; ",
        "context": "\nN = 1000001\nfourDiv = [False] * (N + 1)\n\n",
        "code": "def fourDistinctFactors():\n    primeAll = [True] * (N + 1)\n    p = 2\n    while (p * p <= N):\n        if (primeAll[p]):\n            i = p * 2\n            while (i <= N):\n                primeAll[i] = False\n                i += p\n        p += 1\n    prime = []\n    for p in range(2, N + 1):\n        if (primeAll[p]):\n            prime .append(p)\n    for i in range(len(prime)):\n        p = prime[i]\n        if (1 * p * p * p <= N):\n            fourDiv[p * p * p] = True\n        for j in range(i + 1, len(prime)):\n            q = prime[j]\n            if (1 * p * q > N):\n                break\n            fourDiv[p * q] = True\n",
        "test": "\nfourDistinctFactors()\nnum = 10\nif (fourDiv[num]):\n    print(\"Yes\")\nelse:\n    print(\"No\")\nnum = 12\nif (fourDiv[num]):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\nNo\n",
        "fn_call": "fourDistinctFactors"
    },
    {
        "text": "program to insert dashes between two adjacent odd digits in given number | function to check if char ch is odd or not ; function to insert dash - between any 2 consecutive digit in string str ; traverse the string character by character ; compare every consecutive character with the odd value ; print the resultant string ; ",
        "context": "",
        "code": "def checkOdd(ch):\n    return ((ord(ch) - 48) & 1)\n\n\ndef Insert_dash(num_str):\n    result_str = num_str\n    x = 0\n    while (x < len(num_str) - 1):\n        if (checkOdd(num_str[x]) and checkOdd(num_str[x + 1])):\n            result_str = (result_str[:x + 1] + '-' + result_str[x + 1:])\n            num_str = result_str\n            x += 1\n        x += 1\n    return result_str\n",
        "test": "\nstr = \"1745389\"\nprint(Insert_dash(str))\n",
        "output": "1-745-389\n",
        "fn_call": "Insert_dash"
    },
    {
        "text": "find quotient and remainder of two integer without using division operators | function to the quotient and remainder ; check if start is greater than the end ; calculate mid ; check if n is greater than divisor then increment the mid by 1 ; check if n is less than 0 then decrement the mid by 1 ; check if n equals to divisor ; return the final answer ; recursive calls ; ",
        "context": "",
        "code": "def find(dividend, divisor, start, end):\n    if (start > end):\n        return (0, dividend)\n    mid = start + (end - start) // 2\n    n = dividend - divisor * mid\n    if (n > divisor):\n        start = mid + 1\n    elif (n < 0):\n        end = mid - 1\n    else:\n        if (n == divisor):\n            mid += 1\n            n = 0\n        return (mid, n)\n    return find(dividend, divisor, start, end)\n\n\ndef divide(dividend, divisor):\n    return find(dividend, divisor, 1, dividend)\n",
        "test": "\nif __name__ == \"__main__\":\n    dividend = 10\n    divisor = 3\n    ans = divide(dividend, divisor)\n    print(ans[0], \", \", ans[1])\n",
        "output": "3 ,  1\n",
        "fn_call": "divide"
    },
    {
        "text": "smallest multiple of n formed using the given set of digits | function to return the required number ; initialize both vectors with their initial values ; sort the vector of digits ; initialize the queue ; if modulus value is not present in the queue ; compute digits modulus given number and update the queue and vectors ; while queue is not empty ; remove the first element of the queue ; compute new modulus values by using old queue values and each digit of the set ; if value is not present in the queue ; if required condition can 't be satisfied  ; initialize new vector ; constructing the solution by backtracking ; reverse the vector ; return the required number ; ",
        "context": "",
        "code": "def findSmallestNumber(arr, n):\n    dp = [float('inf')] * n\n    result = [(-1, 0)] * n\n    arr .sort()\n    q = []\n    for i in arr:\n        if i != 0:\n            if dp[i % n] > 10 ** 9:\n                q .append(i % n)\n                dp[i % n] = 1\n                result[i % n] = -1, i\n    while len(q) > 0:\n        u = q .pop(0)\n        for i in arr:\n            v = (u * 10 + i) % n\n            if dp[u] + 1 < dp[v]:\n                dp[v] = dp[u] + 1\n                q .append(v)\n                result[v] = u, i\n    if dp[0] > 10 ** 9:\n        return -1\n    else:\n        ans = []\n        u = 0\n        while u != -1:\n            ans .append(result[u][1])\n            u = result[u][0]\n        ans = ans[::-1]\n        for i in ans:\n            return i\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 2, 3]\n    n = 12\n    print(findSmallestNumber(arr, n))\n",
        "output": "2\n",
        "fn_call": "findSmallestNumber"
    },
    {
        "text": "sum of f ( a [ i ] , a [ j ] ) over all pairs in an array of n integers | function to calculate the sum ; map to keep a count of occurrences ; traverse in the list from start to end number of times a [ i ] can be in a pair and to get the difference we subtract pre_sum . ; if the ( a [ i ] - 1 ) is present then subtract that value as f ( a [ i ] , a [ i ] - 1 ) = 0 ; if the ( a [ i ] + 1 ) is present then add that value as f ( a [ i ] , a [ i ] - 1 ) = 0 here we add as a [ i ] - ( a [ i ] - 1 ) < 0 which would have been added as negative sum , so we add to remove this pair from the sum value ; keeping a counter for every element ; ",
        "context": "",
        "code": "def sum(a, n):\n    cnt = dict()\n    ans = 0\n    pre_sum = 0\n    for i in range(n):\n        ans += (i * a[i]) - pre_sum\n        pre_sum += a[i]\n        if (a[i] - 1) in cnt:\n            ans -= cnt[a[i] - 1]\n        if (a[i] + 1) in cnt:\n            ans += cnt[a[i] + 1]\n        if a[i]not in cnt:\n            cnt[a[i]] = 0\n        cnt[a[i]] += 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 2, 3, 1, 3]\n    n = len(a)\n    print(sum(a, n))\n",
        "output": "4\n",
        "fn_call": "sum"
    },
    {
        "text": "lexicographical concatenation of all substrings of a string | python program to create concatenation of all substrings in lexicographic order . ; creating an array to store substrings ; finding all substrings of string ; sort all substrings in lexicographic order ; concatenating all substrings ; ",
        "context": "",
        "code": "def lexicographicSubConcat(s):\n    n = len(s)\n    sub_count = (n * (n + 1)) // 2\n    arr = [0] * sub_count\n    index = 0\n    for i in range(n):\n        for j in range(1, n - i + 1):\n            arr[index] = s[i:i + j]\n            index += 1\n    arr .sort()\n    res = \"\"\n    for i in range(sub_count):\n        res += arr[i]\n    return res\n",
        "test": "\ns = \"abc\"\nprint(lexicographicSubConcat(s))\n",
        "output": "aababcbbcc\n",
        "fn_call": "lexicographicSubConcat"
    },
    {
        "text": "count of distinct strings possible by swapping prefixes of pairs of strings from the array | python3 program to implement the above approach ; function to count the distinct strings possible after swapping the prefixes between two possible strings of the array ; stores the count of unique characters for each index ; store current string ; stores the total number of distinct strings possible ; return the answer ; ",
        "context": "\nfrom collections import defaultdict\nmod = 1000000007\n\n",
        "code": "def countS(string: list, n: int, m: int) -> int:\n    counts = defaultdict(lambda: set())\n    for i in range(n):\n        s = string[i]\n        for j in range(m):\n            counts[j].add(s[j])\n    result = 1\n    for index in counts:\n        result = (result * len(counts[index])) % mod\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    string = [\"112\", \"211\"]\n    N = 2\n    M = 3\n    print(countS(string, N, M))\n",
        "output": "4\n",
        "fn_call": "countS"
    },
    {
        "text": "sum of series 2 / 3 | function to find sum of series up - to n terms ; initializing counter by 1 ; variable to calculate result ; while loop until nth term is not reached ; boolean type variable for checking validation ; ",
        "context": "",
        "code": "def seriesSum(n):\n    i = 1\n    res = 0.0\n    sign = True\n    while (n > 0):\n        n = n - 1\n        if (sign):\n            sign = False\n            res = res + (i + 1) / (i + 2)\n            i = i + 2\n        else:\n            sign = True\n            res = res - (i + 1) / (i + 2)\n            i = i + 2\n    return res\n",
        "test": "\nn = 5\nprint(round(seriesSum(n), 6))\n",
        "output": "0.744012\n",
        "fn_call": "seriesSum"
    },
    {
        "text": "pair of integers ( a , b ) which satisfy the given equations | function to count valid pairs ; ",
        "context": "",
        "code": "def pairCount(n, m):\n    cnt = 0\n    for b in range(int(pow(m, 1 / 2))):\n        a = m - b * b\n        if (a * a + b == n):\n            cnt += 1\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    n = 9\n    m = 3\n    print(pairCount(n, m))\n",
        "output": "1\n",
        "fn_call": "pairCount"
    },
    {
        "text": "check whether the vowels in a string are in alphabetical order or not | function that checks whether the vowel characters in a string are in alphabetical order or not ; ascii value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; ",
        "context": "",
        "code": "def areVowelsInOrder(s):\n    n = len(s)\n    c = chr(64)\n    for i in range(0, n):\n        if (s[i] == 'a' or s[i] == 'e' or s[i] ==\n                'i' or s[i] == 'o' or s[i] == 'u'):\n            if s[i] < c:\n                return False\n            else:\n                c = s[i]\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"aabbbddeecc\"\n    if areVowelsInOrder(s):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "areVowelsInOrder"
    },
    {
        "text": "count 1 s in binary matrix having remaining indices of its row and column filled with 0 s | function to count required 1 s from the given matrix ; stores the dimensions of the mat ; calculate sum of rows ; calculate sum of columns ; stores required count of 1 s ; if current cell is 1 and sum of row and column is 1 ; increment count of 1 s ; return the final count ; ",
        "context": "",
        "code": "def numSpecial(mat):\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m\n    cols = [0] * n\n    i, j = 0, 0\n    for i in range(m):\n        rows[i] = 0\n        for j in range(n):\n            rows[i] += mat[i][j]\n    for i in range(n):\n        cols[i] = 0\n        for j in range(m):\n            cols[i] += mat[j][i]\n    cnt = 0\n    for i in range(m):\n        for j in range(n):\n            if (mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1):\n                cnt += 1\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[1, 0, 0], [0, 0, 1], [0, 0, 0]]\n    print(numSpecial(mat))\n",
        "output": "2\n",
        "fn_call": "numSpecial"
    },
    {
        "text": "program to print all substrings of a given string | * function to print all ( n * ( n + 1 ) ) / 2 * substrings of a given string s of length n . ; fix start index in outer loop . reveal new character in inner loop till end of string . prtill - now - formed string . ; ",
        "context": "",
        "code": "def printAllSubstrings(s, n):\n    for i in range(n):\n        temp = \"\"\n        for j in range(i, n):\n            temp += s[j]\n            print(temp)\n",
        "test": "\ns = \"Geeky\"\nprintAllSubstrings(s, len(s))\n",
        "output": "G\nGe\nGee\nGeek\nGeeky\ne\nee\neek\neeky\ne\nek\neky\nk\nky\ny\n",
        "fn_call": "printAllSubstrings"
    },
    {
        "text": "finding n | a formula based python program to find sum of series with cubes of first n natural numbers ; ",
        "context": "",
        "code": "def magicOfSequence(N):\n    return (N * (N + 1) / 2) + 2 * N\n",
        "test": "\nN = 6\nprint(int(magicOfSequence(N)))\n",
        "output": "33\n",
        "fn_call": "magicOfSequence"
    },
    {
        "text": "pair with given sum and maximum shortest distance from end | function to find maximum shortest distance ; stores the shortest distance of every element in original array . ; shortest distance from ends ; if duplicates are found , b [ x ] is replaced with minimum of the previous and current position 's  shortest distance ; similar elements ignore them cause we need distinct elements ; ",
        "context": "",
        "code": "def find_maximum(a, n, k):\n    b = dict()\n    for i in range(n):\n        x = a[i]\n        d = min(1 + i, n - i)\n        if x not in b .keys():\n            b[x] = d\n        else:\n            b[x] = min(d, b[x])\n    ans = 10 ** 9\n    for i in range(n):\n        x = a[i]\n        if (x != (k - x) and (k - x) in b .keys()):\n            ans = min(max(b[x], b[k - x]), ans)\n    return ans\n",
        "test": "\na = [3, 5, 8, 6, 7]\nK = 11\nn = len(a)\nprint(find_maximum(a, n, K))\n",
        "output": "2\n",
        "fn_call": "find_maximum"
    },
    {
        "text": "count of numbers in a range where digit d occurs exactly k times | python program to find the count of numbers in a range where digit d occurs exactly k times ; states - position , count , tight , nonz ; d is required digit and k is occurrence ; this function returns the count of required numbers from 0 to num ; last position ; if this result is already computed simply return it ; maximum limit upto which we can place digit . if tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; nonz is true if we placed a non zero digit at the starting of the number ; at this position , number becomes smaller ; next recursive call , also set nonz to 1 if current digit is non zero ; function to convert x into its digit vector and uses count ( ) function to return the required count ; initialize dp ; ",
        "context": "\nM = 20\ndp = []\nd, K = None, None\n\n",
        "code": "def count(pos, cnt, tight, nonz, num: list):\n    if pos == len(num):\n        if cnt == K:\n            return 1\n        return 0\n    if dp[pos][cnt][tight][nonz] != -1:\n        return dp[pos][cnt][tight][nonz]\n    ans = 0\n    limit = 9 if tight else num[pos]\n    for dig in range(limit + 1):\n        currCnt = cnt\n        if dig == d:\n            if d != 0 or not d and nonz:\n                currCnt += 1\n        currTight = tight\n        if dig < num[pos]:\n            currTight = 1\n        ans += count(pos + 1, currCnt, currTight, (nonz or dig != 0), num)\n    dp[pos][cnt][tight][nonz] = ans\n    return dp[pos][cnt][tight][nonz]\n\n\ndef solve(x):\n    global dp, K, d\n    num = []\n    while x:\n        num .append(x % 10)\n        x //= 10\n    num .reverse()\n    dp = [[[[-1, -1]for i in range(2)]for j in range(M)]for k in range(M)]\n    return count(0, 0, 0, 0, num)\n",
        "test": "\nif __name__ == \"__main__\":\n    L = 11\n    R = 100\n    d = 2\n    K = 1\n    print(solve(R) - solve(L - 1))\n",
        "output": "17\n",
        "fn_call": "solve"
    },
    {
        "text": "xor of all possible pairwise sum from two given arrays | function to calculate the sum of xor of the sum of every pair ; stores the xor of sums of every pair ; iterate to generate all possible pairs ; update xor ; return the answer ; ",
        "context": "",
        "code": "def XorSum(A, B, N):\n    ans = 0\n    for i in range(N):\n        for j in range(N):\n            ans = ans ^ (A[i] + B[j])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [4, 6, 0, 0, 3, 3]\n    B = [0, 5, 6, 5, 0, 3]\n    N = len(A)\n    print(XorSum(A, B, N))\n",
        "output": "8\n",
        "fn_call": "XorSum"
    },
    {
        "text": "check if one of the numbers is one 's complement of the other | function to check if all the bits are set or not in the binary representation of 'n ; all bits are not set ; if true , then all bits are set ; else all bits are not set ; function to check if one of the two numbers is one 's complement of the other ; ",
        "context": "",
        "code": "def areAllBitsSet(n):\n    if (n == 0):\n        return False\n    if (((n + 1) & n) == 0):\n        return True\n    return False\n\n\ndef isOnesComplementOfOther(a, b):\n    return areAllBitsSet(a ^ b)\n",
        "test": "\na = 1\nb = 14\nif (isOnesComplementOfOther(a, b)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isOnesComplementOfOther"
    },
    {
        "text": "find all angles of a given triangle | python3 code to find all three angles of a triangle given coordinate of all three vertices ; returns square of distance b / w two points ; square of lengths be a2 , b2 , c2 ; length of sides be a , b , c ; from cosine law ; converting to degree ; printing all the angles ; ",
        "context": "\nimport math\n\n",
        "code": "def lengthSquare(X, Y):\n    xDiff = X[0] - Y[0]\n    yDiff = X[1] - Y[1]\n    return xDiff * xDiff + yDiff * yDiff\n\n\ndef printAngle(A, B, C):\n    a2 = lengthSquare(B, C)\n    b2 = lengthSquare(A, C)\n    c2 = lengthSquare(A, B)\n    a = math .sqrt(a2)\n    b = math .sqrt(b2)\n    c = math .sqrt(c2)\n    alpha = math .acos((b2 + c2 - a2) / (2 * b * c))\n    betta = math .acos((a2 + c2 - b2) / (2 * a * c))\n    gamma = math .acos((a2 + b2 - c2) / (2 * a * b))\n    alpha = alpha * 180 / math .pi\n    betta = betta * 180 / math .pi\n    gamma = gamma * 180 / math .pi\n    print(\"alpha : %f\" % (alpha))\n    print(\"betta : %f\" % (betta))\n    print(\"gamma : %f\" % (gamma))\n",
        "test": "\nA = (0, 0)\nB = (0, 1)\nC = (1, 0)\nprintAngle(A, B, C)\n",
        "output": "alpha : 90.000000\nbetta : 45.000000\ngamma : 45.000000\n",
        "fn_call": "printAngle"
    },
    {
        "text": "smallest element in an array that is repeated exactly ' k ' times . | python program to find smallest number in array that is repeated exactly ' k ' times . ; finds the smallest number in arr [ ] ; computing frequencies of all elements ; finding the smallest element with frequency as k ; if frequency of any of the number is equal to k starting from 0 then return the number ; ",
        "context": "\nMAX = 1000\n\n",
        "code": "def findDuplicate(arr, n, k):\n    freq = [0 for i in range(MAX)]\n    for i in range(n):\n        if (arr[i]  MAX):\n            print(\"Out of range\")\n            return -1\n        freq[arr[i]] += 1\n    for i in range(MAX):\n        if (freq[i] == k):\n            return i\n    return -1\n",
        "test": "\narr = [2, 2, 1, 3, 1]\nk = 2\nn = len(arr)\nprint(findDuplicate(arr, n, k))\n",
        "output": "1\n",
        "fn_call": "findDuplicate"
    },
    {
        "text": "make all array elements equal by repeated subtraction of absolute difference of pairs from their maximum | function to return gcd of a and b ; base case ; recursive call ; function to find gcd of array ; initialise the result ; traverse the array arr [ ] ; update result as gcd of the result and arr [ i ] ; return the resultant gcd ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef findGCD(arr, N):\n    result = 0\n    for element in arr:\n        result = gcd(result, element)\n        if (result == 1):\n            return 1\n    return result\n",
        "test": "\narr = [2, 3, 4]\nN = len(arr)\nprint(findGCD(arr, N))\n",
        "output": "1\n",
        "fn_call": "findGCD"
    },
    {
        "text": "sum of xor of all subarrays | function to calculate the sum of xor of all subarrays ; variable to store the final sum ; multiplier ; variable to store number of sub - arrays with odd number of elements with ith bits starting from the first element to the end of the array ; variable to check the status of the odd - even count while calculating c_odd ; loop to calculate initial value of c_odd ; loop to iterate through all the elements of the array and update sum ; updating the multiplier ; returning the sum ; ",
        "context": "",
        "code": "def findXorSum(arr, n):\n    Sum = 0\n    mul = 1\n    for i in range(30):\n        c_odd = 0\n        odd = 0\n        for j in range(n):\n            if ((arr[j] & (1  0):\n                odd = (~odd)\n            if (odd):\n                c_odd += 1\n        for j in range(n):\n            Sum += (mul * c_odd)\n            if ((arr[j] & (1  0):\n                c_odd = (n - j - c_odd)\n        mul *= 2\n    return Sum\n",
        "test": "\narr = [3, 8, 13]\nn = len(arr)\nprint(findXorSum(arr, n))\n",
        "output": "46\n",
        "fn_call": "findXorSum"
    },
    {
        "text": "Check whether factorial of N is divisible by sum of first N natural numbers | Function to check whether a number is prime or not . ; Count variable to store the number of factors of 'num ; Counting the number of factors ; If number is prime return true ; Function to check for divisibility ; if ' n ' equals 1 then divisibility is possible ; Else check whether ' n + 1' is prime or not ; If ' n + 1' is prime then ' n ! ' is not divisible by 'n*(n+1)/2 ; else divisibility occurs ; Test for n = 3 ; Test for n = 4",
        "context": "",
        "code": "def is_prime(num):\n    count = 0\n    for i in range(1, num + 1):\n\n        if i * i > num:\n            break\n\n        if ((num) % i == 0):\n\n            if (i * i != (num)):\n                count += 2\n            else:\n                count += 1\n    if (count == 2):\n        return True\n    else:\n        return False\n\n\ndef is_divisible(n):\n    if (n == 1):\n        return \"YES\"\n    else:\n        if (is_prime(n + 1)):\n            return \"NO\"\n        else:\n            return \"YES\"\n",
        "test": "\nn = 3\n\nprint(is_divisible(n))\nn = 4\n\nprint(is_divisible(n))\n",
        "output": "YES\nNO\n",
        "fn_call": "is_divisible"
    },
    {
        "text": "print list items containing all characters of a given word | python program to print the list items containing all characters of a given word ; prints list items having all characters of word ; set the values in map ; get the length of given word ; check each item of list if has all characters of words ; unset the bit so that strings like sss not printed ; set the values in map for next item ; ",
        "context": "\nNO_OF_CHARS = 256\n\n",
        "code": "def printList(list, word, list_size):\n    map = [0] * NO_OF_CHARS\n    for i in word:\n        map[ord(i)] = 1\n    word_size = len(word)\n    for i in list:\n        count = 0\n        for j in i:\n            if map[ord(j)]:\n                count += 1\n                map[ord(j)] = 0\n        if count == word_size:\n            print(i)\n        for j in range(len(word)):\n            map[ord(word[j])] = 1\n",
        "test": "\nstring = \"sun\"\nlist = [\"geeksforgeeks\", \"unsorted\", \"sunday\", \"just\", \"sss\"]\nprintList(list, string, 5)\n",
        "output": "unsorted\nsunday\n",
        "fn_call": "printList"
    },
    {
        "text": "count of all even numbers in the range [ l , r ] whose sum of digits is divisible by 3 | function to return the sum of digits of x ; function to return the count of required numbers ; if i is divisible by 2 and sum of digits of i is divisible by 3 ; return the required count ; ",
        "context": "",
        "code": "def sumOfDigits(x):\n    sum = 0\n    while x != 0:\n        sum += x % 10\n        x = x // 10\n    return sum\n\n\ndef countNumbers(l, r):\n    count = 0\n    for i in range(l, r + 1):\n        if i % 2 == 0 and sumOfDigits(i) % 3 == 0:\n            count += 1\n    return count\n",
        "test": "\nl = 1000\nr = 6000\nprint(countNumbers(l, r))\n",
        "output": "834\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "minimum operations required to convert all characters of a string to a given character | function to find the minimum number of operations required ; maximum number of characters that can be changed in one operation ; if length of the less than maximum number of characters that can be changed in an operation ; set the last index as the index for the operation ; otherwise ; if size of the is equal to the maximum number of characters in an operation ; find the number of operations required ; find the starting position ; print i - th index ; shift to next index ; otherwise ; find the number of operations required ; if n % div exceeds k ; print i - th index ; shift to next index ; ",
        "context": "",
        "code": "def countOperations(n, k):\n    div = 2 * k + 1\n    if (n // 2 <= k):\n        print(1)\n        if (n > k):\n            print(k + 1)\n        else:\n            print(n)\n    else:\n        if (n % div == 0):\n            oprn = n // div\n            print(oprn)\n            pos = k + 1\n            print(pos, end=\" \")\n            for i in range(1, oprn + 1):\n                print(pos, end=\" \")\n                pos += div\n        else:\n            oprn = n // div + 1\n            print(oprn)\n            pos = n % div\n            if (n % div > k):\n                pos -= k\n            for i in range(1, oprn + 1):\n                print(pos, end=\" \")\n                pos += div\n",
        "test": "\nif __name__ == '__main__':\n    str = \"edfreqwsazxet\"\n    ch = '$'\n    n = len(str)\n    k = 4\n    countOperations(n, k)\n",
        "output": "2\n4 13 ",
        "fn_call": "countOperations"
    },
    {
        "text": "minimum multiplications with { 2 , 3 , 7 } to make two numbers equal | function to find powers of 2 , 3 and 7 in x ; to keep count of each divisor ; to store the result ; count powers of 2 in x ; count powers of 3 in x ; count powers of 7 in x ; remaining number which is not divisible by 2 , 3 or 7 ; function to return the minimum number of given operations required to make a and b equal ; a = x * 2 ^ a1 * 3 ^ a2 * 7 ^ a3 va [ 0 ] = a1 va [ 1 ] = a2 va [ 2 ] = a3 va [ 3 ] = x ; similarly for b ; if a and b cannot be made equal with the given operation . note that va [ 3 ] and vb [ 3 ] contain remaining numbers after repeated divisions with 2 , 3 and 7. if remaining numbers are not same then we cannot make them equal . ; minimum number of operations required ; ",
        "context": "",
        "code": "def Divisors(x):\n    c = 0\n    v = []\n    while (x % 2 == 0):\n        c += 1\n        x /= 2\n    v .append(c)\n    c = 0\n    while (x % 3 == 0):\n        c += 1\n        x /= 3\n    v .append(c)\n    c = 0\n    while (x % 7 == 0):\n        c += 1\n        x /= 7\n    v .append(c)\n    v .append(x)\n    return v\n\n\ndef MinOperations(a, b):\n    va = Divisors(a)\n    vb = Divisors(b)\n    if (va[3] != vb[3]):\n        return -1\n    minOperations = abs(va[0] - vb[0]) + \\\n        abs(va[1] - vb[1]) + abs(va[2] - vb[2])\n    return minOperations\n",
        "test": "\nif __name__ == '__main__':\n    a = 14\n    b = 28\n    print(MinOperations(a, b))\n",
        "output": "1\n",
        "fn_call": "MinOperations"
    },
    {
        "text": "program to find the nth natural number with exactly two bits set | set 2 | function to find the nth number with exactly two bits set ; initialize variables ; initialize the range in which the value of ' a ' is present ; perform binary search ; find the mid value ; update the range using the mid value t ; find b value using a and n ; print the value 2 ^ a + 2 ^ b ; ",
        "context": "",
        "code": "def findNthNum(N):\n    last_num = 0\n    left = 1\n    right = N\n    while (left <= right):\n        mid = left + (right - left) // 2\n        t = (mid * (mid + 1)) // 2\n        if (t < N):\n            left = mid + 1\n        elif (t == N):\n            a = mid\n            break\n        else:\n            a = mid\n            right = mid - 1\n    t = a - 1\n    b = N - (t * (t + 1)) // 2 - 1\n    print((1 << a) + (1 << b))\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 15\n    findNthNum(N)\n",
        "output": "48\n",
        "fn_call": "findNthNum"
    },
    {
        "text": "count pairs with odd xor | a function will return number of pair whose xor is odd ; to store count of odd and even numbers ; increase even if number is even otherwise increase odd ; return number of pairs ; ",
        "context": "",
        "code": "def countXorPair(arr, n):\n    odd = 0\n    even = 0\n    for i in range(n):\n        if arr[i] % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return odd * even\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3]\n    n = len(arr)\n    print(countXorPair(arr, n))\n",
        "output": "2\n",
        "fn_call": "countXorPair"
    },
    {
        "text": "minimum initial vertices to traverse whole matrix with given conditions | python3 program to find minimum initial vertices to reach whole matrix ; ( n , m ) is current source cell from which we need to do dfs . n and m are total no . of rows and columns . ; marking the vertex as visited ; if below neighbor is valid and has value less than or equal to current cell 's value ; if right neighbor is valid and has value less than or equal to current cell 's value ; if above neighbor is valid and has value less than or equal to current cell 's value ; if left neighbor is valid and has value less than or equal to current cell 's value ; storing the cell value and cell indices in a vector . ; sorting the newly created array according to cell values ; create a visited array for dfs and initialize it as false . ; applying dfs for each vertex with highest value ; if the given vertex is not visited then include it in the set ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def dfs(n, m, visit, adj, N, M):\n    visit[n][m] = 1\n    if (n + 1 = adj[n + 1][m] and not visit[n + 1][m]):\n        dfs(n + 1, m, visit, adj, N, M)\n    if (m + 1 = adj[n][m + 1] and not visit[n][m + 1]):\n        dfs(n, m + 1, visit, adj, N, M)\n    if (n - 1 >= 0 and adj[n][m] >= adj[n - 1][m] and not visit[n - 1][m]):\n        dfs(n - 1, m, visit, adj, N, M)\n    if (m - 1 >= 0 and adj[n][m] >= adj[n][m - 1] and not visit[n][m - 1]):\n        dfs(n, m - 1, visit, adj, N, M)\n\n\ndef printMinSources(adj, N, M):\n    x = []\n    for i in range(N):\n        for j in range(M):\n            x .append([adj[i][j], [i, j]])\n    x .sort()\n    visit = [[False for i in range(MAX)]for i in range(N)]\n    for i in range(len(x) - 1, -1, -1):\n        if (not visit[x[i][1][0]][x[i][1][1]]):\n            print('{} {}'.format(x[i][1][0], x[i][1][1]))\n            dfs(x[i][1][0], x[i][1][1], visit, adj, N, M)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    M = 2\n    adj = [[3, 3], [1, 1]]\n    printMinSources(adj, N, M)\n",
        "output": "0 1\n",
        "fn_call": "printMinSources"
    },
    {
        "text": "absolute difference between the first x and last x digits of n | function to find the number of digits in the integer ; function to find the absolute difference ; store the last x digits in last ; count the no . of digits in n ; remove the digits except the first x ; store the first x digits in first ; return the absolute difference between the first and last ; ",
        "context": "",
        "code": "def digitsCount(n):\n    length = 0\n    while (n > 0):\n        length += 1\n        n //= 10\n    return length\n\n\ndef absoluteFirstLast(n, x):\n    i = 0\n    mod = 1\n    while (i < x):\n        mod *= 10\n        i += 1\n    last = n % mod\n    length = digitsCount(n)\n    while (length != x):\n        n //= 10\n        length -= 1\n    first = n\n    return abs(first - last)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 21546\n    x = 2\n    print(absoluteFirstLast(n, x))\n",
        "output": "25\n",
        "fn_call": "absoluteFirstLast"
    },
    {
        "text": "find the quadratic equation from the given roots | function to find the quadratic equation whose roots are a and b ; ",
        "context": "",
        "code": "def findEquation(a, b):\n    summ = (a + b)\n    product = (a * b)\n    print(\"x^2 - (\", summ, \"x) + (\", product, \") = 0\")\n",
        "test": "\na = 2\nb = 3\nfindEquation(a, b)\n",
        "output": "x^2 - ( 5 x) + ( 6 ) = 0\n",
        "fn_call": "findEquation"
    },
    {
        "text": "program to find remainder without using modulo or % operator | this function returns remainder of num / divisor without using % ( modulo ) operator ; ",
        "context": "",
        "code": "def getRemainder(num, divisor):\n    return (num - divisor * (num // divisor))\n",
        "test": "\nnum = 100\ndivisor = 7\nprint(getRemainder(num, divisor))\n",
        "output": "2\n",
        "fn_call": "getRemainder"
    },
    {
        "text": "find sum of modulo k of first n natural number | return sum of modulo k of first n natural numbers . ; counting the number of times 1 , 2 , . . , k - 1 , 0 sequence occurs . ; finding the number of elements left which are incomplete of sequence leads to case 1 type . ; adding multiplication of number of times 1 , 2 , . . , k - 1 , 0 sequence occurs and sum of first k natural number and sequence from case 1. ; ",
        "context": "",
        "code": "def findSum(N, K):\n    ans = 0\n    y = N / K\n    x = N % K\n    ans = ((K * (K - 1) / 2) * y + (x * (x + 1)) / 2)\n    return int(ans)\n",
        "test": "\nN = 10\nK = 2\nprint(findSum(N, K))\n",
        "output": "5\n",
        "fn_call": "findSum"
    },
    {
        "text": "largest cube that can be inscribed within a right circular cylinder | python 3 program to find the biggest cube inscribed within a right circular cylinder ; function to find the volume of the cube ; height and radius cannot be negative ; volume of the cube ; ",
        "context": "\nimport math\n\n",
        "code": "def cube(h, r):\n    if (h < 0 and r < 0):\n        return -1\n    a = math .pow(h, 3)\n    return a\n",
        "test": "\nh = 5\nr = 4\nprint(cube(h, r))\n",
        "output": "125.0\n",
        "fn_call": "cube"
    },
    {
        "text": "reverse level order traversal | a binary tree node ; function to print reverse level order traversal ; print nodes at a ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def printGivenLevel(root, level):\n    if root is None:\n        return\n    if level == 1:\n        print(root .data,)\n    elif level > 1:\n        printGivenLevel(root .left, level - 1)\n        printGivenLevel(root .right, level - 1)\n\n\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        lheight = height(node .left)\n        rheight = height(node .right)\n        if lheight > rheight:\n            return lheight + 1\n        else:\n            return rheight + 1\n\n\ndef reverseLevelOrder(root):\n    h = height(root)\n    for i in reversed(range(1, h + 1)):\n        printGivenLevel(root, i)\n",
        "test": "\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nroot .left .left = Node(4)\nroot .left .right = Node(5)\nprint(\"Level Order traversal of binary tree is\")\nreverseLevelOrder(root)\n",
        "output": "Level Order traversal of binary tree is\n4\n5\n2\n3\n1\n",
        "fn_call": "reverseLevelOrder"
    },
    {
        "text": "count of n digit numbers whose sum of digits equals to given sum | python3 program to count of n digit numbers whose sum of digits equals to given sum ; in case n = 2 start is 10 and end is ( 100 - 1 ) = 99 ; ",
        "context": "\nimport math\n\n",
        "code": "def findCount(n, sum):\n    start = math .pow(10, n - 1)\n    end = math .pow(10, n) - 1\n    count = 0\n    i = start\n    while (i <= end):\n        cur = 0\n        temp = i\n        while (temp != 0):\n            cur += temp % 10\n            temp = temp // 10\n        if (cur == sum):\n            count = count + 1\n            i += 9\n        else:\n            i = i + 1\n    print(count)\n",
        "test": "\nn = 3\nsum = 5\nfindCount(n, sum)\n",
        "output": "15\n",
        "fn_call": "findCount"
    },
    {
        "text": "length of longest subsequence consisting of distinct adjacent elements | function that finds the length of longest subsequence having different adjacent elements ; stores the length of the longest subsequence ; traverse the array ; if previous and current element are not same ; increment the count ; print the maximum length ; ",
        "context": "",
        "code": "def longestSubsequence(arr, N):\n    count = 1\n    for i in range(1, N, 1):\n        if (arr[i] != arr[i - 1]):\n            count += 1\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [7, 8, 1, 2, 2, 5, 5, 1]\n    N = len(arr)\n    longestSubsequence(arr, N)\n",
        "output": "6\n",
        "fn_call": "longestSubsequence"
    },
    {
        "text": "number of triangles that can be formed with given n points | python3 implementation of the above approach ; this function returns the required number of triangles ; hash map to store the frequency of slope corresponding to a point ( x , y ) ; iterate over all possible points ; calculate slope of all elements with current element ; find the slope with reduced fraction ; total number of ways to form a triangle having one point as current element ; subtracting the total number of ways to form a triangle having the same slope or are collinear ; ",
        "context": "\nfrom collections import defaultdict\nfrom math import gcd\n\n",
        "code": "def countTriangles(P, N):\n    mp = defaultdict(lambda: 0)\n    ans = 0\n    for i in range(0, N):\n        mp .clear()\n        for j in range(i + 1, N):\n            X = P[i][0] - P[j][0]\n            Y = P[i][1] - P[j][1]\n            g = gcd(X, Y)\n            X //= g\n            Y //= g\n            mp[(X, Y)] += 1\n        num = N - (i + 1)\n        ans += (num * (num - 1)) // 2\n        for j in mp:\n            ans -= (mp[j] * (mp[j] - 1)) // 2\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    P = [[0, 0], [2, 0], [1, 1], [2, 2]]\n    N = len(P)\n    print(countTriangles(P, N))\n",
        "output": "3\n",
        "fn_call": "countTriangles"
    },
    {
        "text": "longest subarray having count of 1 s one more than count of 0 s | function to find the length of longest subarray having count of 1 ' s \u2581 one \u2581 more \u2581 than \u2581 count \u2581 of \u2581 0' s ; unordered_map ' um ' implemented as hash table ; traverse the given array ; consider '0' as '-1   ; when subarray starts form index '0   ; make an entry for ' sum ' if it is not present in 'um   ; check if ' sum - 1' is present in ' um ' or not ; update maxlength ; required maximum length ; ",
        "context": "",
        "code": "def lenOfLongSubarr(arr, n):\n    um = {i: 0 for i in range(10)}\n    sum = 0\n    maxLen = 0\n    for i in range(n):\n        if arr[i] == 0:\n            sum += -1\n        else:\n            sum += 1\n        if (sum == 1):\n            maxLen = i + 1\n        elif (sum not in um):\n            um[sum] = i\n        if ((sum - 1) in um):\n            if (maxLen < (i - um[sum - 1])):\n                maxLen = i - um[sum - 1]\n    return maxLen\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 1, 1, 0, 0, 1]\n    n = len(arr)\n    print(\"Length =\", lenOfLongSubarr(arr, n))\n",
        "output": "Length = 5\n",
        "fn_call": "lenOfLongSubarr"
    },
    {
        "text": "generate minimum sum sequence of integers with even elements greater | function to print the required sequence ; arr [ ] will hold the sequence sum variable will store the sum of the sequence ; if sum of the sequence is odd ; print the sequence ; ",
        "context": "",
        "code": "def make_sequence(N):\n    arr = [0] * (N + 1)\n    sum = 0\n    for i in range(1, N + 1):\n        if (i % 2 == 1):\n            arr[i] = 1\n        else:\n            arr[i] = 2\n        sum += arr[i]\n    if (sum % 2 == 1):\n        arr[2] = 3\n    for i in range(1, N + 1):\n        print(arr[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 9\n    make_sequence(N)\n",
        "output": "1 3 1 2 1 2 1 2 1 ",
        "fn_call": "make_sequence"
    },
    {
        "text": "lexicographically largest string possible in one swap | function to return the lexicographically largest string possible by swapping at most one character ; initialize with - 1 for every character ; keep updating the last occurrence of each character ; if a previously unvisited character occurs ; stores the sorted string ; character to replace ; find the last occurrence of this character ; swap this with the last occurrence ; ",
        "context": "",
        "code": "def findLargest(s):\n    Len = len(s)\n    loccur = [-1 for i in range(26)]\n    for i in range(Len - 1, -1, -1):\n        chI = ord(s[i]) - ord('a')\n        if (loccur[chI] == -1):\n            loccur[chI] = i\n    sorted_s = sorted(s, reverse=True)\n    for i in range(Len):\n        if (s[i] != sorted_s[i]):\n            chI = (ord(sorted_s[i]) - ord('a'))\n            last_occ = loccur[chI]\n            temp = list(s)\n            temp[i], temp[last_occ] = (temp[last_occ], temp[i])\n            s = \"\".join(temp)\n            break\n    return s\n",
        "test": "\ns = \"yrstvw\"\nprint(findLargest(s))\n",
        "output": "ywstvr\n",
        "fn_call": "findLargest"
    },
    {
        "text": "concatenate suffixes of a string | function to print the expansion of the string ; take sub - string from i to n - 1 ; print the sub - string ; ",
        "context": "",
        "code": "def printExpansion(str):\n    suff = \"\"\n    for i in range(len(str) - 1, -1, -1):\n        suff = suff + str[i]\n        print(suff, end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"geeks\"\n    printExpansion(str)\n",
        "output": "sskskeskeeskeeg",
        "fn_call": "printExpansion"
    },
    {
        "text": "count the numbers with n digits and whose suffix is divisible by k | python3 implementation to count the numbers with n digits and whose suffix is divisible by k ; suffix of length pos with remainder rem and z representing whether the suffix has a non zero digit until now ; base case ; if count of digits is less than n ; placing all possible digits in remaining positions ; if remainder non zero and suffix has n digits ; if the subproblem is already solved ; placing all digits at msb of suffix and increasing it 's length by 1 ; non zero digit is placed ; store and return the solution to this subproblem ; function to count the numbers with n digits and whose suffix is divisible by k ; since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; initialising dp table values - 1 represents subproblem hasn 't  been solved yet  memset(dp, -1, sizeof(dp)) ; ",
        "context": "\nmod = 1000000007\ndp = [[[-1 for i in range(2)]for i in range(105)]for i in range(1005)]\npowers = [0] * 1005\npowersModk = [0] * 1005\n\n",
        "code": "def calculate(pos, rem, z, k, n):\n    if (rem == 0 and z):\n        if (pos != n):\n            return (powers[n - pos - 1] * 9) % mod\n        else:\n            return 1\n    if (pos == n):\n        return 0\n    if (dp[pos][rem][z] != -1):\n        return dp[pos][rem][z]\n    count = 0\n    for i in range(10):\n        if (i == 0):\n            count = (count + (calculate(pos + 1,\n                     (rem + (i * powersModk[pos]) % k) % k, z, k, n))) % mod\n        else:\n            count = (count + (calculate(pos + 1,\n                     (rem + (i * powersModk[pos]) % k) % k, 1, k, n))) % mod\n    dp[pos][rem][z] = count\n    return count\n\n\ndef countNumbers(n, k):\n    st = 1\n    for i in range(n + 1):\n        powers[i] = st\n        st *= 10\n        st %= mod\n    st = 1\n    for i in range(n + 1):\n        powersModk[i] = st\n        st *= 10\n        st %= mod\n    return calculate(0, 0, 0, k, n)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    K = 2\n    print(countNumbers(N, K))\n",
        "output": "45\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "program for weighted mean of natural numbers . | returns weighted mean assuming for numbers 1 , 2 , . . n and weights 1 , 2 , . . n ; ",
        "context": "",
        "code": "def weightedMean(n):\n    return (2 * n + 1) / 3\n",
        "test": "\nn = 10\nprint(int(weightedMean(n)))\n",
        "output": "7\n",
        "fn_call": "weightedMean"
    },
    {
        "text": "length of intercept cut off from a line by a circle | python3 program for the above approach ; function to find the radius of a circle ; g and f are the coordinates of the center ; case of invalid circle ; apply the radius formula ; function to find the perpendicular distance between circle center and the line ; store the coordinates of center ; stores the perpendicular distance between the line and the point ; invalid case ; return the distance ; function to find the length of intercept cut off from a line by a circle ; calculate the value of radius ; calculate the perpendicular distance between line and center ; invalid case ; if line do not cut circle ; print the intercept length ; ",
        "context": "\nimport math\n\n",
        "code": "def radius(a, b, c):\n    g = a / 2\n    f = b / 2\n    if (g * g + f * f - c < 0):\n        return (-1)\n    return (math .sqrt(g * g + f * f - c))\n\n\ndef centerDistanceFromLine(a, b, i, j, k):\n    g = a / 2\n    f = b / 2\n    distance = (abs(i * g + j * f + k) / (math .sqrt(i * i + j * j)))\n    if (distance < 0):\n        return (-1)\n    return distance\n\n\ndef interceptLength(a, b, c, i, j, k):\n    rad = radius(a, b, c)\n    dist = centerDistanceFromLine(a, b, i, j, k)\n    if (rad < 0 or dist < 0):\n        print(\"circle not possible\")\n        return\n    if (dist > rad):\n        print(\"Line not cutting circle\")\n    else:\n        print(2 * math .sqrt(rad * rad - dist * dist))\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 0\n    b = 0\n    c = -4\n    i = 2\n    j = -1\n    k = 1\n    interceptLength(a, b, c, i, j, k)\n",
        "output": "3.8987177379235853\n",
        "fn_call": "interceptLength"
    },
    {
        "text": "count pairs whose products exist in array | returns count of pairs whose product exists in arr [ ] ; create an empty hash - set that store all array element ; insert all array element into set ; generate all pairs and check is exist in ' hash ' or not ; if product exists in set then we increment count by 1 ; return count of pairs whose product exist in array ; ",
        "context": "",
        "code": "def countPairs(arr, n):\n    result = 0\n    Hash = set()\n    for i in range(n):\n        Hash .add(arr[i])\n    for i in range(n):\n        for j in range(i + 1, n):\n            product = arr[i] * arr[j]\n            if product in (Hash):\n                result += 1\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    arr = [6, 2, 4, 12, 5, 3]\n    n = len(arr)\n    print(countPairs(arr, n))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "split array into subarrays such that sum of difference between their maximums and minimums is maximum | function to find maximum sum of difference between maximums and minimums in the splitted subarrays ; traverse the array ; stores the maximum and minimum elements upto the i - th index ; traverse the range [ 0 , i ] ; update the minimum ; update the maximum ; update dp [ i ] ; return the maximum sum of difference ; ",
        "context": "",
        "code": "def getValue(arr, N):\n    dp = [0 for i in range(N)]\n    for i in range(1, N):\n        minn = arr[i]\n        maxx = arr[i]\n        j = i\n        while (j >= 0):\n            minn = min(arr[j], minn)\n            maxx = max(arr[j], maxx)\n            dp[i] = max(dp[i], maxx - minn + (dp[j - 1]if (j >= 1)else 0))\n            j -= 1\n    return dp[N - 1]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [8, 1, 7, 9, 2]\n    N = len(arr)\n    print(getValue(arr, N))\n",
        "output": "14\n",
        "fn_call": "getValue"
    },
    {
        "text": "minimum divisor of a number to make the number perfect cube | returns the minimum divisor ; since 2 is only even prime , compute its power seprately . ; if count is not divisible by 3 , it must be removed by dividing n by prime number power . ; if count is not divisible by 3 , it must be removed by dividing n by prime number power . ; if n is a prime number ; ",
        "context": "",
        "code": "def findMinNumber(n):\n    count = 0\n    ans = 1\n    while (n % 2 == 0):\n        count += 1\n        n /= 2\n    if (count % 3 != 0):\n        ans *= pow(2, (count % 3))\n    for i in range(3, int(pow(n, 1 / 2)), 2):\n        count = 0\n        while (n % i == 0):\n            count += 1\n            n /= i\n        if (count % 3 != 0):\n            ans *= pow(i, (count % 3))\n    if (n > 2):\n        ans *= n\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 128\n    print(findMinNumber(n))\n",
        "output": "2\n",
        "fn_call": "findMinNumber"
    },
    {
        "text": "minimum distance between two occurrences of maximum | function to return min distance ; case a ; case b ; case c ; ",
        "context": "",
        "code": "def minDistance(arr, n):\n    maximum_element = arr[0]\n    min_dis = n\n    index = 0\n    for i in range(1, n):\n        if (maximum_element == arr[i]):\n            min_dis = min(min_dis, (i - index))\n            index = i\n        elif (maximum_element < arr[i]):\n            maximum_element = arr[i]\n            min_dis = n\n            index = i\n        else:\n            continue\n    return min_dis\n",
        "test": "\narr = [6, 3, 1, 3, 6, 4, 6]\nn = len(arr)\nprint(\"Minimum distance =\", minDistance(arr, n))\n",
        "output": "Minimum distance = 2\n",
        "fn_call": "minDistance"
    },
    {
        "text": "minimize the number of strictly increasing subsequences in an array | set 2 | function to find the number of strictly increasing subsequences in an array ; sort the array ; stores final count of subsequences ; traverse the array ; stores current element ; stores frequency of the current element ; count frequency of the current element ; if current element frequency is greater than count ; print the final count ;  ; ",
        "context": "",
        "code": "def minimumIncreasingSubsequences(arr, N):\n    arr .sort()\n    count = 0\n    i = 0\n    while (i < N):\n        x = arr[i]\n        freqX = 0\n        while (i < N and arr[i] == x):\n            freqX += 1\n            i += 1\n        count = max(count, freqX)\n    print(count)\n",
        "test": "\narr = [2, 1, 2, 1, 4, 3]\nN = len(arr)\nminimumIncreasingSubsequences(arr, N)\n",
        "output": "2\n",
        "fn_call": "minimumIncreasingSubsequences"
    },
    {
        "text": "perfect square factors of a number | function that returns the count of factors that are perfect squares ; stores the count of number of times a prime number divides n . ; stores the number of factors that are perfect square ; count number of 2 's  that divides n ; calculate ans according to above formula ; check for all the possible numbers that can divide it ; check the number of times prime number i divides it ; calculate ans according to above formula ; return final count ; ",
        "context": "",
        "code": "def noOfFactors(N):\n    if (N == 1):\n        return 1\n    count = 0\n    ans = 1\n    while (N % 2 == 0):\n        count += 1\n        N = N // 2\n    ans *= (count // 2 + 1)\n    i = 3\n    while i * i <= N:\n        count = 0\n        while (N % i == 0):\n            count += 1\n            N = N // i\n        ans *= (count // 2 + 1)\n        i += 2\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 100\n    print(noOfFactors(N))\n",
        "output": "4\n",
        "fn_call": "noOfFactors"
    },
    {
        "text": "compute power of power k times % m | python3 program for computing x ^ x ^ x ^ x . . % m ; function to compute the given value ; compute power k times ; ",
        "context": "\nimport math\n\n",
        "code": "def calculate(x, k, m):\n    result = x\n    k = k - 1\n    while (k):\n        result = math .pow(result, x)\n        if (result > m):\n            result = result % m\n        k = k - 1\n    return int(result)\n",
        "test": "\nx = 5\nk = 2\nm = 3\nprint(calculate(x, k, m))\n",
        "output": "2\n",
        "fn_call": "calculate"
    },
    {
        "text": "count sequences of length k having each term divisible by its preceding term | stores the factors of i - th element in v [ i ] ; function to find all the factors of n ; iterate upto sqrt ( n ) ; function to return the count of sequences of length k having all terms divisible by its preceding term ; calculate factors of i ; initialize dp [ 0 ] [ i ] = 0 : no subsequence of length 0 ending with i - th element exists ; initialize dp [ 0 ] [ i ] = 1 : only 1 subsequence of length 1 ending with i - th element exists ; iterate [ 2 , k ] to obtain sequences of each length ; calculate sum of all dp [ i - 1 ] [ vp [ j ] [ k ] ] ; vp [ j ] [ k ] stores all factors of j ; store the sum in a [ i ] [ j ] ; sum of all dp [ k ] [ j ] obtain all k length sequences ending with j ; ",
        "context": "\nvp = [[]for i in range(2009)]\n\n",
        "code": "def finding_factors(n):\n    i = 1\n    a = 0\n    global vp\n    while (i * i <= n):\n        if (n % i == 0):\n            if (i * i == n):\n                vp[n].append(i)\n            else:\n                vp[n].append(i)\n                vp[n].append(int(n / i))\n        i += 1\n\n\ndef countSeq(N, K):\n    i = 0\n    j = 0\n    k = 0\n    dp = [[0 for i in range(109)]for j in range(109)]\n    for i in range(1, N + 1):\n        finding_factors(i)\n        dp[0][i] = 0\n        dp[1][i] = 1\n    for i in range(2, K + 1):\n        for j in range(1, N + 1):\n            Sum = 0\n            for k in range(len(vp[j])):\n                Sum += dp[i - 1][vp[j][k]]\n            dp[i][j] = Sum\n    ans = 0\n    for j in range(1, N + 1):\n        ans += dp[K][j]\n    return ans\n",
        "test": "\nN = 3\nK = 2\nprint(countSeq(N, K))\n",
        "output": "5\n",
        "fn_call": "countSeq"
    },
    {
        "text": "cunningham chain | function to print cunningham chain of the first kind ; iterate till all elements are printed ; check prime or not ; ",
        "context": "",
        "code": "def print_C(p0):\n    i = 0\n    while (True):\n        flag = 1\n        x = pow(2, i)\n        p1 = x * p0 + (x - 1)\n        for k in range(2, p1):\n            if (p1 % k == 0):\n                flag = 0\n                break\n        if (flag == 0):\n            break\n        print(p1, end=\" \")\n        i += 1\n",
        "test": "\np0 = 2\nprint_C(p0)\n",
        "output": "2 5 11 23 47 ",
        "fn_call": "print_C"
    },
    {
        "text": "check if the characters of a given string are in alphabetical order | function that checks whether the string is in alphabetical order or not ; length of the string ; create a character array of the length of the string ; sort the character array ; check if the character array is equal to the string or not ; ",
        "context": "",
        "code": "def isAlphabaticOrder(s):\n    n = len(s)\n    c = [s[i]for i in range(len(s))]\n    c .sort(reverse=False)\n    for i in range(n):\n        if (c[i] != s[i]):\n            return False\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    s = \"aabbbcc\"\n    if (isAlphabaticOrder(s)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isAlphabaticOrder"
    },
    {
        "text": "count three | function to count three - digit numbers having difference x with its reverse ; if x is not multiple of 99 ; no solution exists ; generate all possible pairs of digits [ 1 , 9 ] ; if any pair is obtained with difference x / 99 ; increase count ; return the count ; ",
        "context": "",
        "code": "def Count_Number(x):\n    ans = 0\n    if (x % 99 != 0):\n        ans = -1\n    else:\n        diff = x / 99\n        for i in range(1, 10):\n            for j in range(1, 10):\n                if ((i - j) == diff):\n                    ans += 10\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    x = 792\n    print(Count_Number(x))\n",
        "output": "10\n",
        "fn_call": "Count_Number"
    },
    {
        "text": "largest number in the array having frequency same as value | function to find the largest number whose frequency is equal to itself . ; find the maximum element in the array ; ",
        "context": "",
        "code": "def findLargestNumber(arr):\n    k = max(arr)\n    m = [0] * (k + 1)\n    for n in arr:\n        m[n] += 1\n    for n in range(len(arr) - 1, 0, -1):\n        if (n == m[n]):\n            return n\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 2, 5, 2, 4, 5]\n    print(findLargestNumber(arr))\n",
        "output": "2\n",
        "fn_call": "findLargestNumber"
    },
    {
        "text": "find the integral roots of a given cubic equation | function to find the value at x of the given equation ; find the value equation at x ; return the value of ans ; function to find the integral solution of the given equation ; initialise start and end ; implement binary search ; find mid ; find the value of f ( x ) using current mid ; check if current mid satisfy the equation ; print mid and return ; print \" na \" if not found any integral solution ; ",
        "context": "",
        "code": "def check(A, B, C, D, x):\n    ans = 0\n    ans = (A * x * x * x + B * x * x + C * x + D)\n    return ans\n\n\ndef findSolution(A, B, C, D, E):\n    start = 0\n    end = 100000\n    mid = 0\n    ans = 0\n    while (start <= end):\n        mid = start + (end - start) // 2\n        ans = check(A, B, C, D, mid)\n        if (ans == E):\n            print(mid)\n            return\n        if (ans < E):\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(\"NA\")\n",
        "test": "\nif __name__ == \"__main__\":\n    A = 1\n    B = 0\n    C = 0\n    D = 0\n    E = 27\n    findSolution(A, B, C, D, E)\n",
        "output": "3\n",
        "fn_call": "findSolution"
    },
    {
        "text": "9 's complement of a decimal number | python3 program to find 9 's complement of a number. ; ",
        "context": "",
        "code": "def complement(number):\n    for i in range(0, len(number)):\n        if (number[i] != '.'):\n            a = 9 - int(number[i])\n            number = (number[:i] + str(a) + number[i + 1:])\n    print(\"9's complement is : \", number)\n",
        "test": "\nif __name__ == '__main__':\n    number = \"345.45\"\n    complement(number)\n",
        "output": "9's complement is :  654.54\n",
        "fn_call": "complement"
    },
    {
        "text": "Percentage change in Hemisphere volume if radius is changed | Function to find the change in hemispheric volume ; Get the change in radius ; Calculate the change in hemispheric volume",
        "context": "",
        "code": "def new_vol(x):\n    if (x > 0):\n        print(\"% change in the volume of the hemisphere: \", pow(\n            x, 3) / 10000 + 3 * x + (3 * pow(x, 2)) / 100, \"% increase\")\n    elif (x < 0):\n        print(\"% change in the volume of the hemisphere: \", pow(\n            x, 3) / 10000 + 3 * x + (3 * pow(x, 2)) / 100, \"% decrease\")\n    else:\n        print(\"Volume remains the same.\")\n",
        "test": "\nx = -10.0\nnew_vol(x)\n",
        "output": "% change in the volume of the hemisphere:  -27.1 % decrease\n",
        "fn_call": "new_vol"
    },
    {
        "text": "nambiar number generator | function to return the nambiar number of the given number ; if there is no digit to choose ; choose the first digit ; chosen digit 's parity ; to store the sum of the consecutive digits starting from the chosen digit ; while there are digits to choose ; update the sum ; if the parity differs ; return the current sum concatenated with the numbiar number for the rest of the string ; ",
        "context": "",
        "code": "def nambiarNumber(Str, i):\n    if (i >= len(Str)):\n        return \"\"\n    firstDigit = ord(Str[i]) - ord('0')\n    digitParity = firstDigit % 2\n    sumDigits = 0\n    while (i < len(Str)):\n        sumDigits += (ord(Str[i]) - ord('0'))\n        sumParity = sumDigits % 2\n        if (digitParity != sumParity):\n            break\n        i += 1\n    return (\"\" + str(sumDigits) + nambiarNumber(Str, i + 1))\n",
        "test": "\nStr = \"9880127431\"\nprint(nambiarNumber(Str, 0))\n",
        "output": "26971\n",
        "fn_call": "nambiarNumber"
    },
    {
        "text": "check if quantities of 3 distinct colors can be converted to a single color by given merge | function to check whether it is possible to do the operation or not ; calculate modulo 3 of all the colors ; check for any equal pair ; otherwise ; ",
        "context": "",
        "code": "def isPossible(r, b, g):\n    r = r % 3\n    b = b % 3\n    g = g % 3\n    if (r == b or b == g or g == r):\n        return True\n    else:\n        return False\n",
        "test": "\nR = 1\nB = 3\nG = 6\nif (isPossible(R, B, G)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isPossible"
    },
    {
        "text": "binary search | returns index of x in arr if present , else - 1 ; if element is present at the middle itself ; if element is smaller than mid , then it can only be present in left subarray ; else the element can only be present in right subarray ; element is not present in the array ; ",
        "context": "",
        "code": "def binarySearch(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return binarySearch(arr, l, mid - 1, x)\n        else:\n            return binarySearch(arr, mid + 1, r, x)\n    else:\n        return -1\n",
        "test": "\narr = [2, 3, 4, 10, 40]\nx = 10\nresult = binarySearch(arr, 0, len(arr) - 1, x)\nif result != -1:\n    print(\"Element is present at index % d\" % result)\nelse:\n    print(\"Element is not present in array\")\n",
        "output": "Element is present at index  3\n",
        "fn_call": "binarySearch"
    },
    {
        "text": "sum of m maximum distinct digit sum from 1 to n that are factors of k | python 3 implementation to find the sum of maximum distinct digit sum of at most m numbers from 1 to n that are factors of k ; function to find the factors of k in n ; initialise a vector ; find out the factors of k less than n ; find the digit sum of each factor ; sum of digits for each element in vector ; find the largest m distinct digit sum from the digitsum vector ; find the sum of last m numbers . ; find the at most m numbers from n natural numbers whose digit sum is distinct and those m numbers are factors of k ; find out the factors of k less than n ; sum of digits for each element in vector ; sorting the digitsum vector ; removing the duplicate elements ; finding the sum and returning it ; ",
        "context": "\nimport math\n\n",
        "code": "def findFactors(n, k):\n    factors = []\n    sqt = (int)(math .sqrt(k))\n    for i in range(1, sqt):\n        if (k % i == 0):\n            if (k // i == i and i <= n):\n                factors .append(i)\n            else:\n                if (i <= n):\n                    factors .append(i)\n                if (k // i <= n):\n                    factors .append(k // i)\n    return factors\n\n\ndef findDigitSum(a):\n    for i in range(len(a)):\n        c = 0\n        while (a[i] > 0):\n            c += a[i] % 10\n            a[i] = a[i] // 10\n        a[i] = c\n    return a\n\n\ndef findMMaxDistinctDigitSum(distinctDigitSum, m):\n    sum = 0\n    i = len(distinctDigitSum) - 1\n    while (i >= 0 and m > 0):\n        sum += distinctDigitSum[i]\n        i -= 1\n        m -= 1\n    return sum\n\n\ndef findDistinctMnumbers(n, k, m):\n    factors = findFactors(n, k)\n    digitSum = sorted(findDigitSum(factors))\n    ip = list(set(digitSum))\n    return findMMaxDistinctDigitSum(ip, m)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 100\n    k = 80\n    m = 4\n    print(findDistinctMnumbers(n, k, m))\n",
        "output": "24\n",
        "fn_call": "findDistinctMnumbers"
    },
    {
        "text": "count pairs from an array having sum of twice of their and and xor equal to k | python3 program for the above approach ; function to count number of pairs satisfying the given conditions ; stores the frequency of array elements ; stores the total number of pairs ; traverse the array ; add it to cnt ; update frequency of current array element ; print the count ; given array ; size of the array ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def countPairs(arr, N, K):\n    mp = defaultdict(int)\n    cnt = 0\n    for i in range(N):\n        cnt += mp[K - arr[i]]\n        mp[arr[i]] += 1\n    print(cnt)\n",
        "test": "\narr = [1, 5, 4, 8, 7]\nN = len(arr)\nK = 9\ncountPairs(arr, N, K)\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "count the number of ways to traverse a matrix | find factorial ; find number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ] ; ",
        "context": "",
        "code": "def factorial(n):\n    res = 1\n    for i in range(2, n + 1):\n        res *= i\n    return res\n\n\ndef countWays(m, n):\n    m = m - 1\n    n = n - 1\n    return (factorial(m + n) // (factorial(m) * factorial(n)))\n",
        "test": "\nm = 5\nn = 5\nresult = countWays(m, n)\nprint(result)\n",
        "output": "70\n",
        "fn_call": "countWays"
    },
    {
        "text": "sum of all the numbers present at given level in modified pascal \u2019 s triangle | function to calculate sum ; ",
        "context": "",
        "code": "def ans(n):\n    if (n == 1):\n        print(\"1\", end=\"\")\n    else:\n        print(\"0\", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 2\n    ans(n)\n",
        "output": "0",
        "fn_call": "ans"
    },
    {
        "text": "print indices in non | function to print the order of array elements generating non - decreasing quotient after division by x ; stores the quotient and the order ; traverse the array ; sort the vector ; print the order ; ",
        "context": "",
        "code": "def printOrder(order, N, X):\n    vect = []\n    for i in range(N):\n        if (order[i] % X == 0):\n            vect .append([order[i] // X, i + 1])\n        else:\n            vect .append([order[i] // X + 1, i + 1])\n    vect = sorted(vect)\n    for i in range(N):\n        print(vect[i][1], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N, X = 3, 3\n    order = [2, 7, 4]\n    printOrder(order, N, X)\n",
        "output": "1 3 2 ",
        "fn_call": "printOrder"
    },
    {
        "text": "Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Find XOR of all numbers from 1 to n ; If XOR is equal n , then return true ; Printing multiples of 4 using above method",
        "context": "",
        "code": "def isMultipleOf4(n):\n    if (n == 1):\n        return False\n    XOR = 0\n    for i in range(1, n + 1):\n        XOR = XOR ^ i\n    return (XOR == n)\n",
        "test": "\nfor n in range(0, 43):\n    if (isMultipleOf4(n)):\n        print(n, end=\" \")\n",
        "output": "0 4 8 12 16 20 24 28 32 36 40 ",
        "fn_call": "isMultipleOf4"
    },
    {
        "text": "count pairs with bitwise and as odd number | function to count number of odd pairs ; variable for counting odd pairs ; find all pairs ; find and operation check odd or even ; return number of odd pair ; ",
        "context": "",
        "code": "def findOddPair(A, N):\n    oddPair = 0\n    for i in range(0, N - 1):\n        for j in range(i + 1, N - 1):\n            if ((A[i] & A[j]) % 2 != 0):\n                oddPair = oddPair + 1\n    return oddPair\n",
        "test": "\na = [5, 1, 3, 2]\nn = len(a)\nprint(findOddPair(a, n))\n",
        "output": "3\n",
        "fn_call": "findOddPair"
    },
    {
        "text": "print unique rows in a given boolean matrix | given a binary matrix of m x n of integers , you need to return only unique rows of binary array ; the main function that prints all unique rows in a given matrix . ; traverse through the matrix ; check if there is similar column is already printed , i . e if i and jth column match . ; if no row is similar ; print the row ; ",
        "context": "\nROW = 4\nCOL = 5\n\n",
        "code": "def findUniqueRows(M):\n    for i in range(ROW):\n        flag = 0\n        for j in range(i):\n            flag = 1\n            for k in range(COL):\n                if (M[i][k] != M[j][k]):\n                    flag = 0\n            if (flag == 1):\n                break\n        if (flag == 0):\n            for j in range(COL):\n                print(M[i][j], end=\" \")\n            print()\n",
        "test": "\nif __name__ == '__main__':\n    M = [[0, 1, 0, 0, 1], [1, 0, 1, 1, 0], [0, 1, 0, 0, 1], [1, 0, 1, 0, 0]]\n    findUniqueRows(M)\n",
        "output": "0 1 0 0 1 \n1 0 1 1 0 \n1 0 1 0 0 \n",
        "fn_call": "findUniqueRows"
    },
    {
        "text": "number of subsets with same and , or and xor values in an array | python3 program to find the number of subsets with equal bitwise and , or and xor values ; function to find the number of subsets with equal bitwise and , or and xor values ; precompute the modded powers of two for subset counting ; loop to iterate and find the modded powers of two for subset counting ; map to store the frequency of each element ; loop to compute the frequency ; for every element > 0 , the number of subsets formed using this element only is equal to 2 ^ ( frequency [ element ] - 1 ) . and for 0 , we have to find all the subsets , so 2 ^ ( frequency [ element ] ) - 1 ; if element is greater than 0 ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def countSubsets(a, n):\n    answer = 0\n    powerOfTwo = [0 for x in range(100005)]\n    powerOfTwo[0] = 1\n    for i in range(1, 100005):\n        powerOfTwo[i] = (powerOfTwo[i - 1] * 2) % mod\n    frequency = {}\n    for i in range(0, n):\n        if a[i] in frequency:\n            frequency[a[i]] += 1\n        else:\n            frequency[a[i]] = 1\n    for key, value in frequency .items():\n        if (key != 0):\n            answer = (answer % mod + powerOfTwo[value - 1]) % mod\n        else:\n            answer = (answer % mod + powerOfTwo[value] - 1 + mod) % mod\n    return answer\n",
        "test": "\nN = 6\nA = [1, 3, 2, 1, 2, 1]\nprint(countSubsets(A, N))\n",
        "output": "7\n",
        "fn_call": "countSubsets"
    },
    {
        "text": "minimize count of given operations required to be performed to make all array elements equal to 1 | python 3 program to implement the above approach ; function to check if all array elements are equal or not ; traverse the array ; if all array elements are not equal ; function to find minimum count of operation to make all the array elements equal to 1 ; stores largest element of the array ; check if a number is a power of 2 or not ; if max is a power of 2 and all array elements are equal ; ",
        "context": "\nimport math\n\n",
        "code": "def CheckAllEqual(arr, N):\n    for i in range(1, N):\n        if (arr[0] != arr[i]):\n            return False\n    return True\n\n\ndef minCntOperations(arr, N):\n    Max = max(arr)\n    isPower2 = not (Max and (Max & (Max - 1)))\n    if (isPower2 and CheckAllEqual(arr, N)):\n        return log2(Max)\n    else:\n        return math .ceil(math .log2(Max)) + 1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 4]\n    N = len(arr)\n    print(minCntOperations(arr, N))\n",
        "output": "3\n",
        "fn_call": "minCntOperations"
    },
    {
        "text": "given a number n , find the first k digits of n ^ n | function that manually calculates n ^ n and then removes digits until k digits remain ; loop will terminate when there are only k digits left ; ",
        "context": "",
        "code": "def firstkdigits(n, k):\n    product = 1\n    for i in range(n):\n        product *= n\n    while ((product // pow(10, k)) != 0):\n        product = product // 10\n    return product\n",
        "test": "\nn = 15\nk = 4\nprint(firstkdigits(n, k))\n",
        "output": "4378\n",
        "fn_call": "firstkdigits"
    },
    {
        "text": "minimum increments to modify array such that value of any array element can be splitted to make all remaining elements equal | function to count minimum moves ; stores sum of given array ; stores maximum array element ; base case ; if n is 2 , the answer will always be 0 ; traverse the array ; calculate sum of the array ; finding maximum element ; calculate ceil ( sum / n - 1 ) ; if k is smaller than maxelement ; final sum - original sum ; print the minimum number of increments required ; ",
        "context": "",
        "code": "def minimumMoves(arr, N):\n    sum = 0\n    maxelement = -1\n    if (N == 2):\n        print(0, end=\"\")\n    for i in range(N):\n        sum += arr[i]\n        maxelement = max(maxelement, arr[i])\n    K = (sum + N - 2) // (N - 1)\n    K = max(maxelement, K)\n    ans = K * (N - 1) - sum\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 7]\n    N = 3\n    minimumMoves(arr, N)\n",
        "output": "2\n",
        "fn_call": "minimumMoves"
    },
    {
        "text": "minimum sum of absolute differences of pairs in a triplet from three arrays | lower_bound function ; function to find the value closest to k in the array a [ ] ; initialize close value as the end element ; find lower bound of the array ; if lower_bound is found ; if lower_bound is not the first array element ; if * ( it - 1 ) is closer to k ; return closest value of k ; function to find the minimum sum of abs ( arr [ i ] - brr [ j ] ) and abs ( brr [ j ] - crr [ k ] ) ; sort the vectors arr and crr ; initialize minimum as let_max ; traverse the array brr [ ] ; stores the element closest to val from the array arr [ ] ; stores the element closest to val from the array crr [ ] ; if sum of differences is minimum ; update the minimum ; print the minimum absolute difference possible ; ",
        "context": "",
        "code": "def lower_bound(arr, key):\n    low = 0\n    high = len(arr) - 1\n    while (low < high):\n        mid = low + (high - low) // 2\n        if (arr[mid] >= key):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n\ndef closestValue(A, k):\n    close = A[-1]\n    it = lower_bound(A, k)\n    if (it != len(A)):\n        close = A[it]\n        if (it != 0):\n            if ((k - A[it - 1]) < (close - k)):\n                close = A[it - 1]\n    return close\n\n\ndef minPossible(arr, brr, crr):\n    arr .sort()\n    crr .sort()\n    minimum = 10 ** 9\n    for val in brr:\n        arr_close = closestValue(arr, val)\n        crr_close = closestValue(crr, val)\n        if (abs(val - arr_close) + abs(val - crr_close) < minimum):\n            minimum = abs(val - arr_close) + abs(val - crr_close)\n    print(minimum)\n",
        "test": "\na = [1, 8, 5]\nb = [2, 9]\nc = [5, 4]\nminPossible(a, b, c)\n",
        "output": "3\n",
        "fn_call": "minPossible"
    },
    {
        "text": "find the sum of series 3 , | calculate sum upto n term of series ; ",
        "context": "",
        "code": "def Sum_upto_nth_Term(n):\n    return (1 - pow(-2, n))\n",
        "test": "\nN = 5\nprint(Sum_upto_nth_Term(N))\n",
        "output": "33\n",
        "fn_call": "Sum_upto_nth_Term"
    },
    {
        "text": "nth term of a fibonacci series of primes formed by concatenating pairs of primes in a given range | stores at each index if it 's a prime or not ; sieve of eratosthenes to generate all possible primes ; if p is a prime ; set all multiples of p as non - prime ; function to generate the required fibonacci series ; stores all primes between n1 and n2 ; generate all primes between n1 and n2 ; stores all concatenations of each pair of primes ; generate all concatenations of each pair of primes ; stores the primes out of the numbers generated above ; store the unique primes ; find the minimum ; find the minimum ; find n ; print the n - th term of the fibonacci series ; ",
        "context": "\nprime = [True for i in range(100001)]\n\n",
        "code": "def SieveOfEratosthenes():\n    p = 2\n    while (p * p <= 100000):\n        if (prime[p]):\n            for i in range(p * p, 100001, p):\n                prime[i] = False\n        p += 1\n\n\ndef fibonacciOfPrime(n1, n2):\n    SieveOfEratosthenes()\n    initial = []\n    for i in range(n1, n2):\n        if prime[i]:\n            initial .append(i)\n    now = []\n    for a in initial:\n        for b in initial:\n            if a != b:\n                c = str(a) + str(b)\n                now .append(int(c))\n    current = []\n    for x in now:\n        if prime[x]:\n            current .append(x)\n    current = set(current)\n    first = min(current)\n    second = max(current)\n    count = len(current) - 1\n    curr = 1\n    while curr < count:\n        c = first + second\n        first = second\n        second = c\n        curr += 1\n    print(c)\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 2\n    y = 40\n    fibonacciOfPrime(x, y)\n",
        "output": "13158006689\n",
        "fn_call": "fibonacciOfPrime"
    },
    {
        "text": "maximum distinct lowercase alphabets between two uppercase | python3 program to find maximum lowercase alphabets present between two uppercase alphabets ; function which computes the maximum number of distinct lowercase alphabets between two uppercase alphabets ; ignoring lowercase characters in the beginning . ; we start from next of first capital letter and traverse through remaining character . ; if character is in uppercase , ; count all distinct lower case characters ; update maximum count ; reset count array ; if character is in lowercase ; ",
        "context": "\nMAX_CHAR = 26\n\n",
        "code": "def maxLower(str):\n    n = len(str)\n    i = 0\n    for i in range(n):\n        if str[i] >= 'A' and str[i] <= 'Z':\n            i += 1\n            break\n    maxCount = 0\n    count = []\n    for j in range(MAX_CHAR):\n        count .append(0)\n    for j in range(i, n):\n        if str[j] >= 'A' and str[j] <= 'Z':\n            currCount = 0\n            for k in range(MAX_CHAR):\n                if count[k] > 0:\n                    currCount += 1\n            maxCount = max(maxCount, currCount)\n            for y in count:\n                y = 0\n        if str[j] >= 'a' and str[j] <= 'z':\n            count[ord(str[j]) - ord('a')] += 1\n    return maxCount\n",
        "test": "\nstr = \"zACaAbbaazzC\"\nprint(maxLower(str))\n",
        "output": "3\n",
        "fn_call": "maxLower"
    },
    {
        "text": "count unset bits of a number | an optimized python program to count unset bits in an integer . ; this makes sure two bits ( from msb and including msb ) are set ; this makes sure 4 bits ( from msb and including msb ) are set ; count set bits in toggled number ; ",
        "context": "\nimport math\n\n",
        "code": "def countUnsetBits(n):\n    x = n\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    t = math .log(x ^ n, 2)\n    return math .floor(t)\n",
        "test": "\nn = 17\nprint(countUnsetBits(n))\n",
        "output": "3\n",
        "fn_call": "countUnsetBits"
    },
    {
        "text": "Tree Isomorphism Problem | A Binary tree node ; Check if the binary tree is isomorphic or not ; Both roots are None , trees isomorphic by definition ; Exactly one of the n1 and n2 is None , trees are not isomorphic ; There are two possible cases for n1 and n2 to be isomorphic Case 1 : The subtrees rooted at these nodes have NOT been \" Flipped \" . Both of these subtrees have to be isomorphic , hence the && Case 2 : The subtrees rooted at these nodes have been \" Flipped \" ; Let us create trees shown in above diagram",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def isIsomorphic(n1, n2):\n    if n1 is None and n2 is None:\n        return True\n    if n1 is None or n2 is None:\n        return False\n    if n1 .data != n2 .data:\n        return False\n    return ((isIsomorphic(n1 .left, n2 .left) and isIsomorphic(n1 .right, n2 .right)) or (\n        isIsomorphic(n1 .left, n2 .right) and isIsomorphic(n1 .right, n2 .left)))\n",
        "test": "\nn1 = Node(1)\nn1 .left = Node(2)\nn1 .right = Node(3)\nn1 .left .left = Node(4)\nn1 .left .right = Node(5)\nn1 .right .left = Node(6)\nn1 .left .right .left = Node(7)\nn1 .left .right .right = Node(8)\nn2 = Node(1)\nn2 .left = Node(3)\nn2 .right = Node(2)\nn2 .right .left = Node(4)\nn2 .right .right = Node(5)\nn2 .left .right = Node(6)\nn2 .right .right .left = Node(8)\nn2 .right .right .right = Node(7)\nprint(\"Yes\") if (isIsomorphic(n1, n2)) else (\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isIsomorphic"
    },
    {
        "text": "minimum sum of product of two arrays | function to find the minimum product ; find product of current elements and update result . ; if both product and b [ i ] are negative , we must increase value of a [ i ] to minimize result . ; if both product and a [ i ] are negative , we must decrease value of a [ i ] to minimize result . ; similar to above two cases for positive product . ; check if current difference becomes higher than the maximum difference so far . ; ",
        "context": "",
        "code": "def minproduct(a, b, n, k):\n    diff = 0\n    res = 0\n    for i in range(n):\n        pro = a[i] * b[i]\n        res = res + pro\n        if (pro < 0 and b[i] < 0):\n            temp = (a[i] + 2 * k) * b[i]\n        elif (pro < 0 and a[i] < 0):\n            temp = (a[i] - 2 * k) * b[i]\n        elif (pro > 0 and a[i] < 0):\n            temp = (a[i] + 2 * k) * b[i]\n        elif (pro > 0 and a[i] > 0):\n            temp = (a[i] - 2 * k) * b[i]\n        d = abs(pro - temp)\n        if (d > diff):\n            diff = d\n    return res - diff\n",
        "test": "\na = [2, 3, 4, 5, 4]\nb = [3, 4, 2, 3, 2]\nn = 5\nk = 3\nprint(minproduct(a, b, n, k))\n",
        "output": "25\n",
        "fn_call": "minproduct"
    },
    {
        "text": "non | function to print all pairs whose sum of bitwise or and and is n ; iterate from i = 0 to n ; print pairs ( i , n - i ) ; ",
        "context": "",
        "code": "def findPairs(N):\n    for i in range(0, N + 1):\n        print(\"(\", i, \",\", N - i, \"), \", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    findPairs(N)\n",
        "output": "( 0 , 5 ), ( 1 , 4 ), ( 2 , 3 ), ( 3 , 2 ), ( 4 , 1 ), ( 5 , 0 ), ",
        "fn_call": "findPairs"
    },
    {
        "text": "lexicographically largest string with sum of characters equal to n | function to construct the lexicographically largest string having sum of characters as n ; stores the resulting string ; iterate until n is at least 26 ; append ' z ' to the string ans ; decrement n by 26 ; append character at index ( n + ' a ' ) ; return the resultant string ; ",
        "context": "",
        "code": "def getString(N):\n    ans = \"\"\n    while (N >= 26):\n        ans += 'z'\n        N -= 26\n    ans += chr(N + ord('a') - 1)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    N = 30\n    print(getString(N))\n",
        "output": "zd\n",
        "fn_call": "getString"
    },
    {
        "text": "sum of product of all unordered pairs in given range with update queries | function to calculate the pairwise product sum in range from l to r ; loop to iterate over all possible pairs from l to r ; print answer ; function to update the array element at index p to x ; update the value at pth index in the array ; function to solve q queries ; if query is of type 1 ; if query is of type 2 ; ",
        "context": "",
        "code": "def pairwiseProductSum(a, l, r):\n    sum = 0\n    for j in range(l - 1, r, 1):\n        for k in range(j + 1, r, 1):\n            sum += (a[j] * a[k])\n    print(sum)\n\n\ndef updateArray(a, p, x):\n    a[p - 1] = x\n\n\ndef solveQueries(a, n, Q, query):\n    for i in range(Q):\n        if (query[i][0] == 1):\n            pairwiseProductSum(a, query[i][1], query[i][2])\n        else:\n            updateArray(a, query[i][1], query[i][2])\n",
        "test": "\nif __name__ == '__main__':\n    A = [5, 7, 2, 3, 1]\n    N = len(A)\n    Q = 3\n    query = [[1, 1, 3], [2, 2, 5], [1, 2, 5]]\n    solveQueries(A, N, Q, query)\n",
        "output": "59\n41\n",
        "fn_call": "solveQueries"
    },
    {
        "text": "find the maximum possible value of a [ i ] % a [ j ] over all pairs of i and j | function that returns the second largest element in the array if exists , else 0 ; there must be at least two elements ; to store the maximum and the second maximum element from the array ; if current element is greater than first then update both first and second ; if arr [ i ] is in between first and second then update second ; no second maximum found ; ",
        "context": "\nimport sys\n\n",
        "code": "def getMaxValue(arr, arr_size):\n    if (arr_size < 2):\n        return 0\n    first = -sys .maxsize - 1\n    second = -sys .maxsize - 1\n    for i in range(arr_size):\n        if (arr[i] > first):\n            second = first\n            first = arr[i]\n        elif (arr[i] > second and arr[i] != first):\n            second = arr[i]\n    if (second == -sys .maxsize - 1):\n        return 0\n    else:\n        return second\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 5, 1, 8]\n    n = len(arr)\n    print(getMaxValue(arr, n))\n",
        "output": "5\n",
        "fn_call": "getMaxValue"
    },
    {
        "text": "convert string into binary sequence | utility function ; convert each char to ascii value ; convert ascii value to binary ; ",
        "context": "",
        "code": "def strToBinary(s):\n    bin_conv = []\n    for c in s:\n        ascii_val = ord(c)\n        binary_val = bin(ascii_val)\n        bin_conv .append(binary_val[2:])\n    return (' '.join(bin_conv))\n",
        "test": "\nif __name__ == '__main__':\n    s = 'geeks'\nprint(strToBinary(s))\n",
        "output": "1100111 1100101 1100101 1101011 1110011\n",
        "fn_call": "strToBinary"
    },
    {
        "text": "a backtracking approach to generate n bit gray codes | we have 2 choices for each of the n bits either we can include i . e invert the bit or we can exclude the bit i . e we can leave the number as it is . ; base case when we run out bits to process we simply include it in gray code sequence . ; ignore the bit . ; invert the bit . ; returns the vector containing the gray code sequence of n bits . ; num is passed by reference to keep track of current code . ; ",
        "context": "",
        "code": "def grayCodeUtil(res, n, num):\n    if (n == 0):\n        res .append(num[0])\n        return\n    grayCodeUtil(res, n - 1, num)\n    num[0] = num[0] ^ (1 << (n - 1))\n    grayCodeUtil(res, n - 1, num)\n\n\ndef grayCodes(n):\n    res = []\n    num = [0]\n    grayCodeUtil(res, n, num)\n    return res\n",
        "test": "\nn = 3\ncode = grayCodes(n)\nfor i in range(len(code)):\n    print(code[i])\n",
        "output": "0\n1\n3\n2\n6\n7\n5\n4\n",
        "fn_call": "grayCodes"
    },
    {
        "text": "color n boxes using m colors such that k boxes have different color from the box on its left | python3 program to paint n boxes using m colors such that k boxes have color different from color of box on its left ; this function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; base case ; if already computed ; either paint with same color as previous one ; or paint with remaining ( m - 1 ) colors ; ",
        "context": "\nM = 1001\nMOD = 998244353\ndp = [[-1] * M] * M\n\n",
        "code": "def solve(idx, diff, N, M, K):\n    if (idx > N):\n        if (diff == K):\n            return 1\n        return 0\n    if (dp[idx][diff] != -1):\n        return dp[idx]\n    ans = solve(idx + 1, diff, N, M, K)\n    ans += (M - 1) * solve(idx + 1, diff + 1, N, M, K)\n    dp[idx][diff] = ans % MOD\n    return dp[idx][diff]\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    M = 3\n    K = 0\n    print(M * solve(2, 0, N, M, K))\n",
        "output": "3\n",
        "fn_call": "solve"
    },
    {
        "text": "position of rightmost set bit | python 3 implementation of above approach ; counting the position of first set bit ; ",
        "context": "\nINT_SIZE = 32\n\n",
        "code": "def Right_most_setbit(num):\n    pos = 1\n    for i in range(INT_SIZE):\n        if not (num & (1 << i)):\n            pos += 1\n        else:\n            break\n    return pos\n",
        "test": "\nif __name__ == \"__main__\":\n    num = 18\n    pos = Right_most_setbit(num)\n    print(pos)\n",
        "output": "2\n",
        "fn_call": "Right_most_setbit"
    },
    {
        "text": "longest subsequence forming an arithmetic progression ( ap ) | function that finds the longest arithmetic subsequence having the same absolute difference ; stores the length of sequences having same difference ; stores the resultant length ; iterate over the array ; update length of subsequence ; return res ;  ; ",
        "context": "",
        "code": "def lenghtOfLongestAP(A, n):\n    dp = {}\n    res = 2\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = A[j] - A[i]\n            if d in dp:\n                if i in dp[d]:\n                    dp[d][j] = dp[d][i] + 1\n                else:\n                    dp[d][j] = 2\n            else:\n                dp[d] = {}\n                dp[d][j] = 2\n            if d in dp:\n                if j in dp[d]:\n                    res = max(res, dp[d][j])\n    return res\n",
        "test": "\narr = [20, 1, 15, 3, 10, 5, 8]\nN = len(arr)\nprint(lenghtOfLongestAP(arr, N))\n",
        "output": "4\n",
        "fn_call": "lenghtOfLongestAP"
    },
    {
        "text": "maximum possible rating of a coding contest | python3 program to find the maximum possible rating of a coding contest ; function to sort all problems descending to upvotes ; function to return maximum rating ; declaring vector of pairs ; each pair represents a problem with its points and upvotes ; step ( 1 ) - sort problems by their upvotes value in decreasing order ; declaring min_heap or priority queue to track of the problem with minimum points . ; step ( 2 ) - loop for i = 0 to k - 1 and do accordingly ; step ( 3 ) - loop for i = k to n - 1 and do accordingly ; ",
        "context": "\nimport heapq\n\n",
        "code": "def Comparator(p1):\n    return p1[1]\n\n\ndef FindMaxRating(N, Point, Upvote, K):\n    vec = []\n    for i in range(N):\n        vec .append([Point[i], Upvote[i]])\n    vec .sort(reverse=True, key=Comparator)\n    pq = []\n    heapq .heapify(pq)\n    total_points, max_rating = 0, 0\n    for i in range(K):\n        total_points = (total_points + vec[i][0])\n        max_rating = max(max_rating, total_points * vec[i][1])\n        heapq .heappush(pq, vec[i][0])\n    for i in range(K, N):\n        if pq[0] < vec[i][0]:\n            total_points = (total_points - pq[0] + vec[i][0])\n            max_rating = max(max_rating, total_points * vec[i][1])\n            heapq .heappop(pq)\n            heapq .heappush(pq, vec[i][0])\n    return max_rating\n",
        "test": "\nPoint = [2, 10, 3, 1, 5, 8]\nUpvote = [5, 4, 3, 9, 7, 2]\nN = len(Point)\nK = 2\nprint(\"Maximum Rating of Coding Contest is:\",\n      FindMaxRating(N, Point, Upvote, K))\n",
        "output": "Maximum Rating of Coding Contest is: 60\n",
        "fn_call": "FindMaxRating"
    },
    {
        "text": "perform n steps to convert every digit of a number in the format [ count ] [ digit ] | function to perform every step ; perform n steps ; traverse in the string ; for last digit ; recur for current string ; ",
        "context": "",
        "code": "def countDigits(st, n):\n    if (n > 0):\n        cnt = 1\n        i = 0\n        st2 = \"\"\n        i = 1\n        while (i < len(st)):\n            if (st[i] == st[i - 1]):\n                cnt = cnt + 1\n            else:\n                st2 += chr(48 + cnt)\n                st2 += st[i - 1]\n                cnt = 1\n            i = i + 1\n        st2 += chr(48 + cnt)\n        st2 += st[i - 1]\n        countDigits(st2, n - 1)\n        n = n - 1\n    else:\n        print(st)\n",
        "test": "\nnum = \"123\"\nn = 3\ncountDigits(num, n)\n",
        "output": "1321123113\n",
        "fn_call": "countDigits"
    },
    {
        "text": "sort an array with swapping only with a special element is allowed | n is total number of elements . index is index of 999 or space . k is number of elements yet to be sorted . ; print the sorted array when loop reaches the base case ; else if k > 0 and space is at 0 th index swap each number with space and store index at second last index ; if space is neither start of array nor last element of array and element before it greater than / the element next to space ; first swap space and element next to space in case of { 3 , 999 , 2 } make it { 3 , 2 , 999 } ; than swap space and greater element convert { 3 , 2 , 999 } to { 999 , 2 , 3 } ; wrapper over sortrec . ; find index of space ( or 999 ) ; invalid input ; ",
        "context": "",
        "code": "def sortRec(arr, index, k, n):\n    if (k == 0):\n        for i in range(1, n):\n            print(arr[i], end=\" \")\n        print(999, end=\"\")\n    elif (k > 0 and index == 0):\n        index = n - 2\n        for i in range(1, index + 1):\n            arr[i - 1] = arr[i]\n        arr[index] = 999\n    if (index - 1 >= 0 and index + 1  arr[index + 1]):\n        arr[index], arr[index + 1] = arr[index + 1], arr[index]\n        arr[index - 1], arr[index + 1] = arr[index + 1], arr[index - 1]\n    else:\n        if (index - 1 < 0):\n            return\n        arr[index], arr[index - 1] = arr[index - 1], arr[index]\n    sortRec(arr, index - 1, k - 1, n)\n\n\ndef sort(arr, n):\n    index = -1\n    for i in range(n):\n        if (arr[i] == 999):\n            index = i\n            break\n    if (index == -1):\n        return\n    sortRec(arr, index, n, n)\n",
        "test": "\narr = [3, 2, 999, 1]\nn = len(arr)\nsort(arr, n)\n",
        "output": "1 2 3 999",
        "fn_call": "sort"
    },
    {
        "text": "reorder an array such that sum of left half is not equal to sum of right half | function to print the required reordering of the array if possible ; sort the array in increasing order ; if all elements are equal , then it is not possible ; else print the sorted array arr [ ] ; ",
        "context": "",
        "code": "def printArr(arr, n):\n    arr .sort()\n    if (arr[0] == arr[n - 1]):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        for i in range(n):\n            print(arr[i], end=\" \")\n        print()\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 2, 1, 3, 1]\n    N = len(arr)\n    printArr(arr, N)\n",
        "output": "Yes\n1 1 1 2 2 3 \n",
        "fn_call": "printArr"
    },
    {
        "text": "find the position of the given prime number | python3 program to find the position of the given prime number ; function to precompute the position of every prime number using sieve ; 0 and 1 are not prime numbers ; variable to store the position ; incrementing the position for every prime number ; ",
        "context": "\nlimit = 1000000\nposition = [0] * (limit + 1)\n\n",
        "code": "def sieve():\n    position[0] = -1\n    position[1] = -1\n    pos = 0\n    for i in range(2, limit + 1):\n        if (position[i] == 0):\n            pos += 1\n            position[i] = pos\n            for j in range(i * 2, limit + 1, i):\n                position[j] = -1\n",
        "test": "\nif __name__ == \"__main__\":\n    sieve()\n    n = 11\n    print(position[n])\n",
        "output": "5\n",
        "fn_call": "sieve"
    },
    {
        "text": "count of pairs from array with sum equal to twice their bitwise and | python3 implementation to find the pairs with equal sum and twice the bitwise and of the pairs ; map to store the occurrence of elements of array ; function to find the pairs with equal sum and twice the bitwise and of the pairs ; loop to find the frequency of elements of array ; function to find the count such pairs in the array ; if an element occurs more than once then the answer will by incremented by nc2 times ; ",
        "context": "\nfrom collections import defaultdict\nmp = defaultdict(int)\n\n",
        "code": "def find_pairs(arr, n):\n    ans = 0\n    for i in range(n):\n        mp[arr[i]] += 1\n    for i in mp .values():\n        count = i\n        if (count > 1):\n            ans += ((count * (count - 1)) // 2)\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 3, 4, 5, 5, 7, 8]\n    arr_size = len(arr)\n    print(find_pairs(arr, arr_size))\n",
        "output": "2\n",
        "fn_call": "find_pairs"
    },
    {
        "text": "alternate primes till n | python 3 program to print all equal to n using sieve of eratosthenes ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; print all prime numbers ; for next prime to get printed ; ",
        "context": "",
        "code": "def SieveOfEratosthenes(n):\n    prime = [None] * (n + 1)\n    for i in range(len(prime)):\n        prime[i] = True\n    p = 2\n    while p * p <= n:\n        if (prime[p]):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    flag = True\n    for p in range(2, n + 1):\n        if (prime[p]):\n            if (flag):\n                print(str(p), end=\" \")\n                flag = False\n            else:\n                flag = True\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 15\n    print(\n        \"Following are the alternate\" +\n        \" prime numbers smaller \" +\n        \"than or equal to \" +\n        str(n))\n    SieveOfEratosthenes(n)\n",
        "output": "Following are the alternate prime numbers smaller than or equal to 15\n2 5 11 ",
        "fn_call": "SieveOfEratosthenes"
    },
    {
        "text": "convert a sentence into its equivalent mobile numeric keypad sequence | function which computes the sequence ; length of ",
        "context": "",
        "code": "def printSequence(arr, input):\n    n = len(input)\n    output = \"\"\n    for i in range(n):\n        if (input[i] == ' '):\n            output = output + \"0\"\n        else:\n            position = ord(input[i]) - ord('A')\n            output = output + arr[position]\n    return output\n",
        "test": "\nstr = [\n    \"2\",\n    \"22\",\n    \"222\",\n    \"3\",\n    \"33\",\n    \"333\",\n    \"4\",\n    \"44\",\n    \"444\",\n    \"5\",\n    \"55\",\n    \"555\",\n    \"6\",\n    \"66\",\n    \"666\",\n    \"7\",\n    \"77\",\n    \"777\",\n    \"7777\",\n    \"8\",\n    \"88\",\n    \"888\",\n    \"9\",\n    \"99\",\n    \"999\",\n    \"9999\"]\ninput = \"GEEKSFORGEEKS\"\nprint(printSequence(str, input))\n",
        "output": "4333355777733366677743333557777\n",
        "fn_call": "printSequence"
    },
    {
        "text": "sum of series ( n / 1 ) + ( n / 2 ) + ( n / 3 ) + ( n / 4 ) + ... ... . + ( n / n ) | python 3 program to find sum of given series ; function to find sum of series ; ",
        "context": "\nimport math\n\n",
        "code": "def sum(n):\n    root = (int)(math .sqrt(n))\n    ans = 0\n    for i in range(1, root + 1):\n        ans = ans + n // i\n    ans = 2 * ans - (root * root)\n    return ans\n",
        "test": "\nn = 35\nprint(sum(n))\n",
        "output": "131\n",
        "fn_call": "sum"
    },
    {
        "text": "count of multiplicative partitions of n | function to return number of ways of factoring n with all factors greater than 1 ; variable to store number of ways of factoring n with all factors greater than 1 ; ",
        "context": "",
        "code": "def getDivisors(min, n):\n    total = 0\n    for i in range(min, n):\n        if (n % i == 0 and n // i >= i):\n            total += 1\n            if (n // i > i):\n                total += getDivisors(i, n // i)\n    return total\n",
        "test": "\nif __name__ == '__main__':\n    n = 30\n    print(1 + getDivisors(2, n))\n",
        "output": "5\n",
        "fn_call": "getDivisors"
    },
    {
        "text": "area of largest isosceles triangle that can be inscribed in an ellipse whose vertex coincides with one extremity of the major axis | python 3 program for the above approach ; function to calculate area of the isosceles triangle ; if a and b are negative ; stores the area of the triangle ; print the area ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def triangleArea(a, b):\n    if (a < 0 or b < 0):\n        print(-1)\n        return\n    area = (3 * sqrt(3) * a * b) / (4)\n    print(\"{:.5f}\".format(area))\n",
        "test": "\nif __name__ == '__main__':\n    a = 1\n    b = 2\n    triangleArea(a, b)\n",
        "output": "2.59808\n",
        "fn_call": "triangleArea"
    },
    {
        "text": "dfs for a n | dfs on tree ; printing traversed node ; traversing adjacent edges ; not traversing the parent node ; ",
        "context": "",
        "code": "def dfs(List, node, arrival):\n    print(node)\n    for i in range(len(List[node])):\n        if (List[node][i] != arrival):\n            dfs(List, List[node][i], node)\n",
        "test": "\nif __name__ == '__main__':\n    nodes = 5\n    List = [[]for i in range(10000)]\n    List[1].append(2)\n    List[2].append(1)\n    List[1].append(3)\n    List[3].append(1)\n    List[2].append(4)\n    List[4].append(2)\n    List[3].append(5)\n    List[5].append(3)\n    dfs(List, 1, 0)\n",
        "output": "1\n2\n4\n3\n5\n",
        "fn_call": "dfs"
    },
    {
        "text": "count consecutive pairs of same elements | function to return the count of consecutive elements in the array which are equal ; if consecutive elements are same ; ",
        "context": "",
        "code": "def countCon(ar, n):\n    cnt = 0\n    for i in range(n - 1):\n        if (ar[i] == ar[i + 1]):\n            cnt += 1\n    return cnt\n",
        "test": "\nar = [1, 2, 2, 3, 4, 4, 5, 5, 5, 5]\nn = len(ar)\nprint(countCon(ar, n))\n",
        "output": "5\n",
        "fn_call": "countCon"
    },
    {
        "text": "count total set bits in all numbers from 1 to n | set 2 | function to return the sum of the count of set bits in the integers from 1 to n ; ignore 0 as all the bits are unset ; to store the powers of 2 ; to store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; loop for every bit required to represent n ; total count of pairs of 0 s and 1 s ; totalpairs / 2 gives the complete count of the pairs of 1 s multiplying it with the current power of 2 will give the count of 1 s in the current bit ; if the count of pairs was odd then add the remaining 1 s which could not be groupped together ; next power of 2 ; return the result ; ",
        "context": "",
        "code": "def countSetBits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while (powerOf2 <= n):\n        totalPairs = n // powerOf2\n        cnt += (totalPairs // 2) * powerOf2\n        if (totalPairs & 1):\n            cnt += (n % powerOf2)\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 14\n    print(countSetBits(n))\n",
        "output": "28\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "count of subsets not containing adjacent elements | function to return the count of possible subsets ; if previous element was 0 then 0 as well as 1 can be appended ; if previous element was 1 then only 0 can be appended ; store the count of all possible subsets ; ",
        "context": "",
        "code": "def cntSubsets(arr, n):\n    a = [0] * n\n    b = [0] * n\n    a[0] = b[0] = 1\n    for i in range(1, n):\n        a[i] = a[i - 1] + b[i - 1]\n        b[i] = a[i - 1]\n    result = a[n - 1] + b[n - 1]\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 5, 7]\n    n = len(arr)\n    print(cntSubsets(arr, n))\n",
        "output": "5\n",
        "fn_call": "cntSubsets"
    },
    {
        "text": "print any pair of integers with sum of gcd and lcm equals to n | function to print the required pair ; print the pair ; ",
        "context": "",
        "code": "def printPair(n):\n    print(\"1\", end=\" \")\n    print(n - 1)\n",
        "test": "\nn = 14\nprintPair(n)\n",
        "output": "1 13\n",
        "fn_call": "printPair"
    },
    {
        "text": "find the kth element in the series generated by the given n ranges | function to return the kth element of the required series ; to store the number of integers that lie upto the ith index ; compute the number of integers ; stores the index , lying from 1 to n , ; using binary search , find the index in which the kth element will lie ; find the position of the kth element in the interval in which it lies ; ",
        "context": "",
        "code": "def getKthElement(n, k, L, R):\n    l = 1\n    h = n\n    total = [0 for i in range(n + 1)]\n    total[0] = 0\n    for i in range(n):\n        total[i + 1] = total[i] + (R[i] - L[i]) + 1\n    index = -1\n    while (l <= h):\n        m = (l + h) // 2\n        if (total[m] > k):\n            index = m\n            h = m - 1\n        elif (total[m] < k):\n            l = m + 1\n        else:\n            index = m\n            break\n    l = L[index - 1]\n    h = R[index - 1]\n    x = k - total[index - 1]\n    while (l <= h):\n        m = (l + h) // 2\n        if ((m - L[index - 1]) + 1 == x):\n            return m\n        elif ((m - L[index - 1]) + 1 > x):\n            h = m - 1\n        else:\n            l = m + 1\n",
        "test": "\nL = [1, 8, 21]\nR = [4, 10, 23]\nn = len(L)\nk = 6\nprint(getKthElement(n, k, L, R))\n",
        "output": "9\n",
        "fn_call": "getKthElement"
    },
    {
        "text": "frequency of a substring in a string | simple python program to count occurrences of pat in txt . ; a loop to slide pat [ ] one by one ; for current index i , check for pattern match ; if pat [ 0. . . m - 1 ] = txt [ i , i + 1 , ... i + m - 1 ] ; ",
        "context": "",
        "code": "def countFreq(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    res = 0\n    for i in range(N - M + 1):\n        j = 0\n        while j < M:\n            if (txt[i + j] != pat[j]):\n                break\n            j += 1\n        if (j == M):\n            res += 1\n            j = 0\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    txt = \"dhimanman\"\n    pat = \"man\"\n    print(countFreq(pat, txt))\n",
        "output": "2\n",
        "fn_call": "countFreq"
    },
    {
        "text": "find the final string after flipping bits at the indices that are multiple of prime factors of array elements | python program for the above approach ; stores smallest prime factor ; function to find the smallest prime factor for every number till maxn ; marking smallest prime factor for every number to be itself ; separately marking spf for every even number as 2 ; checking if i is prime ; marking spf for all numbers divisible by i ; function to find all the distinct prime factors of the given number x ; find the prime factors for x ; find the spf [ ] of x ; return the prime factors for x ; function to find string after flipping the characters at indices of prime factors of array elements arr [ ] ; precalculating smallest prime factor ; stores the frequency of each prime factor ; iterate over all elements of the array arr [ ] ; stores prime factors of arr [ i ] ; increment the frequency of all prime factors of arr [ i ] ; iterate over all elements of the array frequency [ ] ; if frequency [ i ] is odd ; flip bits of all indices that are multiple of i ; return answer ; ",
        "context": "\nMAXN = 100001\nspf = [0] * MAXN\n\n",
        "code": "def sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    i = 3\n    while (i * 8 < MAXN):\n        i += 1\n        if (spf[i] == i):\n            for j in range(i * i, MAXN, i):\n                if (spf[j] == j):\n                    spf[j] = i\n\n\ndef getFactorization(x):\n    ret = []\n    while (x != 1):\n        ret .append(spf[x])\n        value = spf[x]\n        while (x % value == 0):\n            x = x // value\n    return ret\n\n\ndef flipString(S, arr, M):\n    sieve()\n    frequency = [0] * MAXN\n    for i in range(0, M):\n        primeFactors = getFactorization(arr[i])\n        for factors in primeFactors:\n            frequency[factors] += 1\n            frequency[factors] %= 2\n    N = len(S)\n    for i in range(0, MAXN):\n        if (frequency[i] & 1):\n            for j in range(i, N + 1, i):\n                S[j - 1] = ('0'if S[j - 1] == '1'else '1')\n    return S\n",
        "test": "\nS = \"000000\"\nS = list(S)\narr = [2, 4, 6]\nM = len(arr)\nprint(\"\".join(flipString(S, arr, M)))\n",
        "output": "011100\n",
        "fn_call": "flipString"
    },
    {
        "text": "nearest power of 2 of frequencies of each digit of a given number | python3 program for the above approach ; function to find the nearest power of 2 for all frequencies in the map freq ; traverse the map ; calculate log of the current array element ; find the nearest power of 2 for the current frequency ; function to find nearest power of 2 for frequency of each digit of num ; length of string ; stores the frequency of each character in the string ; traverse the string s ; function call to generate nearest power of 2 for each frequency ; ",
        "context": "\nfrom math import log2, pow\n\n",
        "code": "def nearestPowerOfTwoUtil(freq):\n    temp = {}\n    for key, value in freq .items():\n        lg = int(log2(value))\n        a = int(pow(2, lg))\n        b = int(pow(2, lg + 1))\n        if ((value - a) < (b - value)):\n            temp[(int(a))] = key\n        else:\n            temp[(int(b))] = key\n    for key, value in temp .items():\n        print(value, \"->\", key)\n\n\ndef nearestPowerOfTwo(S):\n    N = len(S)\n    freq = {}\n    for i in range(N):\n        if (S[i] in freq):\n            freq[S[i]] += 1\n        else:\n            freq[S[i]] = 1\n    nearestPowerOfTwoUtil(freq)\n",
        "test": "\nif __name__ == '__main__':\n    N = \"16333331163\"\n    nearestPowerOfTwo(N)\n",
        "output": "1 -> 4\n6 -> 2\n3 -> 8\n",
        "fn_call": "nearestPowerOfTwo"
    },
    {
        "text": "program to find amount of water in a given glass | returns the amount of water in jth glass of ith row ; a row number i has maximum i columns . so input column number must be less than i ; there will be i * ( i + 1 ) / 2 glasses till ith row ( including ith row ) and initialize all glasses as empty ; put all water in first glass ; now let the water flow to the downward glasses till the row number is less than or / equal to i ( given row ) correction : x can be zero for side glasses as they have lower rate to fill ; fill glasses in a given row . number of columns in a row is equal to row number ; get the water from current glass ; keep the amount less than or equal to capacity in current glass ; get the remaining amount ; distribute the remaining amount to the down two glasses ; the index of jth glass in ith row will be i * ( i - 1 ) / 2 + j - 1 ; ",
        "context": "",
        "code": "def findWater(i, j, X):\n    if (j > i):\n        print(\"Incorrect Input\")\n        return\n    glass = [0] * int(i * (i + 1) / 2)\n    index = 0\n    glass[index] = X\n    for row in range(1, i):\n        for col in range(1, row + 1):\n            X = glass[index]\n            glass[index] = 1.0 if (X >= 1.0)else X\n            X = (X - 1)if (X >= 1.0)else 0.0\n            glass[index + row] += (X / 2)\n            glass[index + row + 1] += (X / 2)\n            index += 1\n    return glass[int(i * (i - 1) / 2 + j - 1)]\n",
        "test": "\nif __name__ == \"__main__\":\n    i = 2\n    j = 2\n    X = 2.0\n    res = repr(findWater(i, j, X))\n    print(\"Amount of water in jth glass of ith row is:\", res .ljust(8, '0'))\n",
        "output": "Amount of water in jth glass of ith row is: 0.500000\n",
        "fn_call": "findWater"
    },
    {
        "text": "print numbers in the range 1 to n having bits in alternate pattern | function to print numbers in the range 1 to nhaving bits in alternate pattern ; first number having bits in alternate pattern ; display ; loop until n < curr_num ; generate next number having alternate bit pattern ; if true then break ; display ; generate next number having alternate bit pattern ; if true then break ; display ; ",
        "context": "",
        "code": "def printNumHavingAltBitPatrn(n):\n    curr_num = 1\n    print(curr_num)\n    while (1):\n        curr_num = curr_num << 1\n        if (n < curr_num):\n            break\n        print(curr_num)\n        curr_num = ((curr_num) << 1) ^ 1\n        if (n < curr_num):\n            break\n        print(curr_num)\n",
        "test": "\nn = 50\nprintNumHavingAltBitPatrn(n)\n",
        "output": "1\n2\n5\n10\n21\n42\n",
        "fn_call": "printNumHavingAltBitPatrn"
    },
    {
        "text": "sum of first n odd numbers in o ( 1 ) complexity | returns the sum of first n odd numbers ; ",
        "context": "",
        "code": "def oddSum(n):\n    return (n * n)\n",
        "test": "\nn = 20\nprint(\" Sum of first\", n, \"Odd Numbers is: \", oddSum(n))\n",
        "output": " Sum of first 20 Odd Numbers is:  400\n",
        "fn_call": "oddSum"
    },
    {
        "text": "find the first n integers such that the sum of their digits is equal to 10 | function to return the sum of digits of n ; add the last digit to the sum ; remove last digit ; return the sum of digits ; function to print the first n numbers whose sum of digits is 10 ; first number of the series is 19 ; if the sum of digits of the current number is equal to 10 ; print the number ; add 9 to the previous number ; ",
        "context": "",
        "code": "def sum(n):\n    sum = 0\n    while (n):\n        sum = sum + n % 10\n        n = n // 10\n    return sum\n\n\ndef firstN(n):\n    num = 19\n    cnt = 1\n    while (cnt != n):\n        if (sum(num) == 10):\n            print(num, end=\" \")\n            cnt += 1\n        num += 9\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 10\n    firstN(n)\n",
        "output": "19 28 37 46 55 64 73 82 91 ",
        "fn_call": "firstN"
    },
    {
        "text": "reduce the number to minimum multiple of 4 after removing the digits | python3 implementation of the approach ; function to return the minimum number that can be formed after removing the digits which is a multiple of 4 ; for every digit of the number ; check if the current digit is divisible by 4 ; if any subsequence of two digits is divisible by 4 ; ",
        "context": "\nimport sys\nTEN = 10\n\n",
        "code": "def minNum(str, len1):\n    res = sys .maxsize\n    for i in range(len1):\n        if (str[i] == '4' or str[i] == '8'):\n            res = min(res, ord(str[i]) - ord('0'))\n    for i in range(len1 - 1):\n        for j in range(i + 1, len1, 1):\n            num = (ord(str[i]) - ord('0')) * TEN + (ord(str[j]) - ord('0'))\n            if (num % 4 == 0):\n                res = min(res, num)\n    if (res == sys .maxsize):\n        return -1\n    else:\n        return res\n",
        "test": "\nif __name__ == '__main__':\n    str = \"17\"\n    len1 = len(str)\n    print(minNum(str, len1))\n",
        "output": "-1\n",
        "fn_call": "minNum"
    },
    {
        "text": "junction numbers | python3 program for the above approach ; function to find the sum of digits of n ; to store sum of n and sumofdigitsof ( n ) ; extracting digit ; function to check junction numbers ; to store count of ways n can be represented as i + sod ( i ) ; ",
        "context": "\nimport math\n\n",
        "code": "def sum1(n):\n    sum1 = 0\n    while (n != 0):\n        r = n % 10\n        sum1 = sum1 + r\n        n = n // 10\n    return sum1\n\n\ndef isJunction(n):\n    count = 0\n    for i in range(1, n + 1):\n        if (i + sum1(i) == n):\n            count = count + 1\n    return count >= 2\n",
        "test": "\nif __name__ == '__main__':\n    n = 111\n    if (isJunction(n) == 1):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isJunction"
    },
    {
        "text": "length of the longest substring that contains even number of vowels | function to find the length of the longest substring having even number of vowels ; create two hashmaps ; keep the track of frequencies of the vowels ; stores the maximum length ; traverse the given string s ; if it is a vowel , then update the frequency ; find the index of occurence of the string evenodd in map ; update the maximum length ; print the maximum length ; ",
        "context": "",
        "code": "def longestSubstring(s):\n    indexes = {}\n    chars = {}\n    chars['a'] = 0\n    chars['e'] = 1\n    chars['i'] = 2\n    chars['o'] = 3\n    chars['u'] = 4\n    evenOdd = \"00000\"\n    evenOdd = [i for i in evenOdd]\n    indexes[\"\".join(evenOdd)] = -1\n    length = 0\n    for i in range(len(s)):\n        c = s[i]\n        if (c in chars):\n            evenOdd[chars[it]] = '1'if evenOdd[chars[it]]else '0'\n        if (\"\".join(evenOdd)not in indexes):\n            indexes[\"\".join(evenOdd)] = i\n        else:\n            length = max(length, i - indexes[\"\".join(evenOdd)])\n    print(length)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"bcbcbc\"\n    longestSubstring(S)\n",
        "output": "6\n",
        "fn_call": "longestSubstring"
    },
    {
        "text": "sum of fibonacci numbers in a range | function to return the nth fibonacci number ; function to return the required sum ; to store the sum ; calculate the sum ; ",
        "context": "",
        "code": "def fib(n):\n    phi = ((1 + (5 ** (1 / 2))) / 2)\n    return round((phi ** n) / (5 ** (1 / 2)))\n\n\ndef calculateSum(l, r):\n    sum = 0\n    for i in range(l, r + 1):\n        sum += fib(i)\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    l, r = 4, 8\n    print(calculateSum(l, r))\n",
        "output": "50\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "find the final co | function to print the final position of the point after traversing through the given directions ; traversing through the given directions ; if its north or south the point will move left or right ; if its west or east the point will move upwards or downwards ; returning the final position ; ",
        "context": "",
        "code": "def finalCoordinates(SX, SY, D):\n    for i in range(len(D)):\n        if (D[i] == 'N'):\n            SY += 1\n        elif (D[i] == 'S'):\n            SY -= 1\n        elif (D[i] == 'E'):\n            SX += 1\n        else:\n            SX -= 1\n    ans = '(' + str(SX) + ',' + str(SY) + ')'\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    SX, SY = 2, 2\n    D = \"NSSE\"\n    finalCoordinates(SX, SY, D)\n",
        "output": "(3,1)\n",
        "fn_call": "finalCoordinates"
    },
    {
        "text": "maximum count of pairs having equal sum based on the given conditions | function to find the maximum count of pairs having equal sum ; size of the array ; iterate through evey sum of pairs possible from the given array ; count of pairs with given sum ; check for a possible pair ; update count of possible pair ; update the answer by taking the pair which is maximum for every possible sum ; return the max possible pair ; function to return the count of pairs ; size of the array ; stores the frequencies ; count the frequency ; ",
        "context": "",
        "code": "def maxCount(freq, maxi, mini):\n    n = len(freq) - 1\n    ans = 0\n    sum = 2 * mini\n    while sum <= 2 * maxi:\n        possiblePair = 0\n        for firElement in range(1, (sum + 1) // 2):\n            if (sum - firElement <= maxi):\n                possiblePair += min(freq[firElement], freq[sum - firElement])\n        sum += 1\n        if (sum % 2 == 0):\n            possiblePair += freq[sum // 2] // 2\n        ans = max(ans, possiblePair)\n    return ans\n\n\ndef countofPairs(a):\n    n = len(a)\n    freq = [0] * (n + 1)\n    maxi = -1\n    mini = n + 1\n    for i in range(len(a)):\n        maxi = max(maxi, a[i])\n        mini = min(mini, a[i])\n    for i in range(n):\n        freq[a[i]] += 1\n    return maxCount(freq, maxi, mini)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 4, 3, 3, 5, 6]\n    print(countofPairs(a))\n",
        "output": "3\n",
        "fn_call": "countofPairs"
    },
    {
        "text": "maximize the sum of array by multiplying prefix of array with | python implementation of the approach ; to store sum ; to store ending indices of the chosen prefix arrays ; adding the absolute value of a [ i ] ; if i == 0 then there is no index to be flipped in ( i - 1 ) position ; print the maximised sum ; print the ending indices of the chosen prefix arrays ; ",
        "context": "",
        "code": "def maxSum(arr, n):\n    s = 0\n    l = []\n    for i in range(len(a)):\n        s += abs(a[i])\n        if (a[i] >= 0):\n            continue\n        if (i == 0):\n            l .append(i + 1)\n        else:\n            l .append(i + 1)\n            l .append(i)\n    print(s)\n    print(*l)\n",
        "test": "\nn = 4\na = [1, -2, -3, 4]\nmaxSum(a, n)\n",
        "output": "10\n2 1 3 2\n",
        "fn_call": "maxSum"
    },
    {
        "text": "ways to choose three points with distance between the most distant points <= l | returns the number of triplets with distance between farthest points <= l ; sort to get ordered triplets so that we can find the distance between farthest points belonging to a triplet ; generate and check for all possible triplets : { arr [ i ] , arr [ j ] , arr [ k ] } ; since the array is sorted the farthest points will be a [ i ] and a [ k ] ; ; ",
        "context": "",
        "code": "def countTripletsLessThanL(n, L, arr):\n    arr .sort()\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                mostDistantDistance = arr[k] - arr[i]\n                if (mostDistantDistance <= L):\n                    ways += 1\n    return ways\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4]\n    n = len(arr)\n    L = 3\n    ans = countTripletsLessThanL(n, L, arr)\n    print(\"Total Number of ways =\", ans)\n",
        "output": "Total Number of ways = 4\n",
        "fn_call": "countTripletsLessThanL"
    },
    {
        "text": "smallest n digit number which is a multiple of 5 | function to return the smallest n digit number which is a multiple of 5 ; ",
        "context": "",
        "code": "def smallestMultiple(n):\n    if (n == 1):\n        return 5\n    return pow(10, n - 1)\n",
        "test": "\nn = 4\nprint(smallestMultiple(n))\n",
        "output": "1000\n",
        "fn_call": "smallestMultiple"
    },
    {
        "text": "find the sub | python 3 program to find subarray with sum closest to 0 ; function to find the subarray ; pick a starting point ; consider current starting point as a subarray and update minimum sum and subarray indexes ; try all subarrays starting with i ; update minimum sum and subarray indexes ; return starting and ending indexes ; ",
        "context": "\nimport sys\n\n",
        "code": "def findSubArray(arr, n):\n    min_sum = sys .maxsize\n    for i in range(n):\n        curr_sum = arr[i]\n        if (min_sum > abs(curr_sum)):\n            min_sum = abs(curr_sum)\n            start = i\n            end = i\n        for j in range(i + 1, n, 1):\n            curr_sum = curr_sum + arr[j]\n            if (min_sum > abs(curr_sum)):\n                min_sum = abs(curr_sum)\n                start = i\n                end = j\n    p = [start, end]\n    return p\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, -5, 4, -6, -3]\n    n = len(arr)\n    point = findSubArray(arr, n)\n    print(\"Subarray starting from \", end=\"\")\n    print(point[0], \"to\", point[1])\n",
        "output": "Subarray starting from 0 to 2\n",
        "fn_call": "findSubArray"
    },
    {
        "text": "how to calculate strike rate of a batsman | function to calculate strike rate of a batsman ; ",
        "context": "",
        "code": "def strikerate(bowls, runs):\n    z = (float(runs) / bowls) * 100\n    return z\n",
        "test": "\nA = 264\nB = 173\nprint(strikerate(B, A))\n",
        "output": "152.60115606936415\n",
        "fn_call": "strikerate"
    },
    {
        "text": "Count all the numbers less than 10 ^ 6 whose minimum prime factor is N | Python3 implementation of above approach ; the sieve of prime number and count of minimum prime factor ; form the prime sieve ; 1 is not a prime number ; form the sieve ; if i is prime ; if i is the least prime factor ; mark the number j as non prime ; count the numbers whose least prime factor is i ; form the sieve ; display ; display",
        "context": "\nMAX = 1000000\nsieve_Prime = [0 for i in range(MAX + 4)]\nsieve_count = [0 for i in range(MAX + 4)]\n\n",
        "code": "def form_sieve():\n    sieve_Prime[1] = 1\n    for i in range(2, MAX + 1):\n        if sieve_Prime[i] == 0:\n            for j in range(i * 2, MAX + 1, i):\n                if sieve_Prime[j] == 0:\n                    sieve_Prime[j] = 1\n                    sieve_count[i] += 1\n",
        "test": "\nform_sieve()\nn = 2\nprint(\"Count =\", sieve_count[n] + 1)\nn = 3\nprint(\"Count =\", sieve_count[n] + 1)\n",
        "output": "Count = 500000\nCount = 166667\n",
        "fn_call": "form_sieve"
    },
    {
        "text": "length of the longest valid substring | function to return the length of the longest valid substring ; variables for left and right counter . maxlength to store the maximum length found so far ; iterating the string from left to right ; if \" ( \" is encountered , then left counter is incremented else right counter is incremented ; whenever left is equal to right , it signifies that the subsequence is valid and ; reseting the counters when the subsequence becomes invalid ; iterating the string from right to left ; if \" ( \" is encountered , then left counter is incremented else right counter is incremented ; whenever left is equal to right , it signifies that the subsequence is valid and ; reseting the counters when the subsequence becomes invalid ; ",
        "context": "",
        "code": "def solve(s, n):\n    left = 0\n    right = 0\n    maxlength = 0\n    for i in range(n):\n        if (s[i] == '('):\n            left += 1\n        else:\n            right += 1\n        if (left == right):\n            maxlength = max(maxlength, 2 * right)\n        elif (right > left):\n            left = right = 0\n    left = right = 0\n    for i in range(n - 1, -1, -1):\n        if (s[i] == '('):\n            left += 1\n        else:\n            right += 1\n        if (left == right):\n            maxlength = max(maxlength, 2 * left)\n        elif (left > right):\n            left = right = 0\n    return maxlength\n",
        "test": "\nprint(solve(\"((()()()()(((())\", 16))\n",
        "output": "8\n",
        "fn_call": "solve"
    },
    {
        "text": "find x , y , z that satisfy 2 / n = 1 / x + 1 / y + 1 / z | function to find x y and z that satisfy given equation . ; ",
        "context": "",
        "code": "def printXYZ(n):\n    if n == 1:\n        print(-1)\n    else:\n        print(\"x is \", n)\n        print(\"y is \", n + 1)\n        print(\"z is \", n * (n + 1))\n",
        "test": "\nn = 7\nprintXYZ(n)\n",
        "output": "x is  7\ny is  8\nz is  56\n",
        "fn_call": "printXYZ"
    },
    {
        "text": "minimize sum by dividing all elements of a subarray by k | python3 implementation of the approach ; function to return the maximum subarray sum ; function to return the minimized sum of the array elements after performing the given operation ; find maximum subarray sum ; find total sum of the array ; maximum subarray sum is already negative ; choose the subarray whose sum is maximum and divide all elements by k ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxSubArraySum(a, size):\n    max_so_far = -(sys .maxsize - 1)\n    max_ending_here = 0\n    for i in range(size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        if (max_ending_here < 0):\n            max_ending_here = 0\n    return max_so_far\n\n\ndef minimizedSum(a, n, K):\n    sum = maxSubArraySum(a, n)\n    totalSum = 0\n    for i in range(n):\n        totalSum += a[i]\n    if (sum < 0):\n        return totalSum\n    totalSum = totalSum - sum + sum / K\n    return totalSum\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, -2, 3]\n    n = len(a)\n    K = 2\n    print(minimizedSum(a, n, K))\n",
        "output": "0.5\n",
        "fn_call": "minimizedSum"
    },
    {
        "text": "find the one missing number in range | find the missing number in a range ; here we xor of all the number ; xor last number ; ",
        "context": "",
        "code": "def missingNum(arr, n):\n    minvalue = min(arr)\n    xornum = 0\n    for i in range(0, n):\n        xornum ^= (minvalue) ^ arr[i]\n        minvalue = minvalue + 1\n    return xornum ^ minvalue\n",
        "test": "\narr = [13, 12, 11, 15]\nn = len(arr)\nprint(missingNum(arr, n))\n",
        "output": "14\n",
        "fn_call": "missingNum"
    },
    {
        "text": "convert a matrix into another matrix of given dimensions | function to construct a matrix of size a * b from the given matrix elements ; initialize a new matrix ; traverse the matrix , mat [ ] [ ] ; update idx ; print the resultant matrix ; ",
        "context": "",
        "code": "def ConstMatrix(mat, N, M, A, B):\n    if (N * M != A * B):\n        return -1\n    idx = 0\n    res = [[0 for i in range(B)]for i in range(A)]\n    for i in range(N):\n        for j in range(M):\n            res[idx // B][idx % B] = mat[i][j]\n            idx += 1\n    for i in range(A):\n        for j in range(B):\n            print(res[i][j], end=\" \")\n        print()\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[1, 2, 3, 4, 5, 6]]\n    A = 2\n    B = 3\n    N = len(mat)\n    M = len(mat[0])\n    ConstMatrix(mat, N, M, A, B)\n",
        "output": "1 2 3 \n4 5 6 \n",
        "fn_call": "ConstMatrix"
    },
    {
        "text": "strings formed from given characters without any consecutive repeating characters | function to print the strings which satisfy the mentioned conditions ; iterate through all the strings in the array . ; check function to check the conditions for every string ; function to check whether the string contains any consecutive repetitive characters and any characters other than those in str ; valid characters check ; nonrepetitive check ; ",
        "context": "",
        "code": "def check(s, strr):\n    chars = s\n    for c in chars:\n        if c not in strr:\n            return False\n    for i in range(len(chars) - 1):\n        if (chars[i] == chars[i + 1]):\n            return False\n    return True\n\ndef getStrings(strr, arr):\n    for i in range(len(arr)):\n        if (check(arr[i], strr)):\n            print(arr[i], end=\" \")\n",
        "test": "\nstrr = \"ABCD\"\narr = [\"AABCDA\", \"ABCDZADC\", \"ABCDBCA\", \"ABCDABDCA\"]\ngetStrings(strr, arr)\n",
        "output": "ABCDBCA ABCDABDCA ",
        "fn_call": "getStrings"
    },
    {
        "text": "smallest string consisting of a string s exactly k times as a substring | kmp algorithm ; function to return the required string ; finding the longest proper prefix which is also suffix ; ans string ; update ans appending the substring k - 1 times ; append the original string ; returning min length string which contain exactly k substring of given string ; ",
        "context": "",
        "code": "def kmp(s):\n    n = len(s)\n    lps = [None] * n\n    lps[0] = 0\n    i, Len = 1, 0\n    while (i < n):\n        if (s[i] == s[Len]):\n            Len += 1\n            lps[i] = Len\n            i += 1\n        else:\n            if (Len != 0):\n                Len = lps[Len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\n\ndef findString(s, k):\n    n = len(s)\n    lps = kmp(s)\n    ans = \"\"\n    suff = s[0:n - lps[n - 1]:1]\n    for i in range(k - 1):\n        ans += suff\n    ans += s\n    return ans\n",
        "test": "\nk = 3\ns = \"geeksforgeeks\"\nprint(findString(s, k))\n",
        "output": "geeksforgeeksforgeeksforgeeks\n",
        "fn_call": "findString"
    },
    {
        "text": "find nth term of the series 5 2 13 41 | python3 program to find nth term of the series 5 2 13 41 ; function to calculate nth term of the series ; if n is even number ; if n is odd number ; return nth term ; ",
        "context": "\nfrom math import pow\n\n",
        "code": "def nthTermOfTheSeries(n):\n    if (n % 2 == 0):\n        nthTerm = pow(n - 1, 2) + n\n    else:\n        nthTerm = pow(n + 1, 2) + n\n    return nthTerm\n",
        "test": "\nif __name__ == '__main__':\n    n = 8\n    print(int(nthTermOfTheSeries(n)))\n    n = 12\n    print(int(nthTermOfTheSeries(n)))\n    n = 102\n    print(int(nthTermOfTheSeries(n)))\n    n = 999\n    print(int(nthTermOfTheSeries(n)))\n    n = 9999\n    print(int(nthTermOfTheSeries(n)))\n",
        "output": "57\n133\n10303\n1000999\n100009999\n",
        "fn_call": "nthTermOfTheSeries"
    },
    {
        "text": "count the number of common divisors of the given strings | function that returns true if sub - string s [ 0. . . k ] is repeated a number of times to generate string s ; function to return the count of common divisors ; if the length of the sub - string divides length of both the strings ; if prefixes match in both the strings ; if both the strings can be generated ; ",
        "context": "",
        "code": "def check(s, k):\n    for i in range(0, len(s)):\n        if (s[i] != s[i % k]):\n            return False\n    return True\n\n\ndef countCommonDivisors(a, b):\n    ct = 0\n    n = len(a)\n    m = len(b)\n    for i in range(1, min(n, m) + 1):\n        if (n % i == 0 and m % i == 0):\n            if (a[0:i] == b[0:i]):\n                if (check(a, i) and check(b, i)):\n                    ct = ct + 1\n    return ct\n",
        "test": "\na = \"xaxa\"\nb = \"xaxaxaxa\"\nprint(countCommonDivisors(a, b))\n",
        "output": "2\n",
        "fn_call": "countCommonDivisors"
    },
    {
        "text": "maximum sum of elements divisible by k from the given array | python3 implementation ; function to return the maximum sum divisible by k from elements of v ; check if sum of elements excluding the current one is divisible by k ; check if sum of elements including the current one is divisible by k ; store the maximum ; ",
        "context": "\ndp = [[-1 for i in range(1001)]for j in range(1001)]\n\n",
        "code": "def find_max(i, sum, v, k):\n    if (i == len(v)):\n        return 0\n    if (dp[i][sum] != -1):\n        return dp[i][sum]\n    ans = 0\n    if ((sum + find_max(i + 1, sum, v, k)) % k == 0):\n        ans = find_max(i + 1, sum, v, k)\n    if ((sum + v[i] + find_max(i + 1, (sum + v[i]) % k, v, k)) % k == 0):\n        ans = max(ans, v[i] + find_max(i + 1, (sum + v[i]) % k, v, k))\n    dp[i][sum] = ans\n    return dp[i][sum]\n",
        "test": "\nif __name__ == '__main__':\n    arr = [43, 1, 17, 26, 15]\n    k = 16\n    print(find_max(0, 0, arr, k))\n",
        "output": "32\n",
        "fn_call": "find_max"
    },
    {
        "text": "number of ways to split n as sum of k numbers from the given range | python3 implementation to count the number of ways to divide n in k groups such that each group has elements in range [ l , r ] ; dp table ; function to count the number of ways to divide the number n in k groups such that each group has number of elements in range [ l , r ] ; base case ; if n is divides completely into less than k groups ; if the subproblem has been solved , use the value ; put all possible values greater equal to prev ; function to count the number of ways to divide the number n ; initialize dp table as - 1 ; ",
        "context": "\nmod = 1000000007\ndp = [[-1 for j in range(1000)]for i in range(1000)]\n\n",
        "code": "def calculate(pos, left, k, L, R):\n    if (pos == k):\n        if (left == 0):\n            return 1\n        else:\n            return 0\n    if (left == 0):\n        return 0\n    if (dp[pos][left] != -1):\n        return dp[pos][left]\n    answer = 0\n    for i in range(L, R + 1):\n        if (i > left):\n            break\n        answer = (answer + calculate(pos + 1, left - i, k, L, R)) % mod\n    dp[pos][left] = answer\n    return answer\n\n\ndef countWaystoDivide(n, k, L, R):\n    return calculate(0, n, k, L, R)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 12\n    K = 3\n    L = 1\n    R = 5\n    print(countWaystoDivide(N, K, L, R))\n",
        "output": "10\n",
        "fn_call": "countWaystoDivide"
    },
    {
        "text": "position of robot after given movements | function to find final position of robot after the complete movement ; traverse the instruction string 'move ; for each movement increment its respective counter ; required final position of robot ; ",
        "context": "",
        "code": "def finalPosition(move):\n    l = len(move)\n    countUp, countDown = 0, 0\n    countLeft, countRight = 0, 0\n    for i in range(l):\n        if (move[i] == 'U '):\n            countUp += 1\n        elif (move[i] == 'D '):\n            countDown += 1\n        elif (move[i] == 'L '):\n            countLeft += 1\n        elif (move[i] == 'R '):\n            countRight += 1\n    print(\"Final Position: (\", (countRight-countLeft), \", \", (countUp-countDown), \")\")\n",
        "test": "\nif __name__ == '__main__':\n    move = \"UDDLLRUUUDUURUDDUULLDRRRR\"\n    finalPosition(move)\n",
        "output": "Final Position: ( 0 ,  0 )\n",
        "fn_call": "finalPosition"
    },
    {
        "text": "count of n digit numbers having no pair of equal consecutive digits | iterative function to calculate ( x ^ y ) % mod in o ( log y ) ; initialize result ; update x if x >= mod ; if x is divisible by mod ; if y is odd , multiply x with result ; y must be even now y = y / 2 ; function to count the number of n - digit numbers with no equal pair of consecutive digits ; base case ; ",
        "context": "",
        "code": "def power(x, y, mod):\n    res = 1\n    x = x % mod\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return res\n\n\ndef count(N):\n    if (N == 1):\n        print(10)\n        return\n    print(power(9, N, 1000000007))\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    count(N)\n",
        "output": "729\n",
        "fn_call": "count"
    },
    {
        "text": "maximum subsequence sum possible by multiplying each element by its index | initialize dp array ; function to find the maximum sum of the subsequence formed ; base case ; if already calculated state occurs ; include the current element ; exclude the current element ; update the maximum ans ; function to calculate maximum sum of the subsequence obtained ; print the maximum sum possible ; ",
        "context": "\ndp = [[-1 for x in range(1005)]for y in range(1005)]\n\n",
        "code": "def maximumSumUtil(a, index, count, n):\n    if (index > n or count > n + 1):\n        return 0\n    if (dp[index][count] != -1):\n        return dp[index][count]\n    ans1 = (maximumSumUtil(a, index + 1, count + 1, n) + a[index] * count)\n    ans2 = maximumSumUtil(a, index + 1, count, n)\n    dp[index][count] = max(ans1, ans2)\n    return dp[index][count]\n\n\ndef maximumSum(arr, N):\n    print(maximumSumUtil(arr, 0, 1, N - 1))\n",
        "test": "\narr = [-1, 2, -10, 4, -20]\nN = len(arr)\nmaximumSum(arr, N)\n",
        "output": "15\n",
        "fn_call": "maximumSum"
    },
    {
        "text": "union and intersection of two sorted arrays | function prints union of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; print remaining elements of the larger array ; ",
        "context": "",
        "code": "def printUnion(arr1, arr2, m, n):\n    i, j = 0, 0\n    while i < m and j < n:\n        if arr1[i] < arr2[j]:\n            print(arr1[i])\n            i += 1\n        elif arr2[j] < arr1[i]:\n            print(arr2[j])\n            j += 1\n        else:\n            print(arr2[j])\n            j += 1\n            i += 1\n    while i < m:\n        print(arr1[i])\n        i += 1\n    while j < n:\n        print(arr2[j])\n        j += 1\n",
        "test": "\narr1 = [1, 2, 4, 5, 6]\narr2 = [2, 3, 5, 7]\nm = len(arr1)\nn = len(arr2)\nprintUnion(arr1, arr2, m, n)\n",
        "output": "1\n2\n3\n4\n5\n6\n7\n",
        "fn_call": "printUnion"
    },
    {
        "text": "find partition line such that sum of values on left and right is equal | python3 implementation of the approach ; function that returns true if the required line exists ; to handle negative values from x [ ] ; update arr [ ] such that arr [ i ] contains the sum of all v [ j ] such that x [ j ] = i for all valid values of j ; update arr [ i ] such that arr [ i ] contains the sum of the subarray arr [ 0. . . i ] from the original array ; if all the points add to 0 then the line can be drawn anywhere ; if the line is drawn touching the leftmost possible points ; if the line is drawn just before the current point ; if the line is drawn touching the current point ; if the line is drawn just after the current point ; if the line is drawn touching the rightmost possible points ; ",
        "context": "\nMAX = 1000\n\n",
        "code": "def lineExists(x, y, v, n):\n    size = (2 * MAX) + 1\n    arr = [0] * size\n    for i in range(n):\n        arr[x[i] + MAX] += v[i]\n    for i in range(1, size):\n        arr[i] += arr[i - 1]\n    if (arr[size - 1] == 0):\n        return True\n    if (arr[size - 1] - arr[0] == 0):\n        return True\n    for i in range(1, size - 1):\n        if (arr[i - 1] == arr[size - 1] - arr[i - 1]):\n            return True\n        if (arr[i - 1] == arr[size - 1] - arr[i]):\n            return True\n        if (arr[i] == arr[size - 1] - arr[i]):\n            return True\n    if (arr[size - 2] == 0):\n        return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    x = [-3, 5, 8]\n    y = [8, 7, 9]\n    v = [8, 2, 10]\n    n = len(x)\n    if (lineExists(x, y, v, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "lineExists"
    },
    {
        "text": "students with maximum average score of three subjects | function to find the list of students having maximum average score ; variables to store maximum average score ; list to store names of students having maximum average score ; traversing the file data ; finding average score of a student ; clear the list and add name of student having current maximum average score in the list ; printing the maximum average score and names of students having this maximum average score as per the order in the file . ; ",
        "context": "",
        "code": "def getStudentsList(file):\n    maxAvgScore = 0\n    names = []\n    for i in range(0, len(file), 4):\n        avgScore = (int(file[i + 1]) +\n                    int(file[i + 2]) + int(file[i + 3])) // 3\n        if avgScore > maxAvgScore:\n            maxAvgScore = avgScore\n            names .clear()\n            names .append(file[i])\n        elif avgScore == maxAvgScore:\n            names .add(file[i])\n    for i in range(len(names)):\n        print(names[i], end=\" \")\n    print(maxAvgScore)\n",
        "test": "\nif __name__ == \"__main__\":\n    file = [\"Shrikanth\", \"20\", \"30\", \"10\", \"Ram\", \"100\", \"50\", \"10\"]\n    getStudentsList(file)\n",
        "output": "Ram 53\n",
        "fn_call": "getStudentsList"
    },
    {
        "text": "program to calculate the number of odd days in ",
        "context": "",
        "code": "def oddDays(N):\n    hund1 = N // 100\n    hund4 = N // 400\n    leap = N >> 2\n    ordd = N - leap\n    if (hund1):\n        ordd += hund1\n        leap -= hund1\n    if (hund4):\n        ordd -= hund4\n        leap += hund4\n    days = ordd + leap * 2\n    odd = days % 7\n    return odd\n",
        "test": "\nN = 100\nprint(oddDays(N))\n",
        "output": "5\n",
        "fn_call": "oddDays"
    },
    {
        "text": "count total set bits in all numbers from 1 to n | function which counts set bits from 0 to n ; ans store sum of set bits from 0 to n ; while n greater than equal to 2 ^ i ; this k will get flipped after 2 ^ i iterations ; change is iterator from 2 ^ i to 1 ; this will loop from 0 to n for every bit position ; when change = 1 flip the bit ; again set change to 2 ^ i ; increment the position ; ",
        "context": "",
        "code": "def countSetBits(n):\n    i = 0\n    ans = 0\n    while ((1 << i) <= n):\n        k = 0\n        change = 1 << i\n        for j in range(0, n + 1):\n            ans += k\n            if change == 1:\n                k = not k\n                change = 1 << i\n            else:\n                change -= 1\n        i += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 17\n    print(countSetBits(n))\n",
        "output": "35\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "smallest of three integers without comparison operators | python3 program to find smallest of three integers without comparison operators ; ",
        "context": "",
        "code": "def smallest(x, y, z):\n    c = 0\n    while (x and y and z):\n        x = x - 1\n        y = y - 1\n        z = z - 1\n        c = c + 1\n    return c\n",
        "test": "\nx = 12\ny = 15\nz = 5\nprint(\"Minimum of 3 numbers is\", smallest(x, y, z))\n",
        "output": "Minimum of 3 numbers is 5\n",
        "fn_call": "smallest"
    },
    {
        "text": "minimum increments by 1 or k required to convert a string into another given string | function to count minimum increments by 1 or k required to convert x to y ; traverse the string x ; case 1 ; case 2 ; add the difference / k to the count ; add the difference % k to the count ; case 3 ; add the difference / k to the count ; add the difference % k to the count ; print the answer ; ",
        "context": "",
        "code": "def countOperations(X, Y, K):\n    count = 0\n    for i in range(len(X)):\n        c = 0\n        if (X[i] == Y[i]):\n            continue\n        elif (X[i] < Y[i]):\n            if ((ord(Y[i]) - ord(X[i])) >= K):\n                c = (ord(Y[i]) - ord(X[i])) // K\n            c += (ord(Y[i]) - ord(X[i])) % K\n        else:\n            t = 90 - ord(X[i])\n            t += ord(Y[i]) - 65 + 1\n            if (t >= K):\n                c = t // K\n            c += (t % K)\n        count += c\n    print(count)\n",
        "test": "\nX = \"ABCT\"\nY = \"PBDI\"\nK = 6\ncountOperations(X, Y, K)\n",
        "output": "11\n",
        "fn_call": "countOperations"
    },
    {
        "text": "search element in a sorted matrix | python3 implementation to search an element in a sorted matrix ; this function does binary search for x in i - th row . it does the search from mat [ i ] [ j_low ] to mat [ i ] [ j_high ] ; element found ; element not found ; function to perform binary search on the mid values of row to get the desired pair of rows where the element can be found ; single row matrix ; do binary search in middle column . condition to terminate the loop when the 2 desired rows are found ; element found ; if element is present on the mid of the two rows ; search element on 1 st half of 1 st row ; search element on 2 nd half of 1 st row ; search element on 1 st half of 2 nd row ; search element on 2 nd half of 2 nd row ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def binarySearch(mat, i, j_low, j_high, x):\n    while (j_low <= j_high):\n        j_mid = (j_low + j_high) // 2\n        if (mat[i][j_mid] == x):\n            print(\"Found at (\", i, \", \", j_mid, \")\")\n            return\n        elif (mat[i][j_mid] > x):\n            j_high = j_mid - 1\n        else:\n            j_low = j_mid + 1\n    print(\"Element no found\")\n\n\ndef sortedMatrixSearch(mat, n, m, x):\n    if (n == 1):\n        binarySearch(mat, 0, 0, m - 1, x)\n        return\n    i_low = 0\n    i_high = n - 1\n    j_mid = m // 2\n    while ((i_low + 1) < i_high):\n        i_mid = (i_low + i_high) // 2\n        if (mat[i_mid][j_mid] == x):\n            print(\"Found at (\", i_mid, \", \", j_mid, \")\")\n            return\n        elif (mat[i_mid][j_mid] > x):\n            i_high = i_mid\n        else:\n            i_low = i_mid\n    if (mat[i_low][j_mid] == x):\n        print(\"Found at (\", i_low, \",\", j_mid, \")\")\n    elif (mat[i_low + 1][j_mid] == x):\n        print(\"Found at (\", (i_low + 1), \", \", j_mid, \")\")\n    elif (x <= mat[i_low][j_mid - 1]):\n        binarySearch(mat, i_low, 0, j_mid - 1, x)\n    elif (x >= mat[i_low][j_mid + 1] and x <= mat[i_low][m - 1]):\n        binarySearch(mat, i_low, j_mid + 1, m - 1, x)\n    elif (x <= mat[i_low + 1][j_mid - 1]):\n        binarySearch(mat, i_low + 1, 0, j_mid - 1, x)\n    else:\n        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    m = 5\n    x = 8\n    mat = [[0, 6, 8, 9, 11], [20, 22, 28, 29, 31], [\n        36, 38, 50, 61, 63], [64, 66, 100, 122, 128]]\n    sortedMatrixSearch(mat, n, m, x)\n",
        "output": "Found at ( 0 , 2 )\n",
        "fn_call": "sortedMatrixSearch"
    },
    {
        "text": "least frequent element in an array | python3 program to find the most frequent element in an array . ; insert all elements in hash . ; find the max frequency ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def leastFrequent(arr, n):\n    Hash = dict()\n    for i in range(n):\n        if arr[i] in Hash .keys():\n            Hash[arr[i]] += 1\n        else:\n            Hash[arr[i]] = 1\n    min_count = n + 1\n    res = -1\n    for i in Hash:\n        if (min_count >= Hash[i]):\n            res = i\n            min_count = Hash[i]\n    return res\n",
        "test": "\narr = [1, 3, 2, 1, 2, 2, 3, 1]\nn = len(arr)\nprint(leastFrequent(arr, n))\n",
        "output": "3\n",
        "fn_call": "leastFrequent"
    },
    {
        "text": "sudo placement [ 1.5 ] | wolfish | python program for sp - wolfish ; function to find the maxcost of path from ( n - 1 , n - 1 ) to ( 0 , 0 ) | recursive approach ; base condition ; reaches the point ; i + j ; check if it is a power of 2 , then only move diagonally ; if not a power of 2 then move side - wise ; function to return the maximum cost ; calling dp function to get the answer ; ",
        "context": "\nsize = 1000\n\n",
        "code": "def maxCost(a: list, m: int, n: int) -> int:\n    if n < 0 or m < 0:\n        return int(-1e9)\n    elif m == 0 and n == 0:\n        return 0\n    else:\n        num = m + n\n        if (num & (num - 1)) == 0:\n            return a[m][n] + maxCost(a, m - 1, n - 1)\n        else:\n            return a[m][n] + max(maxCost(a, m - 1, n), maxCost(a, m, n - 1))\n\n\ndef answer(a: list, n: int) -> int:\n    return maxCost(a, n - 1, n - 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [[1, 2, 3, 1], [4, 5, 6, 1], [7, 8, 9, 1], [1, 1, 1, 1]]\n    n = 4\n    print(answer(a, n))\n",
        "output": "16\n",
        "fn_call": "answer"
    },
    {
        "text": "maximum sum bitonic subarray | function to find the maximum sum bitonic subarray ; ' msis [ ] ' to store the maximum sum increasing subarray up to each index of ' arr ' from the beginning ' msds [ ] ' to store the maximum sum decreasing subarray from each index of ' arr ' up to the end ; to store the maximum sum bitonic subarray ; building up the maximum sum increasing subarray for each array index ; building up the maximum sum decreasing subarray for each array index ; for each array index , calculating the maximum sum of bitonic subarray of which it is a part of ; if true , then update ' max ' bitonic subarray sum ; required maximum sum ; ",
        "context": "",
        "code": "def maxSumBitonicSubArr(arr, n):\n    msis = [None] * n\n    msds = [None] * n\n    max_sum = 0\n    msis[0] = arr[0]\n    for i in range(1, n):\n        if (arr[i] > arr[i - 1]):\n            msis[i] = msis[i - 1] + arr[i]\n        else:\n            msis[i] = arr[i]\n    msds[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        if (arr[i] > arr[i + 1]):\n            msds[i] = msds[i + 1] + arr[i]\n        else:\n            msds[i] = arr[i]\n    for i in range(n):\n        if (max_sum < (msis[i] + msds[i] - arr[i])):\n            max_sum = (msis[i] + msds[i] - arr[i])\n    return max_sum\n",
        "test": "\narr = [5, 3, 9, 2, 7, 6, 4]\nn = len(arr)\nprint(\"Maximum Sum = \" + str(maxSumBitonicSubArr(arr, n)))\n",
        "output": "Maximum Sum = 19\n",
        "fn_call": "maxSumBitonicSubArr"
    },
    {
        "text": "counting pairs when a person can form pair with at most one | number of ways in which participant can take part . ; base condition ; a participant can choose to consider ( 1 ) remains single . number of people reduce to ( x - 1 ) ( 2 ) pairs with one of the ( x - 1 ) others . for every pairing , number of people reduce to ( x - 2 ) . ; ",
        "context": "",
        "code": "def numberOfWays(x):\n    if x == 0 or x == 1:\n        return 1\n    else:\n        return (numberOfWays(x - 1) + (x - 1) * numberOfWays(x - 2))\n",
        "test": "\nx = 3\nprint(numberOfWays(x))\n",
        "output": "4\n",
        "fn_call": "numberOfWays"
    },
    {
        "text": "print all subsequences of a string | iterative method | python3 program to print all subsequences of a string in an iterative manner ; function to find subsequence ; loop while binary is greater than ; get the position of rightmost set bit ; append at beginning as we are going from lsb to msb ; resets bit at pos in binary ; function to print all subsequences ; map to store subsequence lexicographically by length ; total number of non - empty subsequence in string is 2 ^ len - 1 ; i = 0 , corresponds to empty subsequence ; subsequence for binary pattern i ; storing sub in map ; it . first is length of subsequence it . second is set  ; ii is iterator of type set  ; ",
        "context": "\nfrom math import log2, floor\n\n",
        "code": "def subsequence(s, binary):\n    sub = \"\"\n    while (binary > 0):\n        pos = floor(log2(binary & -binary) + 1)\n        sub = s[pos - 1] + sub\n        binary = (binary & ~(1 << (pos - 1)))\n    sub = sub[::-1]\n    return sub\n\n\ndef possibleSubsequences(s):\n    sorted_subsequence = {}\n    length = len(s)\n    limit = 2 ** length\n    for i in range(1, limit):\n        sub = subsequence(s, i)\n        if len(sub) in sorted_subsequence .keys():\n            sorted_subsequence[len(sub)] = tuple(\n                list(sorted_subsequence[len(sub)]) + [sub])\n        else:\n            sorted_subsequence[len(sub)] = [sub]\n    for it in sorted_subsequence:\n        print(\"Subsequences of length =\", it, \"are:\")\n        for ii in sorted(set(sorted_subsequence[it])):\n            print(ii, end=' ')\n        print()\n",
        "test": "\ns = \"aabc\"\npossibleSubsequences(s)\n",
        "output": "Subsequences of length = 1 are:\na b c \nSubsequences of length = 2 are:\naa ab ac bc \nSubsequences of length = 3 are:\naab aac abc \nSubsequences of length = 4 are:\naabc \n",
        "fn_call": "possibleSubsequences"
    },
    {
        "text": "probability of a key k present in array | function to find the probability ; find probability upto 2 decimal places ; ",
        "context": "",
        "code": "def kPresentProbability(a, n, k):\n    count = a .count(k)\n    return round(count / n, 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [4, 7, 2, 0, 8, 7, 5]\n    K = 2\n    N = len(A)\n    print(kPresentProbability(A, N, K))\n",
        "output": "0.14\n",
        "fn_call": "kPresentProbability"
    },
    {
        "text": "euclid\u00e2 \u20ac\u201c mullin sequence | function to return the smallest prime factor of n ; ",
        "context": "",
        "code": "def smallestPrimeFactor(n):\n    i = 2\n    while (i * i) <= n:\n        if n % i == 0:\n            return i\n        i += 1\n    return n\n\n\ndef solve(n):\n    product = 1\n    i = 0\n    while i < n:\n        num = smallestPrimeFactor(product + 1)\n        print(num, end=' ')\n        product = product * num\n        i += 1\n",
        "test": "\nb = 14\nsolve(b)\n",
        "output": "2 3 7 43 13 53 5 6221671 38709183810571 139 2801 11 17 5471 ",
        "fn_call": "solve"
    },
    {
        "text": "maximum product cutting | dp | the main function that returns maximum product obtainable from a rope of length n ; base cases ; make a cut at different places and take the maximum of all ; return the maximum of all values ; ",
        "context": "",
        "code": "def maxProd(n):\n    if (n == 0 or n == 1):\n        return 0\n    max_val = 0\n    for i in range(1, n - 1):\n        max_val = max(max_val, max(i * (n - i), maxProd(n - i) * i))\n    return max_val\n",
        "test": "\nprint(\"Maximum Product is \", maxProd(10))\n",
        "output": "Maximum Product is  36\n",
        "fn_call": "maxProd"
    },
    {
        "text": "program to find count of numbers having odd number of divisors in given range | function to return the count of divisors of a number ; count the powers of the current prime i which divides a ; update the count of divisors ; reset the count ; if the remaining a is prime then a ^ 1 will be one of its prime factors ; function to count numbers having odd number of divisors in range [ a , b ] ; to store the count of elements having odd number of divisors ; iterate from a to b and find the count of their divisors ; to store the count of divisors of i ; if the divisor count of i is odd ; ",
        "context": "",
        "code": "def divisor(a):\n    div = 1\n    count = 0\n    for i in range(2, int(pow(a, 1 / 2)) + 1):\n        while (a % i == 0):\n            count += 1\n            a = a / i\n        div = div * (count + 1)\n        count = 0\n    if (a > 1):\n        div = div * (2)\n    return div\n\n\ndef OddDivCount(a, b):\n    res = 0\n    for i in range(a, b + 1):\n        divCount = divisor(i)\n        if (divCount % 2):\n            res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    a, b = 1, 10\n    print(OddDivCount(a, b))\n",
        "output": "3\n",
        "fn_call": "OddDivCount"
    },
    {
        "text": "maximum range length such that a [ i ] is maximum in given range for all i from [ 1 , n ] | python 3 program for the above approach ; function to find maximum range for each i such that arr [ i ] is max in range ; vector to store the left and right index for each i such that left [ i ] > arr [ i ] and right [ i ] > arr [ i ] ; traverse the array ; while s . top ( ) . first < a [ i ] remove the top element from the stack ; modify left [ i ] ; clear the stack ; traverse the array to find right [ i ] for each i ; while s . top ( ) . first < a [ i ] remove the top element from the stack ; modify right [ i ] ; print the value range for each i ; ",
        "context": "\nimport sys\n\n",
        "code": "def MaxRange(A, n):\n    left = [0] * n\n    right = [0] * n\n    s = []\n    s .append((sys .maxsize, -1))\n    for i in range(n):\n        while (s[-1][0] < A[i]):\n            s .pop()\n        left[i] = s[-1][1]\n        s .append((A[i], i))\n    while (len(s) != 0):\n        s .pop()\n    s .append((sys .maxsize, n))\n    for i in range(n - 1, -1, -1):\n        while (s[-1][0] < A[i]):\n            s .pop()\n        right[i] = s[-1][1]\n        s .append((A[i], i))\n    for i in range(n):\n        print(left[i] + 1, ' ', right[i] - 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 3, 2]\n    n = len(arr)\n    MaxRange(arr, n)\n",
        "output": "0   0\n0   2\n2   2\n",
        "fn_call": "MaxRange"
    },
    {
        "text": "minimum number of flipping adjacent bits required to make given binary strings equal | function to find the minimum number of inversions required . ; initializing the answer ; iterate over the range ; if s1 [ i ] != s2 [ i ] , then inverse the characters at i snd ( i + 1 ) positions in s1 . ; adding 1 to counter if characters are not same ; ",
        "context": "",
        "code": "def find_Min_Inversion(n, s1, s2):\n    count = 0\n    s1 = list(s1)\n    s2 = list(s2)\n    for i in range(n - 1):\n        if (s1[i] != s2[i]):\n            if (s1[i] == '1'):\n                s1[i] = '0'\n            else:\n                s1[i] = '1'\n            if (s1[i + 1] == '1'):\n                s1[i + 1] = '0'\n            else:\n                s1[i + 1] = '1'\n            count += 1\n    s1 = ''.join(s1)\n    s2 = ''.join(s2)\n    if (s1 == s2):\n        return count\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    s1 = \"0101\"\n    s2 = \"1111\"\n    print(find_Min_Inversion(n, s1, s2))\n",
        "output": "2\n",
        "fn_call": "find_Min_Inversion"
    },
    {
        "text": "number of ways to choose elements from the array such that their average is k | python implementation of above approach ; initialize dp array by - 1 ; base cases index can 't be less than 0 ; no element is picked hence average cannot be calculated ; if remainder is non zero , we cannot divide the sum by count i . e . the average will not be an integer ; if we find an average return 1 ; if we have already calculated this function simply return it instead of calculating it again ; if we don 't pick the current element  simple recur for index -1 ; if we pick the current element add it to our current sum and increment count by 1 ; store the value for the current function ; function to return the number of ways ; push - 1 at the beginning to make it 1 - based indexing ; call recursive function waysutil to calculate total ways ; ",
        "context": "\nimport numpy as np\nMAX_INDEX = 51\nMAX_SUM = 2505\ndp = np .ones((MAX_INDEX, MAX_SUM, MAX_INDEX)) * -1\n\n",
        "code": "def waysutil(index, sum, count, arr, K):\n    if (index < 0):\n        return 0\n    if (index == 0):\n        if (count == 0):\n            return 0\n        remainder = sum % count\n        if (remainder != 0):\n            return 0\n        average = sum // count\n        if (average == K):\n            return 1\n    if (dp[index][sum][count] != -1):\n        return dp[index][sum][count]\n    dontpick = waysutil(index - 1, sum, count, arr, K)\n    pick = waysutil(index - 1, sum + arr[index], count + 1, arr, K)\n    total = pick + dontpick\n    dp[index][sum][count] = total\n    return total\n\n\ndef ways(N, K, arr):\n    Arr = []\n    Arr .append(-1)\n    for i in range(N):\n        Arr .append(arr[i])\n    answer = waysutil(N, 0, 0, Arr, K)\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 6, 2, 8, 7, 6, 5, 9]\n    N = len(arr)\n    K = 5\n    print(ways(N, K, arr))\n",
        "output": "19.0\n",
        "fn_call": "ways"
    },
    {
        "text": "how to check if a ",
        "context": "\nimport math\n\n",
        "code": "def isPerfectSquare(x):\n    s = int(math .sqrt(x))\n    return s * s == x\n\n\ndef isFibonacci(n):\n    return isPerfectSquare(5 * n * n + 4) or isPerfectSquare(5 * n * n - 4)\n",
        "test": "\nfor i in range(1, 11):\n    if (isFibonacci(i)):\n        print(i, \"is a Fibonacci Number\")\n    else:\n        print(i, \"is a not Fibonacci Number \")\n",
        "output": "1 is a Fibonacci Number\n2 is a Fibonacci Number\n3 is a Fibonacci Number\n4 is a not Fibonacci Number \n5 is a Fibonacci Number\n6 is a not Fibonacci Number \n7 is a not Fibonacci Number \n8 is a Fibonacci Number\n9 is a not Fibonacci Number \n10 is a not Fibonacci Number \n",
        "fn_call": "isFibonacci"
    },
    {
        "text": "find a subarray of size k whose sum is a perfect square | python3 program for the above approach ; function to check if a given number is a perfect square or not ; find square root of n ; check if the square root is an integer or not ; function to print the subarray whose sum is a perfect square ; sum of first k elements ; if the first k elements have a sum as perfect square ; iterate through the array ; if sum is perfect square ; if subarray not found ; ",
        "context": "\nfrom math import sqrt, ceil, floor\n\n",
        "code": "def isPerfectSquare(n):\n    sr = sqrt(n)\n    return ((sr - floor(sr)) == 0)\n\n\ndef SubarrayHavingPerfectSquare(arr, k):\n    ans = [0, 0]\n    sum = 0\n    i = 0\n    while i < k:\n        sum += arr[i]\n        i += 1\n    found = False\n    if (isPerfectSquare(sum)):\n        ans[0] = 0\n        ans[1] = i - 1\n    else:\n        for j in range(i, len(arr)):\n            sum = sum + arr[j] - arr[j - k]\n            if (isPerfectSquare(sum)):\n                found = True\n                ans[0] = j - k + 1\n                ans[1] = j\n        for k in range(ans[0], ans[1] + 1):\n            print(arr[k], end=\" \")\n    if (found == False):\n        print(\"-1\")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [20, 34, 51, 10, 99, 87, 23, 45]\n    K = 3\n    SubarrayHavingPerfectSquare(arr, K)\n",
        "output": "10 99 87 ",
        "fn_call": "SubarrayHavingPerfectSquare"
    },
    {
        "text": "find the final number obtained after performing the given operation | python3 implementation of the approach ; function to return the final number obtained after performing the given operation ; find the gcd of the array elements ; ",
        "context": "\nfrom math import gcd as __gcd\n\n",
        "code": "def finalNum(arr, n):\n    result = arr[0]\n    for i in arr:\n        result = __gcd(result, i)\n    return result\n",
        "test": "\narr = [3, 9, 6, 36]\nn = len(arr)\nprint(finalNum(arr, n))\n",
        "output": "3\n",
        "fn_call": "finalNum"
    },
    {
        "text": "find the only missing number in a sorted array | python 3 program to find the only missing element . ; if this is the first element which is not index + 1 , then missing element is mid + 1 ; if this is not the first missing element search in left side ; if it follows index + 1 property then search in right side ; if no element is missing ; ",
        "context": "",
        "code": "def findmissing(ar, N):\n    l = 0\n    r = N - 1\n    while (l <= r):\n        mid = (l + r) / 2\n        mid = int(mid)\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid):\n            return (mid + 1)\n        elif (ar[mid] != mid + 1):\n            r = mid - 1\n        else:\n            l = mid + 1\n    return (-1)\n\n\ndef main():\n    ar = [1, 2, 3, 4, 5, 7, 8]\n    N = len(ar)\n    res = findmissing(ar, N)\n    print(res)\n",
        "test": "\nif __name__ == \"__main__\":\n    main()\n",
        "output": "6\n",
        "fn_call": "main"
    },
    {
        "text": "largest number less than x having at most k set bits | function to return the greatest number <= x having at most k set bits . ; remove rightmost set bits one by one until we count becomes k ; return the required number ; ",
        "context": "",
        "code": "def greatestKBits(X, K):\n    set_bit_count = bin(X).count('1')\n    if (set_bit_count <= K):\n        return X\n    diff = set_bit_count - K\n    for i in range(0, diff, 1):\n        X &= (X - 1)\n    return X\n",
        "test": "\nif __name__ == '__main__':\n    X = 21\n    K = 2\n    print(greatestKBits(X, K))\n",
        "output": "20\n",
        "fn_call": "greatestKBits"
    },
    {
        "text": "count of numbers whose sum of increasing powers of digits is equal to the number itself | function to return the count of digits of n ; function to return the sum of increasing powers of n ; to store the required answer ; count of digits in n which will be the power of the last digit ; while there are digits left ; get the last digit ; add the last digit after raising it to the required power ; decrement the power for the previous digit ; remove the last digit ; function to return the count of integers which satisfy the given conditions ; if current element satisfies the given condition ; ",
        "context": "",
        "code": "def countDigits(n):\n    cnt = 0\n    while (n > 0):\n        cnt += 1\n        n //= 10\n    return cnt\n\n\ndef digitPowSum(n):\n    sum = 0\n    pw = countDigits(n)\n    while (n > 0):\n        d = n % 10\n        sum += pow(d, pw)\n        pw -= 1\n        n //= 10\n    return sum\n\n\ndef countNum(n):\n    count = 0\n    for i in range(n + 1):\n        if (i == digitPowSum(i)):\n            count += 1\n    return count\n",
        "test": "\nn = 200\nprint(countNum(n))\n",
        "output": "13\n",
        "fn_call": "countNum"
    },
    {
        "text": "count unique paths with given sum in an n | python3 program for the above approach ; function for counting total no of paths possible with the sum is equal to x ; if the path of the sum from the root to current node is stored in sum ; if already computed ; count different no of paths using all possible ways ; return total no of paths ; ",
        "context": "\nmod = int(1e9 + 7)\n\n",
        "code": "def findTotalPath(X, n, dp):\n    if (X == 0):\n        return 1\n    ans = 0\n    if (dp[X] != -1):\n        return dp[X]\n    for i in range(1, min(X, n) + 1):\n        ans = ans + findTotalPath(X - i, n, dp) % mod\n        ans %= mod\n    dp[X] = ans\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    X = 2\n    dp = [-1] * (X + 1)\n    print(findTotalPath(X, n, dp))\n",
        "output": "2\n",
        "fn_call": "findTotalPath"
    },
    {
        "text": "print rectangular pattern with given center | function to print the matrix filled with rectangle pattern having center coordinates are c1 , c2 ; iterate in the range [ 0 , n - 1 ] ; iterate in the range [ 0 , n - 1 ] ; ",
        "context": "",
        "code": "def printRectPattern(c1, c2, n):\n    for i in range(n):\n        for j in range(n):\n            print(max(abs(c1 - i), abs(c2 - j)), end=\" \")\n        print(\"\")\n",
        "test": "\nc1 = 2\nc2 = 2\nn = 5\nprintRectPattern(c1, c2, n)\n",
        "output": "2 2 2 2 2 \n2 1 1 1 2 \n2 1 0 1 2 \n2 1 1 1 2 \n2 2 2 2 2 \n",
        "fn_call": "printRectPattern"
    },
    {
        "text": "maximize the subarray sum after multiplying all elements of any subarray with x | python3 implementation of the approach ; function to return the maximum sum ; base case ; if already calculated ; if no elements have been chosen ; do not choose any element and use kadane 's algorithm by taking max ; choose the sub - array and multiply x ; choose the sub - array and multiply x ; end the sub - array multiplication ; no more multiplication ; memoize and return the answer ; function to get the maximum sum ; initialize dp with - 1 ; iterate from every position and find the maximum sum which is possible ; ",
        "context": "\nN = 5\n\n",
        "code": "def func(idx, cur, a, dp, n, x):\n    if (idx == n):\n        return 0\n    if (dp[idx][cur] != -1):\n        return dp[idx][cur]\n    ans = 0\n    if (cur == 0):\n        ans = max(ans, a[idx] + func(idx + 1, 0, a, dp, n, x))\n        ans = max(ans, x * a[idx] + func(idx + 1, 1, a, dp, n, x))\n    elif (cur == 1):\n        ans = max(ans, x * a[idx] + func(idx + 1, 1, a, dp, n, x))\n        ans = max(ans, a[idx] + func(idx + 1, 2, a, dp, n, x))\n    else:\n        ans = max(ans, a[idx] + func(idx + 1, 2, a, dp, n, x))\n    dp[idx][cur] = ans\n    return dp[idx][cur]\n\n\ndef getMaximumSum(a, n, x):\n    dp = [[-1 for i in range(3)]for j in range(n)]\n    maxi = 0\n    for i in range(0, n):\n        maxi = max(maxi, func(i, 0, a, dp, n, x))\n    return maxi\n",
        "test": "\na = [-3, 8, -2, 1, -6]\nn = len(a)\nx = -1\nprint(getMaximumSum(a, n, x))\n",
        "output": "15\n",
        "fn_call": "getMaximumSum"
    },
    {
        "text": "hierholzer 's algorithm for directed graph | python3 program to print eulerian circuit in given directed graph using hierholzer algorithm ; adj represents the adjacency list of the directed graph edge_count represents the number of edges emerging from a vertex ; find the count of edges to keep track of unused edges ; empty graph maintain a stack to keep vertices ; vector to store final circuit ; start from any vertex ; current vertex ; if there 's remaining edge ; push the vertex ; find the next vertex using an edge ; and remove that edge ; move to next vertex ; back - track to find remaining circuit ; back - tracking ; we 've got the circuit, now print it in reverse ; ",
        "context": "",
        "code": "def printCircuit(adj):\n    edge_count = dict()\n    for i in range(len(adj)):\n        edge_count[i] = len(adj[i])\n    if len(adj) == 0:\n        return\n    curr_path = []\n    circuit = []\n    curr_path .append(0)\n    curr_v = 0\n    while len(curr_path):\n        if edge_count[curr_v]:\n            curr_path .append(curr_v)\n            next_v = adj[curr_v][-1]\n            edge_count[curr_v] -= 1\n            adj[curr_v].pop()\n            curr_v = next_v\n        else:\n            circuit .append(curr_v)\n            curr_v = curr_path[-1]\n            curr_path .pop()\n    for i in range(len(circuit) - 1, -1, -1):\n        print(circuit[i], end=\"\")\n        if i:\n            print(\" -> \", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    adj1 = [0] * 3\n    for i in range(3):\n        adj1[i] = []\n    adj1[0].append(1)\n    adj1[1].append(2)\n    adj1[2].append(0)\n    printCircuit(adj1)\n    print()\n    adj2 = [0] * 7\n    for i in range(7):\n        adj2[i] = []\n    adj2[0].append(1)\n    adj2[0].append(6)\n    adj2[1].append(2)\n    adj2[2].append(0)\n    adj2[2].append(3)\n    adj2[3].append(4)\n    adj2[4].append(2)\n    adj2[4].append(5)\n    adj2[5].append(0)\n    adj2[6].append(4)\n    printCircuit(adj2)\n    print()\n",
        "output": "0 -> 1 -> 2 -> 0\n0 -> 6 -> 4 -> 5 -> 0 -> 1 -> 2 -> 3 -> 4 -> 2 -> 0\n",
        "fn_call": "printCircuit"
    },
    {
        "text": "minimum length of the reduced array formed using given operations | python3 implementation to find the minimum length of the array ; function to find the length of minimized array ; creating the required dp tables initialising the dp table by - 1 ; base case ; check if the two subarray can be combined ; initialising dp1 table with max value ; check if the subarray can be reduced to a single element ; minimal partition of [ 1 : j - 1 ] + 1 ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def minimalLength(a, n):\n    dp = np .ones((n + 1, n + 1)) * -1\n    dp1 = [0] * n\n    for size in range(1, n + 1):\n        for i in range(n - size + 1):\n            j = i + size - 1\n            if (i == j):\n                dp[i][j] = a[i]\n            else:\n                for k in range(i, j):\n                    if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]):\n                        dp[i][j] = dp[i][k] + 1\n    for i in range(n):\n        dp1[i] = int(1e7)\n    for i in range(n):\n        for j in range(i + 1):\n            if (dp[j][i] != -1):\n                if (j == 0):\n                    dp1[i] = 1\n                else:\n                    dp1[i] = min(dp1[i], dp1[j - 1] + 1)\n    return dp1[n - 1]\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 7\n    a = [3, 3, 4, 4, 4, 3, 3]\n    print(minimalLength(a, n))\n",
        "output": "2\n",
        "fn_call": "minimalLength"
    },
    {
        "text": "find a value whose xor with given number is maximum | function to calculate answer ; find number of bits in the given integer ; xor the given integer with poe ( 2 , number_of_bits - 1 and print the result ; ",
        "context": "",
        "code": "def calculate(X):\n    number_of_bits = 8\n    return ((1 << number_of_bits) - 1) ^ X\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 4\n    print(\"Required Number is:\", calculate(X))\n",
        "output": "Required Number is: 251\n",
        "fn_call": "calculate"
    },
    {
        "text": "program to find all possible triangles having same area and perimeter | function to print sides of all the triangles having same perimeter & area ; stores unique sides of triangles ; i + j + k values cannot exceed 256 ; find the value of 2 * s ; find the value of 2 * ( s - a ) ; find the value of 2 * ( s - b ) ; find the value of 2 * ( s - c ) ; if triplets have same area and perimeter ; store sides of triangle ; sort the triplets ; inserting in set to avoid duplicate sides ; print sides of all desired triangles ; ",
        "context": "",
        "code": "def samePerimeterAndArea():\n    se = []\n    for i in range(1, 256, 1):\n        for j in range(1, 256, 1):\n            for k in range(1, 256, 1):\n                peri = i + j + k\n                mul1 = -i + j + k\n                if (k > 100):\n                    break\n                if (j > 100):\n                    break\n                if (i > 100):\n                    break\n                mul2 = i - j + k\n                mul3 = i + j - k\n                if (16 * peri == mul1 * mul2 * mul3):\n                    v = [i, j, k]\n                    v .sort(reverse=False)\n                    se .append(v)\n                    se .sort(reverse=False)\n    temp = []\n    temp .append(se[0])\n    temp .append(se[6])\n    temp .append(se[12])\n    temp .append(se[18])\n    temp .append(se[24])\n    for it in temp:\n        print(it[0], it[1], it[2])\n",
        "test": "\nif __name__ == '__main__':\n    samePerimeterAndArea()\n",
        "output": "5 12 13\n6 8 10\n6 25 29\n7 15 20\n9 10 17\n",
        "fn_call": "samePerimeterAndArea"
    },
    {
        "text": "find the sum of the series 1 , 2 , 3 , 6 , 9 , 18 , 27 , 54 , ... till n terms | function to find the sum of series ; flag to find the multiplicating factor . . i . e , by 2 or 3 / 2 ; first term ; if flag is true , multiply by 2 ; if flag is false , multiply by 3 / 2 ; update the previous element to nextelement ; print the sum ; ",
        "context": "",
        "code": "def printSeriesSum(N):\n    sum = 0\n    a = 1\n    cnt = 0\n    flag = True\n    sum += a\n    while (cnt < N):\n        nextElement = None\n        if (flag):\n            nextElement = a * 2\n            sum += nextElement\n            flag = not flag\n        else:\n            nextElement = a * (3 / 2)\n            sum += nextElement\n            flag = not flag\n        a = nextElement\n        cnt += 1\n    print(sum)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 8\n    printSeriesSum(N)\n",
        "output": "201.0\n",
        "fn_call": "printSeriesSum"
    },
    {
        "text": "maximize the number of palindromic strings | python3 program for the above approach ; to check if there is any string of odd length ; if there is at least 1 string of odd length . ; if all the strings are of even length . ; count of 0 's in all  the strings ; count of 1 's in  all the strings ; if z is even and o is even then ans will be n . ; otherwise ans will be n - 1. ; ",
        "context": "",
        "code": "def max_palindrome(s, n):\n    flag = 0\n    for i in range(n):\n        if (len(s[i]) % 2 != 0):\n            flag = 1\n    if (flag == 1):\n        return n\n    z = 0\n    o = 0\n    for i in range(n):\n        for j in range(len(s[i])):\n            if (s[i][j] == '0'):\n                z += 1\n            else:\n                o += 1\n    if (o % 2 == 0 and z % 2 == 0):\n        return n\n    else:\n        return n - 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    s = [\"1110\", \"100110\", \"010101\"]\n    print(max_palindrome(s, n))\n",
        "output": "2\n",
        "fn_call": "max_palindrome"
    },
    {
        "text": "capacity to ship packages within d days | function to check if the weights can be delivered in d days or not ; stores the count of days required to ship all the weights if the maximum capacity is mx ; traverse all the weights ; if total weight is more than the maximum capacity ; if days are more than d , then return false ; return true for the days < d ; function to find the least weight capacity of a boat to ship all the weights within d days ; stores the total weights to be shipped ; find the sum of weights ; stores the maximum weight in the array that has to be shipped ; store the ending value for the search space ; store the required result ; perform binary search ; store the middle value ; if mid can be shipped , then update the result and end value of the search space ; search for minimum value in the right part ; print the result ; ",
        "context": "",
        "code": "def isValid(weight, n, D, mx):\n    st = 1\n    sum = 0\n    for i in range(n):\n        sum += weight[i]\n        if (sum > mx):\n            st += 1\n            sum = weight[i]\n        if (st > D):\n            return False\n    return True\n\n\ndef shipWithinDays(weight, D, n):\n    sum = 0\n    for i in range(n):\n        sum += weight[i]\n    s = weight[0]\n    for i in range(1, n):\n        s = max(s, weight[i])\n    e = sum\n    res = -1\n    while (s <= e):\n        mid = s + (e - s) // 2\n        if (isValid(weight, n, D, mid)):\n            res = mid\n            e = mid - 1\n        else:\n            s = mid + 1\n    print(res)\n",
        "test": "\nif __name__ == '__main__':\n    weight = [9, 8, 10]\n    D = 3\n    N = len(weight)\n    shipWithinDays(weight, D, N)\n",
        "output": "10\n",
        "fn_call": "shipWithinDays"
    },
    {
        "text": "find row number of a binary matrix having maximum number of 1 s | python program to find row with maximum 1 in row sorted binary matrix ; function for finding row with maximum 1 ; find left most position of 1 in a row find 1 st zero in a row ; ",
        "context": "\nN = 4\n\n",
        "code": "def findMax(arr):\n    row = 0\n    j = N - 1\n    for i in range(0, N):\n        while (arr[i][j] == 1 and j >= 0):\n            row = i\n            j -= 1\n    print(\"Row number = \", row + 1, \", MaxCount = \", N - 1 - j)\n",
        "test": "\narr = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 0], [0, 1, 1, 1]]\nfindMax(arr)\n",
        "output": "Row number =  4 , MaxCount =  3\n",
        "fn_call": "findMax"
    },
    {
        "text": "count of sub | function that returns the count of sub - arrays with odd product ; initialize the count variable ; initialize variable to store the last index with even number ; initialize variable to store count of continuous odd numbers ; loop through the array ; check if the number is even or not ; calculate count of continuous odd numbers ; increase the count of sub - arrays with odd product ; store the index of last even number ; n considered as index of even number ; ",
        "context": "",
        "code": "def countSubArrayWithOddProduct(A, N):\n    count = 0\n    last = -1\n    K = 0\n    for i in range(N):\n        if (A[i] % 2 == 0):\n            K = (i - last - 1)\n            count += (K * (K + 1) / 2)\n            last = i\n    K = (N - last - 1)\n    count += (K * (K + 1) / 2)\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [12, 15, 7, 3, 25, 6, 2, 1, 1, 7]\n    n = len(arr)\n    print(int(countSubArrayWithOddProduct(arr, n)))\n",
        "output": "16\n",
        "fn_call": "countSubArrayWithOddProduct"
    },
    {
        "text": "find gcd of factorial of elements of given array | implementation of factorial function ; function to find gcd of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; ",
        "context": "",
        "code": "def factorial(n):\n    if n == 1 or n == 0:\n        return 1\n    else:\n        return factorial(n - 1) * n\n\n\ndef gcdOfFactorial(arr, n):\n    minm = arr[0]\n    for i in range(1, n):\n        if minm > arr[i]:\n            minm = arr[i]\n        else:\n            arr[i] = minm\n    return factorial(minm)\n",
        "test": "\narr = [9, 12, 122, 34, 15]\nn = len(arr)\nprint(gcdOfFactorial(arr, n))\n",
        "output": "362880\n",
        "fn_call": "gcdOfFactorial"
    },
    {
        "text": "sum of fibonacci numbers | computes value of first fibonacci numbers ; initialize result ; add remaining terms ; ",
        "context": "",
        "code": "def calculateSum(n):\n    if (n <= 0):\n        return 0\n    fibo = [0] * (n + 1)\n    fibo[1] = 1\n    sm = fibo[0] + fibo[1]\n    for i in range(2, n + 1):\n        fibo[i] = fibo[i - 1] + fibo[i - 2]\n        sm = sm + fibo[i]\n    return sm\n",
        "test": "\nn = 4\nprint(\"Sum of Fibonacci numbers is : \", calculateSum(n))\n",
        "output": "Sum of Fibonacci numbers is :  7\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "length of the longest substring with every character appearing even number of times | function to find length of the longest substring with each element occurring even number of times ; initialize unordered_map ; stores the length of the longest required substring ; traverse the string ; stores the value of the digit present at current index ; bitwise xor of the mask with 1 left - shifted by val ; check if the value of mask is already present in ind or not ; update the final answer ; otherwise ; return the answer ; ",
        "context": "",
        "code": "def lenOfLongestReqSubstr(s, N):\n    ind = {}\n    mask = 0\n    ind[0] = -1\n    ans = 0\n    for i in range(N):\n        val = ord(s[i]) - ord('0')\n        mask ^= (1 << val)\n        if (mask in ind):\n            ans = max(ans, i - ind[mask])\n        else:\n            ind[mask] = i\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"223015150\"\n    N = len(s)\n    print(lenOfLongestReqSubstr(s, N))\n",
        "output": "6\n",
        "fn_call": "lenOfLongestReqSubstr"
    },
    {
        "text": "find cubic root of a number | returns the absolute value of n - mid * mid * mid ; returns cube root of a no n ; set start and end for binary search ; set precision ; if error is less than e then mid is our answer so return mid ; if mid * mid * mid is greater than n set end = mid ; if mid * mid * mid is less than n set start = mid ; ",
        "context": "",
        "code": "def diff(n, mid):\n    if (n > (mid * mid * mid)):\n        return (n - (mid * mid * mid))\n    else:\n        return ((mid * mid * mid) - n)\n\n\ndef cubicRoot(n):\n    start = 0\n    end = n\n    e = 0.0000001\n    while (True):\n        mid = (start + end) / 2\n        error = diff(n, mid)\n        if (error <= e):\n            return mid\n        if ((mid * mid * mid) > n):\n            end = mid\n        else:\n            start = mid\n",
        "test": "\nn = 3\nprint(\"Cubic root of\", n, \"is\", round(cubicRoot(n), 6))\n",
        "output": "Cubic root of 3 is 1.44225\n",
        "fn_call": "cubicRoot"
    },
    {
        "text": "generate k co | python3 implementation of the above approach ; function prints the required pairs ; first co - prime pair ; as a pair ( 1 n ) has already been printed ; if i is a factor of n ; since ( i , i ) won 't form  a coprime pair ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def FindPairs(n, k):\n    print(1, n)\n    k -= 1\n    for i in range(2, int(sqrt(n)) + 1):\n        if (n % i == 0):\n            print(1, i)\n            k -= 1\n            if (k == 0):\n                break\n            if (i != n // i):\n                print(1, n // i)\n                k -= 1\n            if (k == 0):\n                break\n",
        "test": "\nif __name__ == '__main__':\n    N = 100\n    K = 5\n    FindPairs(N, K)\n",
        "output": "1 100\n1 2\n1 50\n1 4\n1 25\n",
        "fn_call": "FindPairs"
    },
    {
        "text": "median of two sorted arrays of different sizes | set 1 ( linear ) | this function returns median of a [ ] and b [ ] . assumptions in this function : both a [ ] and b [ ] are sorted arrays ; current index of i / p array a [ ] ; current index of i / p array b [ ] ; below is to handle the case where all elements of a [ ] are smaller than smallest ( or first ) element of b [ ] or a [ ] is empty ; below is to handle case where all elements of b [ ] are smaller than smallest ( or first ) element of a [ ] or b [ ] is empty ; below is to handle the case where sum of number of elements of the arrays is even ; below is to handle the case where sum of number of elements of the arrays is odd ; ",
        "context": "",
        "code": "def findmedian(a, n1, b, n2):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    for k in range(((n1 + n2) // 2) + 1):\n        if (i < n1 and j < n2):\n            if (a[i] < b[j]):\n                m2 = m1\n                m1 = a[i]\n                i += 1\n            else:\n                m2 = m1\n                m1 = b[j]\n                j += 1\n        elif (i == n1):\n            m2 = m1\n            m1 = b[j]\n            j += 1\n        elif (j == n2):\n            m2 = m1\n            m1 = a[i]\n            i += 1\n    if ((n1 + n2) % 2 == 0):\n        return (m1 + m2) * 1.0 / 2\n    return m1\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 12, 15, 26, 38]\n    b = [2, 13, 24]\n    n1 = len(a)\n    n2 = len(b)\n    print(findmedian(a, n1, b, n2))\n",
        "output": "14.0\n",
        "fn_call": "findmedian"
    },
    {
        "text": "maximum sum in a 2 x n grid such that no two elements are adjacent | function to find max sum without adjacent ; sum including maximum element of first column ; not including first column 's element ; traverse for further elements ; update max_sum on including or excluding of previous column ; include current column . add maximum element from both row of current column ; if current column doesn 't to be included ; return maximum of excl and incl as that will be the maximum sum ; ",
        "context": "",
        "code": "def maxSum(grid, n):\n    incl = max(grid[0][0], grid[1][0])\n    excl = 0\n    for i in range(1, n):\n        excl_new = max(excl, incl)\n        incl = excl + max(grid[0][i], grid[1][i])\n        excl = excl_new\n    return max(excl, incl)\n",
        "test": "\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\n    n = 5\n    print(maxSum(grid, n))\n",
        "output": "24\n",
        "fn_call": "maxSum"
    },
    {
        "text": "longest common substring | dp | returns length of function for longest common substring of x [ 0. . m - 1 ] and y [ 0. . n - 1 ] ; ",
        "context": "",
        "code": "def lcs(i, j, count):\n    if (i == 0 or j == 0):\n        return count\n    if (X[i - 1] == Y[j - 1]):\n        count = lcs(i - 1, j - 1, count + 1)\n    count = max(count, max(lcs(i, j - 1, 0), lcs(i - 1, j, 0)))\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    X = \"abcdxyz\"\n    Y = \"xyzabcd\"\n    n = len(X)\n    m = len(Y)\n    print(lcs(n, m, 0))\n",
        "output": "4\n",
        "fn_call": "lcs"
    },
    {
        "text": "minimum pair merge operations required to make array non | function to find the minimum operations to make the array non - increasing ; size of the array ; dp table initialization ; dp [ i ] : stores minimum number of operations required to make subarray { a [ i ] , ... , a [ n ] } non - increasing ; increment the value of j ; add current value to sum ; update the dp tables ; return the answer ; ",
        "context": "",
        "code": "def solve(a):\n    n = len(a)\n    dp = [0] * (n + 1)\n    val = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        sum = a[i]\n        j = i\n        while (j + 1 < n and sum < val[j + 1]):\n            j += 1\n            sum += a[j]\n        dp[i] = (j - i) + dp[j + 1]\n        val[i] = sum\n    return dp[0]\n",
        "test": "\narr = [1, 5, 3, 9, 1]\nprint(solve(arr))\n",
        "output": "2\n",
        "fn_call": "solve"
    },
    {
        "text": "product of all non repeating subarrays of an array | function to find the product of all non - repeating subarrays of an array ; finding the occurrence of every element ; iterating through the array and finding the product ; we are taking the power of each element in array with the occurrence and then taking product of those . ; ",
        "context": "",
        "code": "def product(arr):\n    occurrence = pow(2, len(arr) - 1)\n    product = 1\n    for i in range(0, len(arr)):\n        product *= pow(arr[i], occurrence)\n    return product\n",
        "test": "\narr = [10, 3, 7]\nprint(product(arr))\n",
        "output": "1944810000\n",
        "fn_call": "product"
    },
    {
        "text": "print all maximal increasing contiguous sub | function to print each of maximal contiguous increasing subarray ; loop to iterate through the array and print the maximal contiguous increasing subarray . ; condition to check whether the element at i , is greater than its next neighbouring element or not . ; ",
        "context": "",
        "code": "def printmaxSubseq(arr, n):\n    for i in range(n - 1):\n        if (arr[i] < arr[i + 1]):\n            print(arr[i], end=\" \")\n        else:\n            print(arr[i])\n    print(arr[n - 1])\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [9, 8, 11, 13, 10, 15, 14, 16, 20, 5]\n    n = len(arr)\n    printmaxSubseq(arr, n)\n",
        "output": "9\n8 11 13\n10 15\n14 16 20\n5\n",
        "fn_call": "printmaxSubseq"
    },
    {
        "text": "minimum increments required to make array elements alternately even and odd | function to find the minimum number of increments required to make the array even - odd alternately or vice - versa ; store the minimum number of increments required ; traverse the array arr [ ] ; increment foreven if even element is present at an odd index ; increment foreven if odd element is present at an even index ; return the minimum number of increments ; ",
        "context": "",
        "code": "def minIncr(arr):\n    forEven = 0\n    for i in range(len(arr)):\n        if i % 2:\n            if not arr[i] % 2:\n                forEven += 1\n        else:\n            if arr[i] % 2:\n                forEven += 1\n    return min(forEven, len(arr) - forEven)\n",
        "test": "\narr = [1, 4, 6, 8, 9, 5]\nprint(minIncr(arr))\n",
        "output": "2\n",
        "fn_call": "minIncr"
    },
    {
        "text": "subarray / substring vs subsequence and programs to generate them | python3 code to generate all possible subsequences . time complexity o ( n * 2 ^ n ) ; number of subsequences is ( 2 * * n - 1 ) ; run from counter 000. . 1 to 111. . 1 ; check if jth bit in the counter is set if set then print jth element from arr [ ] ; ",
        "context": "\nimport math\n\n",
        "code": "def printSubsequences(arr, n):\n    opsize = math .pow(2, n)\n    for counter in range(1, (int)(opsize)):\n        for j in range(0, n):\n            if (counter & (1 << j)):\n                print(arr[j], end=\" \")\n        print()\n",
        "test": "\narr = [1, 2, 3, 4]\nn = len(arr)\nprint(\"All Non-empty Subsequences\")\nprintSubsequences(arr, n)\n",
        "output": "All Non-empty Subsequences\n1 \n2 \n1 2 \n3 \n1 3 \n2 3 \n1 2 3 \n4 \n1 4 \n2 4 \n1 2 4 \n3 4 \n1 3 4 \n2 3 4 \n1 2 3 4 \n",
        "fn_call": "printSubsequences"
    },
    {
        "text": "largest possible value of m not exceeding n having equal bitwise or and xor between them | python3 program to implement the above approach ; function to find required number m ; initialising m ; finding the index of the most significant bit of n ; calculating required number ; ",
        "context": "\nfrom math import log2\n\n",
        "code": "def equalXORandOR(n):\n    m = 0\n    MSB = int(log2(n))\n    for i in range(MSB + 1):\n        if (not (n & (1 << i))):\n            m += (1 << i)\n    return m\n",
        "test": "\nn = 14\nprint(equalXORandOR(n))\n",
        "output": "1\n",
        "fn_call": "equalXORandOR"
    },
    {
        "text": "count distinct possible bitwise xor values of subsets of an array | stores the bitwise xor of every possible subset ; function to generate all combinations of subsets and store their bitwise xor in set s ; if the end of the subset is reached ; stores the bitwise xor of the current subset ; iterate comb [ ] to find xor ; insert the bitwise xor of r elements ; otherwise , iterate to generate all possible subsets ; recursive call for next index ; function to find the size of the set having bitwise xor of all the subsets of the given array ; iterate ove the given array ; generate all possible subsets ; print the size of the set ; ",
        "context": "\ns = set([])\n\n",
        "code": "def countXOR(arr, comb, start, end, index, r):\n    if (index == r):\n        new_xor = 0\n        for j in range(r):\n            new_xor ^= comb[j]\n        s .add(new_xor)\n        return\n    i = start\n    while i = (r - index):\n        comb[index] = arr[i]\n        countXOR(arr, comb, i + 1, end, index + 1, r)\n        i += 1\n\n\ndef maxSizeSet(arr, N):\n    for r in range(2, N + 1):\n        comb = [0] * (r + 1)\n        countXOR(arr, comb, 0, N - 1, 0, r)\n    print(len(s))\n",
        "test": "\narr = [1, 2, 3, 4, 5]\nN = len(arr)\nmaxSizeSet(arr, N)\n",
        "output": "8\n",
        "fn_call": "maxSizeSet"
    },
    {
        "text": "find the sum of the first nth centered hexadecagonal number | centered_hexadecagonal number function ; formula to calculate nth centered_hexadecagonal number & return it into main function . ; function to find the sum of the first n centered hexadecagonal number ; variable to store the sum ; loop to iterate through the first n numbers ; find the sum ; ",
        "context": "",
        "code": "def Centered_Hexadecagonal_num(n):\n    return (8 * n * n - 8 * n + 1)\n\n\ndef sum_Centered_Hexadecagonal_num(n):\n    summ = 0\n    for i in range(1, n + 1):\n        summ += Centered_Hexadecagonal_num(i)\n    return summ\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    print(sum_Centered_Hexadecagonal_num(n))\n",
        "output": "325\n",
        "fn_call": "sum_Centered_Hexadecagonal_num"
    },
    {
        "text": "find the largest alphabetic character present in the string | function to find the largest alphabetic character ; array for keeping track of both uppercase and lowercase english alphabets ; iterate from right side of array to get the largest index character ; check for the character if both its uppercase and lowercase exist or not ; return - 1 if no such character whose uppercase and lowercase present in string str ; ",
        "context": "",
        "code": "def largestCharacter(str):\n    uppercase = [False] * 26\n    lowercase = [False] * 26\n    arr = list(str)\n    for c in arr:\n        if (c .islower()):\n            lowercase[ord(c) - ord('a')] = True\n        if (c .isupper()):\n            uppercase[ord(c) - ord('A')] = True\n    for i in range(25, -1, -1):\n        if (uppercase[i] and lowercase[i]):\n            return chr(i + ord('A')) + \"\"\n    return \"-1\"\n",
        "test": "\nstr = \"admeDCAB\"\nprint(largestCharacter(str))\n",
        "output": "D\n",
        "fn_call": "largestCharacter"
    },
    {
        "text": "print the first n terms of the series 6 , 28 , 66 , 120 , 190 , 276 , ... | function to print the series ; initialise the value of k with 2 ; iterate from 1 to n ; print each number ; increment the value of k by 2 for next number ; ",
        "context": "",
        "code": "def PrintSeries(n):\n    k = 2\n    for i in range(0, n):\n        print(k * (2 * k - 1), end=' ')\n        k = k + 2\n",
        "test": "\nn = 12\nPrintSeries(n)\n",
        "output": "6 28 66 120 190 276 378 496 630 780 946 1128 ",
        "fn_call": "PrintSeries"
    },
    {
        "text": "program to find first n iccanobif numbers | iterative function to reverse digits of num ; function to print first n icanobif numbers ; initialize first , second numbers ; print first two numbers ; reversing digit of previous two terms and adding them ; ",
        "context": "",
        "code": "def reversedigit(num):\n    rev_num = 0\n    while num > 0:\n        rev_num = rev_num * 10 + num % 10\n        num = num // 10\n    return rev_num\n\n\ndef icanobifNumbers(N):\n    first = 0\n    second = 1\n    if N == 1:\n        print(first)\n    elif N == 2:\n        print(first, second)\n    else:\n        print(first, second, end=\" \")\n        for i in range(3, N + 1):\n            x = reversedigit(first)\n            y = reversedigit(second)\n            print(x + y, end=\" \")\n            temp = second\n            second = x + y\n            first = temp\n",
        "test": "\nN = 12\nicanobifNumbers(N)\n",
        "output": "0 1 1 2 3 5 8 13 39 124 514 836 ",
        "fn_call": "icanobifNumbers"
    },
    {
        "text": "add minimum number to an array so that the sum becomes even | function to find out minimum number ; count odd number of terms in array ; ",
        "context": "",
        "code": "def minNum(arr, n):\n    odd = False\n    for i in range(n):\n        if (arr[i] % 2):\n            odd = not odd\n    if (odd):\n        return 1\n    return 2\n",
        "test": "\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(arr)\nprint(minNum(arr, n))\n",
        "output": "1\n",
        "fn_call": "minNum"
    },
    {
        "text": "check given string is oddly palindrome or not | set 2 | functions checks if characters at odd index of the string forms palindrome or not ; initialise two pointers ; iterate till left <= right ; if there is a mismatch occurs then return false ; increment and decrement the left and right pointer by 2 ; ",
        "context": "",
        "code": "def isOddStringPalindrome(Str, n):\n    left, right = 0, 0\n    if (n % 2 == 0):\n        left = 1\n        right = n - 1\n    else:\n        left = 1\n        right = n - 2\n    while (left = 0 and left < right):\n        if (Str[left] != Str[right]):\n            return False\n        left += 2\n        right -= 2\n    return True\n",
        "test": "\nif __name__ == '__main__':\n    n = 10\n    Str = \"aeafacafae\"\n    if (isOddStringPalindrome(Str, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isOddStringPalindrome"
    },
    {
        "text": "remove leading zeros from a number given as a string | python3 program to implement the above approach ; function to remove all leading zeros from a a given string ; regex to remove leading zeros from a string ; replaces the matched value with given string ; ",
        "context": "\nimport re\n\n",
        "code": "def removeLeadingZeros(str):\n    regex = \"^0+(?!$)\"\n    str = re .sub(regex, \"\", str)\n    print(str)\n",
        "test": "\nstr = \"0001234\"\nremoveLeadingZeros(str)\n",
        "output": "1234\n",
        "fn_call": "removeLeadingZeros"
    },
    {
        "text": "find the maximum possible value for the given periodic function | function to return the maximum value of f ( x ) ; ",
        "context": "",
        "code": "def floorMax(A, B, N):\n    x = min(B - 1, N)\n    return (A * x) // B\n",
        "test": "\nA = 11\nB = 10\nN = 9\nprint(floorMax(A, B, N))\n",
        "output": "9\n",
        "fn_call": "floorMax"
    },
    {
        "text": "number of subarrays having sum exactly equal to k | python3 program to find the number of subarrays with sum exactly equal to k . ; function to find number of subarrays with sum exactly equal to k . ; dictionary to store number of subarrays starting from index zero having particular value of sum . ; sum of elements so far . ; add current element to sum so far . ; if currsum is equal to desired sum , then a new subarray is found . so increase count of subarrays . ; currsum exceeds given sum by currsum - sum . find number of subarrays having this sum and exclude those subarrays from currsum by increasing count by same amount . ; add currsum value to count of different values of sum . ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def findSubarraySum(arr, n, Sum):\n    prevSum = defaultdict(lambda: 0)\n    res = 0\n    currsum = 0\n    for i in range(0, n):\n        currsum += arr[i]\n        if currsum == Sum:\n            res += 1\n        if (currsum - Sum) in prevSum:\n            res += prevSum[currsum - Sum]\n        prevSum[currsum] += 1\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 2, -2, -20, 10]\n    Sum = -10\n    n = len(arr)\n    print(findSubarraySum(arr, n, Sum))\n",
        "output": "3\n",
        "fn_call": "findSubarraySum"
    },
    {
        "text": "find the sum of n terms of the series 1 , 8 , 27 , 64 ... . | function to calculate the sum ; return total sum ; ",
        "context": "",
        "code": "def calculateSum(n):\n    return (n * (n + 1) / 2)**2\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    print(calculateSum(n))\n",
        "output": "100.0\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "make array elements equal with minimum cost | function to find the minimum cost required to make array elements equal ; loop to find the count of odd elements ; ",
        "context": "",
        "code": "def makearrayequal(arr, n):\n    x = 0\n    for i in range(n):\n        x += arr[i] & 1\n    print(min(x, n - x))\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 3, 2, 1]\n    n = len(arr)\n    makearrayequal(arr, n)\n",
        "output": "2\n",
        "fn_call": "makearrayequal"
    },
    {
        "text": "sudo placement | placement tour | python program to find the optimal number of elements such that the cumulative value should be less than given number ; this function returns true if the value cumulative according to received integer k is less than budget b , otherwise returns false ; initialize a temporary array which stores the cumulative value of the original array ; sort the array to find the smallest k values ; check if the value is less than budget ; this function prints the optimal number of elements and respective cumulative value which is less than the given number ; initialize answer as zero as optimal value may not exists ; if the current mid value is an optimal value , then try to maximize it ; call again to set the corresponding cumulative value for the optimal ans ; ",
        "context": "\nvalue = 0\n\n",
        "code": "def canBeOptimalValue(K: int, arr: list, N: int, B: int) -> bool:\n    global value\n\n    tmp = [0] * N\n\n    for i in range(N):\n        tmp[i] = (arr[i] + K * (i + 1))\n    tmp.sort()\n\n    value = 0\n    for i in range(K):\n        value += tmp[i]\n    return value <= B\n\n\ndef findNoOfElementsandValue(arr: list, N: int, B: int):\n    global value\n    start = 0\n\n    end = N\n    ans = 0\n\n    value = 0\n    while start <= end:\n        mid = (start + end) // 2\n        if canBeOptimalValue(mid, arr, N, B):\n            ans = mid\n            start = mid + 1\n        else:\n            end = mid - 1\n    canBeOptimalValue(ans, arr, N, B)\n\n    print(ans, value)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 5, 6, 3]\n    N = len(arr)\n    B = 90\n    findNoOfElementsandValue(arr, N, B)\n",
        "output": "4 54\n",
        "fn_call": "findNoOfElementsandValue"
    },
    {
        "text": "count characters in a string whose ascii values are prime | python3 implementation of above approach ; function to find prime characters in the string ; use sieve to find all prime numbers less than or equal to max_val create a boolean array \" prime [ 0 . . n ] \" . a value in prime [ i ] will finally be false if i is not a prime , else true . ; 0 and 1 are not primes ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; traverse all the characters ; ",
        "context": "\nfrom math import sqrt\nmax_val = 257\n\n",
        "code": "def PrimeCharacters(s):\n    prime = [True] * (max_val + 1)\n    prime[0] = False\n    prime[1] = False\n    for p in range(2, int(sqrt(max_val)) + 1):\n        if (prime[p]):\n            for i in range(2 * p, max_val + 1, p):\n                prime[i] = False\n    count = 0\n    for i in range(len(s)):\n        if (prime[ord(s[i])]):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"geeksforgeeks\"\n    print(PrimeCharacters(S))\n",
        "output": "8\n",
        "fn_call": "PrimeCharacters"
    },
    {
        "text": "generate an array of given size with equal count and sum of odd and even numbers | function to find the array such that the array contains the same count of even and odd elements with equal sum of even and odd elements ; length of array which is not divisible by 4 is unable to form such array ; loop to find the resulted array containing the same count of even and odd elements ; find the total sum of even elements ; find the total sum of odd elements ; find the difference between the total sum of even and odd elements ; the difference will be added in the last odd element ; ",
        "context": "",
        "code": "def findSolution(N):\n    if (N % 4 != 0):\n        print(-1)\n    else:\n        temp = 0\n        sum_odd = 0\n        sum_even = 0\n        result = [0] * N\n        for i in range(0, N, 2):\n            temp += 2\n            result[i + 1] = temp\n            sum_even += result[i + 1]\n            result[i] = temp - 1\n            sum_odd += result[i]\n        diff = sum_even - sum_odd\n        result[N - 2] += diff\n        for i in range(N):\n            print(result[i], end=\" \")\n        print()\n",
        "test": "\nN = 8\nfindSolution(N)\n",
        "output": "1 2 3 4 5 6 11 8 \n",
        "fn_call": "findSolution"
    },
    {
        "text": "leaf nodes from preorder of a binary search tree ( using recursion ) | print the leaf node from the given preorder of bst . ; ",
        "context": "",
        "code": "def isLeaf(pre, i, n, Min, Max):\n    if i[0] >= n:\n        return False\n    if pre[i[0]] > Min and pre[i[0]] < Max:\n        i[0] += 1\n        left = isLeaf(pre, i, n, Min, pre[i[0] - 1])\n        right = isLeaf(pre, i, n, pre[i[0] - 1], Max)\n        if left == False and right == False:\n            print(pre[i[0] - 1], end=\" \")\n        return True\n    return False\n\n\ndef printLeaves(preorder, n):\n    i = [0]\n    INT_MIN, INT_MAX = -999999999999, 999999999999\n    isLeaf(preorder, i, n, INT_MIN, INT_MAX)\n",
        "test": "\nif __name__ == '__main__':\n    preorder = [890, 325, 290, 530, 965]\n    n = len(preorder)\n    printLeaves(preorder, n)\n",
        "output": "290 530 965 ",
        "fn_call": "printLeaves"
    },
    {
        "text": "sum of all even numbers in range l and r | function to return the sum of all natural numbers ; function to return sum of even numbers in range l and r ; ",
        "context": "",
        "code": "def sumNatural(n):\n    sum = (n * (n + 1))\n    return int(sum)\n\n\ndef sumEven(l, r):\n    return (sumNatural(int(r / 2)) - sumNatural(int((l - 1) / 2)))\n",
        "test": "\nl, r = 2, 5\nprint(\"Sum of Natural numbers\", \"from L to R is\", sumEven(l, r))\n",
        "output": "Sum of Natural numbers from L to R is 6\n",
        "fn_call": "sumEven"
    },
    {
        "text": "check whether a given number is power | python3 program to find whether a number is power - isolated or not ; for 2 as prime factor ; for odd prime factor ; calculate product of powers and prime factors ; check result for power - isolation ; ",
        "context": "",
        "code": "def checkIfPowerIsolated(num):\n    input1 = num\n    count = 0\n    factor = [0] * (num + 1)\n    if (num % 2 == 0):\n        while (num % 2 == 0):\n            count += 1\n            num //= 2\n        factor[2] = count\n    i = 3\n    while (i * i <= num):\n        count = 0\n        while (num % i == 0):\n            count += 1\n            num //= i\n        if (count > 0):\n            factor[i] = count\n        i += 2\n    if (num > 1):\n        factor[num] = 1\n    product = 1\n    for i in range(0, len(factor)):\n        if (factor[i] > 0):\n            product = product * factor[i] * i\n    if (product == input1):\n        print(\"Power-isolated Integer\")\n    else:\n        print(\"Not a Power-isolated Integer\")\n",
        "test": "\ncheckIfPowerIsolated(12)\ncheckIfPowerIsolated(18)\ncheckIfPowerIsolated(35)\n",
        "output": "Power-isolated Integer\nNot a Power-isolated Integer\nPower-isolated Integer\n",
        "fn_call": "checkIfPowerIsolated"
    },
    {
        "text": "number of distinct words of size n with at most k contiguous vowels | power function to calculate long powers with mod ; function for finding number of ways to create string with length n and atmost k contiguous vowels ; array dp to store number of ways ; dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] . . dp [ i - 1 ] [ k ] ) * 21 ; now setting sum to be dp [ i ] [ 0 ] ; if j > i , no ways are possible to create a string with length i and vowel j ; if j = i all the character should be vowel ; dp [ i ] [ j ] relation with dp [ i - 1 ] [ j - 1 ] ; adding dp [ i ] [ j ] in the sum ; ",
        "context": "",
        "code": "def power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef kvowelwords(N, K):\n    i, j = 0, 0\n    MOD = 1000000007\n    dp = [[0 for i in range(K + 1)]for i in range(N + 1)]\n    sum = 1\n    for i in range(1, N + 1):\n        dp[i][0] = sum * 21\n        dp[i][0] %= MOD\n        sum = dp[i][0]\n        for j in range(1, K + 1):\n            if (j > i):\n                dp[i][j] = 0\n            elif (j == i):\n                dp[i][j] = power(5, i, MOD)\n            else:\n                dp[i][j] = dp[i - 1][j - 1] * 5\n            dp[i][j] %= MOD\n            sum += dp[i][j]\n            sum %= MOD\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    K = 3\n    print(kvowelwords(N, K))\n",
        "output": "17576\n",
        "fn_call": "kvowelwords"
    },
    {
        "text": "count sub | function to count all sub - arrays divisible by k ; create auxiliary hash array to count frequency of remainders ; traverse original array and compute cumulative sum take remainder of this current cumulative sum and increase count by 1 for this remainder in mod array ; as the sum can be negative , taking modulo twice ; initialize result ; traverse mod ; if there are more than one prefix subarrays with a particular mod value . ; add the subarrays starting from the arr [ i ] which are divisible by k itself ; function to count all sub - matrices having sum divisible by the value 'k   ; variable to store the final output ; set the left column ; set the right column for the left column set by outer loop ; calculate sum between current left and right for every row 'i   ; count number of subarrays in temp having sum divisible by ' k ' and then add it to 'tot_count   ; required count of sub - matrices having sum divisible by 'k   ; ",
        "context": "",
        "code": "def subCount(arr, n, k):\n    mod = [0] * k\n    cumSum = 0\n    for i in range(0, n):\n        cumSum = cumSum + arr[i]\n        mod[((cumSum % k) + k) % k] = mod[((cumSum % k) + k) % k] + 1\n    result = 0\n    for i in range(0, k):\n        if (mod[i] > 1):\n            result = result + int((mod[i] * (mod[i] - 1)) / 2)\n    result = result + mod[0]\n    return result\n\n\ndef countSubmatrix(mat, n, k):\n    tot_count = 0\n    temp = [0] * n\n    for left in range(0, n - 1):\n        for right in range(left, n):\n            for i in range(0, n):\n                temp[i] = (temp[i] + mat[i][right])\n            tot_count = (tot_count + subCount(temp, n, k))\n    return tot_count\n",
        "test": "\nmat = [[5, -1, 6], [-2, 3, 8], [7, 4, -9]]\nn = 3\nk = 4\nprint(\"Count = {}\".format(countSubmatrix(mat, n, k)))\n",
        "output": "Count = 6\n",
        "fn_call": "countSubmatrix"
    },
    {
        "text": "convert a mobile numeric keypad sequence to equivalent sentence | function to convert mobile numeric keypad sequence into its equivalent string ; store the mobile keypad mappings ; traverse the str1ing str1 ; if the current character is ' . ' , then continue to the next iteration ; stores the number of continuous clicks ; iterate a loop to find the count of same characters ; 2 , 3 , 4 , 5 , 6 and 8 keys will have maximum of 3 letters ; 7 and 9 keys will have maximum of 4 keys ; handle the end condition ; check if the current pressed key is 7 or 9 ; else , the key pressed is either 2 , 3 , 4 , 5 , 6 or 8 ; ",
        "context": "",
        "code": "def printSentence(str1):\n    nums = [\"\", \"\", \"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\", \"PQRS\", \"TUV\", \"WXYZ\"]\n    i = 0\n    while (i < len(str1)):\n        if (str1[i] == '.'):\n            i += 1\n            continue\n        count = 0\n        while (i + 1 < len(str1) and str1[i + 1] and str1[i] == str1[i + 1]):\n            if (count == 2 and (\n                    (str1[i] >= '2' and str1[i] <= '6') or (str1[i] == '8'))):\n                break\n            elif (count == 3 and (str1[i] == '7' or str1[i] == '9')):\n                break\n            count += 1\n            i += 1\n            if (i < len(str)):\n                break\n        if (str1[i] == '7' or str1[i] == '9'):\n            print(nums[ord(str1[i]) - 48][count % 4], end=\"\")\n        else:\n            print(nums[ord(str1[i]) - 48][count % 3], end=\"\")\n        i += 1\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"234\"\n    printSentence(str1)\n",
        "output": "ADG",
        "fn_call": "printSentence"
    },
    {
        "text": "efficient method for 2 's complement of a binary string | function to find two 's complement ; traverse the string to get first '1' from the last of string ; if there exists no '1' concatenate 1 at the starting of string ; continue traversal after the position of first '1 ; just flip the values ; return the modified string ; ",
        "context": "",
        "code": "def findTwoscomplement(str):\n    n = len(str)\n    i = n - 1\n    while (i >= 0):\n        if (str[i] == '1'):\n            break\n\n        i -= 1\n    if (i == -1):\n        return '1'+str\n    k = i - 1\n    while (k >= 0):\n        if (str[k] == '1'):\n            str = list(str)\n            str[k] = '0'\n            str = ''.join(str)\n        else:\n            str = list(str)\n            str[k] = '1'\n            str = ''.join(str)\n\n        k -= 1\n    return str\n",
        "test": "\nif __name__ == '__main__':\n    str = \"00000101\"\n    print(findTwoscomplement(str))\n",
        "output": "11111011\n",
        "fn_call": "findTwoscomplement"
    },
    {
        "text": "modulus of a complex number | python 3 program to find the modulus of a complex number ; function to find modulus of a complex number ; storing the index of '+ ; storing the index of '- ; finding the real part of the complex number ; finding the imaginary part of the complex number ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def findModulo(s):\n    l = len(s)\n    modulus = 0\n    if ('+' in s):\n        i = s.index('+')\n    else:\n        i = s.index('-')\n    real = s[0:i]\n    imaginary = s[i + 1:l - 1]\n\n    x = int(real)\n    y = int(imaginary)\n\n    print(int(sqrt(x * x + y * y)))\n",
        "test": "\nif __name__ == '__main__':\n    s = \"3+4i\"\n\n    findModulo(s)\n",
        "output": "5\n",
        "fn_call": "findModulo"
    },
    {
        "text": "split array into two equal length subsets such that all repetitions of a number lies in a single subset | python3 program for the above approach ; function to create the frequency array of the given array arr [ ] ; hashmap to store the frequencies ; store freq for each element ; get the total frequencies ; store frequencies in subset [ ] array ; return frequency array ; function to check is sum n / 2 can be formed using some subset ; dp [ i ] [ j ] store the answer to form sum j using 1 st i elements ; initialize dp [ ] [ ] with true ; fill the subset table in the bottom up manner ; if current element is less than j ; update current state ; return the result ; function to check if the given array can be split into required sets ; store frequencies of arr [ ] ; if size of arr [ ] is odd then print \" yes \" ; check if answer is true or not ; print the result ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def findSubsets(arr):\n    M = defaultdict(int)\n    for i in range(len(arr)):\n        M[arr[i]] += 1\n    subsets = [0] * len(M)\n    i = 0\n    for j in M:\n        subsets[i] = M[j]\n        i += 1\n    return subsets\n\n\ndef subsetSum(subsets, target):\n    dp = [[0 for x in range(target + 1)]for y in range(len(subsets) + 1)]\n    for i in range(len(dp)):\n        dp[i][0] = True\n    for i in range(1, len(subsets) + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if (j >= subsets[i - 1]):\n                dp[i][j] |= (dp[i - 1][j - subsets[i - 1]])\n    return dp[len(subsets)][target]\n\n\ndef divideInto2Subset(arr):\n    subsets = findSubsets(arr)\n    if (len(arr) % 2 == 1):\n        print(\"No\")\n        return\n    isPossible = subsetSum(subsets, len(arr) // 2)\n    if (isPossible):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 1, 2, 3]\n    divideInto2Subset(arr)\n",
        "output": "Yes\n",
        "fn_call": "divideInto2Subset"
    },
    {
        "text": "program to check if n is a centered tridecagonal number | python3 program for the above approach ; function to check if the number n is a centered tridecagonal number ; condition to check if n is centered tridecagonal number ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def isCenteredtridecagonal(N):\n    n = (13 + np .sqrt(104 * N + 65)) / 26\n    return (n - int(n)) == 0\n",
        "test": "\nN = 14\nif (isCenteredtridecagonal(N)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isCenteredtridecagonal"
    },
    {
        "text": "check if a large number is divisible by 3 or not | function to find that number divisible by 3 or not ; compute sum of digits ; check if sum of digits is divisible by 3. ; ",
        "context": "",
        "code": "def check(num):\n    digitSum = 0\n    while num > 0:\n        rem = num % 10\n        digitSum = digitSum + rem\n        num = num / 10\n    return (digitSum % 3 == 0)\n",
        "test": "\nnum = 1332\nif (check(num)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "check"
    },
    {
        "text": "check if it is possible to serve customer queue with different notes | function that returns true is selling of the tickets is possible ; nothing to return to the customer ; check if 25 can be returned to customer . ; try returning one 50 and one 25 ; try returning three 25 ; if the loop did not break , all the tickets were sold ; ",
        "context": "",
        "code": "def isSellingPossible(n, a):\n    c25 = 0\n    c50 = 0\n    i = 0\n    while (i < n):\n        if (a[i] == 25):\n            c25 += 1\n        elif (a[i] == 50):\n            c50 += 1\n            if (c25 == 0):\n                break\n            c25 -= 1\n        else:\n            if (c50 > 0 and c25 > 0):\n                c50 -= 1\n                c25 -= 1\n            elif (c25 >= 3):\n                c25 -= 3\n            else:\n                break\n        i += 1\n    if (i == n):\n        return True\n    else:\n        return False\n",
        "test": "\na = [25, 25, 50, 100]\nn = len(a)\nif (isSellingPossible(n, a)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isSellingPossible"
    },
    {
        "text": "find the sum of the first half and second half elements of an array | function to find the sum of the first half elements and second half elements of an array ; add elements in first half sum ; add elements in the second half sum ; ",
        "context": "",
        "code": "def sum_of_elements(arr, n):\n    sumfirst = 0\n    sumsecond = 0\n    for i in range(n):\n        if (i < n // 2):\n            sumfirst += arr[i]\n        else:\n            sumsecond += arr[i]\n    print(\"Sum of first half elements is\", sumfirst, end=\"\")\n    print(\"Sum of second half elements is\", sumsecond, end=\"\")\n",
        "test": "\narr = [20, 30, 60, 10, 25, 15, 40]\nn = len(arr)\nsum_of_elements(arr, n)\n",
        "output": "Sum of first half elements is 110Sum of second half elements is 90",
        "fn_call": "sum_of_elements"
    },
    {
        "text": "program for decimal to binary conversion | function to return the binary equivalent of decimal value n ; to store the binary number ; count used to store exponent value ; ",
        "context": "",
        "code": "def decimalToBinary(N):\n    B_Number = 0\n    cnt = 0\n    while (N != 0):\n        rem = N % 2\n        c = pow(10, cnt)\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    return B_Number\n",
        "test": "\nN = 17\nprint(decimalToBinary(N))\n",
        "output": "10001\n",
        "fn_call": "decimalToBinary"
    },
    {
        "text": "total ways of choosing x men and y women from a total of m men and w women | function to return the value of ncr effectively ; ",
        "context": "",
        "code": "def ncr(n, r):\n    ans = 1\n    for i in range(1, r + 1):\n        ans *= (n - r + i)\n        ans //= i\n    return ans\n\n\ndef totalWays(X, Y, M, W):\n    return (ncr(M, X) * ncr(W, Y))\n",
        "test": "\nX = 4\nY = 3\nM = 6\nW = 5\nprint(totalWays(X, Y, M, W))\n",
        "output": "150\n",
        "fn_call": "totalWays"
    },
    {
        "text": "minimum removals required to make frequency of all remaining array elements equal | python 3 program for the above approach ; function to count the minimum removals required to make frequency of all array elements equal ; stores frequency of all array elements ; traverse the array ; stores all the frequencies ; traverse the map ; sort the frequencies ; count of frequencies ; stores the final count ; traverse the vector ; count the number of removals for each frequency and update the minimum removals required ; print the final count ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def minDeletions(arr, N):\n    freq = defaultdict(int)\n    for i in range(N):\n        freq[arr[i]] += 1\n    v = []\n    for z in freq .keys():\n        v .append(freq[z])\n    v .sort()\n    size = len(v)\n    ans = N - (v[0] * size)\n    for i in range(1, len(v)):\n        if (v[i] != v[i - 1]):\n            safe = v[i] * (size - i)\n            ans = min(ans, N - safe)\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 4, 3, 2, 5, 3]\n    N = len(arr)\n    minDeletions(arr, N)\n",
        "output": "2\n",
        "fn_call": "minDeletions"
    },
    {
        "text": "find the nth natural number which is not divisible by a | python3 code to find the nth number which is not divisible by a from the series ; find the quotient and the remainder when k is divided by n - 1 ; if remainder is 0 then multiply n by q and add the remainder ; print the answer ; ",
        "context": "",
        "code": "def findNum(n, k):\n    q = k // (n - 1)\n    r = k % (n - 1)\n    if (r != 0):\n        a = (n * q) + r\n    else:\n        a = (n * q) - 1\n    print(a)\n",
        "test": "\nA = 4\nN = 6\nfindNum(A, N)\n",
        "output": "7\n",
        "fn_call": "findNum"
    },
    {
        "text": "happy number | utility method to return sum of square of digit of n ; method return true if n is happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; ",
        "context": "",
        "code": "def numSquareSum(n):\n    squareSum = 0\n    while (n):\n        squareSum += (n % 10) * (n % 10)\n        n = int(n / 10)\n    return squareSum\n\n\ndef isHappynumber(n):\n    slow = n\n    fast = n\n    while (True):\n        slow = numSquareSum(slow)\n        fast = numSquareSum(numSquareSum(fast))\n        if (slow != fast):\n            continue\n        else:\n            break\n    return (slow == 1)\n",
        "test": "\nn = 13\nif (isHappynumber(n)):\n    print(n, \"is a Happy number\")\nelse:\n    print(n, \"is not a Happy number\")\n",
        "output": "13 is a Happy number\n",
        "fn_call": "isHappynumber"
    },
    {
        "text": "minimum number of working days required to achieve each of the given scores | function to find the minimum number of days required to work to at least arr [ i ] points for every array element ; traverse the array p [ ] ; find the prefix sum ; traverse the array arr [ ] ; find the minimum index of the array having value at least arr [ i ] ; if the index is not - 1 ; otherwise ; function to find the lower bound of n using binary search ; stores the lower bound ; stores the upper bound ; stores the minimum index having value is at least n ; iterater while i <= j ; stores the mid index of the range [ i , j ] ; if p [ mid ] is at least n ; update the value of mid to index ; update the value of j ; update the value of i ; return the resultant index ; ",
        "context": "",
        "code": "def binarySeach(P, N):\n    i = 0\n    j = len(P) - 1\n    index = -1\n    while (i <= j):\n        mid = i + (j - i) // 2\n        if (P[mid] >= N):\n            index = mid\n            j = mid - 1\n        else:\n            i = mid + 1\n    return index\n\n\ndef minDays(P, arr):\n    for i in range(1, len(P)):\n        P[i] += P[i] + P[i - 1]\n    for i in range(len(arr)):\n        index = binarySeach(P, arr[i])\n        if (index != -1):\n            print(index + 1, end=\" \")\n        else:\n            print(-1, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [400, 200, 700, 900, 1400]\n    P = [100, 300, 400, 500, 600]\n    minDays(P, arr)\n",
        "output": "2 2 2 3 3 ",
        "fn_call": "minDays"
    },
    {
        "text": "print path from given source to destination in 2 | function to print the path ; base condition ; pop stores elements ; recursive call for printing stack in reverse order ; function to store the path into the stack , if path exist ; base condition ; push current elements ; condition to check whether reach to the destination or not ; increment ' x ' ordinate of source by ( 2 * x + y ) keeping ' y ' constant ; increment ' y ' ordinate of source by ( 2 * y + x ) keeping ' x ' constant ; pop current elements form stack ; if no path exists ; utility function to check whether path exist or not ; to store x co - ordinate ; to store y co - ordinate ; function to find the path ; print - 1 , if path doesn 't exist ; ",
        "context": "",
        "code": "def printExistPath(sx, sy, last):\n    if (len(sx) == 0 or len(sy) == 0):\n        return\n    x = sx[-1]\n    y = sy[-1]\n    sx .pop()\n    sy .pop()\n    printExistPath(sx, sy, last)\n    if (len(sx) == last - 1):\n        print(\"(\" + str(x) + \", \" + str(y) + \")\", end='')\n    else:\n        print(\"(\" + str(x) + \", \" + str(y) + \") -> \", end='')\n\n\ndef storePath(srcX, srcY, destX, destY, sx, sy):\n    if (srcX > destX or srcY > destY):\n        return False\n    sx .append(srcX)\n    sy .append(srcY)\n    if (srcX == destX and srcY == destY):\n        printExistPath(sx, sy, len(sx))\n        return True\n    if (storePath((2 * srcX) + srcY, srcY, destX, destY, sx, sy)):\n        return True\n    if (storePath(srcX, (2 * srcY) + srcX, destX, destY, sx, sy)):\n        return True\n    sx .pop()\n    sy .pop()\n    return False\n\n\ndef isPathExist(srcX, srcY, destX, destY):\n    sx = []\n    sy = []\n    return storePath(srcX, srcY, destX, destY, sx, sy)\n\n\ndef printPath(srcX, srcY, destX, destY):\n    if (not isPathExist(srcX, srcY, destX, destY)):\n        print(\"-1\")\n",
        "test": "\nif __name__ == '__main__':\n    srcX = 5\n    srcY = 8\n    destX = 83\n    destY = 21\n    printPath(srcX, srcY, destX, destY)\n",
        "output": "(5, 8) -> (5, 21) -> (31, 21) -> (83, 21) -> ",
        "fn_call": "printPath"
    },
    {
        "text": "number with set bits only between l | function to return the integer with all the bits set in range l - r ; ",
        "context": "",
        "code": "def setbitsfromLtoR(L, R):\n    return ((1 << (R + 1)) - (1 << L))\n",
        "test": "\nL = 2\nR = 5\nprint(setbitsfromLtoR(L, R))\n",
        "output": "60\n",
        "fn_call": "setbitsfromLtoR"
    },
    {
        "text": "least common element in given two arithmetic sequences | function to find the smallest element common in both the subsequences ; if a is equal to c ; if a exceeds c ; check for the satisfying equation ; least value of possible_y satisfying the given equation will yield true in the below if and break the loop ; if the value of possible_y satisfying the given equation lies in range [ 0 , b ] ; if no value of possible_y satisfies the given equation ; ",
        "context": "",
        "code": "def swap(x, y):\n    temp = x\n    x = y\n    y = temp\n\n\ndef smallestCommon(a, b, c, d):\n    if (a == c):\n        return a\n    if (a > c):\n        swap(a, c)\n        swap(b, d)\n    first_term_diff = (c - a)\n    possible_y = 0\n    for possible_y in range(b):\n        if ((first_term_diff % b + possible_y * d) % b == 0):\n            break\n    if (possible_y != b):\n        return c + possible_y * d\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    A = 2\n    B = 20\n    C = 19\n    D = 9\n    print(smallestCommon(A, B, C, D))\n",
        "output": "82\n",
        "fn_call": "smallestCommon"
    },
    {
        "text": "count the nodes of a tree whose weighted string does not contain any duplicate characters | python3 implementation of the approach ; function that returns true if the string contains unique characters ; function to perform dfs ; if weight of the current node node contains unique characters ; ",
        "context": "\ncnt = 0\ngraph = [[]for i in range(100)]\nweight = [0] * 100\n\n",
        "code": "def uniqueChars(x):\n    mp = {}\n    n = len(x)\n    for i in range(n):\n        if x[i]not in mp:\n            mp[x[i]] = 0\n        mp[x[i]] += 1\n    if (len(mp) == len(x)):\n        return True\n    else:\n        return False\n\n\ndef dfs(node, parent):\n    global cnt, x\n    if (uniqueChars(weight[node])):\n        cnt += 1\n    for to in graph[node]:\n        if (to == parent):\n            continue\n        dfs(to, node)\n",
        "test": "\nx = 5\nweight[1] = \"abc\"\nweight[2] = \"aba\"\nweight[3] = \"bcb\"\nweight[4] = \"moh\"\nweight[5] = \"aa\"\ngraph[1].append(2)\ngraph[2].append(3)\ngraph[2].append(4)\ngraph[1].append(5)\ndfs(1, 1)\nprint(cnt)\n",
        "output": "2\n",
        "fn_call": "dfs"
    },
    {
        "text": "check if there are t number of continuous of blocks of 0 s or not in given binary matrix | python program for the above approach ; stores the moves in the matrix ; function to find if the current cell lies in the matrix or not ; function to perform the dfs traversal ; iterate over the direction vector ; dfs call ; function to check if it satisfy the given criteria or not ; keeps the count of cell having value as 0 ; if condition doesn 't satisfy ; keeps the track of unvisted cell having values 0 ; increasing count of black_spot ; find the gcd of n and m ; print the result ; ",
        "context": "\nimport math\nM = 1000000000 + 7\ndirections = [[0, 1], [-1, 0], [0, -1],\n              [1, 0], [1, 1], [-1, -1], [-1, 1], [1, -1]]\n\n",
        "code": "def isInside(i, j, N, M):\n    if (i >= 0 and i = 0 and j < M):\n        return True\n    return False\n\n\ndef DFS(mat, N, M, i, j, visited):\n    if (visited[i][j]):\n        return\n    visited[i][j] = True\n    for it in directions:\n        I = i + it[0]\n        J = j + it[1]\n        if (isInside(I, J, N, M)):\n            if (mat[I][J] == 0):\n                DFS(mat, N, M, I, J, visited)\n\n\ndef check(N, M, mat):\n    black = 0\n    for i in range(0, N):\n        for j in range(0, M):\n            if (mat[i][j] == 0):\n                black += 1\n    if (black < 2 * (max(N, M))):\n        print(\"NO\")\n        return\n    visited = []\n    for i in range(0, N):\n        temp = []\n        for j in range(0, M):\n            temp .append(False)\n        visited .append(temp)\n    black_spots = 0\n    for i in range(0, N):\n        for j in range(0, M):\n            if (visited[i][j] == False and mat[i][j] == 0):\n                black_spots += 1\n                DFS(mat, N, M, i, j, visited)\n    T = math .gcd(N, M)\n    if black_spots >= T:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    M = 3\n    mat = [[0, 0, 1], [1, 1, 1], [0, 0, 1]]\n    check(M, N, mat)\n",
        "output": "NO\n",
        "fn_call": "check"
    },
    {
        "text": "lexicographically first alternate vowel and consonant string | python3 implementation of lexicographically first alternate vowel and consonant string ; ' ch ' is vowel or not ; create alternate vowel and consonant string str1 [ 0. . . l1 - 1 ] and str2 [ start ... l2 - 1 ] ; first adding character of vowel / consonant then adding character of consonant / vowel ; function to find the required lexicographically first alternate vowel and consonant string ; hash table to store frequencies of each character in ' str ' char_freq = [ 0 ] * size initialize all elements of char_freq [ ] to 0 ; count vowels ; count consonants ; update frequency of ' ch ' in char_freq [ ] ; no such string can be formed ; form the vowel string ' vstr ' and consonant string ' cstr ' which contains characters in lexicographical order ; remove first character of vowel string then create alternate string with cstr [ 0. . . nc - 1 ] and vstr [ 1. . . nv - 1 ] ; remove first character of consonant string then create alternate string with vstr [ 0. . . nv - 1 ] and cstr [ 1. . . nc - 1 ] ; if both vowel and consonant strings are of equal length start creating string with consonant ; start creating string with vowel ; ",
        "context": "\nSIZE = 26\n\n",
        "code": "def isVowel(ch):\n    if (ch == 'a' or ch == 'e' or\n        ch == 'i' or ch == 'o' or\n            ch == 'u'):\n        return True\n    return False\n\n\ndef createAltStr(str1, str2, start, l):\n    finalStr = \"\"\n    i = 0\n    j = start\n    while j < l:\n        finalStr += str1[i] + str2[j]\n        i += 1\n        j += 1\n    return finalStr\n\n\ndef findAltStr(string):\n    char_freq = [0] * SIZE\n    nv = 0\n    nc = 0\n    vstr = \"\"\n    cstr = \"\"\n    l = len(string)\n\n    for i in range(l):\n        ch = string[i]\n        if isVowel(ch):\n            nv += 1\n        else:\n            nc += 1\n        char_freq[ord(ch) - 97] += 1\n    if abs(nv - nc) >= 2:\n        return \"no such string\"\n    for i in range(SIZE):\n        ch = chr(i + 97)\n        for j in range(1, char_freq[i] + 1):\n            if isVowel(ch):\n                vstr += ch\n            else:\n                cstr += ch\n    if nv > nc:\n        return vstr[0] + createAltStr(cstr,\n                                      vstr, 1, nv)\n    if nc > nv:\n        return cstr[0] + createAltStr(vstr,\n                                      cstr, 1, nc)\n    if cstr[0] < vstr[0]:\n        return createAltStr(cstr, vstr, 0, nv)\n    return createAltStr(vstr, cstr, 0, nc)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"aeroplane\"\n    print(findAltStr(string))\n",
        "output": "alanepero\n",
        "fn_call": "findAltStr"
    },
    {
        "text": "permutation of array such that sum of adjacent elements are not divisible by 3 | python3 implementation to find the permutation of the array such that sum of adjacent elements is not divisible by 3 ; function to segregate numbers based on their remainder when divided by three ; loop to iterate over the elements of the given array ; condition to check the remainder of the number ; function to find the permutation of the array such that sum of adjacent elements is not divisible by 3 ; condition to check when it 's impossible to arrange ; condition to check when there are no zeros , and only ones or only twos ; array to store the permutation ; place the ones on alternate places in the answer array , leaving spaces for zeros remainder elements in the array ; adding a zero to connect it with a two ; place the twos on alternate places in the answer array , leaving spaces for zeros ; fill the zeros finally , between the ones and the twos ; print the arrangement of the array ; function to solve the problem ; as there can be only 3 remainders ; function call ; ",
        "context": "\nhell = 1000000007\nN = 100005\nc_0 = 0\nc_1 = 0\nc_2 = 0\n\n",
        "code": "def count_k(arr, ones, twos, zeros):\n    global c_0, c_1, c_2\n    for i in range(len(arr)):\n        if (arr[i] % 3 == 0):\n            c_0 += 1\n            zeros .append(arr[i])\n        elif (arr[i] % 3 == 1):\n            c_1 += 1\n            ones .append(arr[i])\n        else:\n            c_2 += 1\n            twos .append(arr[i])\n\n\ndef printArrangement(arr, ones, twos, zeros):\n    global c_0, c_1, c_2\n    if ((c_0 == 0 and c_1 != 0 and c_2 != 0) or c_0 > c_1 + c_2 + 1):\n        print(\"-1\", end=\"\")\n        return\n    if (c_0 == 0):\n        for i in range(len(arr)):\n            print(arr[i], end=\" \")\n        return\n    ans = [-1] * N\n    i, j = 1, 0\n    while (j < c_1):\n        ans[i] = ones[-1]\n        ones .pop()\n        i += 2\n        j += 1\n    ans[i - 1] = zeros[-1]\n    zeros .pop()\n    c_0 -= 1\n    j = 0\n    while (j < c_2):\n        ans[i] = twos[-1]\n        twos .pop()\n        j += 1\n        i += 2\n    k = 0\n    while c_0 > 0:\n        if (ans[k] == -1):\n            ans[k] = zeros[-1]\n            c_0 -= 1\n        k += 2\n    for i1 in range(N):\n        if (ans[i1] != -1):\n            print(ans[i1], end=\" \")\n    return\n\n\ndef solve(n, arr):\n    ones = []\n    zeros = []\n    twos = []\n    count_k(arr, ones, twos, zeros)\n    printArrangement(arr, ones, twos, zeros)\n",
        "test": "\nn = 5\narr = [1, 2, 3, 4, 5]\nsolve(n, arr)\n",
        "output": "4 1 3 5 2 ",
        "fn_call": "solve"
    },
    {
        "text": "check if it is possible to create a palindrome string from given n | function to check if a string is palindrome or not ; string that stores characters of s in reverse order ; length of the string s ; string used to form substring using n ; variable to store sum of digits of n ; forming the substring by traversing n ; appending the substr to str till it 's length becomes equal to sum ; trimming the string str so that it 's length becomes equal to sum ; ",
        "context": "",
        "code": "def isPalindrome(s):\n    s1 = \"\"\n    N = len(s)\n    i = (N - 1)\n    while (i >= 0):\n        s1 += s[i]\n        i = i - 1\n    if (s == s1):\n        return True\n    return False\n\n\ndef createString(N):\n    s2 = \"\"\n    s = str(N)\n    letters = \"abcdefghij\"\n    sum = 0\n    substr = \"\"\n    for i in range(0, len(s)):\n        digit = int(s[i])\n        substr += letters[digit]\n        sum += digit\n    while (len(s2) <= sum):\n        s2 += substr\n    s2 = s2[:sum]\n    return isPalindrome(s2)\n",
        "test": "\nN = 61\nflag = createString(N)\nif (flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "createString"
    },
    {
        "text": "minimum sum falling path in a nxn grid | python3 program to minimum required sum ; function to return minimum path falling sum ; r = row and c = column we begin from second last row and keep adding maximum sum . ; best = min ( a [ r + 1 ] [ c - 1 ] , a [ r + 1 ] [ c ] , a [ r + 1 ] [ c + 1 ] ) ; ",
        "context": "\nimport sys\nn = 3\n\n",
        "code": "def minFallingPathSum(A):\n    for R in range(n - 2, -1, -1):\n        for C in range(n):\n            best = A[R + 1][C]\n            if C > 0:\n                best = min(best, A[R + 1][C - 1])\n            if C + 1 < n:\n                best = min(best, A[R + 1][C + 1])\n            A[R][C] = A[R][C] + best\n    ans = sys .maxsize\n    for i in range(n):\n        ans = min(ans, A[0][i])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(minFallingPathSum(A))\n",
        "output": "12\n",
        "fn_call": "minFallingPathSum"
    },
    {
        "text": "program to find line passing through 2 points | function to find the line given two points ; ",
        "context": "",
        "code": "def lineFromPoints(P, Q):\n    a = Q[1] - P[1]\n    b = P[0] - Q[0]\n    c = a * (P[0]) + b * (P[1])\n    if (b < 0):\n        print(\n            \"The line passing through points P and Q is:\",\n            a,\n            \"x - \",\n            b,\n            \"y = \",\n            c,\n            \"\")\n    else:\n        print(\n            \"The line passing through points P and Q is: \",\n            a,\n            \"x + \",\n            b,\n            \"y = \",\n            c,\n            \"\")\n",
        "test": "\nif __name__ == '__main__':\n    P = [3, 2]\n    Q = [2, 6]\n    lineFromPoints(P, Q)\n",
        "output": "The line passing through points P and Q is:  4 x +  1 y =  14 \n",
        "fn_call": "lineFromPoints"
    },
    {
        "text": "area of the largest square that can be inscribed in an ellipse | function to find the area of the square ; a and b cannot be negative ; area of the square ; ",
        "context": "",
        "code": "def squarearea(a, b):\n    if (a < 0 or b < 0):\n        return -1\n    area = 4 * (((pow(a, 2) + pow(b, 2)) / (pow(a, 2) * pow(b, 2))))\n    return area\n",
        "test": "\nif __name__ == '__main__':\n    a = 4\n    b = 2\n    print(squarearea(a, b))\n",
        "output": "1.25\n",
        "fn_call": "squarearea"
    },
    {
        "text": "smallest value of n such that the sum of all natural numbers from k to n is at least x | function to find the minimum possible value of n such that sum of natural numbers from k to n is at least x ; if k is greater than x ; stores value of minimum n ; stores the sum of values over the range [ k , ans ] ; iterate over the range [ k , n ] ; check if sum of first i natural numbers is >= x ; print the possible value of ans ; ",
        "context": "",
        "code": "def minimumNumber(K, X):\n    if (K > X):\n        print(\"-1\")\n        return\n    ans = 0\n    sum = 0\n    for i in range(K, X + 1):\n        sum += i\n        if (sum >= X):\n            ans = i\n            break\n    print(ans)\n",
        "test": "\nK = 5\nX = 13\nminimumNumber(K, X)\n",
        "output": "7\n",
        "fn_call": "minimumNumber"
    },
    {
        "text": "smallest substring occurring only once in a given string | python3 program of the above approach ; function to find the smallest substring occurring only once ; stores all occurences ; generate all the substrings ; avoid multiple occurences ; append all substrings ; take into account all the substrings ; iterate over all unique substrings ; if frequency is 1 ; append into fresh list ; initialize a dictionary ; append the keys ; traverse the dictionary ; print the minimum of dictionary ; ",
        "context": "\nfrom collections import Counter\n\n",
        "code": "def smallestSubstring(a):\n    a1 = []\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if i != j:\n                a1 .append(a[i:j + 1])\n    a2 = Counter(a1)\n    freshlist = []\n    for i in a2:\n        if a2[i] == 1:\n            freshlist .append(i)\n    dictionary = dict()\n    for i in range(len(freshlist)):\n        dictionary[freshlist[i]] = len(freshlist[i])\n    newlist = []\n    for i in dictionary:\n        newlist .append(dictionary[i])\n    return (min(newlist))\n",
        "test": "\nS = \"ababaabba\"\nprint(smallestSubstring(S))\n",
        "output": "2\n",
        "fn_call": "smallestSubstring"
    },
    {
        "text": "find nth root of a number using bisection method | function that returns the value of the function at a given value of x ; calculating the value of the differential of the function ; the function that returns the root of given number ; defining range on which answer can be found ; finding mid value ; ",
        "context": "",
        "code": "def f(x, p, num):\n    return pow(x, p) - num\n\n\ndef f_prime(x, p):\n    return p * pow(x, p - 1)\n\n\ndef root(num, p):\n    left = -num\n    right = num\n    x = 0\n    while (True):\n        x = (left + right) / 2.0\n        value = f(x, p, num)\n        prime = f_prime(x, p)\n        if (value * prime <= 0):\n            left = x\n        else:\n            right = x\n        if (value = 0):\n            return x\n",
        "test": "\nif __name__ == \"__main__\":\n    P = 1234321\n    N = 2\n    ans = root(P, N)\n    print(ans)\n",
        "output": "1111.0000000004495\n",
        "fn_call": "root"
    },
    {
        "text": "maximize sum of consecutive differences in a circular array | return the maximum sum of difference between consecutive elements ; sorting the array ; subtracting a1 , a2 , a3 , ... . . , a ( n / 2 ) - 1 , an / 2 twice and adding a ( n / 2 ) + 1 , a ( n / 2 ) + 2 , a ( n / 2 ) + 3 , . ... . , an - 1 , an twice . ; ",
        "context": "",
        "code": "def maxSum(arr, n):\n    sum = 0\n    arr .sort()\n    for i in range(0, int(n / 2)):\n        sum -= (2 * arr[i])\n        sum += (2 * arr[n - i - 1])\n    return sum\n",
        "test": "\narr = [4, 2, 1, 8]\nn = len(arr)\nprint(maxSum(arr, n))\n",
        "output": "18\n",
        "fn_call": "maxSum"
    },
    {
        "text": "satisfy the parabola when point ( a , b ) and the equation is given | function to find the required values ; ",
        "context": "",
        "code": "def solve(A, B):\n    p = B / 2\n    M = int(4 * p)\n    N = 1\n    O = -2 * A\n    Q = int(A * A + 4 * p * p)\n    return [M, N, O, Q]\n",
        "test": "\na = 1\nb = 1\nprint(*solve(a, b))\n",
        "output": "2 1 -2 2\n",
        "fn_call": "solve"
    },
    {
        "text": "minimum number of squares whose sum equals to a given number n | set | python3 program for the above approach ; function that returns true if n is a perfect square ; function that returns true check if n is sum of three squares ; factor out the powers of 4 ; n is not of the form 4 ^ a * ( 8 b + 7 ) ; function that finds the minimum number of square whose sum is n ; if n is perfect square ; if n is sum of 2 perfect squares ; if n is sum of 3 perfect squares ; otherwise , n is the sum of 4 perfect squares ; ",
        "context": "\nfrom math import sqrt, floor, ceil\n\n",
        "code": "def isPerfectSquare(N):\n    floorSqrt = floor(sqrt(N))\n    return (N == floorSqrt * floorSqrt)\n\n\ndef legendreFunction(N):\n    while (N % 4 == 0):\n        N //= 4\n    if (N % 8 != 7):\n        return True\n    else:\n        return False\n\n\ndef minSquares(N):\n    if (isPerfectSquare(N)):\n        return 1\n    for i in range(N):\n        if i * i < N:\n            break\n        if (isPerfectSquare(N - i * i)):\n            return 2\n    if (legendreFunction(N)):\n        return 3\n    return 4\n",
        "test": "\nif __name__ == '__main__':\n    N = 123\n    print(minSquares(N))\n",
        "output": "3\n",
        "fn_call": "minSquares"
    },
    {
        "text": "find the smallest twins in given range | python3 program to find the smallest twin in given range ; create a boolean array \" prime [ 0 . . high ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; look for the smallest twin ; if p is not marked , then it is a prime ; update all multiples of p ; now print the smallest twin in range ; ",
        "context": "\nimport math\n\n",
        "code": "def printTwins(low, high):\n    prime = [True] * (high + 1)\n    twin = False\n    prime[0] = prime[1] = False\n    for p in range(2, int(math .floor(math .sqrt(high)) + 2)):\n        if (prime[p]):\n            for i in range(p * 2, high + 1, p):\n                prime[i] = False\n    for i in range(low, high + 1):\n        if (prime[i] and prime[i + 2]):\n            print(\"Smallest twins in given range: (\", i, \",\", (i + 2), \")\")\n            twin = True\n            break\n    if (twin == False):\n        print(\"No such pair exists\")\n",
        "test": "\nprintTwins(10, 100)\n",
        "output": "Smallest twins in given range: ( 11 , 13 )\n",
        "fn_call": "printTwins"
    },
    {
        "text": "fast doubling method to find the nth fibonacci number | python3 program to find the nth fibonacci number using fast doubling method ; function calculate the n - th fibanacci number using fast doubling method ; base condition ; here a = f ( n ) ; here b = f ( n + 1 ) ; as f ( 2 n ) = f ( n ) [ 2f ( n + 1 ) f ( n ) ] here c = f ( 2 n ) ; as f ( 2 n + 1 ) = f ( n ) ^ 2 + f ( n + 1 ) ^ 2 here d = f ( 2 n + 1 ) ; check if n is odd or even ; ",
        "context": "\nMOD = 1000000007\n\n",
        "code": "def FastDoubling(n, res):\n    if (n == 0):\n        res[0] = 0\n        res[1] = 1\n        return\n    FastDoubling((n // 2), res)\n    a = res[0]\n    b = res[1]\n    c = 2 * b - a\n    if (c < 0):\n        c += MOD\n    c = (a * c) % MOD\n    d = (a * a + b * b) % MOD\n    if (n % 2 == 0):\n        res[0] = c\n        res[1] = d\n    else:\n        res[0] = d\n        res[1] = c + d\n",
        "test": "\nN = 6\nres = [0] * 2\nFastDoubling(N, res)\nprint(res[0])\n",
        "output": "8\n",
        "fn_call": "FastDoubling"
    },
    {
        "text": "number of balanced bracket subsequence of length 2 and 4 | python 3 implementation of above approach ; taking the frequency suffix sum of the number of 2 's present  after every index ; storing the count of subsequence ; subsequence of length 2 ; subsequence of length 4 of type 1 1 2 2 ; subsequence of length 4 of type 1 2 1 2 ; ",
        "context": "",
        "code": "def countWays(a, n):\n    suff = [0] * n\n    if (a[n - 1] == 2):\n        suff[n - 1] = 1\n    for i in range(n - 2, -1, -1):\n        if (a[i] == 2):\n            suff[i] = suff[i + 1] + 1\n        else:\n            suff[i] = suff[i + 1]\n    ss = 0\n    for i in range(n):\n        if (a[i] == 1):\n            ss += suff[i]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] == 1 and a[j] == 1 and suff[j] >= 2):\n                ss += (suff[j]) * (suff[j] - 1) // 2\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] == 1 and a[j] == 1 and (\n                    suff[i] - suff[j]) >= 1 and suff[j] >= 1):\n                ss += (suff[i] - suff[j]) * suff[j]\n    print(ss)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 2, 1, 1, 2, 2]\n    n = 6\n    countWays(a, n)\n",
        "output": "14\n",
        "fn_call": "countWays"
    },
    {
        "text": "number of connected components of a graph ( using disjoint set union ) | stores the parent of each vertex ; function to find the topmost parent of vertex a ; if current vertex is the topmost vertex ; otherwise , set topmost vertex of its parent as its topmost vertex ; function to connect the component having vertex a with the component having vertex b ; connect edges ; function to find unique top most parents ; traverse all vertices ; insert all topmost vertices obtained ; print count of connected components ; function to print answer ; setting parent to itself ; traverse all edges ; print answer ; given n ; ",
        "context": "\nparent = [0] * (1000000)\n\n",
        "code": "def root(a):\n    if (a == parent[a]):\n        return a\n    parent[a] = root(parent[a])\n    return parent[a]\n\n\ndef connect(a, b):\n    a = root(a)\n    b = root(b)\n    if (a != b):\n        parent[b] = a\n\n\ndef connectedComponents(n):\n    s = set()\n    for i in range(n):\n        s .add(root(parent[i]))\n    print(len(s))\n\n\ndef printAnswer(N, edges):\n    for i in range(N + 1):\n        parent[i] = i\n    for i in range(len(edges)):\n        connect(edges[i][0], edges[i][1])\n    connectedComponents(N)\n",
        "test": "\nN = 6\nedges = [[1, 0], [2, 3], [1, 2], [4, 5]]\nprintAnswer(N, edges)\n",
        "output": "2\n",
        "fn_call": "printAnswer"
    },
    {
        "text": "channel assignment problem | a depth first search based recursive function that returns true if a matching for vertex u is possible ; try every receiver one by one ; if sender u has packets to send to receiver v and receiver v is not already mapped to any other sender just check if the number of packets is greater than '0' because only one packet can be sent in a time frame anyways ; mark v as visited ; if receiver ' v ' is not assigned to any sender or previously assigned sender for receiver v ( which is matchr [ v ] ) has an alternate receiver available . since v is marked as visited in the above line , matchr [ v ] in the following recursive call will not get receiver ' v ' again ; returns maximum number of packets that can be sent parallely in 1 time slot from sender to receiver ; initially all receivers are not mapped to any senders ; count of receivers assigned to senders ; mark all receivers as not seen for next sender ; find if the sender ' u ' can be assigned to the receiver ; ",
        "context": "",
        "code": "def bpm(table, u, seen, matchR):\n    global M, N\n    for v in range(N):\n        if (table[u][v] > 0 and not seen[v]):\n            seen[v] = True\n            if (matchR[v] < 0 or bpm(table, matchR[v], seen, matchR)):\n                matchR[v] = u\n                return True\n    return False\n\n\ndef maxBPM(table):\n    global M, N\n    matchR = [-1] * N\n    result = 0\n    for u in range(M):\n        seen = [0] * N\n        if (bpm(table, u, seen, matchR)):\n            result += 1\n    print(\"The number of maximum packets sent\", \"in the time slot is\", result)\n    for x in range(N):\n        if (matchR[x] + 1 != 0):\n            print(\"T\", matchR[x] + 1, \"-> R\", x + 1)\n    return result\n",
        "test": "\nM = 3\nN = 4\ntable = [[0, 2, 0], [3, 0, 1], [2, 4, 0]]\nmax_flow = maxBPM(table)\n",
        "output": "The number of maximum packets sent in the time slot is 3\nT 3 -> R 1\nT 1 -> R 2\nT 2 -> R 3\n",
        "fn_call": "maxBPM"
    },
    {
        "text": "replace all occurrences of pi with 3.14 in a given string | function to replace all occurrences of pi in a given with 3.14 ; iterate through second last element of the string ; if current and current + 1 alphabets form the word ' pi ' append 3.14 to output ; append the current letter ; return the output string ; ",
        "context": "",
        "code": "def replacePi(input):\n    output = \"\"\n    size = len(input)\n    for i in range(size):\n        if (i + 1 < size and input[i] == 'p' and input[i + 1] == 'i'):\n            output += \"3.14\"\n            i += 1\n        else:\n            output += input[i]\n    return output\n",
        "test": "\ninput = \"2 * pi + 3 * pi = 5 * pi\"\nprint(replacePi(input))\n",
        "output": "2 * 3.14i + 3 * 3.14i = 5 * 3.14i\n",
        "fn_call": "replacePi"
    },
    {
        "text": "front and back search in unsorted array | python program to implement front and back search ; start searching from both ends ; keep searching while two indexes do not cross . ; ",
        "context": "",
        "code": "def search(arr, n, x):\n    front = 0\n    back = n - 1\n    while (front <= back):\n        if (arr[front] == x or arr[back] == x):\n            return True\n        front += 1\n        back -= 1\n    return False\n",
        "test": "\narr = [10, 20, 80, 30, 60, 50, 110, 100, 130, 170]\nx = 130\nn = len(arr)\nif (search(arr, n, x)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "search"
    },
    {
        "text": "check if there exists a permutation of given string which doesn 't contain any monotonous substring | function to check a string doesn 't contains a monotonous substring ; loop to iterate over the string and check that it doesn 't contains  the monotonous substring ; function to check that there exist a arrangement of string such that it doesn 't contains monotonous substring ; loop to group the characters of the string into two buckets ; sorting the two buckets ; condition to check if the concatenation point doesn 't  contains the monotonous string ; ",
        "context": "",
        "code": "def check(s):\n    ok = True\n    for i in range(0, len(s) - 1, 1):\n        ok = (ok & (abs(ord(s[i]) - ord(s[i + 1])) != 1))\n    return ok\n\n\ndef monotonousString(s):\n    odd = \"\"\n    even = \"\"\n    for i in range(len(s)):\n        if (ord(s[i]) % 2 == 0):\n            odd += s[i]\n        else:\n            even += s[i]\n    odd = list(odd)\n    odd .sort(reverse=False)\n    odd = str(odd)\n    even = list(even)\n    even .sort(reverse=False)\n    even = str(even)\n    if (check(odd + even)):\n        return \"Yes\"\n    elif (check(even + odd)):\n        return \"Yes\"\n    return \"No\"\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"abcd\"\n    ans = monotonousString(str1)\n    print(ans)\n",
        "output": "Yes\n",
        "fn_call": "monotonousString"
    },
    {
        "text": "queries to count array elements from a ",
        "context": "",
        "code": "def check(N):\n    if (N == 0):\n        return 0\n    return ((N & (N - 1)) == 0)\n\n\ndef build_seg_tree(ss, se, si, tree, arr):\n    if (ss == se):\n        tree[si] = check(arr[ss])\n        return\n    mid = (ss + se) // 2\n    build_seg_tree(ss, mid, 2 * si + 1, tree, arr)\n    build_seg_tree(mid + 1, se, 2 * si + 2, tree, arr)\n    tree[si] = tree[2 * si + 1] + tree[2 * si + 2]\n\n\ndef update(ss, se, si, X, V, tree, arr):\n    if (ss == se):\n        if (ss == X):\n            arr[X] = V\n            tree[si] = check(V)\n        return\n    mid = (ss + se) // 2\n    if (X <= mid):\n        update(ss, mid, 2 * si + 1, X, V, tree, arr)\n    else:\n        update(mid + 1, se, 2 * si + 2, X, V, tree, arr)\n    tree[si] = tree[2 * si + 1] + tree[2 * si + 2]\n\n\ndef query(l, r, ss, se, si, tree):\n    if (r  se):\n        return 0\n    if (l = se):\n        return tree[si]\n    mid = (ss + se) // 2\n    return (query(l, r, ss, mid, 2 * si + 1, tree) +\n            query(l, r, mid + 1, se, 2 * si + 2, tree))\n\n\ndef Query(arr, N, Q):\n    tree = [0] * (4 * N)\n    build_seg_tree(0, N - 1, 0, tree, arr)\n    for i in range(len(Q)):\n        if (Q[i][0] == 1):\n            print(query(Q[i][1], Q[i][2], 0, N - 1, 0, tree), end=\" \")\n        else:\n            update(0, N - 1, 0, Q[i][1], Q[i][2], tree, arr)\n",
        "test": "\narr = [12, 11, 16, 2, 32]\nQ = [[1, 0, 2], [2, 4, 24], [1, 1, 4]]\nN = len(arr)\nQuery(arr, N, Q)\n",
        "output": "1 2 ",
        "fn_call": "Query"
    },
    {
        "text": "minimize count of flips required such that no substring of 0 s have length exceeding k | function to return minimum number of flips required ; base case ; stores the count of minimum number of flips ; stores the count of zeros in current sub ; if current character is 0 ; continue ongoing sub ; start a new sub ; if k consecutive zeroes are obtained ; end segment ; return the result ; ",
        "context": "",
        "code": "def min_flips(strr, k):\n    if (len(strr) == 0):\n        return 0\n    ans = 0\n    cnt_zeros = 0\n    for ch in strr:\n        if (ch == '0'):\n            cnt_zeros += 1\n        else:\n            cnt_zeros = 0\n        if (cnt_zeros == k):\n            ans += 1\n            cnt_zeros = 0\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"11100000011\"\n    k = 3\n    print(min_flips(strr, k))\n",
        "output": "2\n",
        "fn_call": "min_flips"
    },
    {
        "text": "largest right circular cylinder that can be inscribed within a cone which is in turn inscribed within a cube | python3 program to find the biggest right circular cylinder that can be inscribed within a right circular cone which in turn is inscribed within a cube ; function to find the biggest right circular cylinder ; side cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def cyl(a):\n    if (a < 0):\n        return -1\n    r = (2 * a * mt .sqrt(2)) / 3\n    h = (2 * a) / 3\n    V = 3.14 * pow(r, 2) * h\n    return V\n",
        "test": "\na = 5\nprint(cyl(a))\n",
        "output": "232.59259259259264\n",
        "fn_call": "cyl"
    },
    {
        "text": "lexicographically largest string possible consisting of at most k consecutive similar characters | function to return nearest lower character ; traverse charset from start - 1 ; if no character can be appended ; function to find largest string ; stores the frequency of characters ; traverse the string ; append larger character ; decrease count in charset ; increase count ; check if count reached to charlimit ; find nearest lower char ; if no character can be appended ; append nearest lower character ; reset count for next calculation ; return new largest string ; ",
        "context": "",
        "code": "def nextAvailableChar(charset, start):\n    for i in range(start - 1, -1, -1):\n        if (charset[i] > 0):\n            charset[i] -= 1\n            return chr(i + ord('a'))\n    return '\\0'\n\n\ndef newString(originalLabel, limit):\n    n = len(originalLabel)\n    charset = [0] * (26)\n    newStrings = \"\"\n    for i in originalLabel:\n        charset[ord(i) - ord('a')] += 1\n    for i in range(25, -1, -1):\n        count = 0\n        while (charset[i] > 0):\n            newStrings += chr(i + ord('a'))\n            charset[i] -= 1\n            count += 1\n            if (charset[i] > 0 and count == limit):\n                next = nextAvailableChar(charset, i)\n                if (next == '\\0'):\n                    return newStrings\n                newStrings += next\n                count = 0\n    return newStrings\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"ccbbb\"\n    K = 2\n    print(newString(S, K))\n",
        "output": "ccbb\n",
        "fn_call": "newString"
    },
    {
        "text": "find the next non | python 3 implementation of the approach ; function to check if a number is perfect square ; function to check if a number is fibinacci number ; n is fibinacci if either ( 5 * n * n + 4 ) , ( 5 * n * n - 4 ) or both is a perferct square ; function to find the next non - fibinacci number ; case 1 if n <= 3 , then 4 will be next non - fibinacci number ; case 2 if n + 1 is fibinacci , then n + 2 will be next non - fibinacci number ; if n + 1 is non - fibinacci , then n + 2 will be next non - fibinacci number ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isPerfectSquare(x):\n    s = sqrt(x)\n    return (s * s == x)\n\n\ndef isFibonacci(N):\n    return isPerfectSquare(5 * N * N + 4) or isPerfectSquare(5 * N * N - 4)\n\n\ndef nextNonFibonacci(N):\n    if (N <= 3):\n        return 4\n    if (isFibonacci(N + 1)):\n        return N + 2\n    else:\n        return N\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    print(nextNonFibonacci(N))\n    N = 4\n    print(nextNonFibonacci(N))\n    N = 7\n    print(nextNonFibonacci(N))\n",
        "output": "4\n6\n9\n",
        "fn_call": "nextNonFibonacci"
    },
    {
        "text": "count of n digit numbers whose sum of digits equals to given sum | recursive function to count ' n ' digit numbers with sum of digits as ' sum ' this function considers leading 0 's also as digits, that is why not directly called ; base case ; initialize answer ; traverse through every digit and count numbers beginning with it using recursion ; this is mainly a wrapper over countrec . it explicitly handles leading digit and calls countrec ( ) for remaining digits . ; initialize final answer ; traverse through every digit from 1 to 9 and count numbers beginning with it ; ",
        "context": "",
        "code": "def countRec(n, sum):\n    if (n == 0):\n        return (sum == 0)\n    if (sum == 0):\n        return 1\n    ans = 0\n    for i in range(0, 10):\n        if (sum - i >= 0):\n            ans = ans + countRec(n - 1, sum - i)\n    return ans\n\n\ndef finalCount(n, sum):\n    ans = 0\n    for i in range(1, 10):\n        if (sum - i >= 0):\n            ans = ans + countRec(n - 1, sum - i)\n    return ans\n",
        "test": "\nn = 2\nsum = 5\nprint(finalCount(n, sum))\n",
        "output": "5\n",
        "fn_call": "finalCount"
    },
    {
        "text": "find smallest positive number y such that bitwise and of x and y is zero | method to find smallest number y for a given value of x such that x and y is zero ; convert the number into its binary form ; case 1 : if all bits are ones , then return the next number ; case 2 : find the first 0 - bit index and return the y ; ",
        "context": "",
        "code": "def findSmallestNonZeroY(A_num):\n    A_binary = bin(A_num)\n    B = 1\n    length = len(A_binary)\n    no_ones = (A_binary).count('1')\n    if length == no_ones:\n        return A_num + 1\n    for i in range(length):\n        ch = A_binary[length - i - 1]\n        if (ch == '0'):\n            B = pow(2.0, i)\n            break\n    return B\n",
        "test": "\nif __name__ == \"__main__\":\n    X = findSmallestNonZeroY(10)\n    print(X)\n",
        "output": "1.0\n",
        "fn_call": "findSmallestNonZeroY"
    },
    {
        "text": "swap every two bits in bytes | python program to swap every two bits in a byte . ; extracting the high bit shift it to lowbit extracting the low bit shift it to highbit ; ",
        "context": "\nimport math\n\n",
        "code": "def swapBitsInPair(x):\n    return ((x & 0b10101010) >> 1) or ((x & 0b01010101) << 1)\n",
        "test": "\nx = 4\nprint(swapBitsInPair(x))\n",
        "output": "8\n",
        "fn_call": "swapBitsInPair"
    },
    {
        "text": "program to find sum of first n natural numbers | returns sum of first n natural numbers ; ",
        "context": "",
        "code": "def findSum(n):\n    return n * (n + 1) / 2\n",
        "test": "\nn = 5\nprint(findSum(n))\n",
        "output": "15.0\n",
        "fn_call": "findSum"
    },
    {
        "text": "check if given coins can be used to pay a value of s | function to check if it is possible to pay a value ; loop to add the value of coin a ; condition to check if it is possible to pay a value of s ; ",
        "context": "",
        "code": "def knowPair(a, b, n, s, m):\n    i = 0\n    rem = 0\n    count_b = 0\n    flag = 0\n    while (i <= a):\n        rem = s - (n * i)\n        count_b = rem // m\n        if (rem % m == 0 and count_b <= b):\n            flag = 1\n        i += 1\n    if (flag == 1):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == '__main__':\n    A = 1\n    B = 2\n    n = 3\n    S = 4\n    m = 2\n    knowPair(A, B, n, S, m)\n",
        "output": "YES\n",
        "fn_call": "knowPair"
    },
    {
        "text": "represent k as sum of n | array to store the n - bonacci series ; function to express k as sum of several n_bonacci numbers ; ",
        "context": "\nN_bonacci = [0] * 100\n\n",
        "code": "def N_bonacci_nums(n, k):\n    N_bonacci[0] = 1\n    for i in range(1, 51):\n        j = i - 1\n        while j >= i - k and j >= 0:\n            N_bonacci[i] += N_bonacci[j]\n            j -= 1\n    ans = []\n    for i in range(50, -1, -1):\n        if (n - N_bonacci[i] >= 0):\n            ans .append(N_bonacci[i])\n            n -= N_bonacci[i]\n    if (len(ans) == 1):\n        ans .append(0)\n    print(len(ans))\n    for i in ans:\n        print(i, end=\", \")\n",
        "test": "\nif __name__ == '__main__':\n    n = 21\n    k = 5\n    N_bonacci_nums(n, k)\n",
        "output": "3\n16, 4, 1, ",
        "fn_call": "N_bonacci_nums"
    },
    {
        "text": "minimum boxes required to carry all gifts | function to return number of boxes ; sort the boxes in ascending order ; try to fit smallest box with current heaviest box ( from right side ) ; ",
        "context": "",
        "code": "def numBoxex(A, n, K):\n    A .sort()\n    i = 0\n    j = n - 1\n    ans = 0\n    while i <= j:\n        ans += 1\n        if A[i] + A[j] <= K:\n            i += 1\n        j -= 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    A = [3, 2, 2, 1]\n    K = 3\n    n = len(A)\n    print(numBoxex(A, n, K))\n",
        "output": "3\n",
        "fn_call": "numBoxex"
    },
    {
        "text": "choose points from two ranges such that no point lies in both the ranges | function to find the required points ; ",
        "context": "",
        "code": "def findPoints(l1, r1, l2, r2):\n    x = min(l1, l2)if (l1 != l2)else -1\n    y = max(r1, r2)if (r1 != r2)else -1\n    print(x, y)\n",
        "test": "\nif __name__ == \"__main__\":\n    l1 = 5\n    r1 = 10\n    l2 = 1\n    r2 = 7\n    findPoints(l1, r1, l2, r2)\n",
        "output": "1 10\n",
        "fn_call": "findPoints"
    },
    {
        "text": "check if possible to cross the matrix with given power | python3 program to find if it is possible to cross the matrix with given power ; for each value of dp [ i ] [ j ] [ k ] ; for first cell and for each value of k ; for first cell of each row ; for first cell of each column ; for rest of the cell ; down movement . ; right movement . ; diagonal movement . ; finding maximum k . ; ",
        "context": "\nN = 105\nR = 3\nC = 4\n\n",
        "code": "def maximumValue(n, m, p, grid):\n    dp = [[[False for i in range(N)]for j in range(N)]for k in range(N)]\n    for i in range(n):\n        for j in range(m):\n            k = grid[i][j]\n            while (k <= p):\n                if (i == 0 and j == 0):\n                    if (k == grid[i][j]):\n                        dp[i][j][k] = True\n                elif (i == 0):\n                    dp[i][j][k] = (dp[i][j][k] or dp[i][j - 1][k - grid[i][j]])\n                elif (j == 0):\n                    dp[i][j][k] = (dp[i][j][k] or dp[i - 1][j][k - grid[i][j]])\n                else:\n                    dp[i][j][k] = (dp[i][j][k] or dp[i][j - 1][k - grid[i][j]])\n                    dp[i][j][k] = (dp[i][j][k] or dp[i - 1][j][k - grid[i][j]])\n                    dp[i][j][k] = (dp[i][j][k] or dp[i - 1]\n                                   [j - 1][k - grid[i][j]])\n                k += 1\n    ans = k\n    while (ans >= 0):\n        if (dp[n - 1][m - 1][ans]):\n            break\n        ans -= 1\n    return ans\n",
        "test": "\nn = 3\nm = 4\np = 9\ngrid = [[2, 3, 4, 1], [6, 5, 5, 3], [5, 2, 3, 4]]\nprint(maximumValue(n, m, p, grid))\n",
        "output": "-1\n",
        "fn_call": "maximumValue"
    },
    {
        "text": "print concatenation of zig | function for zig - zag concatenation ; check is n is less or equal to 1 ; iterate rownum from 0 to n - 1 ; iterate i till s . length ( ) - 1 ; check is rownum is 0 or n - 1 ; ",
        "context": "",
        "code": "def zigZagConcat(s, n):\n    if (n <= 1):\n        return s\n    result = \"\"\n    for rowNum in range(n):\n        i = rowNum\n        up = True\n        while (i < len(s)):\n            result += s[i]\n            if (rowNum == 0 or rowNum == n - 1):\n                i += (2 * n - 2)\n            else:\n                if (up):\n                    i += (2 * (n - rowNum) - 2)\n                else:\n                    i += rowNum * 2\n                up ^= True\n    return result\n",
        "test": "\nstr = \"GEEKSFORGEEKS\"\nn = 3\nprint(zigZagConcat(str, n))\n",
        "output": "GSGSEKFREKEOE\n",
        "fn_call": "zigZagConcat"
    },
    {
        "text": "minimize cost with replacement with other allowed | function returns the minimum cost of the array ; ",
        "context": "",
        "code": "def getMinCost(arr, n):\n    min_ele = min(arr)\n    return min_ele * (n - 1)\n",
        "test": "\narr = [4, 2, 5]\nn = len(arr)\nprint(getMinCost(arr, n))\n",
        "output": "4\n",
        "fn_call": "getMinCost"
    },
    {
        "text": "number of ways to convert a character x to a string y | python3 implementation of the approach ; function to find the modular - inverse ; while power > 1 ; updating s and a ; updating power ; return the final answer ; function to return the count of ways ; to store the final answer ; to store pre - computed factorials ; computing factorials ; loop to find the occurrences of x and update the ans ; multiplying the answer by ( n - 1 ) ! ; return the final answer ; ",
        "context": "\nMOD = 1000000007\n\n",
        "code": "def modInv(a, p=MOD - 2):\n    s = 1\n    while (p != 1):\n        if (p % 2):\n            s = (s * a) % MOD\n        a = (a * a) % MOD\n        p //= 2\n    return (a * s) % MOD\n\n\ndef findCnt(x, y):\n    ans = 0\n    fact = [1] * (len(y) + 1)\n    for i in range(1, len(y)):\n        fact[i] = (fact[i - 1] * i) % MOD\n    for i in range(len(y)):\n        if (y[i] == x):\n            ans += (modInv(fact[i]) * modInv(fact[len(y) - i - 1])) % MOD\n            ans %= MOD\n    ans *= fact[(len(y) - 1)]\n    ans %= MOD\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 'a'\n    y = \"xxayy\"\n    print(findCnt(x, y))\n",
        "output": "6\n",
        "fn_call": "findCnt"
    },
    {
        "text": "check if a point having maximum x and y coordinates exists or not | python3 program for the above approach ; function to find the pohaving max x and y coordinates ; initialize maxx and maxy ; length of the given array ; get maximum x & y coordinates ; check if the required point i . e . , ( maxx , maxy ) is present ; if powith maximum x and y coordinates is present ; if no such poexists ; ",
        "context": "\nimport sys\n\n",
        "code": "def findMaxPoint(arr):\n    maxX = -sys .maxsize\n    maxY = -sys .maxsize\n    n = len(arr)\n    for i in range(n):\n        maxX = max(maxX, arr[i][0])\n        maxY = max(maxY, arr[i][1])\n    for i in range(n):\n        if (maxX == arr[i][0] and maxY == arr[i][1]):\n            print(\"(\", maxX, \", \", maxY, \")\")\n            return\n    print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, 2], [2, 1], [3, 4], [4, 3], [5, 5]]\n    findMaxPoint(arr)\n",
        "output": "( 5 ,  5 )\n",
        "fn_call": "findMaxPoint"
    },
    {
        "text": "check if two same sub | function to check if similar subsequences occur in a string or not ; iterate and count the frequency ; counting frequency of the letters ; check if frequency is more than once of any character ; ",
        "context": "",
        "code": "def check(s, l):\n    freq = [0 for i in range(26)]\n    for i in range(l):\n        freq[ord(s[i]) - ord('a')] += 1\n    for i in range(26):\n        if (freq[i] >= 2):\n            return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    s = \"geeksforgeeks\"\n    l = len(s)\n    if (check(s, l)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "check"
    },
    {
        "text": "count the numbers  2 ; count the total elements that have divisors exactly equal to as that of k 's ; exclude k from the result if it is smaller than n . ; ",
        "context": "",
        "code": "def countDivisors(n):\n    x, ans = 0, 1\n    while (n % 2 == 0):\n        x += 1\n        n = n / 2\n    ans = ans * (x + 1)\n    for i in range(3, int(n ** 1 / 2) + 1, 2):\n        x = 0\n        while (n % i == 0):\n            x += 1\n            n = n / i\n        ans = ans * (x + 1)\n    if (n > 2):\n        ans = ans * 2\n    return ans\n\n\ndef getTotalCount(n, k):\n    k_count = countDivisors(k)\n    count = 0\n    for i in range(1, n):\n        if (k_count == countDivisors(i)):\n            count += 1\n    if (k < n):\n        count = count - 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n, k = 500, 6\n    print(getTotalCount(n, k))\n",
        "output": "148\n",
        "fn_call": "getTotalCount"
    },
    {
        "text": "smallest difference triplet from three arrays | function to find maximum number ; function to find minimum number ; finds and prints the smallest difference triplet ; sorting all the three arrays ; to store resultant three numbers ; pointers to arr1 , arr2 , arr3 respectively ; loop until one array reaches to its end find the smallest difference . ; maximum number ; find minimum and increment its index . ; comparing new difference with the previous one and updating accordingly ; print result ; ",
        "context": "",
        "code": "def maximum(a, b, c):\n    return max(max(a, b), c)\n\n\ndef minimum(a, b, c):\n    return min(min(a, b), c)\n\n\ndef smallestDifferenceTriplet(arr1, arr2, arr3, n):\n    arr1 .sort()\n    arr2 .sort()\n    arr3 .sort()\n    res_min = 0\n    res_max = 0\n    res_mid = 0\n    i = 0\n    j = 0\n    k = 0\n    diff = 2147483647\n    while (i < n and j < n and k < n):\n        sum = arr1[i] + arr2[j] + arr3[k]\n        max = maximum(arr1[i], arr2[j], arr3[k])\n        min = minimum(arr1[i], arr2[j], arr3[k])\n        if (min == arr1[i]):\n            i += 1\n        elif (min == arr2[j]):\n            j += 1\n        else:\n            k += 1\n        if (diff > (max - min)):\n            diff = max - min\n            res_max = max\n            res_mid = sum - (max + min)\n            res_min = min\n    print(res_max, \",\", res_mid, \",\", res_min)\n",
        "test": "\narr1 = [5, 2, 8]\narr2 = [10, 7, 12]\narr3 = [9, 14, 6]\nn = len(arr1)\nsmallestDifferenceTriplet(arr1, arr2, arr3, n)\n",
        "output": "7 , 6 , 5\n",
        "fn_call": "smallestDifferenceTriplet"
    },
    {
        "text": "length of longest common subsequence containing vowels | function to check whether ' ch ' is a vowel or not ; function to find the length of longest common subsequence which contains all vowel characters ; following steps build l [ m + 1 ] [ n + 1 ] in bottom up fashion . note that l [ i ] [ j ] contains length of lcs of x [ 0. . i - 1 ] and y [ 0. . j - 1 ] ; l [ m ] [ n ] contains length of lcs for x [ 0. . n - 1 ] and y [ 0. . m - 1 ] which contains all vowel characters ; ",
        "context": "",
        "code": "def isVowel(ch):\n    if (ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u'):\n        return True\n    return False\n\n\ndef lcs(X, Y, m, n):\n    L = [[0 for i in range(n + 1)]for j in range(m + 1)]\n    i, j = 0, 0\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if (i == 0 or j == 0):\n                L[i][j] = 0\n            elif ((X[i - 1] == Y[j - 1]) and isVowel(X[i - 1])):\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    return L[m][n]\n",
        "test": "\nX = \"aieef\"\nY = \"klaief\"\nm = len(X)\nn = len(Y)\nprint(\"Length of LCS =\", lcs(X, Y, m, n))\n",
        "output": "Length of LCS = 3\n",
        "fn_call": "lcs"
    },
    {
        "text": "count pairs of points having distance between them equal to integral values in a k | function to find pairs whose distance between the points of is an integer value . ; stores count of pairs whose distance between points is an integer ; traverse the array , points [ ] ; stores distance between points ( i , j ) ; traverse all the points of current pair ; update temp ; update dist ; if dist is a perfect square ; update ans ; given value of k ; given points ; ",
        "context": "",
        "code": "def cntPairs(points, n, K):\n    ans = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            dist = 0\n            for k in range(K):\n                temp = (points[i][k] - points[j][k])\n                dist += temp * temp\n            if (((dist)**(1 / 2)) * ((dist)**(1 / 2)) == dist):\n                ans += 1\n    print(ans)\n",
        "test": "\nK = 2\npoints = [[1, 2], [5, 5], [-2, 8]]\nn = len(points)\ncntPairs(points, n, K)\n",
        "output": "1\n",
        "fn_call": "cntPairs"
    },
    {
        "text": "count of strings that can be formed using a , b and c under given constraints | n is total number of characters . bcount and ccount are counts of ' b ' and ' c ' respectively . ; base cases ; three cases , we choose , a or b or c in all three cases n decreases by 1. ; ",
        "context": "",
        "code": "def countStr(n, bCount, cCount):\n    if (bCount < 0 or cCount < 0):\n        return 0\n    if (n == 0):\n        return 1\n    if (bCount == 0 and cCount == 0):\n        return 1\n    res = countStr(n - 1, bCount, cCount)\n    res += countStr(n - 1, bCount - 1, cCount)\n    res += countStr(n - 1, bCount, cCount - 1)\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    print(countStr(n, 1, 2))\n",
        "output": "19\n",
        "fn_call": "countStr"
    },
    {
        "text": "number of substrings with count of each character as k | python3 program to count number of substrings with counts of distinct characters as k . ; returns true if all values in freq [ ] are either 0 or k . ; returns count of substrings where frequency of every present character is k ; pick a starting point ; initialize all frequencies as 0 for this starting point ; one by one pick ending points ; increment frequency of current char ; if frequency becomes more than k , we can 't have more substrings  starting with i ; if frequency becomes k , then check other frequencies as well ; ",
        "context": "\nMAX_CHAR = 26\n\n",
        "code": "def check(freq, k):\n    for i in range(0, MAX_CHAR):\n        if (freq[i] and freq[i] != k):\n            return False\n    return True\n\n\ndef substrings(s, k):\n    res = 0\n    for i in range(0, len(s)):\n        freq = [0] * MAX_CHAR\n        for j in range(i, len(s)):\n            index = ord(s[j]) - ord('a')\n            freq[index] += 1\n            if (freq[index] > k):\n                break\n            elif (freq[index] == k and check(freq, k)):\n                res += 1\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"aabbcc\"\n    k = 2\n    print(substrings(s, k))\n    s = \"aabbc\"\n    k = 2\n    print(substrings(s, k))\n",
        "output": "6\n3\n",
        "fn_call": "substrings"
    },
    {
        "text": "create an array of size n with sum s such that no subarray exists with sum s or s | function to create an array with n elements with sum as s such that the given conditions satisfy ; check if the solution exists ; print the array as print ( n - 1 ) elements of array as 2 ; print the last element of the array ; print the value of k ; if solution doesnot exists ; ",
        "context": "",
        "code": "def createArray(n, s):\n    if (2 * n <= s):\n        for i in range(n - 1):\n            print(2, end=\" \")\n            s -= 2\n        print(s)\n        print(1)\n    else:\n        print('-1')\n",
        "test": "\nN = 1\nS = 4\ncreateArray(N, S)\n",
        "output": "4\n1\n",
        "fn_call": "createArray"
    },
    {
        "text": "generate n | python3 program to generate n - bit gray codes ; this function generates all n bit gray codes and prints the generated codes ; base case ; ' arr ' will store all generated codes ; start with one - bit pattern ; every iteration of this loop generates 2 * i codes from previously generated i codes . ; enter the prviously generated codes again in arr [ ] in reverse order . nor arr [ ] has double number of codes . ; append 0 to the first half ; append 1 to the second half ; prcontents of arr [ ] ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def generateGrayarr(n):\n    if (n <= 0):\n        return\n    arr = list()\n    arr .append(\"0\")\n    arr .append(\"1\")\n    i = 2\n    j = 0\n    while (True):\n        if i >= 1 << n:\n            break\n        for j in range(i - 1, -1, -1):\n            arr .append(arr[j])\n        for j in range(i):\n            arr[j] = \"0\" + arr[j]\n        for j in range(i, 2 * i):\n            arr[j] = \"1\" + arr[j]\n        i = i << 1\n    for i in range(len(arr)):\n        print(arr[i])\n",
        "test": "\ngenerateGrayarr(3)\n",
        "output": "000\n001\n011\n010\n110\n111\n101\n100\n",
        "fn_call": "generateGrayarr"
    },
    {
        "text": "smallest perfect power of 2 greater than n ( without using arithmetic operators ) | function to find smallest perfect power of 2 greater than n ; to store perfect power of 2 ; bitwise left shift by 1 ; bitwise right shift by 1 ; required perfect power of 2 ; ",
        "context": "",
        "code": "def perfectPowerOf2(n):\n    per_pow = 1\n    while n > 0:\n        per_pow = per_pow << 1\n        n = n >> 1\n    return per_pow\n",
        "test": "\nn = 128\nprint(\"Perfect power of 2 greater than\", n, \":\", perfectPowerOf2(n))\n",
        "output": "Perfect power of 2 greater than 128 : 256\n",
        "fn_call": "perfectPowerOf2"
    },
    {
        "text": "count of possible hexagonal walks | python 3 implementation of counting number of possible hexagonal walks ; we initialize our origin with 1 ; for each n = 1 to 14 , we traverse in all possible direction . using this 3d array we calculate the number of ways at each step and the total ways for a given step shall be found at ways [ step number ] [ 8 ] [ 8 ] because all the steps after that will be used to trace back to the original point index 0 : 0 according to the image . ; this array stores the number of ways possible for a given step ; ",
        "context": "\ndepth = 16\nways = [[[0 for i in range(17)]for i in range(17)]for i in range(17)]\n\n",
        "code": "def preprocess(list, steps):\n    ways[0][8][8] = 1\n    for N in range(1, 16, 1):\n        for i in range(1, depth, 1):\n            for j in range(1, depth, 1):\n                ways[N][i][j] = (ways[N -\n                                      1][i][j +\n                                            1] +\n                                 ways[N -\n                                      1][i][j -\n                                            1] +\n                                 ways[N -\n                                      1][i +\n                                         1][j] +\n                                 ways[N -\n                                      1][i -\n                                         1][j] +\n                                 ways[N -\n                                      1][i +\n                                         1][j -\n                                            1] +\n                                 ways[N -\n                                      1][i -\n                                         1][j +\n                                            1])\n        list[N] = ways[N][8][8]\n    print(\"Number of walks possible is/are\", list[steps])\n",
        "test": "\nif __name__ == '__main__':\n    list = [0 for i in range(16)]\n    steps = 4\n    preprocess(list, steps)\n",
        "output": "Number of walks possible is/are 90\n",
        "fn_call": "preprocess"
    },
    {
        "text": "maximize difference between maximum and minimum array elements after k operations | function to find the maximum difference between the maximum and minimum in the array after k operations ; stores maximum difference between largest and smallest array element ; sort the array in descending order ; traverse the array arr [ ] ; update maxdiff ; ",
        "context": "",
        "code": "def maxDiffLargSmallOper(arr, N, K):\n    maxDiff = 0\n    arr .sort(reverse=True)\n    for i in range(min(K + 1, N)):\n        maxDiff += arr[i]\n    return maxDiff\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [7, 7, 7, 7]\n    N = len(arr)\n    K = 1\n    print(maxDiffLargSmallOper(arr, N, K))\n",
        "output": "14\n",
        "fn_call": "maxDiffLargSmallOper"
    },
    {
        "text": "check if a large number is divisible by 5 or not | function to find that number divisible by 5 or not . the function assumes that string length is at least one . ; ",
        "context": "",
        "code": "def isDivisibleBy5(st):\n    n = len(st)\n    return ((st[n - 1] == '0') or (st[n - 1] == '5'))\n",
        "test": "\nst = \"76955\"\nif isDivisibleBy5(st):\n    print(\"Yes\")\nelse:\n    print(\"No \")\n",
        "output": "Yes\n",
        "fn_call": "isDivisibleBy5"
    },
    {
        "text": "minimum perimeter of n blocks | python3 program to find minimum perimeter using n blocks . ; if n is a perfect square ; number of rows ; perimeter of the rectangular grid ; if there are blocks left ; ",
        "context": "\nimport math\n\n",
        "code": "def minPerimeter(n):\n    l = math .sqrt(n)\n    sq = l * l\n    if (sq == n):\n        return l * 4\n    else:\n        row = n / l\n        perimeter = 2 * (l + row)\n        if (n % l != 0):\n            perimeter += 2\n        return perimeter\n",
        "test": "\nn = 10\nprint(int(minPerimeter(n)))\n",
        "output": "14\n",
        "fn_call": "minPerimeter"
    },
    {
        "text": "find two numbers made up of a given digit such that their difference is divisible by n | function to implement the above approach ; hashmap to store remainder - length of the number as key - value pairs ; iterate till n + 1 length ; search remainder in the map ; if remainder is not already present insert the length for the corresponding remainder ; keep increasing m ; to keep m in range of integer ; length of one number is the current length ; length of the other number is the length paired with current remainder in map ; ",
        "context": "",
        "code": "def findNumbers(N, M):\n    m = M\n    remLen = {}\n    for len1 in range(1, N + 1, 1):\n        remainder = M % N\n        if (remLen .get(remainder) is None):\n            remLen[remainder] = len1\n        else:\n            break\n        M = M * 10 + m\n        M = M % N\n    LenA = len1\n    LenB = remLen[remainder]\n    for i in range(LenB):\n        print(m, end=\"\")\n    print(\" \", end=\"\")\n    for i in range(LenA):\n        print(m, end=\"\")\n    return\n",
        "test": "\nif __name__ == '__main__':\n    N = 8\n    M = 2\n    findNumbers(N, M)\n",
        "output": "22 222",
        "fn_call": "findNumbers"
    },
    {
        "text": "check if original array is retained after performing xor with m exactly k times | function to check if original array can be retained by performing xor with m exactly k times ; check if o is present or not ; if k is odd and 0 is not present then the answer will always be no . ; else it will be yes ; ",
        "context": "",
        "code": "def check(Arr, n, M, K):\n    flag = 0\n    for i in range(n):\n        if (Arr[i] == 0):\n            flag = 1\n    if (K % 2 != 0 and flag == 0):\n        return \"No\"\n    else:\n        return \"Yes\"\n",
        "test": "\nif __name__ == '__main__':\n    Arr = [1, 1, 2, 4, 7, 8]\n    M = 5\n    K = 6\n    n = len(Arr)\n    print(check(Arr, n, M, K))\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "length of longest subarray whose sum is not divisible by integer k | function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; sum of the array ; find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; updating the rightmost element ; update the sum of the array up to the index i ; check if the sum of the array is not divisible by k , then return the size of array ; all elements of array are divisible by k , then no such subarray possible so return - 1 ; length of prefix elements that can be removed ; length of suffix elements that can be removed ; return the length of subarray after removing the elements which have lesser number of elements ; ",
        "context": "",
        "code": "def MaxSubarrayLength(arr, n, k):\n    left = -1\n    sum = 0\n    for i in range(n):\n        if ((arr[i] % k) != 0):\n            if (left == -1):\n                left = i\n            right = i\n        sum += arr[i]\n    if ((sum % k) != 0):\n        return n\n    elif (left == -1):\n        return -1\n    else:\n        prefix_length = left + 1\n        suffix_length = n - right\n        return n - min(prefix_length, suffix_length)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [6, 3, 12, 15]\n    n = len(arr)\n    K = 3\n    print(MaxSubarrayLength(arr, n, K))\n",
        "output": "-1\n",
        "fn_call": "MaxSubarrayLength"
    },
    {
        "text": "minimum elements to be added in a range so that count of elements is divisible by k | python 3 implementation of the approach ; total elements in the range ; if total elements are already divisible by k ; value that must be added to count in order to make it divisible by k ; ",
        "context": "",
        "code": "def minimumMoves(k, l, r):\n    count = r - l + 1\n    if (count % k == 0):\n        return 0\n    return (k - (count % k))\n",
        "test": "\nif __name__ == '__main__':\n    k = 3\n    l = 10\n    r = 10\n    print(minimumMoves(k, l, r))\n",
        "output": "2\n",
        "fn_call": "minimumMoves"
    },
    {
        "text": "check if two elements of a matrix are on the same diagonal or not | function to check if two integers are on the same diagonal of the matrix ; storing indexes of y in p , q ; condition to check if the both the elements are in same diagonal of a matrix ; ",
        "context": "",
        "code": "def checkSameDiag(x, y):\n    for i in range(m):\n        for j in range(n):\n            if li[i][j] == x:\n                I, J = i, j\n            if li[i][j] == y:\n                P, Q = i, j\n    if P - Q == I - J or P + Q == I + J:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nif __name__ == \"__main__\":\n    m, n = 6, 5\n    li = [[32, 94, 99, 26, 82], [51, 69, 52, 63, 17], [90, 36, 88, 55, 33], [\n        93, 42, 73, 39, 28], [81, 31, 83, 53, 10], [12, 29, 85, 80, 87]]\n    x, y = 42, 80\n    checkSameDiag(x, y)\n",
        "output": "YES\n",
        "fn_call": "checkSameDiag"
    },
    {
        "text": "find maximum n such that the sum of square of first n natural numbers is not more than x | function to return the sum of the squares of first n natural numbers ; function to return the maximum n such that the sum of the squares of first n natural numbers is not more than x ; ",
        "context": "",
        "code": "def squareSum(N):\n    Sum = (N * (N + 1) * (2 * N + 1)) // 6\n    return Sum\n\n\ndef findMaxN(X):\n    low, high, N = 1, 100000, 0\n    while low <= high:\n        mid = (high + low) // 2\n        if squareSum(mid) <= X:\n            N = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return N\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 25\n    print(findMaxN(X))\n",
        "output": "3\n",
        "fn_call": "findMaxN"
    },
    {
        "text": "percentage increase in volume of the cube if a side of cube is increased by a given percentage | python program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; ",
        "context": "",
        "code": "def newvol(x):\n    print(\"percentage increase\" \"in the volume of the cube is \",\n          ((x ** (3)) / 10000 + 3 * x + (3 * (x ** (2))) / 100), \"%\")\n",
        "test": "\nx = 10\nnewvol(x)\n",
        "output": "percentage increasein the volume of the cube is  33.1 %\n",
        "fn_call": "newvol"
    },
    {
        "text": "replace all occurrences of a string with space | function to extract the secret message ; replacing all occurrences of sub in str by empty spaces ; removing unwanted spaces in the start and end of the string ; ",
        "context": "",
        "code": "def extractSecretMessage(Str, Sub):\n    Str = Str .replace(Sub, \" \")\n    return Str .strip()\n",
        "test": "\nStr = \"LIELIEILIEAMLIECOOL\"\nSub = \"LIE\"\nprint(extractSecretMessage(Str, Sub))\n",
        "output": "I AM COOL\n",
        "fn_call": "extractSecretMessage"
    },
    {
        "text": "check if a number is divisible by 47 or not | function to check if the number is divisible by 47 or not ; while there are at least two digits ; extracting the last ; truncating the number ; subtracting fourteen times the last digit to the remaining number ; finally return if the two - digit number is divisible by 43 or not ; ",
        "context": "",
        "code": "def isDivisible(n):\n    while n // 100:\n        d = n % 10\n        n //= 10\n        n = abs(n - (d * 14))\n    return (n % 47 == 0)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 59173\n    if (isDivisible(n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isDivisible"
    },
    {
        "text": "find the player to reach at least n by multiplying with any value from given range | function to find the winner ; backtrack from n to 1 ; ",
        "context": "",
        "code": "def Winner(N):\n    player = True\n    while N > 1:\n        X, Y = divmod(N, (9 if player else 2))\n        N = X + 1 if Y else X\n        player = not player\n    if player:\n        return 'B'\n    else:\n        return 'A'\n",
        "test": "\nN = 10\nprint(Winner(N))\n",
        "output": "B\n",
        "fn_call": "Winner"
    },
    {
        "text": "minimum halls required for class scheduling | python3 implementation of the approach ; function to return the minimum number of halls required ; array to store the number of lectures ongoing at time t ; for every lecture increment start point s decrement ( end point + 1 ) ; perform prefix sum and update the ans to maximum ; ",
        "context": "\nMAX = 100001\n\n",
        "code": "def minHalls(lectures, n):\n    prefix_sum = [0] * MAX\n    for i in range(n):\n        prefix_sum[lectures[i][0]] += 1\n        prefix_sum[lectures[i][1] + 1] -= 1\n    ans = prefix_sum[0]\n    for i in range(1, MAX):\n        prefix_sum[i] += prefix_sum[i - 1]\n        ans = max(ans, prefix_sum[i])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    lectures = [[0, 5], [1, 2], [1, 10]]\n    n = len(lectures)\n    print(minHalls(lectures, n))\n",
        "output": "3\n",
        "fn_call": "minHalls"
    },
    {
        "text": "generate a combination of minimum coins that sums to a given value | python3 program for the above approach ; dp array to memoize the results ; list to store the result ; function to find the minimum number of coins to make the sum equals to x ; base case ; if previously computed subproblem occurred ; initialize result ; try every coin that has smaller value than n ; check for int_max to avoid overflow and see if result . an be minimized ; memoizing value of current state ; function to find the possible combination of coins to make the sum equal to x ; base case ; print solutions ; try every coin that has value smaller than n ; add current denominations ; backtrack ; function to find the minimum combinations of coins for value x ; min coins ; if no solution exists ; backtrack to find the solution ; ",
        "context": "\nimport sys\nMAX = 100000\ndp = [-1] * (MAX + 1)\ndenomination = []\n\n",
        "code": "def countMinCoins(n, C, m):\n    if (n == 0):\n        dp[0] = 0\n        return 0\n    if (dp[n] != -1):\n        return dp[n]\n    ret = sys .maxsize\n    for i in range(m):\n        if (C[i] <= n):\n            x = countMinCoins(n - C[i], C, m)\n            if (x != sys .maxsize):\n                ret = min(ret, 1 + x)\n    dp[n] = ret\n    return ret\n\n\ndef findSolution(n, C, m):\n    if (n == 0):\n        for it in denomination:\n            print(it, end=\" \")\n        return\n    for i in range(m):\n        if (n - C[i] >= 0 and dp[n - C[i]] + 1 == dp[n]):\n            denomination .append(C[i])\n            findSolution(n - C[i], C, m)\n            break\n\n\ndef countMinCoinsUtil(X, C, N):\n    isPossible = countMinCoins(X, C, N)\n    if (isPossible == sys .maxsize):\n        print(\"-1\")\n    else:\n        findSolution(X, C, N)\n",
        "test": "\nif __name__ == '__main__':\n    X = 21\n    arr = [2, 3, 4, 5]\n    N = len(arr)\n    countMinCoinsUtil(X, arr, N)\n",
        "output": "2 4 5 5 5 ",
        "fn_call": "countMinCoinsUtil"
    },
    {
        "text": "count numbers less than n whose bitwise and with n is zero | function to count number of unset bits in the integer n ; stores the number of unset bits in n ; check if n is even ; increment the value of c ; right shift n by 1 ; return the value of count of unset bits ; function to count numbers whose bitwise and with n equal to 0 ; stores the number of unset bits in n ; prthe value of 2 to the power of unsetbits ; ",
        "context": "",
        "code": "def countUnsetBits(N):\n    c = 0\n    while (N):\n        if (N % 2 == 0):\n            c += 1\n        N = N >> 1\n    return c\n\n\ndef countBitwiseZero(N):\n    unsetBits = countUnsetBits(N)\n    print((1 << unsetBits))\n",
        "test": "\nif __name__ == '__main__':\n    N = 9\n    countBitwiseZero(N)\n",
        "output": "4\n",
        "fn_call": "countBitwiseZero"
    },
    {
        "text": "print prime numbers from 1 to n in reverse order | python3 program to print all primes between 1 to n in reverse order using sieve of eratosthenes ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; print all prime numbers in reverse order ; static ",
        "context": "",
        "code": "def Reverseorder(n):\n    prime = [True] * (n + 1)\n\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range((p * 2), (n + 1), p):\n                prime[i] = False\n        p += 1\n    for p in range(n, 1, -1):\n        if (prime[p]):\n            print(p, end=\" \")\n",
        "test": "\nN = 25\nprint(\"Prime number in reverse order\")\n\nif (N == 1):\n    print(\"No prime no exist in this range\")\nelse:\n    Reverseorder(N)\n",
        "output": "Prime number in reverse order\n23 19 17 13 11 7 5 3 2 ",
        "fn_call": "Reverseorder"
    },
    {
        "text": "minimize hamming distance in binary string by setting only one k size substring bits | function to find minimum hamming distance after atmost one operation ; store the size of the string ; store the prefix sum of 1 s ; create prefix sum array ; initialize cnt as number of ones in string s ; store the required result ; traverse the string , s ; store the number of 1 s in the substring s [ i , i + k - 1 ] ; update the answer ; return the result ; ",
        "context": "",
        "code": "def minimumHammingDistance(S, K):\n    n = len(S)\n    pref = [0] * n\n    pref[0] = ord(S[0]) - ord('0')\n    for i in range(1, n):\n        pref[i] = pref[i - 1] + (ord(S[i]) - ord('0'))\n    cnt = pref[n - 1]\n    ans = cnt\n    for i in range(n - K):\n        value = pref[i + K - 1] - (pref[i - 1]if (i - 1) >= 0 else 0)\n        ans = min(ans, cnt - value + (K - value))\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    s = \"101\"\n    K = 2\n    print(minimumHammingDistance(s, K))\n",
        "output": "2\n",
        "fn_call": "minimumHammingDistance"
    },
    {
        "text": "count pairs in an array whose product is composite number | function to check if a number is prime or not ; check if n is multiple of i or not . ; if n is multiple of i . ; function to get the count of pairs whose product is a composite number . ; stores the count of pairs whose product is a composite number ; generate all possible pairs ; stores the product of element of current pair ; if prod is a composite number ; ",
        "context": "",
        "code": "def isComposite(N):\n    for i in range(2, N + 1):\n        if i * i > N:\n            break\n        if (N % i == 0):\n            return True\n    return False\n\n\ndef compositePair(arr, N):\n    res = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            prod = arr[i] * arr[j]\n            if (isComposite(prod)):\n                res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 2, 2, 8]\n    N = len(arr)\n    print(compositePair(arr, N))\n",
        "output": "5\n",
        "fn_call": "compositePair"
    },
    {
        "text": "number formed by flipping all bits to the left of rightmost set bit | function to get the total count ; moving until we get the rightmost set bit ; to get total number of bits in a number ; function to find the integer formed after flipping all bits to the left of the rightmost set bit ; find the total count of bits and the rightmost set bit ; xor given number with the number which has is made up of only totbits set ; to avoid flipping the bits to the right of the set bit , take xor with the number made up of only set firstbits ; ",
        "context": "",
        "code": "def getTotCount(num):\n    totCount = 1\n    firstCount = 1\n    temp = 1\n    while (not (num & temp)):\n        temp = temp << 1\n        totCount += 1\n    firstCount = totCount\n    temp = num >> totCount\n    while (temp):\n        totCount += 1\n        temp = temp >> 1\n    return totCount, firstCount\n\n\ndef flipBitsFromRightMostSetBit(num):\n    totbit, firstbit = getTotCount(num)\n    num1 = num ^ ((1 << totbit) - 1)\n    num1 = num1 ^ ((1 << firstbit) - 1)\n    return num1\n",
        "test": "\nif __name__ == '__main__':\n    n = 120\n    print(flipBitsFromRightMostSetBit(n))\n",
        "output": "8\n",
        "fn_call": "flipBitsFromRightMostSetBit"
    },
    {
        "text": "check if a pair of strings exists that starts with and without the character k or not | function to check whether a pair of strings exists satisfying the conditions ; stores the visited strings ; iterate over the array arr [ ] ; if first character of current string is k ; otherwise ; adding to the visited ; ",
        "context": "",
        "code": "def checkhappy(arr, K, N):\n    visited = set()\n    for s in arr:\n        if (s[0] == K):\n            if s[1:] in visited:\n                return 'Yes'\n        else:\n            if (K + s) in visited:\n                return 'Yes'\n        visited .add(s)\n    return \"No\"\n",
        "test": "\nif __name__ == '__main__':\n    arr = ['a', '! a', 'b', '! c', 'd', '! d']\n    K = '!'\n    N = len(arr)\n    print(checkhappy(arr, K, N))\n",
        "output": "No\n",
        "fn_call": "checkhappy"
    },
    {
        "text": "find second largest element in an array | set 2 | function to find the largest element in the array arr [ ] ; base condition ; initialize an empty list ; divide the array into two equal length subarrays and recursively find the largest among the two ; store length of compared1 [ ] in the first index ; store the maximum element ; return compared1 which contains the maximum element ; store length of compared2 [ ] in the first index ; store the maximum element ; return compared2 [ ] which contains the maximum element ; function to print the second largest element in the array arr [ ] ; find the largest element in arr [ ] ; find the second largest element in arr [ ] ; print the second largest element ; ",
        "context": "",
        "code": "def findLargest(beg, end, arr, n):\n    if (beg == end):\n        compared = [0] * n\n        compared[0] = 1\n        compared[1] = arr[beg]\n        return compared\n    compared1 = findLargest(beg, (beg + end) // 2, arr, n)\n    compared2 = findLargest((beg + end) // 2 + 1, end, arr, n)\n    if (compared1[1] > compared2[1]):\n        k = compared1[0] + 1\n        compared1[0] = k\n        compared1[k] = compared2[1]\n        return compared1\n    else:\n        k = compared2[0] + 1\n        compared2[0] = k\n        compared2[k] = compared1[1]\n        return compared2\n\n\ndef findSecondLargest(end, arr):\n    compared1 = findLargest(0, end - 1, arr, end)\n    compared2 = findLargest(2, compared1[0] + 2, compared1, compared1[0])\n    print(compared2[1])\n",
        "test": "\nN = 10\narr = [20, 1990, 12, 1110, 1, 59, 12, 15, 120, 1110]\nfindSecondLargest(N, arr)\n",
        "output": "1110\n",
        "fn_call": "findSecondLargest"
    },
    {
        "text": "find position of non | function to find the count of placing non - attacking rooks on the n x n chessboard ; count of the non - attacking rooks ; printing lexographically smallest configuration ; ",
        "context": "",
        "code": "def findCountRooks(row, col, n, k):\n    res = n - k\n    print(res)\n    ri = 0\n    ci = 0\n    while (res > 0):\n        while (ri < k and row[ri] == 1):\n            ri += 1\n        while (ci < k and col[ci] == 1):\n            ci += 1\n        print((ri + 1), \"\", (ci + 1))\n        ri += 1\n        ci += 1\n        res -= 1\n",
        "test": "\nn = 4\nk = 2\nrow = [1, 2]\ncol = [4, 2]\nfindCountRooks(row, col, n, k)\n",
        "output": "2\n2  1\n3  2\n",
        "fn_call": "findCountRooks"
    },
    {
        "text": "check if n can be represented as sum of integers chosen from set { a , b } | function to find if number n can be represented as sum of a ' s \u2581 and \u2581 b ' s ; base condition ; if x is already visited ; set x as possible ; recursive call ; ",
        "context": "",
        "code": "def checkIfPossibleRec(x, a, b, isPossible, n):\n    if x > n:\n        return\n    if isPossible[x]:\n        return\n    isPossible[x] = True\n    checkIfPossibleRec(x + a, a, b, isPossible, n)\n    checkIfPossibleRec(x + b, a, b, isPossible, n)\n\n\ndef checkPossible(n, a, b):\n    isPossible = [False] * (n + 1)\n    checkIfPossibleRec(0, a, b, isPossible, n)\n    return isPossible[n]\n",
        "test": "\nif __name__ == \"__main__\":\n    a, b, n = 3, 7, 8\n    if checkPossible(a, b, n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "checkPossible"
    },
    {
        "text": "number of alternating substrings from a given binary string | function to count number of alternating substrings from a given binary string ; initialize dp array , where dp [ i ] [ j ] stores the number of alternating strings starts with i and having j elements . ; traverse the string from the end ; if i is equal to n - 1 ; otherwise , ; increment count of substrings starting at i and has 0 in the beginning ; increment count of substrings starting at i and has 1 in the beginning ; stores the result ; iterate in the range [ 0 , n - 1 ] ; update ans ; return the ans ; ",
        "context": "",
        "code": "def countAlternatingSubstrings(S, N):\n    dp = [[0 for i in range(N)]for i in range(2)]\n    for i in range(N - 1, -1, -1):\n        if (i == N - 1):\n            if (S[i] == '1'):\n                dp[1][i] = 1\n            else:\n                dp[0][i] = 1\n        else:\n            if (S[i] == '0'):\n                dp[0][i] = 1 + dp[1][i + 1]\n            else:\n                dp[1][i] = 1 + dp[0][i + 1]\n    ans = 0\n    for i in range(N):\n        ans += max(dp[0][i], dp[1][i])\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    S = \"0010\"\n    N = len(S)\n    print(countAlternatingSubstrings(S, N))\n",
        "output": "7\n",
        "fn_call": "countAlternatingSubstrings"
    },
    {
        "text": "compute sum of digits in all numbers from 1 to n | returns sum of all digits in numbers from 1 to n ; initialize result ; one by one compute sum of digits in every number from 1 to n ; a utility function to compute sum of digits in a given number x ; ",
        "context": "",
        "code": "def sumOfDigits(x):\n    sum = 0\n    while (x != 0):\n        sum = sum + x % 10\n        x = x // 10\n    return sum\n\n\ndef sumOfDigitsFrom1ToN(n):\n    result = 0\n    for x in range(1, n + 1):\n        result = result + sumOfDigits(x)\n    return result\n",
        "test": "\nn = 328\nprint(\"Sum of digits in numbers from 1 to\", n, \"is\", sumOfDigitsFrom1ToN(n))\n",
        "output": "Sum of digits in numbers from 1 to 328 is 3241\n",
        "fn_call": "sumOfDigitsFrom1ToN"
    },
    {
        "text": "find all combinations that add upto given number | arr - array to store the combination index - next location in array num - given number reducednum - reduced number ; base condition ; if combination is found , print it ; find the previous number stored in arr [ ] . it helps in maintaining increasing order ; note loop starts from previous number i . e . at array location index - 1 ; next element of array is k ; call recursively with reduced number ; function to find out all combinations of positive numbers that add upto given number . it uses findcombinationsutil ( ) ; array to store the combinations it can contain max n elements ; find all combinations ; ",
        "context": "",
        "code": "def findCombinationsUtil(arr, index, num, reducedNum):\n    if (reducedNum < 0):\n        return\n    if (reducedNum == 0):\n        for i in range(index):\n            print(arr[i], end=\" \")\n        print(\"\")\n        return\n    prev = 1 if (index == 0)else arr[index - 1]\n    for k in range(prev, num + 1):\n        arr[index] = k\n        findCombinationsUtil(arr, index + 1, num, reducedNum - k)\n\n\ndef findCombinations(n):\n    arr = [0] * n\n    findCombinationsUtil(arr, 0, n, n)\n",
        "test": "\nn = 5\nfindCombinations(n)\n",
        "output": "1 1 1 1 1 \n1 1 1 2 \n1 1 3 \n1 2 2 \n1 4 \n2 3 \n5 \n",
        "fn_call": "findCombinations"
    },
    {
        "text": "Check if sums of i | Python3 program to check the if sum of a row is same as corresponding column ; Function to check the if sum of a row is same as corresponding column ; number of rows ; number of columns",
        "context": "\nMAX = 100\n\n",
        "code": "def areSumSame(a, n, m):\n    sum1 = 0\n    sum2 = 0\n    for i in range(0, n):\n        sum1 = 0\n        sum2 = 0\n        for j in range(0, m):\n            sum1 += a[i][j]\n            sum2 += a[j][i]\n        if (sum1 == sum2):\n            return 1\n    return 0\n",
        "test": "\nn = 4\nm = 4\nM = [[1, 2, 3, 4], [9, 5, 3, 1], [0, 3, 5, 6], [0, 4, 5, 6]]\nprint(areSumSame(M, n, m))\n",
        "output": "1\n",
        "fn_call": "areSumSame"
    },
    {
        "text": "probability that an arbitrary positive divisor of 10 ^ x is an integral multiple of 10 ^ y | python3 program to find the probability of an arbitrary positive divisor of xth power of 10 to be a multiple of yth power of 10 ; function to calculate and print the required probability ; count of potential divisors of x - th power of 10 which are also multiples of y - th power of 10 ; count of divisors of x - th power of 10 ; calculate gcd ; print the reduced fraction probability ; ",
        "context": "\nfrom math import *\n\n",
        "code": "def prob(x, y):\n    num = abs(x - y + 1) * abs(x - y + 1)\n    den = (x + 1) * (x + 1)\n    gcd1 = gcd(num, den)\n    print(num // gcd1, end=\"\")\n    print(\"/\", end=\"\")\n    print(den // gcd1)\n",
        "test": "\nif __name__ == '__main__':\n    X = 2\n    Y = 1\n    prob(X, Y)\n",
        "output": "4/9\n",
        "fn_call": "prob"
    },
    {
        "text": "find a rotation with maximum hamming distance | return the maximum hamming distance of a rotation ; arr [ ] to brr [ ] two times so that we can traverse through all rotations . ; we know hamming distance with 0 rotation would be 0. ; we try other rotations one by one and compute hamming distance of every rotation ; we can never get more than n . ; ",
        "context": "",
        "code": "def maxHamming(arr, n):\n    brr = [0] * (2 * n + 1)\n    for i in range(n):\n        brr[i] = arr[i]\n    for i in range(n):\n        brr[n + i] = arr[i]\n    maxHam = 0\n    for i in range(1, n):\n        currHam = 0\n        k = 0\n        for j in range(i, i + n):\n            if brr[j] != arr[k]:\n                currHam += 1\n                k = k + 1\n        if currHam == n:\n            return n\n        maxHam = max(maxHam, currHam)\n    return maxHam\n",
        "test": "\narr = [2, 4, 6, 8]\nn = len(arr)\nprint(maxHamming(arr, n))\n",
        "output": "4\n",
        "fn_call": "maxHamming"
    },
    {
        "text": "find the largest number smaller than integer n with maximum number of set bits | function to return the largest number less than n ; iterate through all the numbers ; find the number of set bits for the current number ; check if this number has the highest set bits ; return the result ; ",
        "context": "",
        "code": "def largestNum(n):\n    num = 0\n    max_setBits = 0\n    for i in range(n + 1):\n        setBits = bin(i).count('1')\n        if (setBits >= max_setBits):\n            num = i\n            max_setBits = setBits\n    return num\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 345\n    print(largestNum(N))\n",
        "output": "255\n",
        "fn_call": "largestNum"
    },
    {
        "text": "minimum swaps to balance the given brackets at any index | function to balance the given bracket by swap ; to count the number of uunbalanced pairs ; if there is an opening bracket and we encounter closing bracket then it will decrement the count of unbalanced bracket . ; else it will increment unbalanced pair count ; ",
        "context": "",
        "code": "def BalancedStringBySwapping(s):\n    unbalancedPair = 0\n    for i in range(len(s)):\n        if (unbalancedPair > 0 and s[i] == ']'):\n            unbalancedPair -= 1\n        elif (s[i] == '['):\n            unbalancedPair += 1\n    return (unbalancedPair + 1) // 2\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"]]][[[\"\n    print(BalancedStringBySwapping(s))\n",
        "output": "2\n",
        "fn_call": "BalancedStringBySwapping"
    },
    {
        "text": "print first k digits of 1 / n where n is a positive integer | python code to print first k digits of 1 / n where n is a positive integer ; function to print first k digits after dot in value of 1 / n . n is assumed to be a positive integer . ; initialize remainder ; run a loop k times to print k digits ; the next digit can always be obtained as doing ( 10 * rem ) / 10 ; update remainder ; ",
        "context": "\nimport math\n\n",
        "code": "def Print(n, k):\n    rem = 1\n    for i in range(0, k):\n        print(math .floor(((10 * rem) / n)), end=\"\")\n        rem = (10 * rem) % n\n",
        "test": "\nn = 7\nk = 3\nPrint(n, k)\nprint(\" \")\nn = 21\nk = 4\nPrint(n, k)\n",
        "output": "142 \n0476",
        "fn_call": "Print"
    },
    {
        "text": "count number of digits after decimal on dividing a number | python3 program to count digits after dot when a number is divided by another . ; ans = 0 initialize result ; calculating remainder ; if this remainder appeared before then the numbers are irrational and would not converge to a solution the digits after decimal will be infinite ; ",
        "context": "",
        "code": "def count(x, y):\n    ans = 0\n    m = dict()\n    while x % y != 0:\n        x %= y\n        ans += 1\n        if x in m:\n            return -1\n        m[x] = 1\n        x *= 10\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    res = count(1, 2)\n    print(\"INF\")if res == -1 else print(res)\n    res = count(5, 3)\n    print(\"INF\")if res == -1 else print(res)\n    res = count(3, 5)\n    print(\"INF\")if res == -1 else print(res)\n",
        "output": "1\nINF\n1\n",
        "fn_call": "count"
    },
    {
        "text": "queries to update array by adding or multiplying array elements and print the element present at specified index | function to modify the array by performing given queries ; stores the multiplication of all integers of type 1 ; stores the value obtained after performing queries of type 1 & 2 ; iterate over the queries ; query of type 0 ; update the value of add ; query of type 1 ; update the value of mul ; update the value of add ; otherwise ; store the element at index q [ i ] [ 1 ] ; prthe result for the current query ; ",
        "context": "",
        "code": "def Query(arr, N, Q):\n    mul = 1\n    add = 0\n    for i in range(len(Q)):\n        if (Q[i][0] == 0):\n            add = add + Q[i][1]\n        elif (Q[i][0] == 1):\n            mul = mul * Q[i][1]\n            add = add * Q[i][1]\n        else:\n            ans = arr[Q[i][1]] * mul + add\n            print(ans, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 1, 23, 45, 100]\n    N = len(arr)\n    Q = [[1, 2], [0, 10], [2, 3], [1, 5], [2, 4]]\n    Query(arr, N, Q)\n",
        "output": "100 1050 ",
        "fn_call": "Query"
    },
    {
        "text": "max occurring divisor in an interval | function to find max occurring divisor interval [ x , y ] ; if there is only one number in the in the interval , return that number ; otherwise , 2 is max occurring divisor ; ",
        "context": "",
        "code": "def findDivisor(x, y):\n    if (x == y):\n        return y\n    return 2\n",
        "test": "\nx = 3\ny = 16\nprint(findDivisor(x, y))\n",
        "output": "2\n",
        "fn_call": "findDivisor"
    },
    {
        "text": "program to calculate length of diagonal of a square | python3 program for the above approach ; function to find the length of the diagonal of a square of a given side ; ",
        "context": "\nimport math\n\n",
        "code": "def findDiagonal(s):\n    return math .sqrt(2) * s\n",
        "test": "\nif __name__ == \"__main__\":\n    S = 10\n    print(findDiagonal(S))\n",
        "output": "14.142135623730951\n",
        "fn_call": "findDiagonal"
    },
    {
        "text": "evil number | returns number of 1 s from the binary number ; counting 1 s ; check if number is evil or not ; converting n to binary form ; calculating remainder storing the remainders in binary form as a number ; calling the count_one function to count and return number of 1 s in bin ; ",
        "context": "",
        "code": "def count_one(n):\n    c_one = 0\n    while n != 0:\n        rem = n % 10\n        if rem == 1:\n            c_one = c_one + 1\n        n = n / 10\n    return c_one\n\n\ndef checkEvil(n):\n    i = 0\n    binary = 0\n    while n != 0:\n        r = n % 2\n        binary = binary + r * (int(10 ** i))\n        n = n / 2\n    n_one = count_one(binary)\n    if n_one % 2 == 0:\n        return True\n    return False\n",
        "test": "\nnum = 32\ncheck = checkEvil(num)\nif check:\n    print(num, \"is Evil Number\")\nelse:\n    print(num, \"is Odious Number\")\n",
        "output": "32 is Evil Number\n",
        "fn_call": "checkEvil"
    },
    {
        "text": "find the batting average of a batsman | function to find the average of a batsman ; calculate number of dismissals ; check for 0 times out ; calculate batting average ; ",
        "context": "",
        "code": "def averageRuns(runs, matches, notout):\n    out = matches - notout\n    if (out == 0):\n        return -1\n    avg = runs // out\n    return avg\n",
        "test": "\nruns = 10000\nmatches = 250\nnotout = 50\navg = averageRuns(runs, matches, notout)\nif (avg == -1):\n    print(\"NA\")\nelse:\n    print(avg)\n",
        "output": "50\n",
        "fn_call": "averageRuns"
    },
    {
        "text": "radius of the inscribed circle within three tangent circles | python3 implementation of the approach ; radius of the 3 ",
        "context": "\nimport math\nr1 = 0\nr2 = 0\nr3 = 0\n\n",
        "code": "def area(a, b, c):\n    p = (a + b + c) / 2\n    return ((math .sqrt(p)) * (math .sqrt(p - a)) *\n            (math .sqrt(p - b)) * (math .sqrt(p - c)))\n\n\ndef binary_search():\n    global r1, r2, r3\n    s = area(r1 + r2, r2 + r3, r3 + r1)\n    l = 0\n    h = s / (r1 + r2 + r3)\n    while (h - l > 0.00000001):\n        mid = (l + h) / 2\n        s1 = area(mid + r1, mid + r2, r1 + r2)\n        s2 = area(mid + r1, mid + r3, r1 + r3)\n        s3 = area(mid + r2, mid + r3, r2 + r3)\n        if (s1 + s2 + s3 < s):\n            l = mid\n        else:\n            h = mid\n    return ((l + h) / 2)\n",
        "test": "\nr1 = 1\nr2 = 2\nr3 = 3\nprint(\"{0:.6f}\".format(binary_search()))\n",
        "output": "0.260870\n",
        "fn_call": "binary_search"
    },
    {
        "text": "queries to count the number of unordered co | python3 program to find number of unordered coprime pairs of integers from 1 to n ; to store euler 's totient function ; to store required answer ; computes and prints totient of all numbers smaller than or equal to n . ; initialise the phi [ ] with 1 ; compute other phi values ; if phi [ p ] is not computed already , then number p is prime ; phi of a prime number p is always equal to p - 1. ; update phi values of all multiples of p ; add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; function to compute number coprime pairs ; function call to compute euler totient function ; prefix sum of all euler totient function values ; ",
        "context": "\nN = 100005\nphi = [0] * N\nS = [0] * N\n\n",
        "code": "def computeTotient():\n    for i in range(1, N):\n        phi[i] = i\n    for p in range(2, N):\n        if (phi[p] == p):\n            phi[p] = p - 1\n            for i in range(2 * p, N, p):\n                phi[i] = (phi[i] // p) * (p - 1)\n\n\ndef CoPrimes():\n    computeTotient()\n    for i in range(1, N):\n        S[i] = S[i - 1] + phi[i]\n",
        "test": "\nif __name__ == \"__main__\":\n    CoPrimes()\n    q = [3, 4]\n    n = len(q)\n    for i in range(n):\n        print(\"Numberofunorderedcoprime\" +\n              \"pairsofintegersfrom1to\",  q[i],  \"are\", S[q[i]])\n",
        "output": "Numberofunorderedcoprimepairsofintegersfrom1to 3 are 4\nNumberofunorderedcoprimepairsofintegersfrom1to 4 are 6\n",
        "fn_call": "CoPrimes"
    },
    {
        "text": "count array elements having modular inverse under given prime number p equal to itself | function to get the count of elements that satisfy the given condition . ; stores count of elements that satisfy the condition ; traverse the given array . ; if square of current element is equal to 1 ; ",
        "context": "",
        "code": "def equvInverse(arr, N, P):\n    cntElem = 0\n    for i in range(0, N):\n        if ((arr[i] * arr[i]) % P == 1):\n            cntElem = cntElem + 1\n    return cntElem\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 6, 4, 5]\n    N = len(arr)\n    P = 7\n    print(equvInverse(arr, N, P))\n",
        "output": "2\n",
        "fn_call": "equvInverse"
    },
    {
        "text": "find the next perfect square greater than a given number | python3 implementation of above approach ; function to find the next perfect square ; ",
        "context": "\nimport math\n\n",
        "code": "def nextPerfectSquare(N):\n    nextN = math .floor(math .sqrt(N)) + 1\n    return nextN * nextN\n",
        "test": "\nif __name__ == '__main__':\n    N = 35\n    print(nextPerfectSquare(N))\n",
        "output": "36\n",
        "fn_call": "nextPerfectSquare"
    },
    {
        "text": "count all numbers up to n having m as the last digit | function to count the numbers ending with m ; stores the count of numbers required ; calculate count upto nearest power of 10 ; computing the value of x ; adding the count of numbers ending at m from x to n ; ",
        "context": "",
        "code": "def getCount(N, M):\n    total_count = 0\n    total_count += N // 10\n    x = (N // 10) * 10\n    if ((N - x) >= M):\n        total_count = total_count + 1\n    return total_count\n",
        "test": "\nN = 100\nM = 1\nprint(getCount(N, M))\n",
        "output": "10\n",
        "fn_call": "getCount"
    },
    {
        "text": "longest subsequence with a given and value | o ( n ) | function to return the required length ; to store the filtered numbers ; filtering the numbers ; if there are no elements to check ; find the or of all the filtered elements ; check if the or is equal to m ; ",
        "context": "",
        "code": "def findLen(arr, n, m):\n    filter = []\n    for i in range(n):\n        if ((arr[i] & m) == m):\n            filter .append(arr[i])\n    if (len(filter) == 0):\n        return 0\n    c_and = filter[0]\n    for i in range(1, len(filter)):\n        c_and &= filter[i]\n    if (c_and == m):\n        return len(filter)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [7, 3, 3, 1, 3]\n    n = len(arr)\n    m = 3\n    print(findLen(arr, n, m))\n",
        "output": "4\n",
        "fn_call": "findLen"
    },
    {
        "text": "sum of all elements up to nth row in a pascal triangle | function to find sum of all elements upto nth row . ; initialize sum with 0 ; calculate 2 ^ n ; ",
        "context": "",
        "code": "def calculateSum(n):\n    sum = 0\n    sum = 1 << n\n    return (sum - 1)\n",
        "test": "\nn = 10\nprint(\"Sum of all elements:\", calculateSum(n))\n",
        "output": "Sum of all elements: 1023\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "check if all leaves are at same level | a binary tree node ; recursive function which check whether all leaves are at same level ; base case ; if a tree node is encountered ; when a leaf node is found first time ; set first leaf found ; if this is not first leaf node , compare its level with first leaf 's level ; if this is not first leaf node , compare its level with first leaf 's level ; the ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def checkUtil(root, level):\n    if root is None:\n        return True\n    if root .left is None and root .right is None:\n        if check .leafLevel == 0:\n            check .leafLevel = level\n            return True\n        return level == check .leafLevel\n    return (\n        checkUtil(\n            root .left,\n            level +\n            1) and checkUtil(\n            root .right,\n            level +\n            1))\n\n\ndef check(root):\n    level = 0\n    check .leafLevel = 0\n    return (checkUtil(root, level))\n",
        "test": "\n\nroot = Node(12)\nroot .left = Node(5)\nroot .left .left = Node(3)\nroot .left .right = Node(9)\nroot .left .left .left = Node(1)\nroot .left .right .left = Node(2)\nif (check(root)):\n    print(\"Leaves are at same level\")\nelse:\n    print(\"Leaves are not at same level\")\n",
        "output": "Leaves are at same level\n",
        "fn_call": "check"
    },
    {
        "text": "sort a string according to the frequency of characters | returns count of character in the string ; check for vowel ; function to sort the string according to the frequency ; vector to store the frequency of characters with respective character ; inserting frequency with respective character in the vector pair ; sort the vector , this will sort the pair according to the number of characters ; print the sorted vector content ; ",
        "context": "",
        "code": "def countFrequency(string, ch):\n    count = 0\n    for i in range(len(string)):\n        if (string[i] == ch):\n            count += 1\n    return count\n\n\ndef sortArr(string):\n    n = len(string)\n    vp = []\n    for i in range(n):\n        vp .append((countFrequency(string, string[i]), string[i]))\n    vp .sort()\n    for i in range(len(vp)):\n        print(vp[i][1], end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    sortArr(string)\n",
        "output": "forggkksseeee",
        "fn_call": "sortArr"
    },
    {
        "text": "check whether k | python3 code to check if k - th bit of a given number is set or not ; ",
        "context": "",
        "code": "def isKthBitSet(n, k):\n    if n & (1 << (k - 1)):\n        print(\"SET\")\n    else:\n        print(\"NOT SET\")\n",
        "test": "\nn = 5\nk = 1\nisKthBitSet(n, k)\n",
        "output": "SET\n",
        "fn_call": "isKthBitSet"
    },
    {
        "text": "maximize the number n by inserting given digit at any position | function to find the maximum value of n after inserting the digit k ; convert it into n to string ; stores the maximum value of n after inserting k ; iterate till all digits that are not less than k ; add the current digit to the string result ; add digit ' k ' to result ; iterate through all remaining characters ; add current digit to result ; print the maximum number formed ; ",
        "context": "",
        "code": "def maximizeNumber(N, K):\n    s = str(N)\n    L = len(s)\n    result = \"\"\n    i = 0\n    while ((i < L) and (K <= (ord(s[i]) - ord('0')))):\n        result += (s[i])\n        i += 1\n    result += (chr(K + ord('0')))\n    while (i < L):\n        result += (s[i])\n        i += 1\n    print(result)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6673\n    K = 6\n    maximizeNumber(N, K)\n",
        "output": "66763\n",
        "fn_call": "maximizeNumber"
    },
    {
        "text": "count sequences of positive integers having product x | python3 program for the above approach ; function to prthe total number of possible sequences with product x ; precomputation of binomial coefficients ; max length of a subsequence ; ways dp array ; fill i slots using all the primes ; subtract ways for all slots that exactly fill less than i slots ; total possible sequences ; print the resultant count ; ",
        "context": "\nbin = [[0 for i in range(3000)]for i in range(3000)]\n\n",
        "code": "def countWays(arr):\n    mod = 10 ** 9 + 7\n    bin[0][0] = 1\n    for i in range(1, 3000):\n        bin[i][0] = 1\n        for j in range(1, i + 1):\n            bin[i][j] = (bin[i - 1][j] + bin[i - 1][j - 1]) % mod\n    n = 0\n    for x in arr:\n        n += x\n    ways = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ways[i] = 1\n        for j in range(len(arr)):\n            ways[i] = (ways[i] * bin[arr[j] + i - 1][i - 1]) % mod\n        for j in range(1, i):\n            ways[i] = ((ways[i] - bin[i][j] * ways[j]) % mod + mod) % mod\n    ans = 0\n    for x in ways:\n        ans = (ans + x) % mod\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1]\n    countWays(arr)\n",
        "output": "3\n",
        "fn_call": "countWays"
    },
    {
        "text": "count of distinct numbers formed by shuffling the digits of a large number n | recursive function to return the value of ( x ^ n ) % m ; base case ; if n is even ; else n is odd ; function to find modular inverse of a number x under modulo m ; using fermat 's little theorem ; function to count of numbers formed by shuffling the digits of a large number n ; modulo value ; array to store the factorials upto the maximum value of n ; store factorial of i at index i ; to store count of occurrence of a digit ; increment the count of digit occured ; assign the factorial of length of input ; multiplying result with the modulo multiplicative inverse of factorial of count of i ; print the result ; ",
        "context": "",
        "code": "def modexp(x, n, m):\n    if (n == 0):\n        return 1\n    else:\n        if (n % 2 == 0):\n            return modexp((x * x) % m, n / 2, m)\n        else:\n            return (x * modexp((x * x) % m, (n - 1) / 2, m) % m)\n\n\ndef modInverse(x, m):\n    return modexp(x, m - 2, m)\n\n\ndef countNumbers(N):\n    m = 1000000007\n    factorial = [0 for x in range(100001)]\n    factorial[0] = 1\n    for i in range(1, 100001):\n        factorial[i] = (factorial[i - 1] * i) % m\n    count = [0 for x in range(10)]\n    for i in range(0, 10):\n        count[i] = 0\n    length = len(N)\n    for i in range(0, length):\n        count[int(N[i])] += 1\n    result = factorial[int(length)]\n    for i in range(0, 10):\n        result = (result * modInverse(factorial[int(count[i])], m)) % m\n    print(result)\n",
        "test": "\nN = \"0223\"\ncountNumbers(N)\n",
        "output": "12\n",
        "fn_call": "countNumbers"
    },
    {
        "text": "euler 's totient function for all numbers smaller than or equal to n | python program for the above approach ; ",
        "context": "\nimport math\n\n",
        "code": "def Euler_totient_function(n):\n    result = 1\n    for i in range(2, n + 1):\n        c = 0\n        if n % i == 0:\n            while (n % i == 0):\n                c += 1\n                n //= i\n        if (c > 0):\n            power = math .pow(i, c - 1)\n            m = math .pow(i, c - 1) * (i - 1)\n            result *= m\n    if (n > 1):\n        result *= (n - 1)\n    return int(result)\n",
        "test": "\nfor i in range(1, 13):\n    print(\"Euler_totient_function(\", i, \"): \", end=\"\")\n    print(Euler_totient_function(i))\n",
        "output": "Euler_totient_function( 1 ): 1\nEuler_totient_function( 2 ): 1\nEuler_totient_function( 3 ): 2\nEuler_totient_function( 4 ): 2\nEuler_totient_function( 5 ): 4\nEuler_totient_function( 6 ): 2\nEuler_totient_function( 7 ): 6\nEuler_totient_function( 8 ): 4\nEuler_totient_function( 9 ): 6\nEuler_totient_function( 10 ): 4\nEuler_totient_function( 11 ): 10\nEuler_totient_function( 12 ): 4\n",
        "fn_call": "Euler_totient_function"
    },
    {
        "text": "largest number smaller than or equal to n and digits in non | returns the required number ; loop to recursively check the numbers less than or equal to given number ; keep traversing digits from right to left . for every digit check if it is smaller than prev_dig ; we found the required number ; ",
        "context": "",
        "code": "def nondecdigits(n):\n    x = 0\n    for x in range(n, 0, -1):\n        no = x\n        prev_dig = 11\n        flag = True\n        while (no != 0):\n            if (prev_dig < no % 10):\n                flag = False\n                break\n            prev_dig = no % 10\n            no //= 10\n        if (flag):\n            break\n    return x\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 200\n    print(nondecdigits(n))\n",
        "output": "199\n",
        "fn_call": "nondecdigits"
    },
    {
        "text": "maximum value of division of two numbers in an array | function to maximum value of division of two numbers in an array ; traverse through the array ; return the required answer ; ",
        "context": "",
        "code": "def Division(a, n):\n    maxi = -10 ** 9\n    mini = 10 ** 9\n    for i in a:\n        maxi = max(i, maxi)\n        mini = min(i, mini)\n    return maxi // mini\n",
        "test": "\na = [3, 7, 9, 3, 11]\nn = len(a)\nprint(Division(a, n))\n",
        "output": "3\n",
        "fn_call": "Division"
    },
    {
        "text": "find maximum unreachable height using two ladders | function to return the maximum height which can 't be reached ; ",
        "context": "",
        "code": "def maxHeight(h1, h2):\n    return ((h1 * h2) - h1 - h2)\n",
        "test": "\nh1 = 7\nh2 = 5\nprint(max(0, maxHeight(h1, h2)))\n",
        "output": "23\n",
        "fn_call": "maxHeight"
    },
    {
        "text": "remove two consecutive integers from 1 to n to make sum equal to s | function to find the numbers to be removed ; typecast appropriately so that answer is float ; return the obtained result ; convert i to integer ; if i is an integer is 0 then answer is yes ; ",
        "context": "",
        "code": "def findNumber(N, S):\n    i = (((N) * (N + 1)) / 4) - ((S + 1) / 2)\n    return i\n\n\ndef check(N, S):\n    i = findNumber(N, S)\n    integerI = int(i)\n    if (i - integerI == 0):\n        print(\"Yes:\", integerI, \",\", integerI + 1)\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    S = 3\n    check(N, S)\n    N = 5\n    S = 3\n    check(N, S)\n",
        "output": "Yes: 3 , 4\nNo\n",
        "fn_call": "check"
    },
    {
        "text": "absolute distinct count in a sorted array | this function returns number of distinct absolute values among the elements of the array ; set keeps all unique elements ; ",
        "context": "",
        "code": "def distinctCount(arr, n):\n    s = set()\n    for i in range(n):\n        s .add(abs(arr[i]))\n    return len(s)\n",
        "test": "\narr = [-2, -1, 0, 1, 1]\nn = len(arr)\nprint(\"Count of absolute distinct values:\", distinctCount(arr, n))\n",
        "output": "Count of absolute distinct values: 3\n",
        "fn_call": "distinctCount"
    },
    {
        "text": "maximum score possible after performing given operations on an array | memoizing by the use of a table ; function to calculate maximum score ; bse case ; if the same state has already been computed ; sum of array in range ( l , r ) ; if the operation is even - numbered the score is decremented ; exploring all paths , and storing maximum value in dp table to avoid further repetitive recursive calls ; function to find the max score ; prefix sum array ; calculating prefix_sum ; initialising the dp table , - 1 represents the subproblem hasn 't been solved yet ; ",
        "context": "\ndp = [[[-1 for x in range(100)]for y in range(100)]for z in range(100)]\n\n",
        "code": "def MaximumScoreDP(l, r, prefix_sum, num):\n    if (l > r):\n        return 0\n    if (dp[l][r][num] != -1):\n        return dp[l][r][num]\n    current_sum = prefix_sum[r]\n    if (l - 1 >= 0):\n        current_sum -= prefix_sum[l - 1]\n    if (num % 2 == 0):\n        current_sum *= -1\n    dp[l][r][num] = (current_sum +\n                     max(MaximumScoreDP(l +\n                                        1, r, prefix_sum, num +\n                                        1), MaximumScoreDP(l, r -\n                                                           1, prefix_sum, num +\n                                                           1)))\n    return dp[l][r][num]\n\n\ndef findMaxScore(a, n):\n    prefix_sum = [0] * n\n    prefix_sum[0] = a[0]\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i]\n    global dp\n    return MaximumScoreDP(0, n - 1, prefix_sum, 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 6\n    A = [1, 2, 3, 4, 2, 6]\n    print(findMaxScore(A, n))\n",
        "output": "13\n",
        "fn_call": "findMaxScore"
    },
    {
        "text": "lexicographically smallest permutation of first n natural numbers having k perfect indices | function to print the lexicographically smallest permutation with k perfect indices ; iterator to traverse the array ; traverse first k array indices ; traverse remaining indices ; ",
        "context": "",
        "code": "def findPerfectIndex(N, K):\n    i = 0\n    for i in range(K):\n        print((N - K + 1) + i, end=\" \")\n    for i in range(3, N):\n        print(i - K + 1, end=\" \")\n",
        "test": "\nN = 10\nK = 3\nfindPerfectIndex(N, K)\n",
        "output": "8 9 10 1 2 3 4 5 6 7 ",
        "fn_call": "findPerfectIndex"
    },
    {
        "text": "repeated unit divisibility | to find least value of k ; to check n is coprime or not ; to store r ( k ) mod n and 10 ^ k mod n value ; ",
        "context": "",
        "code": "def repUnitValue(n):\n    if (n % 2 == 0 or n % 5 == 0):\n        return 0\n    rem = 1\n    power = 1\n    k = 1\n    while (rem % n != 0):\n        k += 1\n        power = power * 10 % n\n        rem = (rem + power) % n\n    return k\n",
        "test": "\nn = 13\nprint(repUnitValue(n))\n",
        "output": "6\n",
        "fn_call": "repUnitValue"
    },
    {
        "text": "largest square that can be inscribed within a hexagon | function to find the area of the square ; side cannot be negative ; area of the square ; ",
        "context": "",
        "code": "def squareArea(a):\n    if (a < 0):\n        return -1\n    area = (1.268 ** 2) * (a ** 2)\n    return area\n",
        "test": "\na = 6\nprint(squareArea(a))\n",
        "output": "57.88166400000001\n",
        "fn_call": "squareArea"
    },
    {
        "text": "check if the n | return if the nth term is even or odd . ; if a is even ; if b is even ; if b is odd ; if a is odd ; if b is odd ; if b is eve ; ",
        "context": "",
        "code": "def findNature(a, b, n):\n    if (n == 0):\n        return (a & 1)\n    if (n == 1):\n        return (b & 1)\n    if ((a & 1) == 0):\n        if ((b & 1) == 0):\n            return False\n        else:\n            return True if (n % 3 != 0)else False\n    else:\n        if ((b & 1) == 0):\n            return True if ((n - 1) % 3 != 0)else False\n        else:\n            return True if ((n + 1) % 3 != 0)else False\n",
        "test": "\na = 2\nb = 4\nn = 3\nif (findNature(a, b, n)):\n    print(\"Odd\", end=\" \")\nelse:\n    print(\"Even\", end=\" \")\n",
        "output": "Even ",
        "fn_call": "findNature"
    },
    {
        "text": "print indices of pair of array elements required to be removed to split array into 3 equal sum subarrays | function to check if array can be split into three equal sum subarrays by removing two elements ; stores sum of all three subarrays ; sum of left subarray ; sum of middle subarray ; sum of right subarray ; check if sum of subarrays are equal ; print the possible pair ; if no pair exists , print - 1 ; ",
        "context": "",
        "code": "def findSplit(arr, N):\n    for l in range(1, N - 3, 1):\n        for r in range(l + 2, N - 1, 1):\n            lsum = 0\n            rsum = 0\n            msum = 0\n            for i in range(0, l, 1):\n                lsum += arr[i]\n            for i in range(l + 1, r, 1):\n                msum += arr[i]\n            for i in range(r + 1, N, 1):\n                rsum += arr[i]\n            if (lsum == rsum and rsum == msum):\n                print(l, r)\n                return\n    print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 5, 12, 7, 19, 4, 3]\n    N = len(arr)\n    findSplit(arr, N)\n",
        "output": "2 4\n",
        "fn_call": "findSplit"
    },
    {
        "text": "count all distinct pairs of repeating elements from the array for every array element | function to prthe required count of pairs excluding the current element ; store the frequency ; find all the count ; delete the contribution of each element for equal pairs ; print the answer ; ",
        "context": "",
        "code": "def solve(arr, n):\n    mp = {}\n    for i in arr:\n        mp[i] = mp .get(i, 0) + 1\n    cnt = 0\n    for x in mp:\n        cnt += ((mp[x]) * (mp[x] - 1) // 2)\n    ans = [0] * n\n    for i in range(n):\n        ans[i] = cnt - (mp[arr[i]] - 1)\n    for i in ans:\n        print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 1, 2, 1, 2]\n    N = len(arr)\n    solve(arr, N)\n",
        "output": "2 2 3 2 3 ",
        "fn_call": "solve"
    },
    {
        "text": "mean of minimum of all possible k | function to find the value of ncr ; base case ; find ncr recursively ; function to find the expected minimum values of all the subsets of size k ; find the factorials that will be used later ; find the factorials ; total number of subsets ; stores the sum of minimum over all possible subsets ; iterate over all possible minimum ; find the mean over all subsets ; ",
        "context": "",
        "code": "def nCr(n, r, f):\n    if (n < r):\n        return 0\n    return f[n] / (f[r] * f[n - r])\n\n\ndef findMean(N, X):\n    f = [0 for i in range(N + 1)]\n    f[0] = 1\n    for i in range(1, N + 1, 1):\n        f[i] = f[i - 1] * i\n    total = nCr(N, X, f)\n    count = 0\n    for i in range(1, N + 1, 1):\n        count += nCr(N - i, X - 1, f) * i\n    E_X = (count) / (total)\n    print(\"{0:.9f}\".format(E_X))\n    return 0\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    X = 2\n    findMean(N, X)\n",
        "output": "1.333333333\n",
        "fn_call": "findMean"
    },
    {
        "text": "print nodes between two given level numbers of a binary tree | a binary tree node ; given a binary tree , print nodes form level number ' low ' to level number 'high   ; marker node to indicate end of level ; initialize level number ; enqueue the only first level node and marker node for end of level ; print q simple level order traversal loop ; remove the front item from queue ; print q check if end of level is reached ; print a new line and increment level number ; check if marker node was last node in queue or level nubmer is beyond the given upper limit ; enqueue the marker for end of next level ; if this is marker , then we don 't need print it  and enqueue its children ; if level is equal to or greater than given lower level , print it ; enqueue children of non - marker node ; ",
        "context": "\nclass Node:\n    def __init__(self, key):\n        self .key = key\n        self .left = None\n        self .right = None\n\n",
        "code": "def printLevels(root, low, high):\n    Q = []\n    marker = Node(11114)\n    level = 1\n    Q .append(root)\n    Q .append(marker)\n    while (len(Q) > 0):\n        n = Q[0]\n        Q .pop(0)\n        if n == marker:\n            print\n            level += 1\n            if len(Q) == 0 or level > high:\n                break\n            Q .append(marker)\n            continue\n        if level >= low:\n            print(n .key,)\n        if n .left is not None:\n            Q .append(n .left)\n            Q .append(n .right)\n",
        "test": "\nroot = Node(20)\nroot .left = Node(8)\nroot .right = Node(22)\nroot .left .left = Node(4)\nroot .left .right = Node(12)\nroot .left .right .left = Node(10)\nroot .left .right .right = Node(14)\nprint(\"Level Order Traversal between given two levels is\",)\nprintLevels(root, 2, 3)\n",
        "output": "Level Order Traversal between given two levels is\n8\n22\n4\n12\n",
        "fn_call": "printLevels"
    },
    {
        "text": "sum of pairwise products | simple python3 program to find sum of given series . ; ",
        "context": "",
        "code": "def findSum(n):\n    sm = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            sm = sm + i * j\n    return sm\n",
        "test": "\nn = 5\nprint(findSum(n))\n",
        "output": "140\n",
        "fn_call": "findSum"
    },
    {
        "text": "count subsequences 01 in string generated by concatenation of given numeric string k times | function to calculate the number of subsequences of \"01\" ; store count of 0 ' s \u2581 and \u2581 1' s ; count of subsequences without concatenation ; case 1 ; case 2 ; return the total count ; ",
        "context": "",
        "code": "def countSubsequence(S, N, K):\n    C = 0\n    C1 = 0\n    C0 = 0\n    for i in range(0, N):\n        if (S[i] == '1'):\n            C1 += 1\n        elif (S[i] == '0'):\n            C0 += 1\n    B1 = 0\n    for i in range(0, N):\n        if (S[i] == '1'):\n            B1 += 1\n        elif (S[i] == '0'):\n            C = C + (C1 - B1)\n    ans = C * K\n    ans += (C1 * C0 * (((K) * (K - 1)) // 2))\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"230013110087\"\n    K = 2\n    N = len(S)\n    print(countSubsequence(S, N, K))\n",
        "output": "24\n",
        "fn_call": "countSubsequence"
    },
    {
        "text": "minimum number of coins needed to remove all the elements of the array based on given rules | function to calculate minimum number of coins needed ; consider the first element separately , add 1 to the total if it 's of type 1 ; iterate from the second element ; if the current element is of type 2 then any player can remove the element ; second pointer to reach end of type 1 elements ; increment j until arr [ j ] is equal to 1 and j is not out of bounds ; number of type 1 elements in a continious chunk ; from next iteration i pointer will start from index of j ; return the minimum count of coins ; ",
        "context": "",
        "code": "def minimumcoins(arr, N):\n    coins = 0\n    j = 0\n    if (arr[0] == 1):\n        coins += 1\n    for i in range(1, N):\n        if (arr[i] == 2):\n            continue\n        j = i\n        while (j < N and arr[j] == 1):\n            j += 1\n        x = (j - i)\n        coins += x // 3\n        i = j - 1\n    return coins\n",
        "test": "\nN = 8\narr = [1, 2, 1, 1, 2, 1, 1, 1]\nprint(minimumcoins(arr, N))\n",
        "output": "2\n",
        "fn_call": "minimumcoins"
    },
    {
        "text": "sum of minimum element of all subarrays of a sorted array | function to find the sum of minimum of all subarrays ; ",
        "context": "",
        "code": "def findMinSum(arr, n):\n    sum = 0\n    for i in range(0, n):\n        sum += arr[i] * (n - i)\n    return sum\n",
        "test": "\narr = [3, 5, 7, 8]\nn = len(arr)\nprint(findMinSum(arr, n))\n",
        "output": "49\n",
        "fn_call": "findMinSum"
    },
    {
        "text": "find a symmetric matrix of order n that contain integers from 0 to n | function to generate the required matrix ; form cyclic array of elements 1 to n - 1 ; store initial array into final array ; fill the last row and column with 0 's ; swap 0 and the number present at the current indexed row ; also make changes in the last row with the number we swapped ; print the final array ; ",
        "context": "",
        "code": "def solve(n):\n    initial_array = [[0 for i in range(n - 1)]for j in range(n - 1)]\n    final_array = [[0 for i in range(n)]for j in range(n)]\n    for i in range(n - 1):\n        initial_array[0][i] = i + 1\n    for i in range(1, n - 1):\n        for j in range(n - 1):\n            initial_array[i][j] = initial_array[i - 1][(j + 1) % (n - 1)]\n    for i in range(n - 1):\n        for j in range(n - 1):\n            final_array[i][j] = initial_array[i][j]\n    for i in range(n):\n        final_array[i][n - 1] = final_array[n - 1][i] = 0\n    for i in range(n):\n        t0 = final_array[i][i]\n        t1 = final_array[i][n - 1]\n        temp = final_array[i][i]\n        final_array[i][i] = final_array[i][n - 1]\n        final_array[i][n - 1] = temp\n        final_array[n - 1][i] = t0\n    for i in range(n):\n        for j in range(n):\n            print(final_array[i][j], end=\" \")\n        print(\"\", end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    solve(n)\n",
        "output": "0 2 3 4 1 2 0 4 1 3 3 4 0 2 1 4 1 2 0 3 1 3 1 3 0 ",
        "fn_call": "solve"
    },
    {
        "text": "count of substrings having sum equal to their length | python3 program to implement the above approach ; function to count the number of substrings with sum equal to length ; stores the count of substrings ; add character to sum ; add count of substrings to result ; increase count of subarrays ; return count ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def countSubstrings(s, n):\n    count, sum = 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n",
        "test": "\nstr = '112112'\nn = len(str)\nprint(countSubstrings(str, n))\n",
        "output": "6\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "minimize cost to cover floor using tiles of dimensions 1 * 1 and 1 * 2 | function to find the minimum cost of flooring with the given tiles ; store the size of the 2d array ; stores the minimum cost of flooring ; traverse the 2d array row - wise ; if the current character is ' * ' , then skip it ; choose the 1 * 1 tile if j is m - 1 ; if consecutive ' . ' are present , the greedily choose tile with the minimum cost ; otherwise choose the 1 * 1 tile ; print the minimum cost ; ",
        "context": "",
        "code": "def minCost(arr, A, B):\n    n = len(arr)\n    m = len(arr[0])\n    ans = 0\n    for i in range(n):\n        j = 0\n        while j < m:\n            if (arr[i][j] == '*'):\n                j += 1\n                continue\n            if (j == m - 1):\n                ans += A\n            else:\n                if (arr[i][j + 1] == '.'):\n                    ans += min(2 * A, B)\n                    j += 1\n                else:\n                    ans += A\n            j += 1\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [['.', '.', '*'], ['.', '*', '*']]\n    A, B = 2, 10\n    minCost(arr, A, B)\n",
        "output": "6\n",
        "fn_call": "minCost"
    },
    {
        "text": "count ways to split an array into subarrays such that sum of the i | python3 program for the above approach ; function to count ways to split an array into subarrays such that sum of the i - th subarray is divisible by i ; stores the prefix sum of array ; find the prefix sum ; initialize dp [ ] [ ] array ; stores the count of splitting ; iterate over the range [ 0 , n ] ; update the dp table ; if the last index is reached , then add it to the variable ans ; return the possible count of splitting of array into subarrays ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def countOfWays(arr, N):\n    pre = [0] * (N + 1)\n    for i in range(N):\n        pre[i + 1] = pre[i] + arr[i]\n    dp = np .zeros((N + 2, N + 2))\n    dp[1][0] += 1\n    ans = 0\n    for i in range(N):\n        for j in range(N, 0, -1):\n            dp[j + 1][pre[i + 1] % (j + 1)] += dp[j][pre[i + 1] % j]\n            if (i == N - 1):\n                ans += dp[j][pre[i + 1] % j]\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4]\n    N = len(arr)\n    print(countOfWays(arr, N))\n",
        "output": "3.0\n",
        "fn_call": "countOfWays"
    },
    {
        "text": "check if every group of a ' s \u2581 is \u2581 followed \u2581 by \u2581 a \u2581 group \u2581 of \u2581 b ' s of same length | function to match whether there are always n consecutive b ' s \u2581 followed \u2581 by \u2581 n \u2581 consecutive \u2581 a ' s throughout the string ; traverse through the string ; count a 's in current segment ; count b 's in current segment ; if both counts are not same . ; ",
        "context": "",
        "code": "def matchPattern(s):\n    count = 0\n    n = len(s)\n    i = 0\n    while (i < n):\n        while (i < n and s[i] == 'a'):\n            count += 1\n            i = +1\n        while (i < n and s[i] == 'b'):\n            count -= 1\n            i += 1\n        if (count != 0):\n            return False\n    return True\n",
        "test": "\ns = \"bb\"\nif (matchPattern(s)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "matchPattern"
    },
    {
        "text": "kth smallest / largest in a small range unsorted array | python 3 program of kth smallest / largest in a small range unsorted array ; storing counts of elements ; traverse hash array build above until we reach k - th smallest element . ; ",
        "context": "",
        "code": "def kthSmallestLargest(arr, n, k):\n    max_val = arr[0]\n    for i in range(len(arr)):\n        if (arr[i] > max_val):\n            max_val = arr[i]\n    hash = [0 for i in range(max_val + 1)]\n    for i in range(n):\n        hash[arr[i]] += 1\n    count = 0\n    for i in range(max_val + 1):\n        while (hash[i] > 0):\n            count += 1\n            if (count == k):\n                return i\n            hash[i] -= 1\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [11, 6, 2, 9, 4, 3, 16]\n    n = len(arr)\n    k = 3\n    print(\"kth smallest number is:\", kthSmallestLargest(arr, n, k))\n",
        "output": "kth smallest number is: 4\n",
        "fn_call": "kthSmallestLargest"
    },
    {
        "text": "find the largest element in an array generated using the given conditions | function to generate the required array ; stores the array ; base case ; iterate over the indices ; if current index is even ; otherwise ; function to find and return the maximum array element ; if n is 0 ; if n is 1 ; generates the required array ; return maximum element of arr ; ",
        "context": "",
        "code": "def findArray(n):\n    Arr = [0] * (n + 1)\n    Arr[1] = 1\n    for i in range(2, n + 1):\n        if (i % 2 == 0):\n            Arr[i] = Arr[i // 2]\n        else:\n            Arr[i] = (Arr[(i - 1) // 2] + Arr[(i - 1) // 2 + 1])\n    return Arr\n\n\ndef maxElement(n):\n    if (n == 0):\n        return 0\n    if (n == 1):\n        return 1\n    Arr = findArray(n)\n    return max(Arr)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 7\n    print(maxElement(N))\n",
        "output": "3\n",
        "fn_call": "maxElement"
    },
    {
        "text": "find permutation of [ 1 , n ] such that ( arr [ i ] != i + 1 ) and sum of absolute difference between arr [ i ] and ( i + 1 ) is minimum | function to generate the permutation of the first n natural numbers having sum of absolute difference between element and indices as minimum ; initialize array arr [ ] from 1 to n ; swap alternate positions ; check n is greater than 1 and n is odd ; swapping last two positions ; print the permutation ; ",
        "context": "",
        "code": "def findPermutation(N):\n    arr = [i + 1 for i in range(N)]\n    for i in range(1, N, 2):\n        arr[i], arr[i - 1] = arr[i - 1], arr[i]\n    if N % 2 and N > 1:\n        arr[-1], arr[-2] = arr[-2], arr[-1]\n    for i in arr:\n        print(i, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 7\n    findPermutation(N)\n",
        "output": "2 1 4 3 6 7 5 ",
        "fn_call": "findPermutation"
    },
    {
        "text": "find duplicate in an array in o ( n ) and by using o ( 1 ) extra space | function to find duplicate ; find the intersection point of the slow and fast . ; find the \" entrance \" to the cycle . ; ",
        "context": "",
        "code": "def findDuplicate(arr):\n    slow = arr[0]\n    fast = arr[0]\n    while True:\n        slow = arr[slow]\n        fast = arr[arr[fast]]\n        if slow == fast:\n            break\n    ptr1 = arr[0]\n    ptr2 = slow\n    while ptr1 != ptr2:\n        ptr1 = arr[ptr1]\n        ptr2 = arr[ptr2]\n    return ptr1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 3, 2, 1]\n    print(findDuplicate(arr))\n",
        "output": "1\n",
        "fn_call": "findDuplicate"
    },
    {
        "text": "breaking an integer to get maximum product | the main function that returns the max possible product ; n equals to 2 or 3 must be handled explicitly ; keep removing parts of size 3 while n is greater than 4 ; keep multiplying 3 to res ; the last part multiplied by previous parts ; ",
        "context": "",
        "code": "def maxProd(n):\n    if (n == 2 or n == 3):\n        return (n - 1)\n    res = 1\n    while (n > 4):\n        n -= 3\n        res *= 3\n    return (n * res)\n",
        "test": "\nif __name__ == '__main__':\n    print(\"Maximum Product is\", maxProd(45))\n",
        "output": "Maximum Product is 14348907\n",
        "fn_call": "maxProd"
    },
    {
        "text": "find two prime numbers with given sum | generate all prime numbers less than n . ; initialize all entries of boolean array as true . a value in isprime [ i ] will finally be false if i is not a prime , else true bool isprime [ n + 1 ] ; if isprime [ p ] is not changed , then it is a prime ; update all multiples of p ; prints a prime pair with given sum ; generating primes using sieve ; traversing all numbers to find first pair ; ",
        "context": "",
        "code": "def SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while (p * p <= n):\n        if (isPrime[p]):\n            i = p * p\n            while (i <= n):\n                isPrime[i] = False\n                i += p\n        p += 1\n\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if (isPrime[i] and isPrime[n - i]):\n            print(i, (n - i))\n            return\n",
        "test": "\nn = 74\nfindPrimePair(n)\n",
        "output": "3 71\n",
        "fn_call": "findPrimePair"
    },
    {
        "text": "maximize count of indices with same element by pairing rows from given matrices | function to find the maximum defined score ; if all students are assigned ; check if row is not paired yet ; check for all indexes ; if values at current indexes are same increase cursum ; further recursive call ; store the ans for current mask and return ; utility function to find the maximum defined score ; create a mask with all set bits 1 -> row is not paired yet 0 -> row is already paired ; initialise dp array with - 1 ; ",
        "context": "",
        "code": "def maxScoreSum(a, b, row, mask, dp):\n    if (row >= len(a)):\n        return 0\n    if (dp[mask] != -1):\n        return dp[mask]\n    ans = 0\n    for i in range(len(a)):\n        if (mask & (1 << i)):\n            newMask = mask ^ (1 << i)\n            curSum = 0\n            for j in range(len(a[i])):\n                if (a[row][j] == b[i][j]):\n                    curSum += 1\n            ans = max(ans, curSum + maxScoreSum(a, b, row + 1, newMask, dp))\n    dp[mask] = ans\n    return dp[mask]\n\n\ndef maxScoreSumUtil(a, b, N, M):\n    row = 0\n    mask = pow(2, M) - 1\n    dp = [-1] * (mask + 1)\n    return maxScoreSum(a, b, row, mask, dp)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    M = 3\n    a = [[1, 1, 0], [1, 0, 1], [0, 0, 1]]\n    b = [[1, 0, 0], [0, 0, 1], [1, 1, 0]]\n    print(maxScoreSumUtil(a, b, N, M))\n",
        "output": "8\n",
        "fn_call": "maxScoreSumUtil"
    },
    {
        "text": "count tiles of dimensions 2 * 1 that can be placed in an m * n rectangular board that satisfies the given conditions | function to count tiles of dimensions 2 x 1 that can be placed in a grid of dimensions m * n as per given conditions ; number of tiles required ; ",
        "context": "",
        "code": "def numberOfTiles(N, M):\n    if (N % 2 == 1):\n        return -1\n    return (N * M) // 2\n",
        "test": "\nN = 2\nM = 4\nprint(numberOfTiles(N, M))\n",
        "output": "4\n",
        "fn_call": "numberOfTiles"
    },
    {
        "text": "reorder an array according to given indexes | function to reorder elements of arr [ ] according to index [ ] ; arr [ i ] should be present at index [ i ] index ; copy temp [ ] to arr [ ] ; ",
        "context": "",
        "code": "def reorder(arr, index, n):\n    temp = [0] * n\n    for i in range(0, n):\n        temp[index[i]] = arr[i]\n    for i in range(0, n):\n        arr[i] = temp[i]\n        index[i] = i\n",
        "test": "\narr = [50, 40, 70, 60, 90]\nindex = [3, 0, 4, 1, 2]\nn = len(arr)\nreorder(arr, index, n)\nprint(\"Reordered array is:\")\nfor i in range(0, n):\n    print(arr[i], end=\" \")\nprint(\"ModifiedIndexarrayis:\")\nfor i in range(0, n):\n    print(index[i], end=\" \")\n",
        "output": "Reordered array is:\n40 60 90 50 70 ModifiedIndexarrayis:\n0 1 2 3 4 ",
        "fn_call": "reorder"
    },
    {
        "text": "sum of all natural numbers in range l to r | function to return the sum of all natural numbers ; function to return the sum of all numbers in range l and r ; ",
        "context": "",
        "code": "def sumNatural(n):\n    sum = (n * (n + 1)) // 2\n    return sum\n\n\ndef suminRange(l, r):\n    return sumNatural(r) - sumNatural(l - 1)\n",
        "test": "\nl = 2\nr = 5\nprint(\"Sum of Natural numbers from L to R is \", suminRange(l, r))\n",
        "output": "Sum of Natural numbers from L to R is  14\n",
        "fn_call": "suminRange"
    },
    {
        "text": "count ways to split array into k non | function to get the value of pow ( k , m ) ; stores value of pow ( k , m ) ; calculate value of pow ( k , n ) ; if n is odd , update res ; update m to m / 2 ; update k ; function to print total ways to split the array that satisfies the given condition ; stores total ways that satisfies the given condition ; stores count of distinct elements in the given arr ; store distinct elements of the given array ; traverse the given array ; insert current element into set st . ; update m ; update cntways ; ",
        "context": "",
        "code": "def power(K, M):\n    res = 1\n    while (M > 0):\n        if ((M & 1) == 1):\n            res = (res * K)\n        M = M >> 1\n        K = (K * K)\n    return res\n\n\ndef cntWays(arr, N, K):\n    cntways = 0\n    M = 0\n    st = set()\n    for i in range(N):\n        st .add(arr[i])\n    M = len(st)\n    cntways = power(K, M)\n    return cntways\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3]\n    N = len(arr)\n    K = 2\n    print(cntWays(arr, N, K))\n",
        "output": "4\n",
        "fn_call": "cntWays"
    },
    {
        "text": "maximum length substring with highest frequency in a string | function to return maximum occurred substring of a string ; size of string ; to store maximum frequency ; to store string which has maximum frequency ; return substring which has maximum freq ; ",
        "context": "",
        "code": "def MaxFreq(s):\n    n = len(s)\n    m = dict()\n    for i in range(n):\n        string = ''\n        for j in range(i, n):\n            string += s[j]\n            if string in m .keys():\n                m[string] += 1\n            else:\n                m[string] = 1\n    maxi = 0\n    maxi_str = ''\n    for i in m:\n        if m[i] > maxi:\n            maxi = m[i]\n            maxi_str = i\n        elif m[i] == maxi:\n            ss = i\n            if len(ss) > len(maxi_str):\n                maxi_str = ss\n    return maxi_str\n",
        "test": "\nstring = \"ababecdecd\"\nprint(MaxFreq(string))\n",
        "output": "ecd\n",
        "fn_call": "MaxFreq"
    },
    {
        "text": "sum of the series 1 + ( 1 + 3 ) + ( 1 + 3 + 5 ) + ( 1 + 3 + 5 + 7 ) + \u00e2 \u20ac\u00a6 \u00e2 \u20ac\u00a6 + ( 1 + 3 + 5 + 7 + \u00e2 \u20ac\u00a6 + ( 2 n | functionn to find the sum of the given series ; first term of each i - th term ; next term ; required sum ; ",
        "context": "",
        "code": "def sumOfTheSeries(n):\n    sum = 0\n    for i in range(1, n + 1):\n        k = 1\n        for j in range(1, i + 1):\n            sum += k\n            k += 2\n    return sum\n",
        "test": "\nn = 5\nprint(\"Sum =\", sumOfTheSeries(n))\n",
        "output": "Sum = 55\n",
        "fn_call": "sumOfTheSeries"
    },
    {
        "text": "sum of first n natural numbers which are divisible by 2 and 7 | function to calculate the sum of numbers divisible by 2 or 7 ; ",
        "context": "",
        "code": "def sum(N):\n    S1 = ((N // 2)) * (2 * 2 + (N // 2 - 1) * 2) // 2\n    S2 = ((N // 7)) * (2 * 7 + (N // 7 - 1) * 7) // 2\n    S3 = ((N // 14)) * (2 * 14 + (N // 14 - 1) * 14) // 2\n    return S1 + S2 - S3\n",
        "test": "\nif __name__ == '__main__':\n    N = 20\n    print(sum(N))\n",
        "output": "117\n",
        "fn_call": "sum"
    },
    {
        "text": "check if given array is almost sorted ( elements are at | function for checking almost sort ; one by one compare adjacents . ; check whether resultant is sorted or not ; is resultant is sorted return true ; ",
        "context": "",
        "code": "def almostSort(A, n):\n    i = 0\n    while i < n - 1:\n        if A[i] > A[i + 1]:\n            A[i], A[i + 1] = A[i + 1], A[i]\n            i += 1\n        i += 1\n    for i in range(0, n - 1):\n        if A[i] > A[i + 1]:\n            return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 3, 2, 4, 6, 5]\n    n = len(A)\n    if almostSort(A, n):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "almostSort"
    },
    {
        "text": "maximum perimeter of a square in a 2d grid | function to calculate the perfix sum of the rows and the columns of the given matrix ; number of rows and cols ; first column of the row prefix array ; update the prefix sum for the rows ; first row of the column prefix array ; update the prefix sum for the columns ; function to return the perimeter of the square having top - left corner at ( i , j ) and size k ; i and j represent the top left corner of the square and k is the size ; get the upper row sum ; get the left column sum ; at the distance of k in both direction ; the perimeter will be sum of all the values ; since all the corners are included twice , they need to be subtract from the sum ; function to return the maximum perimeter of a square in the given matrix ; number of rows and cols ; function call to calculate the prefix sum of rows and cols ; to store the maximum perimeter ; nested loops to choose the top - left corner of the square ; loop for the size of the square ; get the perimeter of the current square ; update the maximum perimeter so far ; ",
        "context": "",
        "code": "def perfix_calculate(A, row, col):\n    n = len(A)\n    m = len(A[0])\n    for i in range(n):\n        row[i][0] = A[i][0]\n    for i in range(n):\n        for j in range(1, m):\n            row[i][j] = row[i][j - 1] + A[i][j]\n    for i in range(m):\n        col[0][i] = A[0][i]\n    for i in range(m):\n        for j in range(1, m):\n            col[j][i] = A[j][i] + col[j - 1][i]\n\n\ndef perimeter(i, j, k, row, col, A):\n    row_s, col_s = 0, 0\n    if (j == 0):\n        row_s = 0\n    else:\n        row_s = row[i][j - 1]\n    if (i == 0):\n        col_s = 0\n    else:\n        col_s = col[i - 1][j]\n    upper_row = row[i][j + k] - row_s\n    left_col = col[i + k][j] - col_s\n    if (j == 0):\n        row_s = 0\n    else:\n        row_s = row[i + k][j - 1]\n    if (i == 0):\n        col_s = 0\n    else:\n        col_s = col[i - 1][j + k]\n    lower_row = row[i + k][j + k] - row_s\n    right_col = col[i + k][j + k] - col_s\n    sum = upper_row + lower_row + left_col + right_col\n    sum -= (A[i][j] + A[i + k][j] + A[i][j + k] + A[i + k][j + k])\n    return sum\n\n\ndef maxPerimeter(A):\n    n = len(A)\n    m = len(A[0])\n    row = [[0 for i in range(m)]for i in range(n)]\n    col = [[0 for i in range(m)]for i in range(n)]\n    perfix_calculate(A, row, col)\n    maxPer = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(min(n - i, m - j)):\n                perimtr = perimeter(i, j, k, row, col, A)\n                maxPer = max(maxPer, perimtr)\n    return maxPer\n",
        "test": "\nA = [[1, 1, 0], [1, 1, 1], [0, 1, 1]]\nprint(maxPerimeter(A))\n",
        "output": "6\n",
        "fn_call": "maxPerimeter"
    },
    {
        "text": "find if an expression has duplicate parenthesis or not | function to find duplicate parenthesis in a balanced expression ; create a stack of characters ; iterate through the given expression ; if current character is close parenthesis ' ) ' ; pop character from the stack ; stores the number of characters between a closing and opening parenthesis if this count is less than or equal to 1 then the brackets are redundant else not ; push open parenthesis ' ( ' , operators and operands to stack ; no duplicates found ; ",
        "context": "",
        "code": "def findDuplicateparenthesis(string):\n    Stack = []\n    for ch in string:\n        if ch == ')':\n            top = Stack .pop()\n            elementsInside = 0\n            while top != '(':\n                elementsInside += 1\n                top = Stack .pop()\n            if elementsInside < 1:\n                return True\n        else:\n            Stack .append(ch)\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"(((a+(b))+(c+d)))\"\n    if findDuplicateparenthesis(string):\n        print(\"Duplicate Found\")\n    else:\n        print(\"No Duplicates Found\")\n",
        "output": "Duplicate Found\n",
        "fn_call": "findDuplicateparenthesis"
    },
    {
        "text": "sum of all perfect numbers present in an array | function to return the sum of all the proper factors of n ; f is the factor of n ; function to return the required sum ; to store the sum ; if current element is non - zero and equal to the sum of proper factors of itself ; ",
        "context": "",
        "code": "def sumOfFactors(n):\n    sum = 0\n    for f in range(1, n // 2 + 1):\n        if (n % f == 0):\n            sum += f\n    return sum\n\n\ndef getSum(arr, n):\n    sum = 0\n    for i in range(n):\n        if (arr[i] > 0 and arr[i] == sumOfFactors(arr[i])):\n            sum += arr[i]\n    return sum\n",
        "test": "\narr = [17, 6, 10, 6, 4]\nn = len(arr)\nprint(getSum(arr, n))\n",
        "output": "12\n",
        "fn_call": "getSum"
    },
    {
        "text": "count of subsequences which consists exactly k prime numbers | returns factorial of n ; function to return total number of combinations ; function check whether a number is prime or not ; corner case ; check from 2 to n - 1 ; function for finding number of subsequences which consists exactly k primes ; if number of primes are less than k ; ",
        "context": "",
        "code": "def fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\n\n\ndef nCr(n, r):\n    return (fact(n) // (fact(r) * fact(n - r)))\n\n\ndef isPrime(n):\n    if (n <= 1):\n        return False\n    for i in range(2, n):\n        if (n % i == 0):\n            return False\n    return True\n\n\ndef countSubsequences(arr, n, k):\n    countPrime = 0\n    for i in range(n):\n        if (isPrime(arr[i])):\n            countPrime += 1\n    if (countPrime < k):\n        return 0\n    return (nCr(countPrime, k) * pow(2, (n - countPrime)))\n",
        "test": "\narr = [1, 2, 3, 4, 5, 6, 7]\nK = 3\nn = len(arr)\nprint(countSubsequences(arr, n, K))\n",
        "output": "32\n",
        "fn_call": "countSubsequences"
    },
    {
        "text": "lexicographically smallest permutation of the array possible by at most one swap | ''function to print the elements of the array arr[] ; '' traverse the array arr[] ; ''function to convert given array to lexicographically smallest permutation possible by swapping at most one pair ; '' stores the index of the first  element which is not at its  correct position ; '' checks if any such array  element exists or not ; '' traverse the given array ; '' if element is found at i ; '' if the first array is  not in correct position ; '' store the index of  the first elements ; '' store the index of  the first element ; '' swap the pairs ; '' print the array ; ''",
        "context": "",
        "code": "def printt(arr, N):\n    for i in range(N):\n        print(arr[i], end=\" \")\n\n\ndef makeLexicographically(arr, N):\n    index = 0\n    temp = 0\n    check = 0\n    condition = 0\n    element = 0\n    for i in range(N):\n        if (element == arr[i]):\n            check = i\n            break\n        elif (arr[i] != i + 1 and check == 0):\n            index = i\n            check = 1\n            condition = -1\n            element = i + 1\n    if (condition == -1):\n        temp = arr[index]\n        arr[index] = arr[check]\n        arr[check] = temp\n    printt(arr, N)\n",
        "test": "\narr = [1, 2, 3, 4]\nN = len(arr)\nmakeLexicographically(arr, N)\n",
        "output": "1 2 3 4 ",
        "fn_call": "makeLexicographically"
    },
    {
        "text": "efficiently check if a string has all unique characters without using any additional data structure | ",
        "context": "",
        "code": "def unique(s):\n    s = sorted(s)\n    for i in range(len(s) - 1):\n        if (s[i] == s[i + 1]):\n            return False\n            break\n    return True\n",
        "test": "\nif (unique(\"abcdd\")):\n    print(\"String is Unique\")\nelse:\n    print(\"String is not Unique\")\n",
        "output": "String is not Unique\n",
        "fn_call": "unique"
    },
    {
        "text": "number of rectangles in n * m grid | python3 program to count number of rectangles in a n x m grid ; ",
        "context": "",
        "code": "def rectCount(n, m):\n    return (m * n * (n + 1) * (m + 1)) // 4\n",
        "test": "\nn, m = 5, 4\nprint(rectCount(n, m))\n",
        "output": "150\n",
        "fn_call": "rectCount"
    },
    {
        "text": "lexicographic rank of a string | a utility function to find factorial of n ; a utility function to count smaller characters on right of arr [ low ] ; a function to find rank of a string in all permutations of characters ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; ",
        "context": "",
        "code": "def fact(n):\n    f = 1\n    while n >= 1:\n        f = f * n\n        n = n - 1\n    return f\n\n\ndef findSmallerInRight(st, low, high):\n    countRight = 0\n    i = low + 1\n    while i <= high:\n        if st[i] < st[low]:\n            countRight = countRight + 1\n        i = i + 1\n    return countRight\n\n\ndef findRank(st):\n    ln = len(st)\n    mul = fact(ln)\n    rank = 1\n    i = 0\n    while i < ln:\n        mul = mul / (ln - i)\n        countRight = findSmallerInRight(st, i, ln - 1)\n        rank = rank + countRight * mul\n        i = i + 1\n    return rank\n",
        "test": "\nst = \"string\"\nprint(findRank(st))\n",
        "output": "598.0\n",
        "fn_call": "findRank"
    },
    {
        "text": "minimum cost path in a matrix by moving only on value difference of x | python3 implementation to find the minimum number of operations required to move from ( 1 , 1 ) to ( n , m ) ; function to find the minimum operations required to move to bottom - right cell of matrix ; condition to check if the current cell is the bottom - right cell of the matrix ; condition to check if the current cell is out of matrix ; condition to check if the current indices is already computed ; condition to check that the movement with the current value is not possible ; recursive call to compute the number of operation required to compute the value ; function to find the minimum number of operations required to reach the bottom - right cell ; loop to iterate over every possible cell of the matrix ; ",
        "context": "\nMAX = 1e18\nv = [[0, 0]] * (151)\ndp = [[-1 for i in range(151)]for i in range(151)]\n\n",
        "code": "def min_operation(i, j, val, x):\n    if (i == n - 1 and j == m - 1):\n        if (val > v[i][j]):\n            dp[i][j] = MAX\n            return MAX\n        else:\n            dp[i][j] = v[i][j] - val\n            return dp[i][j]\n    if (i == n or j == m):\n        dp[i][j] = MAX\n        return MAX\n    if (dp[i][j] != -1):\n        return dp[i][j]\n    if (val > v[i][j]):\n        dp[i][j] = MAX\n        return MAX\n    tmp = v[i][j] - val\n    tmp += min(min_operation(i + 1, j, val + x, x),\n               min_operation(i, j + 1, val + x, x))\n    dp[i][j] = tmp\n    return tmp\n\n\ndef solve(x):\n    ans = 10 ** 19\n    for i in range(n):\n        for j in range(m):\n            val = v[i][j] - x * (i + j)\n            for ii in range(151):\n                for jj in range(151):\n                    dp[ii][jj] = -1\n            val = min_operation(0, 0, val, x)\n            ans = min(ans, val)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    m = 2\n    x = 3\n    v[0] = [15, 153]\n    v[1] = [135, 17]\n    print(solve(x))\n",
        "output": "125\n",
        "fn_call": "solve"
    },
    {
        "text": "check if x and y elements can be selected from two arrays respectively such that the maximum in x is less than the minimum in y | function to check if it is possible to choose x and y elements from a [ ] and b [ ] such that maximum element among x element is less than minimum element among y elements ; check if there are atleast x elements in arr1 [ ] and atleast y elements in arr2 [ ] ; sort arrays in ascending order ; check if ( x - 1 ) - th element in arr1 [ ] is less than from m - yth element in arr2 [ ] ; return false ; ",
        "context": "",
        "code": "def check(a, b, Na, Nb, k, m):\n    if (Na < k or Nb < m):\n        return \"No\"\n    a .sort()\n    a .sort()\n    if (a[k - 1] < b[Nb - m]):\n        return \"Yes\"\n    return \"No\"\n",
        "test": "\narr1 = [1, 2, 3]\narr2 = [3, 4, 5]\nN = len(arr1)\nM = len(arr2)\nX = 2\nY = 1\nprint(check(arr1, arr2, N, M, X, Y))\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "calculate the sum of gcd over all subarrays | utility function to calculate sum of gcd of all sub - arrays . ; fixing the starting index of a subarray ; fixing the ending index of a subarray ; finding the gcd of this subarray ; adding this gcd in our sum ; ",
        "context": "",
        "code": "def __gcd(a, b):\n    return a if (b == 0)else __gcd(b, a % b)\n\ndef findGCDSum(n, a):\n    GCDSum = 0\n    tempGCD = 0\n    for i in range(n):\n        for j in range(i, n):\n            tempGCD = 0\n            for k in range(i, j + 1):\n                tempGCD = __gcd(tempGCD, a[k])\n            GCDSum += tempGCD\n    return GCDSum\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    a = [1, 2, 3, 4, 5]\n    totalSum = findGCDSum(n, a)\n    print(totalSum)\n",
        "output": "25\n",
        "fn_call": "findGCDSum"
    },
    {
        "text": "fibonacci modulo p | returns position of first fibonacci number whose modulo p is 0. ; add previous two remainders and then take its modulo p . ; ",
        "context": "",
        "code": "def findMinZero(p):\n    first = 1\n    second = 1\n    number = 2\n    next = 1\n    while (next):\n        next = (first + second) % p\n        first = second\n        second = next\n        number = number + 1\n    return number\n",
        "test": "\nif __name__ == '__main__':\n    p = 7\n    print(\"Minimal zero is:\", findMinZero(p))\n",
        "output": "Minimal zero is: 8\n",
        "fn_call": "findMinZero"
    },
    {
        "text": "modify a binary string by flipping characters such that any pair of indices consisting of 1 s are neither co | function to modify a string such that there doesn 't exist any pair of indices consisting of 1s, whose gcd is 1 and are divisible by each other ; flips characters at indices 4 n , 4 n - 2 , 4 n - 4 . ... upto n terms ; print the string ; ",
        "context": "",
        "code": "def findString(S, N):\n    strLen = 4 * N\n    for i in range(1, N + 1):\n        S[strLen - 1] = '1'\n        strLen -= 2\n    for i in range(4 * N):\n        print(S[i], end=\"\")\n",
        "test": "\nN = 2\nS = [0] * (4 * N)\nfor i in range(4 * N):\n    S[i] = '0'\nfindString(S, N)\n",
        "output": "00000101",
        "fn_call": "findString"
    },
    {
        "text": "lexicographically largest subsequence such that every character occurs at least k times | find lexicographically largest subsequence of s [ 0. . n - 1 ] such that every character appears at least k times . the result is filled in t [ ] ; starting from largest charter ' z ' to 'a ; counting the frequency of the character ; if frequency is greater than k ; from the last point we leave ; check if string contain ch ; if yes , append to output string ; update the last point . ; ",
        "context": "",
        "code": "def subsequence(s, t, n, k):\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n\n    for ch in string:\n        cnt = 0\n        for i in range(last, n):\n            if s[i] == ch:\n                cnt += 1\n        if cnt >= k:\n            for i in range(last, n):\n                if s[i] == ch:\n                    t[size] = ch\n                    new_last = i\n                    size += 1\n            last = new_last\n",
        "test": "\nif __name__ == \"__main__\":\n    s = ['b', 'a', 'n', 'a', 'n', 'a']\n    n = len(s)\n    k = 2\n    t = [''] * n\n    subsequence(s, t, n - 1, k)\n    t = ''.join(t)\n    print(t)\n",
        "output": "nn\n",
        "fn_call": "subsequence"
    },
    {
        "text": "k | function to calculate k - th smallest solution ( y ) of equation x + y = x | y ; initialize the variable to store the answer ; the i - th bit of x is off ; the i - bit of k is on ; divide k by 2 ; if k becomes 0 then break ; ",
        "context": "",
        "code": "def KthSolution(X, K):\n    ans = 0\n    for i in range(0, 64):\n        if (not (X & (1 << i))):\n            if (K & 1):\n                ans |= (1 << i)\n            K >>= 1\n            if (not K):\n                break\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    X = 5\n    K = 5\n    print(KthSolution(X, K))\n",
        "output": "18\n",
        "fn_call": "KthSolution"
    },
    {
        "text": "lexicographically all shortest palindromic substrings from a given string | function to find all lexicographically shortest palindromic substring ; array to keep track of alphabetic characters ; iterate to print all lexicographically shortest substring ; ",
        "context": "",
        "code": "def shortestPalindrome(s):\n    abcd = [0] * 26\n    for i in range(len(s)):\n        abcd[ord(s[i]) - 97] = 1\n    for i in range(26):\n        if abcd[i] == 1:\n            print(chr(i + 97), end=' ')\n",
        "test": "\ns = \"geeksforgeeks\"\nshortestPalindrome(s)\n",
        "output": "e f g k o r s ",
        "fn_call": "shortestPalindrome"
    },
    {
        "text": "count of n | function to find the value of x to the power y ; stores the value of x ^ y ; if y is odd , multiply x with result ; update the value of y and x ; return the result ; function to count number of arrays having element over the range [ 0 , 2 ^ k - 1 ] with bitwise and value 0 having maximum possible sum ; print the value of n ^ k ; ",
        "context": "",
        "code": "def power(x, y):\n    res = 1\n    while (y > 0):\n        if (y & 1):\n            res = res * x\n        y = y >> 1\n        x = x * x\n    return res\n\n\ndef countArrays(N, K):\n    print(power(N, K))\n",
        "test": "\nN = 5\nK = 6\ncountArrays(N, K)\n",
        "output": "15625\n",
        "fn_call": "countArrays"
    },
    {
        "text": "count of arrays of size n having absolute difference between adjacent elements at most 1 | function to find the count of possible arrays such that the absolute difference between any adjacent elements is atmost 1 ; stores the dp states where dp [ i ] [ j ] represents count of arrays of length i + 1 having their last element as j ; case where 1 st array element is missing ; all integers in range [ 1 , m ] are reachable ; only reachable integer is arr [ 0 ] ; iterate through all values of i ; if arr [ i ] is not missing ; only valid value of j is arr [ i ] ; if arr [ i ] is missing ; iterate through all possible values of j in range [ 1 , m ] ; stores the count of valid arrays ; calculate the total count of valid arrays ; return answer ; ",
        "context": "",
        "code": "def countArray(arr, N, M):\n    dp = [[0 for i in range(M + 2)]for j in range(N)]\n    if (arr[0] == -1):\n        for j in range(1, M + 1, 1):\n            dp[0][j] = 1\n    else:\n        dp[0][arr[0]] = 1\n    for i in range(1, N, 1):\n        if (arr[i] != -1):\n            j = arr[i]\n            dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]\n        if (arr[i] == -1):\n            for j in range(1, M + 1, 1):\n                dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]\n    arrCount = 0\n    for j in range(1, M + 1, 1):\n        arrCount += dp[N - 1][j]\n    return arrCount\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, -1, 2, 1, -1, -1]\n    N = len(arr)\n    M = 10\n    print(countArray(arr, N, M))\n",
        "output": "5\n",
        "fn_call": "countArray"
    },
    {
        "text": "minimum difference between adjacent elements of array which contain elements from each row of a matrix | return smallest element greater than or equal to the current element . ; return the minimum absolute difference adjacent elements of array ; arr = [ 0 for i in range ( r ) ] [ for j in range ( c ) ] sort each row of the matrix . ; for each matrix element ; search smallest element in the next row which is greater than or equal to the current element ; largest element which is smaller than the current element in the next row must be just before smallest element which is greater than or equal to the current element because rows are sorted . ; ",
        "context": "",
        "code": "def bsearch(low, high, n, arr):\n    mid = (low + high)//2\n\n    if (low <= high):\n        if (arr[mid] < n):\n            return bsearch(mid + 1, high, n, arr)\n        return bsearch(low, mid - 1, n, arr)\n\n    return low\n\n\ndef mindiff(arr, n, m):\n    for i in range(n):\n        sorted(arr)\n\n    ans = 2147483647\n    for i in range(n-1):\n        for j in range(m):\n            p = bsearch(0, m-1, arr[i][j], arr[i + 1])\n            ans = min(ans, abs(arr[i + 1][p] - arr[i][j]))\n            if (p-1 >= 0):\n                ans = min(ans, abs(arr[i + 1][p - 1] - arr[i][j]))\n    return ans\n",
        "test": "\nm = [8, 5], [6, 8]\nprint(mindiff(m, 2, 2))\n",
        "output": "0\n",
        "fn_call": "mindiff"
    },
    {
        "text": "number of words that can be made using exactly p consonants and q vowels from the given string | function to return the value of nck ; function to return the factorial of n ; function that returns true if ch is a vowel ; function to return the number of words possible ; to store the count of vowels and consonanats in the given string ; if current character is a vowel ; find the total possible words ; ",
        "context": "",
        "code": "def binomialCoeff(n, k):\n    if (k == 0 or k == n):\n        return 1\n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k)\n\n\ndef fact(n):\n    if (n >= 1):\n        return n * fact(n - 1)\n    else:\n        return 1\n\n\ndef isVowel(ch):\n    if (ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u'):\n        return True\n    return False\n\n\ndef countWords(s, p, q):\n    countc = 0\n    countv = 0\n    for i in range(len(s)):\n        if (isVowel(s[i])):\n            countv += 1\n        else:\n            countc += 1\n    a = binomialCoeff(countc, p)\n    b = binomialCoeff(countv, q)\n    c = fact(p + q)\n    ans = (a * b) * c\n    return ans\n",
        "test": "\ns = \"crackathon\"\np = 4\nq = 3\nprint(countWords(s, p, q))\n",
        "output": "176400\n",
        "fn_call": "countWords"
    },
    {
        "text": "find one extra character in a string | python3 program to find extra character in one string ; store string values in map ; store second string in map with frequency ; store first string in map with frequency ; if the frequency is 1 then this character is which is added extra ; ",
        "context": "",
        "code": "def findExtraCharacter(strA, strB):\n    m1 = {}\n    for i in strB:\n        if i in m1:\n            m1[i] += 1\n        else:\n            m1[i] = 1\n    for i in strA:\n        m1[i] -= 1\n    for h1 in m1:\n        if m1[h1] == 1:\n            return h1\n",
        "test": "\nif __name__ == \"__main__\":\n    strA = 'abcd'\n    strB = 'cbdad'\n    print(findExtraCharacter(strA, strB))\n",
        "output": "d\n",
        "fn_call": "findExtraCharacter"
    },
    {
        "text": "count number of pairs with positive sum in an array | returns number of pairs in arr [ 0. . n - 1 ] with positive sum ; initialize result ; consider all possible pairs and check their sums ; if arr [ i ] & arr [ j ] form valid pair ; ",
        "context": "",
        "code": "def CountPairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] + arr[j] > 0):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [-7, -1, 3, 2]\n    n = len(arr)\n    print(CountPairs(arr, n))\n",
        "output": "3\n",
        "fn_call": "CountPairs"
    },
    {
        "text": "generate an array of minimum sum whose xor of same | function to generate an array whose xor with same - indexed elements of the given array is always a prime ; traverse the array ; if current array element is 2 ; print its xor with 3 ; otherwise ; print its xor with 2 ; ",
        "context": "",
        "code": "def minXOR(Arr, N):\n    for i in range(N):\n        if (Arr[i] == 2):\n            print(Arr[i] ^ 3, end=\" \")\n        else:\n            print(Arr[i] ^ 2, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    Arr = [5, 4, 7, 6]\n    N = len(Arr)\n    minXOR(Arr, N)\n",
        "output": "7 6 5 4 ",
        "fn_call": "minXOR"
    },
    {
        "text": "minimum flip required to make binary matrix symmetric | python3 code to find minimum flip required to make binary matrix symmetric along main diagonal ; return the minimum flip required to make binary matrix symmetric along main diagonal . ; finding the transpose of the matrix ; finding the number of position where element are not same . ; ",
        "context": "\nN = 3\n\n",
        "code": "def minimumflip(mat, n):\n    transpose = [[0] * n] * n\n    for i in range(n):\n        for j in range(n):\n            transpose[i][j] = mat[j][i]\n    flip = 0\n    for i in range(n):\n        for j in range(n):\n            if transpose[i][j] != mat[i][j]:\n                flip += 1\n    return int(flip / 2)\n",
        "test": "\nn = 3\nmat = [[0, 0, 1], [1, 1, 1], [1, 0, 0]]\nprint(minimumflip(mat, n))\n",
        "output": "2\n",
        "fn_call": "minimumflip"
    },
    {
        "text": "sum of all substrings of a string representing a number | set 2 ( constant extra space ) | returns sum of all substring of num ; initialize result ; here traversing the array in reverse order . initializing loop from last element . mf is multiplying factor . ; each time sum is added to its previous sum . multiplying the three factors as explained above . int ( s [ i ] ) is done to convert char to int . ; making new multiplying factor as explained above . ; ",
        "context": "",
        "code": "def sumOfSubstrings(num):\n    sum = 0\n    mf = 1\n    for i in range(len(num) - 1, -1, -1):\n        sum = sum + (int(num[i])) * (i + 1) * mf\n        mf = mf * 10 + 1\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    num = \"6759\"\n    print(sumOfSubstrings(num))\n",
        "output": "8421\n",
        "fn_call": "sumOfSubstrings"
    },
    {
        "text": "find sum of product of every number and its frequency in given range | function to solve queries ; calculating answer for every query ; the end points of the ith query ; map for storing frequency ; incrementing the frequency ; iterating over map to find answer ; adding the contribution of ith number ; print answer ; ",
        "context": "",
        "code": "def answerQueries(arr, n, queries):\n    for i in range(len(queries)):\n        ans = 0\n        l = queries[i][0] - 1\n        r = queries[i][1] - 1\n        freq = dict()\n        for j in range(l, r + 1):\n            freq[arr[j]] = freq .get(arr[j], 0) + 1\n        for i in freq:\n            ans += (i * freq[i])\n        print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 1]\n    n = len(arr)\n    queries = [[1, 2], [1, 3]]\n    answerQueries(arr, n, queries)\n",
        "output": "3\n4\n",
        "fn_call": "answerQueries"
    },
    {
        "text": "program to find nth term divisible by a or b | python 3 program to find nth term divisible by a or b ; function to return gcd of a and b ; function to calculate how many numbers from 1 to num are divisible by a or b ; calculate number of terms divisible by a and by b then , remove the terms which are divisible by both a and b ; binary search to find the nth term divisible by a or b ; set low to 1 and high to max ( a , b ) * n , here we have taken high as 10 ^ 18 ; if the current term is less than n then we need to increase low to mid + 1 ; if current term is greater than equal to n then high = mid ; ",
        "context": "\nimport sys\n\n",
        "code": "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef divTermCount(a, b, lcm, num):\n    return num // a + num // b - num // lcm\n\n\ndef findNthTerm(a, b, n):\n    low = 1\n    high = sys .maxsize\n    lcm = (a * b) // gcd(a, b)\n    while low < high:\n        mid = low + (high - low) // 2\n        if divTermCount(a, b, lcm, mid) < n:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n",
        "test": "\na = 2\nb = 5\nn = 10\nprint(findNthTerm(a, b, n))\n",
        "output": "16\n",
        "fn_call": "findNthTerm"
    },
    {
        "text": "find maximum sum taking every kth element in the array | function to return the maximum sum for every possible sequence such that a [ i ] + a [ i + k ] + a [ i + 2 k ] + ... + a [ i + qk ] is maximized ; initialize the maximum with the smallest value ; initialize the sum array with zero ; iterate from the right ; update the sum starting at the current element ; update the maximum so far ; ",
        "context": "",
        "code": "def maxSum(arr, n, K):\n    maximum = -2 ** 32\n    sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        if (i + K < n):\n            sum[i] = sum[i + K] + arr[i]\n        else:\n            sum[i] = arr[i]\n        maximum = max(maximum, sum[i])\n    return maximum\n",
        "test": "\narr = [3, 6, 4, 7, 2]\nn = len(arr)\nK = 2\nprint(maxSum(arr, n, K))\n",
        "output": "13\n",
        "fn_call": "maxSum"
    },
    {
        "text": "check if an array has a majority element | returns true if there is a majority element in a [ ] ; insert all elements in a hash table ; check if frequency of any element is n / 2 or more . ; ",
        "context": "",
        "code": "def isMajority(a):\n    mp = {}\n    for i in a:\n        if i in mp:\n            mp[i] += 1\n        else:\n            mp[i] = 1\n    for x in mp:\n        if mp[x] >= len(a) // 2:\n            return True\n    return False\n",
        "test": "\na = [2, 3, 9, 2, 2]\nprint(\"Yes\"if isMajority(a)else \"No\")\n",
        "output": "Yes\n",
        "fn_call": "isMajority"
    },
    {
        "text": "program to find sum of the given sequence | python3 program to find the sum of the given sequence ; function to find moudulo inverse under 10 ^ 9 + 7 ; function to find the sum of the given sequence ; ",
        "context": "\nMOD = 1000000007\n\n",
        "code": "def modInv(x):\n    n = MOD - 2\n    result = 1\n    while (n):\n        if (n & 1):\n            result = result * x % MOD\n        x = x * x % MOD\n        n = int(n / 2)\n    return result\n\n\ndef getSum(n, k):\n    ans = 1\n    for i in range(n + 1, n - k, -1):\n        ans = ans * i % MOD\n    ans = ans * modInv(k + 1) % MOD\n    return ans\n",
        "test": "\nn = 3\nk = 2\nprint(getSum(n, k))\n",
        "output": "8\n",
        "fn_call": "getSum"
    },
    {
        "text": "check if two nodes are on same path in a tree | set 2 | function to filter the return values ; utility function to check if nodes are on same path or not ; condition to check if any vertex is equal to given two vertex or not ; check if the current position has 1 ; recursive call ; return lca ; function to check if nodes lies on same path or not ; ",
        "context": "",
        "code": "def filter(x, y, z):\n    if (x != -1 and y != -1):\n        return z\n    return y if x == -1 else x\n\n\ndef samePathUtil(mtrx, vrtx, v1, v2, i):\n    ans = -1\n    if (i == v1 or i == v2):\n        return i\n    for j in range(0, vrtx):\n        if (mtrx[i][j] == 1):\n            ans = filter(ans, samePathUtil(mtrx, vrtx, v1, v2, j), i)\n    return ans\n\n\ndef isVertexAtSamePath(mtrx, vrtx, v1, v2, i):\n    lca = samePathUtil(mtrx, vrtx, v1 - 1, v2 - 1, i)\n    if (lca == v1 - 1 or lca == v2 - 1):\n        return True\n    return False\n",
        "test": "\nvrtx = 7\nedge = 6\nmtrx = [\n    [\n        0, 1, 1, 1, 0, 0, 0], [\n            0, 0, 0, 0, 1, 0, 0], [\n                0, 0, 0, 0, 0, 1, 0], [\n                    0, 0, 0, 0, 0, 0, 1], [\n                        0, 0, 0, 0, 0, 0, 0], [\n                            0, 0, 0, 0, 0, 0, 0], [\n                                0, 0, 0, 0, 0, 0, 0]]\nv1 = 1\nv2 = 5\nif (isVertexAtSamePath(mtrx, vrtx, v1, v2, 0)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "isVertexAtSamePath"
    },
    {
        "text": "print all paths from a source point to all the 4 corners of a matrix | function to check if we reached on of the entry / exit ( corner ) point . ; function to check if the index is within the matrix boundary . ; recursive helper function ; if any corner is reached push the string t into ans and return ; for all the four directions ; the new ith index ; the new jth index ; the direction r / l / u / d ; if the new cell is within the matrix boundary and it is not previously visited in same path ; mark the new cell visited ; store the direction ; backtrack to explore other paths ; function to find all possible paths ; create a direction array for all the four directions ; stores the result ; ",
        "context": "",
        "code": "def isCorner(i, j, M, N):\n    if ((i == 0 and j == 0) or (i == 0 and j == N - 1)\n            or (i == M - 1 and j == N - 1) or (i == M - 1 and j == 0)):\n        return True\n    return False\n\n\ndef isValid(i, j, M, N):\n    if (i = M or j = N):\n        return False\n    return True\n\n\ndef solve(i, j, M, N, Dir, maze, t, ans):\n    if (isCorner(i, j, M, N)):\n        ans .append(t)\n        return\n    for k in range(4):\n        x = i + Dir[k][0]\n        y = j + Dir[k][1]\n        c = Dir[k][2]\n        if (isValid(x, y, M, N) and maze[x][y] == 1):\n            maze[x][y] = 0\n            t += c\n            solve(x, y, M, N, Dir, maze, t, ans)\n            t = t[:len(t) - 1]\n            maze[x][y] = 1\n    return\n\n\ndef possiblePaths(src, maze):\n    Dir = [[-1, 0, 'U'], [0, 1, 'R'], [1, 0, 'D'], [0, -1, 'L']]\n    temp = \"\"\n    ans = []\n    solve(src[0], src[1], len(maze), len(maze[0]), Dir, maze, temp, ans)\n    return ans\n",
        "test": "\nmaze = [\n    [\n        1, 0, 0, 1, 0, 0, 1, 1], [\n            1, 1, 1, 0, 0, 0, 1, 0], [\n                1, 0, 1, 1, 1, 1, 1, 0], [\n                    0, 0, 0, 0, 1, 0, 0, 0], [\n                        1, 0, 1, 0, 1, 0, 0, 1], [\n                            0, 1, 1, 1, 1, 0, 0, 1], [\n                                0, 1, 0, 0, 1, 1, 1, 1], [\n                                    1, 1, 0, 0, 0, 0, 0, 1]]\nsrc = [4, 2]\npaths = possiblePaths(src, maze)\nif (len(paths) == 0):\n    print(\"No Possible Paths\")\nelse:\n    for i in paths:\n        print(i)\n",
        "output": "DRRUUURRUUR\nDRRUUULLULLU\nDRRDRRRD\nDLDDL\n",
        "fn_call": "possiblePaths"
    },
    {
        "text": "count of perfect numbers in given range for q queries | python 3 program for the above approach ; function to check whether a number is perfect number ; stores sum of divisors ; itearate over the range [ 2 , sqrt ( n ) ] ; if sum of divisors is equal to n , then n is a perfect number ; function to find count of perfect numbers in a given range ; stores the count of perfect numbers upto a every number less than max ; iterate over the range [ 1 , max ] ; traverse the array arr [ ] ; print the count of perfect numbers in the range [ arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ] ; ",
        "context": "\nfrom math import sqrt\nMAX = 100005\n\n",
        "code": "def isPerfect(N):\n    sum = 1\n    for i in range(2, int(sqrt(N)) + 1, 1):\n        if (N % i == 0):\n            if (i * i != N):\n                sum = sum + i + N // i\n            else:\n                sum = sum + i\n    if (sum == N and N != 1):\n        return True\n    return False\n\n\ndef Query(arr, N):\n    prefix = [0 for i in range(MAX + 1)]\n    for i in range(2, MAX + 1, 1):\n        prefix[i] = prefix[i - 1] + isPerfect(i)\n    for i in range(N):\n        print(prefix[arr[i][1]] - prefix[arr[i][0] - 1], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, 1000], [1000, 2000], [2000, 3000]]\n    N = len(arr)\n    Query(arr, N)\n",
        "output": "3 0 0 ",
        "fn_call": "Query"
    },
    {
        "text": "find number of solutions of a linear equation of n variables | recursive function that returns count of solutions for given rhs value and coefficients coeff [ stat ... end ] ; base case ; initialize count of solutions ; one by one subtract all smaller or equal coefficients and recur ; ",
        "context": "",
        "code": "def countSol(coeff, start, end, rhs):\n    if (rhs == 0):\n        return 1\n    result = 0\n    for i in range(start, end + 1):\n        if (coeff[i] <= rhs):\n            result += countSol(coeff, i, end, rhs - coeff[i])\n    return result\n",
        "test": "\ncoeff = [2, 2, 5]\nrhs = 4\nn = len(coeff)\nprint(countSol(coeff, 0, n - 1, rhs))\n",
        "output": "3\n",
        "fn_call": "countSol"
    },
    {
        "text": "search an element in a reverse sorted array | function to search if element x is present in reverse sorted array ; store the first index of the subarray in which x lies ; store the last index of the subarray in which x lies ; store the middle index of the subarray ; check if value at middle index of the subarray equal to x ; element is found ; if x is smaller than the value at middle index of the subarray ; search in right half of subarray ; search in left half of subarray ; if x not found ; ",
        "context": "",
        "code": "def binarySearch(arr, N, X):\n    start = 0\n    end = N\n    while (start <= end):\n        mid = start + (end - start) // 2\n        if (X == arr[mid]):\n            return mid\n        elif (X < arr[mid]):\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 4, 3, 2, 1]\n    N = len(arr)\n    X = 5\n    print(binarySearch(arr, N, X))\n",
        "output": "0\n",
        "fn_call": "binarySearch"
    },
    {
        "text": "minimum number of jumps to reach end | returns minimum number of jumps to reach end ; jumps [ 0 ] will hold the result ; start from the second element , move from right to left and construct the jumps [ ] array where jumps [ i ] represents minimum number of jumps needed to reach arr [ m - 1 ] form arr [ i ] ; if arr [ i ] is 0 then arr [ n - 1 ] can 't be reached from here ; if we can directly reach to the end point from here then jumps [ i ] is 1 ; otherwise , to find out the minimum number of jumps needed to reach arr [ n - 1 ] , check all the points reachable from here and jumps [ ] value for those points ; initialize min value ; following loop checks with all reachavle points and takes the minimum ; handle overflow ; or int_max ; ",
        "context": "",
        "code": "def minJumps(arr, n):\n    jumps = [0 for i in range(n)]\n    for i in range(n - 2, -1, -1):\n        if (arr[i] == 0):\n            jumps[i] = float('inf')\n        elif (arr[i] >= n - i - 1):\n            jumps[i] = 1\n        else:\n            min = float('inf')\n            for j in range(i + 1, n):\n                if (j <= arr[i] + i):\n                    if (min > jumps[j]):\n                        min = jumps[j]\n            if (min != float('inf')):\n                jumps[i] = min + 1\n            else:\n                jumps[i] = min\n    return jumps[0]\n",
        "test": "\narr = [1, 3, 6, 3, 2, 3, 6, 8, 9, 5]\nn = len(arr)\nprint('Minimum number of jumps to reach', 'end is', minJumps(arr, n - 1))\n",
        "output": "Minimum number of jumps to reach end is 3\n",
        "fn_call": "minJumps"
    },
    {
        "text": "count number of triplets ( a , b , c ) from first n natural numbers such that a * b + c = n | function to find the count of triplets ( a , b , c ) with a * b + c = n ; stores count of triplets of 1 st n natural numbers which are of the form a * b + c = n ; iterate over the range [ 1 , n ] ; if n is divisible by i ; update cnttriplet ; update cnttriplet ; ",
        "context": "",
        "code": "def findCntTriplet(N):\n    cntTriplet = 0\n    for i in range(1, N):\n        if (N % i != 0):\n            cntTriplet += N // i\n        else:\n            cntTriplet += (N // i) - 1\n    return cntTriplet\n",
        "test": "\nif __name__ == '__main__':\n    N = 3\n    print(findCntTriplet(N))\n",
        "output": "3\n",
        "fn_call": "findCntTriplet"
    },
    {
        "text": "count frequency of k in a matrix of size n where matrix ( i , j ) = i + j | python program to find the frequency of k in matrix where m ( i , j ) = i + j ; ",
        "context": "\nimport math\n\n",
        "code": "def find(n, k):\n    if (n + 1 >= k):\n        return (k - 1)\n    else:\n        return (2 * n + 1 - k)\n",
        "test": "\nn = 4\nk = 7\nfreq = find(n, k)\nif (freq < 0):\n    print(\" element not exist\")\nelse:\n    print(\" Frequency of \", k, \" is \", freq)\n",
        "output": " Frequency of  7  is  2\n",
        "fn_call": "find"
    },
    {
        "text": "minimize value of | a | function to find the minimum possible value of | a - x | + | b - y | + | c - z | such that x * y = z for given a , b and c ; stores the minimum value of | a - x | + | b - y | + | c - z | such that x * y = z ; iterate over all values of i in the range [ 1 , 2 * c ] ; iterate over all values of j such that i * j <= 2 * c ; update the value of ans ; return answer ; ",
        "context": "",
        "code": "def minimizeCost(A, B, C):\n    ans = A + B + C\n    for i in range(1, 2 * C + 1):\n        j = 0\n        while (i * j <= 2 * C):\n            ans = min(ans, abs(A - i) + abs(B - j) + abs(i * j - C))\n            j += 1\n    return ans\n",
        "test": "\nA = 19\nB = 28\nC = 522\nprint(minimizeCost(A, B, C))\n",
        "output": "2\n",
        "fn_call": "minimizeCost"
    },
    {
        "text": "check whether the ",
        "context": "\nimport math\n\n",
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(math .sqrt(n) + 1), 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\n\ndef isCousinPrime(n1, n2):\n    if (not (abs(n1 - n2) == 4)):\n        return False\n    else:\n        return (isPrime(n1) and isPrime(n2))\n",
        "test": "\nn1 = 7\nn2 = 11\nif (isCousinPrime(n1, n2)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isCousinPrime"
    },
    {
        "text": "minimum operation require to make first and last character same | python3 program to find minimum operation require to make first and last character same ; return the minimum operation require to make string first and last character same . ; store indexes of first occurrences of characters . ; initialize result ; traverse through all characters ; find first occurrence ; update result for subsequent occurrences ; ",
        "context": "\nMAX = 256\n\n",
        "code": "def minimumOperation(s):\n    n = len(s)\n    first_occ = [-1] * MAX\n    res = float('inf')\n    for i in range(0, n):\n        x = s[i]\n        if first_occ[ord(x)] == -1:\n            first_occ[ord(x)] = i\n        else:\n            last_occ = n - i - 1\n            res = min(res, first_occ[ord(x)] + last_occ)\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"bacdefghipalop\"\n    print(minimumOperation(s))\n",
        "output": "4\n",
        "fn_call": "minimumOperation"
    },
    {
        "text": "find the other number when lcm and hcf given | function that will calculates the zeroes at the end ; ",
        "context": "",
        "code": "def otherNumber(a, Lcm, Hcf):\n    return (Lcm * Hcf) // A\n",
        "test": "\nA = 8\nLcm = 8\nHcf = 1\nresult = otherNumber(A, Lcm, Hcf)\nprint(\"B =\", result)\n",
        "output": "B = 1\n",
        "fn_call": "otherNumber"
    },
    {
        "text": "count of binary strings of length n having equal count of 0 ' s \u2581 and \u2581 1' s | python3 program to implement the above approach ; function to calculate c ( n , r ) % mod dp based approach ; corner case ; stores the last row of pascal 's triangle ; initialize top row of pascal triangle ; construct pascal 's triangle  from top to bottom ; fill current row with the help of previous row ; c ( n , j ) = c ( n - 1 , j ) + c ( n - 1 , j - 1 ) ; ",
        "context": "\nMOD = 1000000007\n\n",
        "code": "def nCrModp(n, r):\n    if (n % 2 == 1):\n        return -1\n    C = [0] * (r + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            C[j] = (C[j] + C[j - 1]) % MOD\n    return C[r]\n",
        "test": "\nN = 6\nprint(nCrModp(N, N // 2))\n",
        "output": "20\n",
        "fn_call": "nCrModp"
    },
    {
        "text": "find a pair of overlapping intervals from a given set | function to find a pair ( i , j ) such that i - th interval lies within the j - th interval ; store interval and index of the interval in the form of { { l , r } , index } ; traverse the array , arr [ ] [ ] ; stores l - value of the interval ; stores r - value of the interval ; push current interval and index into tup ; sort the vector based on l - value of the intervals ; stores r - value of current interval ; stores index of current interval ; traverse the vector , tup [ ] ; stores l - value of previous interval ; stores l - value of current interval ; if q and r are equal ; print the index of interval ; stores r - value of current interval ; if t is less than or equal to curr ; update curr ; update currpos ; if such intervals found ; given l - value of segments ; given r - value of segments ; ",
        "context": "",
        "code": "def findOverlapSegement(N, a, b):\n    tup = []\n    for i in range(N):\n        x = a[i]\n        y = b[i]\n        tup .append(((x, y), i))\n    tup .sort()\n    curr = tup[0][0][1]\n    currPos = tup[0][1]\n    for i in range(1, N):\n        Q = tup[i - 1][0][0]\n        R = tup[i][0][0]\n        if Q == R:\n            if tup[i - 1][0][1] < tup[i][0][1]:\n                print(tup[i - 1][1], tup[i][1])\n            else:\n                print(tup[i][1], tup[i - 1][1])\n            return\n        T = tup[i][0][1]\n        if (T <= curr):\n            print(tup[i][1], currPos)\n            return\n        else:\n            curr = T\n            currPos = tup[i][1]\n    print(\"-1\", \"-1\", end=\"\")\n",
        "test": "\na = [1, 2, 3, 2, 2]\nb = [5, 10, 10, 2, 15]\nN = len(a)\nfindOverlapSegement(N, a, b)\n",
        "output": "3 0\n",
        "fn_call": "findOverlapSegement"
    },
    {
        "text": "maximum sum path in a matrix from top to bottom and back | python 3 implementation of the approach ; input matrix ; dp matrix ; function to return the sum of the cells arr [ i1 ] [ j1 ] and arr [ i2 ] [ j2 ] ; recursive function to return the required maximum cost path ; column number of second path ; base case ; if already calculated , return from dp matrix ; recurring for neighbouring cells of both paths together ; saving result to the dp matrix for current state ; ",
        "context": "\nimport sys\nn = 4\nm = 4\narr = [[1, 0, 3, -1], [3, 5, 1, -2], [-2, 0, 1, 1], [2, 1, -1, 1]]\ncache = [[[-1 for i in range(5)]for j in range(5)]for k in range(5)]\n\n",
        "code": "def sum(i1, j1, i2, j2):\n    if (i1 == i2 and j1 == j2):\n        return arr[i1][j1]\n    return arr[i1][j1] + arr[i2][j2]\n\n\ndef maxSumPath(i1, j1, i2):\n    j2 = i1 + j1 - i2\n    if (i1 >= n or i2 >= n or j1 >= m or j2 >= m):\n        return 0\n    if (cache[i1][j1][i2] != -1):\n        return cache[i1][j1][i2]\n    ans = -sys .maxsize - 1\n    ans = max(ans, maxSumPath(i1 + 1, j1, i2 + 1) + sum(i1, j1, i2, j2))\n    ans = max(ans, maxSumPath(i1, j1 + 1, i2) + sum(i1, j1, i2, j2))\n    ans = max(ans, maxSumPath(i1, j1 + 1, i2 + 1) + sum(i1, j1, i2, j2))\n    ans = max(ans, maxSumPath(i1 + 1, j1, i2) + sum(i1, j1, i2, j2))\n    cache[i1][j1][i2] = ans\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    print(maxSumPath(0, 0, 0))\n",
        "output": "16\n",
        "fn_call": "maxSumPath"
    },
    {
        "text": "position of rightmost different bit | python implementation to find the position of rightmost different bit ; function to find the position of rightmost set bit in 'n ; to handle edge case when n = 0. ; function to find the position of rightmost different bit in the binary representations of ' m ' and 'n ; position of rightmost different bit ; ",
        "context": "\nimport math\n\n",
        "code": "def getRightMostSetBit(n):\n    if (n == 0):\n        return 0\n    return math.log2(n & -n)+1\n\n\ndef posOfRightMostDiffBit(m, n):\n    return getRightMostSetBit(m ^ n)\n",
        "test": "\nm = 52\nn = 4\nprint(\"position = \", int(posOfRightMostDiffBit(m, n)))\n",
        "output": "position =  5\n",
        "fn_call": "posOfRightMostDiffBit"
    },
    {
        "text": "count all distinct pairs with product equal to k | python3 program to count the number of pairs whose product is equal to k ; function to count the number of pairs whose product is equal to k ; initialize the count ; initialize empty hashmap . ; insert array elements to hashmap ; checking if the index is a whole number and present in the hashmap ; ",
        "context": "\nMAX = 100000\n\n",
        "code": "def countPairsWithProductK(arr, n, k):\n    count = 0\n    hashmap = [False] * MAX\n    for i in range(n):\n        hashmap[arr[i]] = True\n    for i in range(n):\n        x = arr[i]\n        index = 1.0 * k / arr[i]\n        if (index >= 0 and ((index - int(index)) == 0) and hashmap[k // x]):\n            count += 1\n        hashmap[x] = False\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 5, 3, 4, 2]\n    N = len(arr)\n    K = 3\n    print(countPairsWithProductK(arr, N, K))\n",
        "output": "1\n",
        "fn_call": "countPairsWithProductK"
    },
    {
        "text": "minimum elements inserted in a sorted array to form an arithmetic progression | function to find the greatest common divisor of two numbers ; function to find the minimum the minimum number of elements required to be inserted into array ; difference array of consecutive elements of the array ; gcd of the difference array ; loop to calculate the minimum number of elements required ; ",
        "context": "",
        "code": "def gcdFunc(a, b):\n    if (b == 0):\n        return a\n    return gcdFunc(b, a % b)\n\n\ndef findMinimumElements(a, n):\n    b = [0] * (n - 1)\n    for i in range(1, n):\n        b[i - 1] = a[i] - a[i - 1]\n    gcd = b[0]\n    for i in range(n - 1):\n        gcd = gcdFunc(gcd, b[i])\n    ans = 0\n    for i in range(n - 1):\n        ans += (b[i] // gcd) - 1\n    return ans\n",
        "test": "\narr1 = [1, 6, 8, 10, 14, 16]\nn1 = len(arr1)\nprint(findMinimumElements(arr1, n1))\n",
        "output": "10\n",
        "fn_call": "findMinimumElements"
    },
    {
        "text": "largest sum subarray with at | returns maximum sum of a subarray with at - least k elements . ; maxsum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; we use kadane 's algorithm to fill maxsum[]  below code is taken from method3 of  https:www.geeksforgeeks.org/largest-sum-contiguous-subarray/ ; sum of first k elements ; use the concept of sliding window ; compute sum of k elements ending with a [ i ] . ; update result if required ; include maximum sum till [ i - k ] also if it increases overall max . ; ",
        "context": "",
        "code": "def maxSumWithK(a, n, k):\n    maxSum = [0 for i in range(n)]\n    maxSum[0] = a[0]\n    curr_max = a[0]\n    for i in range(1, n):\n        curr_max = max(a[i], curr_max + a[i])\n        maxSum[i] = curr_max\n    sum = 0\n    for i in range(k):\n        sum += a[i]\n    result = sum\n    for i in range(k, n):\n        sum = sum + a[i] - a[i - k]\n        result = max(result, sum)\n        result = max(result, sum + maxSum[i - k])\n    return result\n",
        "test": "\na = [1, 2, 3, -10, -3]\nk = 4\nn = len(a)\nprint(maxSumWithK(a, n, k))\n",
        "output": "-4\n",
        "fn_call": "maxSumWithK"
    },
    {
        "text": "count number of rotated strings which have more number of vowels in the first half than second half | function to return the count of rotated strings which have more number of vowels in the first half than the second half ; compute the number of vowels in first - half ; compute the number of vowels in second - half ; check if first - half has more vowels ; check for all possible rotations ; return the answer ; ",
        "context": "",
        "code": "def cntRotations(s, n):\n    lh, rh, ans = 0, 0, 0\n    for i in range(n // 2):\n        if (s[i] == 'a' or s[i] == 'e' or s[i] ==\n                'i' or s[i] == 'o' or s[i] == 'u'):\n            lh += 1\n    for i in range(n // 2, n):\n        if (s[i] == 'a' or s[i] == 'e' or s[i] ==\n                'i' or s[i] == 'o' or s[i] == 'u'):\n            rh += 1\n    if (lh > rh):\n        ans += 1\n    for i in range(1, n):\n        if (s[i - 1] == 'a' or s[i - 1] == 'e' or s[i - 1]\n                == 'i' or s[i - 1] == 'o' or s[i - 1] == 'u'):\n            rh += 1\n            lh -= 1\n        if (s[(i - 1 + n // 2) %\n              n] == 'a' or s[(i - 1 + n // 2) %\n                             n] == 'e' or s[(i - 1 + n // 2) %\n                                            n] == 'i' or s[(i - 1 + n // 2) %\n                                                           n] == 'o' or s[(i - 1 + n // 2) %\n                                                                          n] == 'u'):\n            rh -= 1\n            lh += 1\n        if (lh > rh):\n            ans += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abecidft\"\n    n = len(s)\n    print(cntRotations(s, n))\n",
        "output": "4\n",
        "fn_call": "cntRotations"
    },
    {
        "text": "maximize the sum of modulus with every array element | function to return the maximum sum of modulus with every array element ; sum of array elements ; return the answer ; ",
        "context": "",
        "code": "def maxModulosum(a, n):\n    sum1 = 0\n    for i in range(0, n):\n        sum1 += a[i]\n    return sum1 - n\n",
        "test": "\na = [3, 4, 6]\nn = len(a)\nprint(maxModulosum(a, n))\n",
        "output": "10\n",
        "fn_call": "maxModulosum"
    },
    {
        "text": "Sum of the first N terms of the series 2 , 6 , 12 , 20 , 30. ... | Function to calculate the sum ; number of terms to be included in the sum ; find the Sum",
        "context": "",
        "code": "def calculateSum(n):\n    return (n * (n + 1) // 2 + n * (n + 1) * (2 * n + 1) // 6)\n",
        "test": "\nn = 3\nprint(\"Sum = \", calculateSum(n))\n",
        "output": "Sum =  20\n",
        "fn_call": "calculateSum"
    },
    {
        "text": "program to check plus perfect number | python 3 implementation to check if the number is plus perfect or not ; function to check plus perfect number ; calculating number of digits ; calculating plus perfect number ; checking whether number is plus perfect or not ; ",
        "context": "\nimport math\n\n",
        "code": "def checkplusperfect(x):\n    temp = x\n    n = 0\n    while (x != 0):\n        x = x // 10\n        n = n + 1\n    x = temp\n    sm = 0\n    while (x != 0):\n        sm = sm + (int)(math .pow(x % 10, n))\n        x = x // 10\n    return (sm == temp)\n",
        "test": "\nx = 9474\nif (checkplusperfect(x)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkplusperfect"
    },
    {
        "text": "find the position of the given row in a 2 | python3 implementation of the approach ; function that compares both the arrays and returns - 1 , 0 and 1 accordingly ; return 1 if mid row is less than arr [ ] ; return 1 if mid row is greater than arr [ ] ; both the arrays are equal ; function to find a row in the given matrix using binary search ; if current row is equal to the given array then return the row number ; if arr [ ] is greater , ignore left half ; if arr [ ] is smaller , ignore right half ; no valid row found ; ",
        "context": "\nm = 6\nn = 4\n\n",
        "code": "def compareRow(a1, a2):\n    for i in range(n):\n        if (a1[i] < a2[i]):\n            return 1\n        elif (a1[i] > a2[i]):\n            return -1\n    return 0\n\n\ndef binaryCheck(ar, arr):\n    l = 0\n    r = m - 1\n    while (l <= r):\n        mid = (l + r) // 2\n        temp = compareRow(ar[mid], arr)\n        if (temp == 0):\n            return mid + 1\n        elif (temp == 1):\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    mat = [[0, 0, 1, 0], [10, 9, 22, 23], [40, 40, 40, 40], [\n        43, 44, 55, 68], [81, 73, 100, 132], [100, 75, 125, 133]]\n    row = [10, 9, 22, 23]\n    print(binaryCheck(mat, row))\n",
        "output": "2\n",
        "fn_call": "binaryCheck"
    },
    {
        "text": "remove last occurrence of a word from a given sentence string | function to remove last occurrence of w from s ; if m is greater than n ; iterate while i is greater than or equal to 0 ; of w has been found or not ; iterate over the range [ 0 , m ] ; if s [ j + 1 ] is not equal to w [ j ] ; mark flag true and break ; if occurrence has been found ; delete the subover the range [ i , i + m ] ; resize the s ; return s ; ",
        "context": "",
        "code": "def removeLastOccurrence(S, W, N, M):\n    S = [i for i in S]\n    W = [i for i in W]\n    if (M > N):\n        return S\n    for i in range(N - M, -1, -1):\n        flag = 0\n        for j in range(M):\n            if (S[j + i] != W[j]):\n                flag = 1\n                break\n        if (flag == 0):\n            for j in range(i, N - M):\n                S[j] = S[j + M]\n            S = S[:N - M]\n            break\n    return \"\".join(S)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"This is GeeksForGeeks\"\n    W = \"Geeks\"\n    N = len(S)\n    M = len(W)\n    print(removeLastOccurrence(S, W, N, M))\n",
        "output": "This is GeeksFor\n",
        "fn_call": "removeLastOccurrence"
    },
    {
        "text": "check if the characters in a string form a palindrome in o ( 1 ) extra space | utility function to get the position of first character in the string ; get the position of first character in the string ; utility function to get the position of last character in the string ; get the position of last character in the string ; function to check if the characters in the given string forms a palindrome in o ( 1 ) extra space ; break , when all letters are checked ; if mismatch found , break the loop ; ",
        "context": "",
        "code": "def firstPos(str, start, end):\n    firstChar = -1\n    for i in range(start, end + 1):\n        if (str[i] >= 'a' and str[i] <= 'z'):\n            firstChar = i\n            break\n    return firstChar\n\n\ndef lastPos(str, start, end):\n    lastChar = -1\n    for i in range(start, end - 1, -1):\n        if (str[i] >= 'a' and str[i] <= 'z'):\n            lastChar = i\n            break\n    return lastChar\n\n\ndef isPalindrome(str):\n    firstChar = 0\n    lastChar = len(str) - 1\n    ch = True\n    for i in range(len(str)):\n        firstChar = firstPos(str, firstChar, lastChar)\n        lastChar = lastPos(str, lastChar, firstChar)\n        if (lastChar < 0 or firstChar < 0):\n            break\n        if (str[firstChar] == str[lastChar]):\n            firstChar += 1\n            lastChar -= 1\n            continue\n        ch = False\n        break\n    return (ch)\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"mTABSYMBOLa 343 la y a l am\"\n    if (isPalindrome(str)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isPalindrome"
    },
    {
        "text": "find second largest element in an array | function to print the second largest elements ; there should be atleast two elements ; if current element is smaller than first then update both first and second ; if arr [ i ] is in between first and second then update second ; ",
        "context": "",
        "code": "def print2largest(arr, arr_size):\n    if (arr_size < 2):\n        print(\" Invalid Input \")\n        return\n    first = second = -2147483648\n    for i in range(arr_size):\n        if (arr[i] > first):\n            second = first\n            first = arr[i]\n        elif (arr[i] > second and arr[i] != first):\n            second = arr[i]\n    if (second == -2147483648):\n        print(\"There is no second largest element\")\n    else:\n        print(\"The second largest element is\", second)\n",
        "test": "\narr = [12, 35, 1, 10, 34, 1]\nn = len(arr)\nprint2largest(arr, n)\n",
        "output": "The second largest element is 34\n",
        "fn_call": "print2largest"
    },
    {
        "text": "maximum subarray sum after inverting at most two elements | function to return the maximum required sub - array sum ; creating one based indexing ; 2d array to contain solution for each step ; case 1 : choosing current or ( current + previous ) whichever is smaller ; case 2 : ( a ) altering sign and add to previous case 1 or value 0 ; case 2 : ( b ) adding current element with previous case 2 and updating the maximum ; case 3 : ( a ) altering sign and add to previous case 2 ; case 3 : ( b ) adding current element with previous case 3 ; updating the maximum value of variable ans ; return the final solution ; ",
        "context": "",
        "code": "def maxSum(a, n):\n    ans = 0\n    arr = [0] * (n + 1)\n    for i in range(1, n + 1):\n        arr[i] = a[i - 1]\n    dp = [[0 for i in range(3)]for j in range(n + 1)]\n    for i in range(0, n + 1):\n        dp[i][0] = max(arr[i], dp[i - 1][0] + arr[i])\n        dp[i][1] = max(0, dp[i - 1][0]) - arr[i]\n        if i >= 2:\n            dp[i][1] = max(dp[i][1], dp[i - 1][1] + arr[i])\n        if i >= 2:\n            dp[i][2] = dp[i - 1][1] - arr[i]\n        if i >= 3:\n            dp[i][2] = max(dp[i][2], dp[i - 1][2] + arr[i])\n        ans = max(ans, dp[i][0])\n        ans = max(ans, dp[i][1])\n        ans = max(ans, dp[i][2])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [-5, 3, 2, 7, -8, 3, 7, -9, 10, 12, -6]\n    n = len(arr)\n    print(maxSum(arr, n))\n",
        "output": "61\n",
        "fn_call": "maxSum"
    },
    {
        "text": "replace the maximum element in the array by coefficient of range | utility function to print the contents of the array ; function to replace the maximum element from the array with the coefficient of range of the array ; maximum element from the array ; minimum element from the array ; calculate the coefficient of range for the array ; assuming all the array elements are distinct . replace the maximum element with the coefficient of range of the array ; print the updated array ; ",
        "context": "",
        "code": "def printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end=\" \")\n\n\ndef replaceMax(arr, n):\n    max_element = max(arr)\n    min_element = min(arr)\n    ranges = max_element - min_element\n    coeffOfRange = ranges / (max_element + min_element)\n    for i in range(n):\n        if (arr[i] == max_element):\n            arr[i] = coeffOfRange\n            break\n    printArr(arr, n)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [15, 16, 10, 9, 6, 7, 17]\n    n = len(arr)\n    replaceMax(arr, n)\n",
        "output": "15 16 10 9 6 7 0.4782608695652174 ",
        "fn_call": "replaceMax"
    },
    {
        "text": "find k positive integers not exceeding n and having sum s | function to represent s as the sum of k positive integers less than or equal to n ; if s can cannot be represented as sum of k integers ; if sum of first i natural numbers exceeds s ; insert i into nums [ ] ; insert first k - 1 positive numbers into answer [ ] ; insert the k - th number ; traverse the array answer [ ] ; if current element exceeds n ; add the extra value to the previous element ; reduce current element to n ; printing the k numbers ; ",
        "context": "",
        "code": "def solve(S, K, N):\n    if (K > N):\n        print(\"-1\")\n        return\n    max_sum, min_sum = 0, 0\n    for i in range(K + 1):\n        min_sum += i\n        max_sum += N - i + 1\n    if (S  max_sum):\n        print(\"-1\")\n        return\n    s1 = 0\n    nums = []\n    for i in range(1, N + 1):\n        if (s1 > S):\n            break\n        s1 += i\n        nums .append(i)\n    answer = []\n    s2 = 0\n    for i in range(K - 1):\n        answer .append(nums[i])\n        s2 += nums[i]\n    answer .append(S - s2)\n    Max = N\n    for i in range(len(answer) - 1, -1, -1):\n        if (answer[i] > Max):\n            extra = answer[i] - Max\n            if (i - 1 >= 0):\n                answer[i - 1] += extra\n            answer[i] = Max\n            Max -= 1\n        else:\n            break\n    for x in answer:\n        print(x, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    S, K, N = 15, 4, 8\n    solve(S, K, N)\n",
        "output": "1 2 4 8 ",
        "fn_call": "solve"
    },
    {
        "text": "k | function that finds the nth element of k - fibonacci series ; if n is less than k then the element is '1 ; first k elements are 1 ; ( k + 1 ) th element is k ; find the elements of the k - fibonacci series ; subtract the element at index i - k - 1 and add the element at index i - i from the sum ( sum contains the sum of previous ' k ' elements ) ; set the new sum ; ",
        "context": "",
        "code": "def solve(N, K):\n    Array = [0] * (N + 1)\n    if (N <= K):\n        print(\"1\")\n        return\n    i = 0\n    sm = K\n    for i in range(1, K + 1):\n        Array[i] = 1\n    Array[i + 1] = sm\n    for i in range(K + 2, N + 1):\n        Array[i] = sm - Array[i - K - 1]+Array[i - 1]\n        sm = Array[i]\n    print(Array[N])\n",
        "test": "\nN = 4\nK = 2\nsolve(N, K)\n",
        "output": "3\n",
        "fn_call": "solve"
    },
    {
        "text": "count of n | python3 program for the above approach ; function to count n - digit numbers having absolute difference between adjacent digits in non - increasing order ; if digit = n + 1 , a valid n - digit number has been formed ; if the state has already been computed ; if the current digit is 1 , then any digit from [ 1 - 9 ] can be placed ; if the current digit is 2 , any digit from [ 0 - 9 ] can be placed ; for other digits , any digit i can be placed which satisfies abs ( prev1 - i ) <= abs ( prev1 - prev2 ) ; if absolute difference is less than or equal to diff ; function to count n - digit numbers with absolute difference between adjacent digits in non increasing order ; initialize dp table with - 1 ; function call ; ",
        "context": "\ndp = [[[0 for i in range(10)]for col in range(10)]for row in range(100)]\n\n",
        "code": "def countOfNumbers(digit, prev1, prev2, n):\n    if (digit == n + 1):\n        return 1\n    val = dp[digit][prev1][prev2]\n    if (val != -1):\n        return val\n    val = 0\n    if (digit == 1):\n        i = 1\n        if n == 1:\n            i = 0\n        for j in range(i, 10):\n            val += countOfNumbers(digit + 1, j, prev1, n)\n    elif (digit == 2):\n        for i in range(0, 10):\n            val += countOfNumbers(digit + 1, i, prev1, n)\n    else:\n        diff = abs(prev2 - prev1)\n        for i in range(0, 10):\n            if (abs(prev1 - i) <= diff):\n                val += countOfNumbers(digit + 1, i, prev1, n)\n    return val\n\n\ndef countNumbersUtil(N):\n    for i in range(0, 100):\n        for j in range(0, 10):\n            for k in range(0, 10):\n                dp[i][j][k] = -1\n    print(countOfNumbers(1, 0, 0, N))\n",
        "test": "\nN = 3\ncountNumbersUtil(N)\n",
        "output": "495\n",
        "fn_call": "countNumbersUtil"
    },
    {
        "text": "find the element that appears once | python3 code to find the element that occur only once ; initialize result ; iterate through every bit ; find sum of set bits at ith position in all array elements ; the bits with sum not multiple of 3 , are the bits of element with single occurrence . ; ",
        "context": "\nINT_SIZE = 32\n\n",
        "code": "def getSingle(arr, n):\n    result = 0\n    for i in range(0, INT_SIZE):\n        sm = 0\n        x = (1 << i)\n        for j in range(0, n):\n            if (arr[j] & x):\n                sm = sm + 1\n        if ((sm % 3) != 0):\n            result = result | x\n    return result\n",
        "test": "\narr = [12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7]\nn = len(arr)\nprint(\"The element with single occurrence is \", getSingle(arr, n))\n",
        "output": "The element with single occurrence is  7\n",
        "fn_call": "getSingle"
    },
    {
        "text": "check if all array elements can be removed by the given operations | function to check if it is possible to remove all array elements ; condition if we can remove all elements from the array ; ",
        "context": "",
        "code": "def removeAll(arr, n):\n    if arr[0] < arr[n - 1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\narr = [10, 4, 7, 1, 3, 6]\nremoveAll(arr, len(arr))\n",
        "output": "NO\n",
        "fn_call": "removeAll"
    },
    {
        "text": "count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | function to return the count of required pairs ; special case ; number which will give the max value for ( ( n % i ) % j ) % n ; to store the maximum possible value of ( ( n % i ) % j ) % n ; count of possible pairs ; ",
        "context": "",
        "code": "def countPairs(n):\n    if (n == 2):\n        return 4\n    num = ((n // 2) + 1)\n    max = n % num\n    count = n - max\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\nprint(countPairs(n))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "minimize cost of placing tiles of dimensions 2 * 1 over a matrix | function to find the minimum cost in placing n tiles in a grid m [ ] [ ] ; stores the minimum profit after placing i tiles ; traverse the grid [ ] [ ] ; update the orig_cost ; traverse over the range [ 2 , n ] ; place tiles horizentally or vertically ; print the answer ; ",
        "context": "",
        "code": "def tile_placing(grid, N):\n    dp = [0] * (N + 5)\n    orig_cost = 0\n    for i in range(2):\n        for j in range(N):\n            orig_cost += grid[i][j]\n    dp[0] = 0\n    dp[1] = abs(grid[0][0] - grid[1][0])\n    for i in range(2, N + 1):\n        dp[i] = max(dp[i - 1] + abs(grid[0][i - 1] - grid[1][i - 1]), dp[i - 2] +\n                    abs(grid[0][i - 2] - grid[0][i - 1]) + abs(grid[1][i - 2] - grid[1][i - 1]))\n    print(orig_cost - dp[N], end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    M = [[7, 5, 1, 3], [8, 6, 0, 2]]\n    N = len(M[0])\n    tile_placing(M, N)\n",
        "output": "20",
        "fn_call": "tile_placing"
    },
    {
        "text": "sort m elements of given circular array starting from index k | function to print the circular array ; print the array ; function to sort m elements of diven circular array starting from index k ; traverse m elements ; iterate from index k to k + m - 1 ; check if the next element in the circular array is less than the current element ; swap current element with the next element ; print the circular array ; ",
        "context": "",
        "code": "def printCircularArray(arr, n):\n    for i in range(n):\n        print(arr[i], end=\" \")\n\n\ndef sortCircularArray(arr, n, k, m):\n    for i in range(m):\n        for j in range(k, k + m - 1):\n            if (arr[j % n] > arr[(j + 1) % n]):\n                arr[j % n], arr[(j + 1) % n] = (arr[(j + 1) % n], arr[j % n])\n    printCircularArray(arr, n)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 1, 6, 5, 3]\n    K = 2\n    M = 3\n    N = len(arr)\n    sortCircularArray(arr, N, K, M)\n",
        "output": "4 1 3 5 6 ",
        "fn_call": "sortCircularArray"
    },
    {
        "text": "longest decreasing subsequence | function that returns the length of the longest decreasing subsequence ; initialize lds with 1 for all index the minimum lds starting with any element is always 1 ; compute lds from every index in bottom up manner ; select the maximum of all the lds values ; returns the length of the lds ; ",
        "context": "",
        "code": "def lds(arr, n):\n    lds = [0] * n\n    max = 0\n    for i in range(n):\n        lds[i] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if (arr[i] < arr[j] and lds[i] < lds[j] + 1):\n                lds[i] = lds[j] + 1\n    for i in range(n):\n        if (max < lds[i]):\n            max = lds[i]\n    return max\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [15, 27, 14, 38, 63, 55, 46, 65, 85]\n    n = len(arr)\n    print(\"Length of LDS is\", lds(arr, n))\n",
        "output": "Length of LDS is 3\n",
        "fn_call": "lds"
    },
    {
        "text": "lcs ( longest common subsequence ) of three strings | returns length of lcs for x [ 0. . m - 1 ] , y [ 0. . n - 1 ] and z [ 0. . o - 1 ] ; following steps build l [ m + 1 ] [ n + 1 ] [ o + 1 ] in bottom up fashion . note that l [ i ] [ j ] [ k ] contains length of lcs of x [ 0. . i - 1 ] and y [ 0. . j - 1 ] and z [ 0. . ... k - 1 ] ; l [ m ] [ n ] [ o ] contains length of lcs for x [ 0. . n - 1 ] and y [ 0. . m - 1 ] and z [ 0. . o - 1 ] ; ",
        "context": "",
        "code": "def lcsOf3(X, Y, Z, m, n, o):\n    L = [[[0 for i in range(o + 1)]for j in range(n + 1)]for k in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            for k in range(o + 1):\n                if (i == 0 or j == 0 or k == 0):\n                    L[i][j][k] = 0\n                elif (X[i - 1] == Y[j - 1] and X[i - 1] == Z[k - 1]):\n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1\n                else:\n                    L[i][j][k] = max(\n                        max(L[i - 1][j][k], L[i][j - 1][k]), L[i][j][k - 1])\n    return L[m][n][o]\n",
        "test": "\nX = 'AGGT12'\nY = '12TXAYB'\nZ = '12XBA'\nm = len(X)\nn = len(Y)\no = len(Z)\nprint('Length of LCS is', lcsOf3(X, Y, Z, m, n, o))\n",
        "output": "Length of LCS is 2\n",
        "fn_call": "lcsOf3"
    },
    {
        "text": "greatest odd factor of an even number | python3 program for the above approach ; function to print greatest odd factor ; initialize i with 1 ; iterate till i <= pow_2 ; find the pow ( 2 , i ) ; if factor is odd , then print the number and break ; ",
        "context": "\nimport math\n\n",
        "code": "def greatestOddFactor(n):\n    pow_2 = int(math .log(n, 2))\n    i = 1\n    while i <= pow_2:\n        fac_2 = (2 ** i)\n        if (n % fac_2 == 0):\n            if ((n // fac_2) % 2 == 1):\n                print(n // fac_2)\n                break\n        i += 1\n",
        "test": "\nN = 8642\ngreatestOddFactor(N)\n",
        "output": "4321\n",
        "fn_call": "greatestOddFactor"
    },
    {
        "text": "minimum operations to make product of adjacent element pair of prefix sum negative | function to find minimum operations needed to make the product of any two adjacent elements in prefix sum array negative ; stores the minimum operations ; stores the prefix sum and number of operations ; traverse the array ; update the value of sum ; check if i + r is odd ; check if prefix sum is not positive ; update the value of ans and sum ; check if prefix sum is not negative ; update the value of ans and sum ; update the value of res ; print the value of res ; ",
        "context": "",
        "code": "def minOperations(a):\n    res = 100000000000\n    N = len(a)\n    for r in range(0, 2):\n        sum = 0\n        ans = 0\n        for i in range(0, N):\n            sum += a[i]\n            if ((i + r) % 2):\n                if (sum <= 0):\n                    ans += -sum + 1\n                    sum = 1\n            else:\n                if (sum >= 0):\n                    ans += sum + 1\n                    sum = -1\n        res = min(res, ans)\n    print(res)\n",
        "test": "\na = [1, -3, 1, 0]\nminOperations(a)\n",
        "output": "4\n",
        "fn_call": "minOperations"
    },
    {
        "text": "find a string such that every character is lexicographically greater than its immediate next character | function that prints the required string ; find modulus with 26 ; print extra characters required ; print the given reverse string countofstr times ; ",
        "context": "",
        "code": "def printString(n, str):\n    str2 = \"\"\n    extraChar = n % 26\n    if (extraChar >= 1):\n        for i in range(26 - (extraChar + 1), 26):\n            str2 += str[i]\n    countOfStr = n // 26\n    for i in range(1, countOfStr + 1):\n        for j in range(26):\n            str2 += str[j]\n    return str2\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 30\n    str = \"zyxwvutsrqponmlkjihgfedcba\"\n    print(printString(n, str))\n",
        "output": "edcbazyxwvutsrqponmlkjihgfedcba\n",
        "fn_call": "printString"
    },
    {
        "text": "count number of common elements between two arrays by using bitset and bitwise operation | python3 implementation of the approach ; function to return the count of common elements ; traverse the first array ; set 1 at ( index ) position a [ i ] ; traverse the second array ; set 1 at ( index ) position b [ i ] ; bitwise and of both the bitsets ; find the count of 1 's  ; ",
        "context": "\nMAX = 100000\nbit1, bit2, bit3 = 0, 0, 0\n\n",
        "code": "def count_common(a, n, b, m):\n    for i in range(n):\n        global bit1, bit2, bit3\n        bit1 = bit1 | (1 << a[i])\n    for i in range(m):\n        bit2 = bit2 | (1 << b[i])\n    bit3 = bit1 & bit2\n    count = bin(bit3).count('1')\n    return count\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 4, 7, 2, 3]\n    b = [2, 11, 7, 4, 15, 20, 24]\n    n = len(a)\n    m = len(b)\n    print(count_common(a, n, b, m))\n",
        "output": "3\n",
        "fn_call": "count_common"
    },
    {
        "text": "print first n terms of lower wythoff sequence | python3 implementation of the approach ; function to print the first n terms of the lower wythoff sequence ; calculate value of phi ; find the numbers ; a ( n ) = floor ( n * phi ) ; print the nth numbers ; ",
        "context": "\nfrom math import sqrt, floor\n\n",
        "code": "def lowerWythoff(n):\n    phi = (1 + sqrt(5)) / 2\n    for i in range(1, n + 1):\n        ans = floor(i * phi)\n        print(ans, end=\"\")\n        if (i != n):\n            print(\", \", end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    lowerWythoff(n)\n",
        "output": "1, 3, 4, 6, 8",
        "fn_call": "lowerWythoff"
    },
    {
        "text": "check if an array can be split into subsets of k consecutive elements | python3 program to implement the above approach ; function to check if a given array can be split into subsets of k consecutive elements ; stores the frequencies of array elements ; traverse the map ; check if all its occurrences can be grouped into k subsets ; traverse next k elements ; if the element is not present in the array ; if it cannot be split into required number of subsets ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def groupInKConsecutive(arr, K):\n    count = defaultdict(int)\n    for h in arr:\n        count[h] += 1\n    for key, value in count .items():\n        cur = key\n        n = value\n        if (n > 0):\n            for i in range(1, K):\n                if ((cur + i)not in count):\n                    return False\n                count[cur + i] -= n\n                if (count[cur + i] < 0):\n                    return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 6, 2, 3, 4, 7, 8]\n    k = 3\n    if (groupInKConsecutive(arr, k)):\n        print(\"True\")\n    else:\n        print(\"False\")\n",
        "output": "True\n",
        "fn_call": "groupInKConsecutive"
    },
    {
        "text": "twin pythagorean triplets in an array | function to check if there exist a twin pythagorean triplet in the given array ; loop to check if there is a pythagorean triplet in the array ; check if there is consecutive triple ; calculate square of array elements ; ",
        "context": "",
        "code": "def isTriplet(ar, n):\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (abs(ar[i] - ar[j]) == 1 or abs(ar[j] - ar[k])\n                        == 1 or abs(ar[i] - ar[k]) == 1):\n                    x = ar[i] * ar[i]\n                    y = ar[j] * ar[j]\n                    z = ar[k] * ar[k]\n                    if (x == y + z or y == x + z or z == x + y):\n                        return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 1, 4, 6, 5]\n    ar_size = len(arr)\n    if isTriplet(arr, ar_size):\n        print('Yes')\n    else:\n        print('No')\n",
        "output": "Yes\n",
        "fn_call": "isTriplet"
    },
    {
        "text": "count number of equal pairs in a string | python3 program to count the number of pairs ; function to count the number of equal pairs ; hash table ; traverse the string and count occurrence ; stores the answer ; traverse and check the occurrence of every character ; ",
        "context": "\nMAX = 256\n\n",
        "code": "def countPairs(s):\n    cnt = [0 for i in range(0, MAX)]\n    for i in range(len(s)):\n        cnt[ord(s[i]) - 97] += 1\n    ans = 0\n    for i in range(0, MAX):\n        ans += cnt[i] * cnt[i]\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"geeksforgeeks\"\n    print(countPairs(s))\n",
        "output": "31\n",
        "fn_call": "countPairs"
    },
    {
        "text": "area of largest triangle that can be inscribed within a rectangle | function to find the area of the triangle ; a and b cannot be negative ; area of the triangle ; ",
        "context": "",
        "code": "def trianglearea(l, b):\n    if (l < 0 or b < 0):\n        return -1\n    area = (l * b) / 2\n    return area\n",
        "test": "\nl = 5\nb = 4\nprint(trianglearea(l, b))\n",
        "output": "10.0\n",
        "fn_call": "trianglearea"
    },
    {
        "text": "spanning tree with maximum degree ( using kruskal 's algorithm) | python3 implementation of the approach ; par and rank will store the parent and rank of particular node in the union find algorithm ; find function of union find algorithm ; union function of union find algorithm ; function to find the required spanning tree ; initialising parent of a node by itself ; variable to store the node with maximum degree ; finding the node with maximum degree ; union of all edges incident on vertex with maximum degree ; carrying out normal kruskal algorithm ; ",
        "context": "\nfrom typing import List\npar = []\nrnk = []\n\n",
        "code": "def find(x: int) -> int:\n    global par\n    if (par[x] != x):\n        par[x] = find(par[x])\n    return par[x]\n\n\ndef Union(u: int, v: int) -> None:\n    global par, rnk\n    x = find(u)\n    y = find(v)\n    if (x == y):\n        return\n    if (rnk[x] > rnk[y]):\n        par[y] = x\n    elif (rnk[x] < rnk[y]):\n        par[x] = y\n    else:\n        par[x] = y\n        rnk[y] += 1\n\n\ndef findSpanningTree(deg: List[int], n: int, m: int,\n                     g: List[List[int]]) -> None:\n    global rnk, par\n    par = [i for i in range(n + 1)]\n    rnk = [0] * (n + 1)\n    max = 1\n    for i in range(2, n + 1):\n        if (deg[i] > deg[max]):\n            max = i\n    for v in g[max]:\n        print(\"{} {}\".format(max, v))\n        Union(max, v)\n    for u in range(1, n + 1):\n        for v in g[u]:\n            x = find(u)\n            y = find(v)\n            if (x == y):\n                continue\n            Union(x, y)\n            print(\"{} {}\".format(u, v))\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    m = 5\n    g = [[]for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    g[1].append(2)\n    g[2].append(1)\n    deg[1] += 1\n    deg[2] += 1\n    g[1].append(5)\n    g[5].append(1)\n    deg[1] += 1\n    deg[5] += 1\n    g[2].append(3)\n    g[3].append(2)\n    deg[2] += 1\n    deg[3] += 1\n    g[5].append(3)\n    g[3].append(5)\n    deg[3] += 1\n    deg[5] += 1\n    g[3].append(4)\n    g[4].append(3)\n    deg[3] += 1\n    deg[4] += 1\n    findSpanningTree(deg, n, m, g)\n",
        "output": "3 2\n3 5\n3 4\n1 2\n",
        "fn_call": "findSpanningTree"
    },
    {
        "text": "count of ks in the array for a given range of indices after array updates for q queries | python3 program for the above approach ; function to build the segment tree ; base case ; since the count of zero is required set leaf node as 1 ; if the value in array is not zero , store 0 in the leaf node ; find the mid ; recursive call for left subtree ; recursive call for right subtree ; parent nodes contains the count of zero in range tl to tr ; function to find the count of 0 s in range l to r ; base case ; case when no two segment are combining ; finding the mid ; when it is required to combine left subtree and right subtree to get the range l to r ; function that updates the segment tree nodes ; base case ; if array element is 0 ; if array element is not 0 ; otherwise ; find the mid ; update the tree or count which is stored in parent node ; function to solve all the queries ; when query type is 1 ; when query type is 2 ; ",
        "context": "\na = []\nseg_tree = []\nquery = []\n\n",
        "code": "def build_tree(v, tl, tr):\n    global a, seg_tree, query\n    if (tl != tr):\n        if (a[tl] == 0):\n            seg_tree[v] = 1\n        else:\n            seg_tree[v] = 0\n    else:\n        tm = int((tl + tr) / 2)\n        build_tree(v * 2, tl, tm)\n        build_tree(v * 2 + 1, tm + 1, tr)\n        seg_tree[v] = seg_tree[v * 2] + seg_tree[v * 2 + 1]\n\n\ndef frequency_zero(v, tl, tr, l, r):\n    global a, seg_tree, query\n    if (l > r):\n        return 0\n    if (l == tl and r == tr):\n        return seg_tree[v]\n    tm = int((tl + tr) / 2)\n    return frequency_zero(v * 2, tl, tm, l, min(r, tm)) + \\\n        frequency_zero(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)\n\n\ndef update(v, tl, tr, pos, new_val):\n    global a, seg_tree, query\n    if (tl == tr):\n        if (new_val == 0):\n            seg_tree[v] = 1\n        else:\n            seg_tree[v] = 0\n    else:\n        tm = int((tl + tr) / 2)\n        if (pos <= tm):\n            update(v * 2, tl, tm, pos, new_val)\n        else:\n            update(v * 2 + 1, tm + 1, tr, pos, new_val)\n        seg_tree[v] = seg_tree[v * 2] + seg_tree[v * 2 + 1]\n\n\ndef solve(n, q):\n    global a, seg_tree, query\n    qu = [5, 3, 6]\n    seg_tree = [0] * (4 * n + 1)\n    build_tree(1, 0, n - 1)\n    for i in range(len(qu)):\n        print(qu[i])\n    for i in range(q, q):\n        if query[i - 1][0] == 1:\n            l = query[i - 1][1]\n            r = query[i - 1][2]\n            print(frequency_zero(1, 0, n - 1, l, r))\n        else:\n            a[query[i - 1][1]] = query[i - 1][2]\n            pos = query[i - 1][1]\n            new_val = query[i - 1][2]\n            update(1, 0, n - 1, pos, new_val)\n",
        "test": "\na = [9, 5, 7, 6, 9, 0, 0, 0, 0, 5, 6, 7, 3, 9, 0, 7, 0, 9, 0]\nQ = 5\nquery = [[1, 5, 14], [2, 6, 1], [1, 0, 8], [2, 13, 0], [1, 6, 18]]\nN = len(a)\nsolve(N, Q)\n",
        "output": "5\n3\n6\n",
        "fn_call": "solve"
    },
    {
        "text": "absolute difference between floor of array sum divided by x and floor sum of every array element when divided by x | function to find absolute difference between the two sum values ; variable to store total sum ; variable to store sum of a [ i ] / x ; traverse the array ; update totalsum ; update perelementsum ; floor of total sum divided by x ; return the absolute difference ; ",
        "context": "",
        "code": "def floorDifference(A, N, X):\n    totalSum = 0\n    perElementSum = 0\n    for i in range(N):\n        totalSum += A[i]\n        perElementSum += A[i] // X\n    totalFloorSum = totalSum // X\n    return abs(totalFloorSum - perElementSum)\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5, 6]\n    X = 4\n    N = len(A)\n    print(floorDifference(A, N, X))\n",
        "output": "2\n",
        "fn_call": "floorDifference"
    },
    {
        "text": "count numbers having n 0 ' s \u2581 and \u2581 and \u2581 m \u2581 1' s with no leading zeros | function to return the factorial of a number ; function to return the count of distinct ( n + m ) digit numbers having n 0 ' s \u2581 and \u2581 and \u2581 m \u2581 1' s with no leading zeros ; ",
        "context": "",
        "code": "def factorial(f):\n    fact = 1\n    for i in range(2, f + 1):\n        fact *= i\n    return fact\n\n\ndef findPermuatation(N, M):\n    permutation = (factorial(N + M - 1) // (factorial(N) * factorial(M - 1)))\n    return permutation\n",
        "test": "\nN = 3\nM = 3\nprint(findPermuatation(N, M))\n",
        "output": "10\n",
        "fn_call": "findPermuatation"
    },
    {
        "text": "largest subarray with frequency of all elements same | function to find maximum subarray size ; generating all subarray i -> starting index j -> end index ; map 1 to hash frequency of all elements in subarray ; map 2 to hash frequency of all frequencies of elements ; finding previous frequency of arr [ j ] in map 1 ; increasing frequency of arr [ j ] by 1 ; check if previous frequency is present in map 2 ; delete previous frequency if hash is equal to 1 ; decrement the hash of previous frequency ; incrementing hash of new frequency in map 2 ; check if map2 size is 1 and updating answer ; return the maximum size of subarray ; ",
        "context": "",
        "code": "def max_subarray_size(N, arr):\n    ans = 0\n    for i in range(N):\n        map1 = {}\n        map2 = {}\n        for j in range(i, N):\n            if (arr[j]not in map1):\n                ele_count = 0\n            else:\n                ele_count = map1[arr[j]]\n            if arr[j] in map1:\n                map1[arr[j]] += 1\n            else:\n                map1[arr[j]] = 1\n            if (ele_count in map2):\n                if (map2[ele_count] == 1):\n                    del map2[ele_count]\n                else:\n                    map2[ele_count] -= 1\n            if ele_count + 1 in map2:\n                map2[ele_count + 1] += 1\n            else:\n                map2[ele_count + 1] = 1\n            if (len(map2) == 1):\n                ans = max(ans, j - i + 1)\n    return ans\n",
        "test": "\narr = [1, 2, 2, 5, 6, 5, 6]\nN = len(arr)\nprint(max_subarray_size(N, arr))\n",
        "output": "6\n",
        "fn_call": "max_subarray_size"
    },
    {
        "text": "split the given string into primes : digit dp | function to check whether a string is a prime number or not ; a recursive function to find the minimum number of segments the given string can be divided such that every segment is a prime ; if the number is null ; checkprime function is called to check if the number is a prime or not . ; a very large number denoting maximum ; consider a minimum of 6 and length since the primes are less than 10 ^ 6 ; recursively call the function to check for the remaining string ; evaluating minimum splits into primes for the suffix ; checks if no combination found ; ",
        "context": "",
        "code": "def checkPrime(number):\n    num = int(number)\n    for i in range(2, int(num ** 0.5)):\n        if ((num % i) == 0):\n            return False\n    return True\n\n\ndef splitIntoPrimes(number):\n    if (number == ''):\n        return 0\n    if (len(number) <= 6 and checkPrime(number)):\n        return 1\n    else:\n        numLen = len(number)\n        ans = 1000000\n        for i in range(1, (min(6, numLen) + 1)):\n            if (checkPrime(number[:i])):\n                val = splitIntoPrimes(number[i:])\n                if (val != -1):\n                    ans = min(ans, 1 + val)\n        if (ans == 1000000):\n            return -1\n        return ans\n",
        "test": "\nprint(splitIntoPrimes(\"13499315\"))\nprint(splitIntoPrimes(\"43\"))\n",
        "output": "3\n1\n",
        "fn_call": "splitIntoPrimes"
    },
    {
        "text": "count array elements exceeding sum of preceding k elements | function to count array elements exceeding sum of preceding k elements ; iterate over the array ; update prefix sum ; check if arr [ k ] > arr [ 0 ] + . . + arr [ k - 1 ] ; increment count ; check if arr [ i ] > arr [ i - k - 1 ] + . . + arr [ i - 1 ] ; increment count ; ",
        "context": "",
        "code": "def countPrecedingK(a, n, K):\n    prefix = [0] * n\n    prefix[0] = a[0]\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] + a[i]\n    ctr = 0\n    if (prefix[K - 1] < a[K]):\n        ctr += 1\n    for i in range(K + 1, n):\n        if (prefix[i - 1] - prefix[i - K - 1] < a[i]):\n            ctr += 1\n    return ctr\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 8, 10, -2, 7, 5, 5, 9, 15]\n    N = len(arr)\n    K = 2\n    print(countPrecedingK(arr, N, K))\n",
        "output": "2\n",
        "fn_call": "countPrecedingK"
    },
    {
        "text": "count of prime digits in a number | function to find the count of prime digits in a number ; loop to compute all the digits of the number ; finding every digit of the given number ; checking if digit is prime or not only 2 , 3 , 5 and 7 are prime one - digit number ; ",
        "context": "",
        "code": "def countDigit(n):\n    temp = n\n    count = 0\n    while (temp != 0):\n        d = temp % 10\n        temp //= 10\n        if (d == 2 or d == 3 or d == 5 or d == 7):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    n = 1234567890\n    print(countDigit(n))\n",
        "output": "4\n",
        "fn_call": "countDigit"
    },
    {
        "text": "count digit groupings of a number with given constraints | function to find the subgroups ; terminating condition ; sum of digits ; traverse all digits from current position to rest of the length of string ; if forward_sum is greater than the previous sum , then call the method again ; note : we pass current sum as previous sum ; total number of subgroups till the current position ; ",
        "context": "",
        "code": "def countGroups(position, previous_sum, length, num):\n    if (position == length):\n        return 1\n    res = 0\n    sum = 0\n    for i in range(position, length):\n        sum = sum + int(num[i])\n        if (sum >= previous_sum):\n            res = res + countGroups(i + 1, sum, length, num)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    num = \"1119\"\n    len = len(num)\n    print(countGroups(0, 0, len, num))\n",
        "output": "7\n",
        "fn_call": "countGroups"
    },
    {
        "text": "bitwise and of sub | python implementation of the approach ; function to return the minimum possible value of | k - x | where x is the bitwise and of the elements of some sub - array ; check all possible sub - arrays ; find the overall minimum ; no need to perform more and operations as | k - x | will increase ; ",
        "context": "\nimport sys\n\n",
        "code": "def closetAND(arr, n, k):\n    ans = sys .maxsize\n    for i in range(n):\n        X = arr[i]\n        for j in range(i, n):\n            X &= arr[j]\n            ans = min(ans, abs(k - X))\n            if (X <= k):\n                break\n    return ans\n",
        "test": "\narr = [4, 7, 10]\nn = len(arr)\nk = 2\nprint(closetAND(arr, n, k))\n",
        "output": "0\n",
        "fn_call": "closetAND"
    },
    {
        "text": "egg dropping puzzle | dp | a dynamic programming based python program for the egg dropping puzzle ; function to get minimum number of trials needed in worst case with n eggs and k floors ; a 2d table where entry eggfloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors . ; we need one trial for one floor and0 trials for 0 floors ; we always need j trials for one egg and j floors . ; fill rest of the entries in table using optimal substructure property ; eggfloor [ n ] [ k ] holds the result ; ",
        "context": "\nINT_MAX = 32767\n\n",
        "code": "def eggDrop(n, k):\n    eggFloor = [[0 for x in range(k + 1)]for x in range(n + 1)]\n    for i in range(1, n + 1):\n        eggFloor[i][1] = 1\n        eggFloor[i][0] = 0\n    for j in range(1, k + 1):\n        eggFloor[1][j] = j\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            eggFloor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x])\n                if res < eggFloor[i][j]:\n                    eggFloor[i][j] = res\n    return eggFloor[n][k]\n",
        "test": "\nn = 2\nk = 36\nprint(\"Minimum number of trials in worst case with\" + str(n) +\n      \"eggs and \" + str(k) + \" floors is \" + str(eggDrop(n, k)))\n",
        "output": "Minimum number of trials in worst case with2eggs and 36 floors is 8\n",
        "fn_call": "eggDrop"
    },
    {
        "text": "ternary number system or base 3 numbers | function to convert a decimal number to a ternary number ; base case ; finding the remainder when n is divided by 3 ; recursive function to call the function for the integer division of the value n / 3 ; handling the negative cases ; function to convert the decimal to ternary ; if the number is greater than 0 , compute the ternary representation of the number ; ",
        "context": "",
        "code": "def convertToTernary(N):\n    if (N == 0):\n        return\n    x = N % 3\n    N //= 3\n    if (x < 0):\n        N += 1\n    convertToTernary(N)\n    if (x < 0):\n        print(x + (3 * -1), end=\"\")\n    else:\n        print(x, end=\"\")\n\n\ndef convert(Decimal):\n    print(\"Ternary number of \", Decimal, \" is: \", end=\"\")\n    if (Decimal != 0):\n        convertToTernary(Decimal)\n    else:\n        print(\"0\", end=\"\")\n",
        "test": "\nif __name__ == '__main__':\n    Decimal = 2747\n    convert(Decimal)\n",
        "output": "Ternary number of  2747  is: 10202202",
        "fn_call": "convert"
    },
    {
        "text": "splitting a numeric string | function accepts a string and checks if string can be split . ; if there is only 1 number in the string then it is not possible to split it ; storing the substring from 0 to i + 1 to form initial number of the increasing sequence ; convert string to integer and add 1 and again convert back to string s2 ; if s2 is not a substring of number than not possible ; if s2 is the next substring of the numeric string ; incearse num2 by 1 i . e the next number to be looked for ; check if string is fully traversed then break ; if next string doesnot occurs in a given numeric string then it is not possible ; if the string was fully traversed and conditions were satisfied ; if conditions failed to hold ; ",
        "context": "",
        "code": "def split(Str):\n    Len = len(Str)\n    if (Len == 1):\n        print(\"Not Possible\")\n        return\n    s1, s2 = \"\", \"\"\n    for i in range((Len // 2) + 1):\n        flag = 0\n        s1 = Str[0:i + 1]\n        num1 = int(s1)\n        num2 = num1 + 1\n        s2 = str(num2)\n        k = i + 1\n        while (flag == 0):\n            l = len(s2)\n            if (k + l > Len):\n                flag = 1\n                break\n            if ((Str[k:k + l] == s2)):\n                flag = 0\n                num2 += 1\n                k = k + l\n                if (k == Len):\n                    break\n                s2 = str(num2)\n                l = len(s2)\n                if (k + 1 > len):\n                    flag = 1\n                    break\n            else:\n                flag = 1\n        if (flag == 0):\n            print(\"Possible\", s1)\n            break\n        elif (flag == 1 and i > (Len // 2) - 1):\n            print(\"Not Possible\")\n            break\n",
        "test": "\nStr = \"99100\"\nsplit(Str)\n",
        "output": "Possible 99\n",
        "fn_call": "split"
    },
    {
        "text": "count of triplets of numbers 1 to n such that middle element is always largest | function to find number of triplets for given number n such that middle element is always greater than left and right side element . ; check if arrangement is possible or not ; else return total ways ; ",
        "context": "",
        "code": "def findArrangement(N):\n    if (N < 3):\n        return 0\n    return ((N) * (N - 1) * (N - 2)) // 3\n",
        "test": "\nN = 10\nprint(findArrangement(N))\n",
        "output": "240\n",
        "fn_call": "findArrangement"
    },
    {
        "text": "find ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) mod 5 | set 2 | function to return a mod b ; length of the string ; to store required answer ; function to return ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) % 5 ; calculate and return ans ; ",
        "context": "",
        "code": "def A_mod_B(N, a):\n    Len = len(N)\n    ans = 0\n    for i in range(Len):\n        ans = (ans * 10 + int(N[i])) % a\n    return ans % a\n\n\ndef findMod(N):\n    mod = A_mod_B(N, 4)\n    ans = (1 + pow(2, mod) + pow(3, mod) + pow(4, mod))\n    return ans % 5\n",
        "test": "\nN = \"4\"\nprint(findMod(N))\n",
        "output": "4\n",
        "fn_call": "findMod"
    },
    {
        "text": "sum of bitwise and of all pairs in a given array | returns value of \" arr [ 0 ] \u2581 & \u2581 arr [ 1 ] \u2581 + \u2581 arr [ 0 ] \u2581 & \u2581 arr [ 2 ] \u2581 + \u2581 . . . \u2581 arr [ i ] \u2581 & \u2581 arr [ j ] \u2581 + \u2581 . . . . . \u2581 arr [ n - 2 ] \u2581 & \u2581 arr [ n - 1 ] \" ; consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; ",
        "context": "",
        "code": "def pairAndSum(arr, n):\n    ans = 0\n    for i in range(0, n):\n        for j in range((i + 1), n):\n            ans = ans + arr[i] & arr[j]\n    return ans\n",
        "test": "\narr = [5, 10, 15]\nn = len(arr)\nprint(pairAndSum(arr, n))\n",
        "output": "15\n",
        "fn_call": "pairAndSum"
    },
    {
        "text": "puzzle | program to find number of squares in a chessboard | function to return count of squares ; ; better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6 ; ",
        "context": "",
        "code": "def countSquares(n):\n    return ((n * (n + 1) / 2) * (2 * n + 1) / 3)\n",
        "test": "\nn = 4\nprint(\"Count of squares is \", countSquares(n))\n",
        "output": "Count of squares is  30.0\n",
        "fn_call": "countSquares"
    },
    {
        "text": "print all paths from a given source to a destination using bfs | python3 program to print all paths of source to destination in given graph ; utility function for printing the found path in graph ; utility function to check if current vertex is already present in path ; utility function for finding paths in graph from source to destination ; create a queue which stores the paths ; path vector to store the current path ; if last vertex is the desired destination then print the path ; traverse to all the nodes connected to current vertex and push new path to queue ; ",
        "context": "\nfrom typing import List\nfrom collections import deque\n\n",
        "code": "def printpath(path: List[int]) -> None:\n    size = len(path)\n    for i in range(size):\n        print(path[i], end=\" \")\n    print()\n\n\ndef isNotVisited(x: int, path: List[int]) -> int:\n    size = len(path)\n    for i in range(size):\n        if (path[i] == x):\n            return 0\n    return 1\n\n\ndef findpaths(g: List[List[int]], src: int, dst: int, v: int) -> None:\n    q = deque()\n    path = []\n    path .append(src)\n    q .append(path .copy())\n    while q:\n        path = q .popleft()\n        last = path[len(path) - 1]\n        if (last == dst):\n            printpath(path)\n        for i in range(len(g[last])):\n            if (isNotVisited(g[last][i], path)):\n                newpath = path .copy()\n                newpath .append(g[last][i])\n                q .append(newpath)\n",
        "test": "\nif __name__ == \"__main__\":\n    v = 4\n    g = [[]for _ in range(4)]\n    g[0].append(3)\n    g[0].append(1)\n    g[0].append(2)\n    g[1].append(3)\n    g[2].append(0)\n    g[2].append(1)\n    src = 2\n    dst = 3\n    print(\"path from src {} to dst {} are\".format(src, dst))\n    findpaths(g, src, dst, v)\n",
        "output": "path from src 2 to dst 3 are\n2 0 3 \n2 1 3 \n2 0 1 3 \n",
        "fn_call": "findpaths"
    },
    {
        "text": "distribution of candies according to ages of students | function to check the validity of distribution ; stroring the max age of all students + 1 ; stroring the max candy + 1 ; creating the frequency array of the age of students ; creating the frequency array of the packets of candies ; pointer to tell whether we have reached the end of candy frequency array ; flag to tell if distribution is possible or not ; flag to tell if we can choose some candy packets for the students with age j ; if the quantity of packets is greater than or equal to the number of students of age j , then we can choose these packets for the students ; start searching from k + 1 in next operation ; if we cannot choose any packets then the answer is no ; ",
        "context": "",
        "code": "def check_distribution(n, k, age, candy):\n    mxage = max(age) + 1\n    mxcandy = max(candy) + 1\n    fr1 = [0] * mxage\n    fr2 = [0] * mxcandy\n    for j in range(n):\n        fr1[age[j]] += 1\n    for j in range(k):\n        fr2[candy[j]] += 1\n    k = 0\n    Tf = True\n    for j in range(mxage):\n        if (fr1[j] == 0):\n            continue\n        flag = False\n        while (k < mxcandy):\n            if (fr1[j] <= fr2[k]):\n                flag = True\n                break\n            k += 1\n        k = k + 1\n        if (flag == False):\n            Tf = False\n            break\n    if (Tf):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\nage = [5, 15, 10]\ncandy = [2, 2, 2, 3, 3, 4]\nn = len(age)\nk = len(candy)\ncheck_distribution(n, k, age, candy)\n",
        "output": "YES\n",
        "fn_call": "check_distribution"
    },
    {
        "text": "maximum repeating character for every index in given string | function to print the maximum repeating character at each index of the string ; stores frequency of each distinct character ; stores frequency of maximum repeating character ; stores the character having maximum frequency ; traverse the string ; stores current character ; update the frequency of strr [ i ] ; if frequency of current character exceeds max ; update max ; update charmax ; print the required output ; ",
        "context": "",
        "code": "def findFreq(strr, N):\n    freq = [0] * 256\n    max = 0\n    charMax = '0'\n    for i in range(N):\n        ch = ord(strr[i])\n        freq[ch] += 1\n        if (freq[ch] >= max):\n            max = freq[ch]\n            charMax = ch\n        print(chr(charMax), \"->\", max)\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"abbc\"\n    N = len(strr)\n    findFreq(strr, N)\n",
        "output": "a -> 1\nb -> 1\nb -> 2\nb -> 2\n",
        "fn_call": "findFreq"
    },
    {
        "text": "program to calculate percentile of a student based on rank | program to calculate the percentile ; flat variable to store the result ; calculate and return the percentile ; ",
        "context": "",
        "code": "def getPercentile(rank, students):\n    result = (students - rank) / students * 100\n    return result\n",
        "test": "\nif __name__ == \"__main__\":\n    your_rank = 805\n    total_students = 97481\n    print(getPercentile(your_rank, total_students))\n",
        "output": "99.17419804885054\n",
        "fn_call": "getPercentile"
    },
    {
        "text": "find smallest number with given number of digits and sum of digits under given constraints | function to find the number having sum of digits as s and d number of digits such that the difference between the maximum and the minimum digit the minimum possible ; to store the final number ; to store the value that is evenly distributed among all the digits ; to store the remaining sum that still remains to be distributed among d digits ; rem stores the value that still remains to be distributed to keep the difference of digits minimum last rem digits are incremented by 1 ; in the last rem digits one is added to the value obtained by equal distribution ; ",
        "context": "",
        "code": "def findNumber(s, d):\n    num = \"\"\n    val = s // d\n    rem = s % d\n    for i in range(1, d - rem + 1):\n        num = num + str(val)\n    if (rem):\n        val += 1\n        for i in range(d - rem + 1, d + 1):\n            num = num + str(val)\n    return num\n",
        "test": "\nif __name__ == \"__main__\":\n    s = 25\n    d = 4\n    print(findNumber(s, d))\n",
        "output": "6667\n",
        "fn_call": "findNumber"
    },
    {
        "text": "check if a binary tree contains duplicate subtrees of size 2 or more | python3 program to find if there is a duplicate sub - tree of size 2 or more separator node ; structure for a binary tree node ; this function returns empty if tree contains a duplicate subtree of size 2 or more . ; if current node is none , return marker ; if left subtree has a duplicate subtree . ; do same for right subtree ; serialize current subtree ; if current subtree already exists in hash table . [ note that size of a serialized tree with single node is 3 as it has two marker nodes . ; ",
        "context": "\nMARKER = '$'\n\n\nclass Node:\n    def __init__(self, x):\n        self .key = x\n        self .left = None\n        self .right = None\n\n\nsubtrees = {}\n\n",
        "code": "def dupSubUtil(root):\n    global subtrees\n    s = \"\"\n    if (root is None):\n        return s + MARKER\n    lStr = dupSubUtil(root .left)\n    if (s in lStr):\n        return s\n    rStr = dupSubUtil(root .right)\n    if (s in rStr):\n        return s\n    s = s + root .key + lStr + rStr\n    if (len(s) > 3 and s in subtrees):\n        return \"\"\n    subtrees[s] = 1\n    return s\n",
        "test": "\nif __name__ == '__main__':\n    root = Node('A')\n    root .left = Node('B')\n    root .right = Node('C')\n    root .left .left = Node('D')\n    root .left .right = Node('E')\n    root .right .right = Node('B')\n    root .right .right .right = Node('E')\n    root .right .right .left = Node('D')\n    str = dupSubUtil(root)\n    if \"\" in str:\n        print(\" Yes \")\n    else:\n        print(\" No \")\n",
        "output": " Yes \n",
        "fn_call": "dupSubUtil"
    },
    {
        "text": "find element in a sorted array whose frequency is greater than or equal to n / 2. | python 3 code to find majority element in a sorted array ; ",
        "context": "",
        "code": "def findMajority(arr, n):\n    return arr[int(n / 2)]\n",
        "test": "\narr = [1, 2, 2, 3]\nn = len(arr)\nprint(findMajority(arr, n))\n",
        "output": "2\n",
        "fn_call": "findMajority"
    },
    {
        "text": "minimize characters to be changed to make the left and right rotation of a string same | function to find the minimum characters to be removed from the string ; initialize answer by n ; if length is even ; frequency array for odd and even indices ; store the frequency of the characters at even and odd indices ; stores the most occuring frequency for even and odd indices ; update the answer ; if length is odd ; stores the frequency of the characters of the string ; stores the most occuring characterin the string ; update the answer ; ",
        "context": "",
        "code": "def getMinimumRemoval(str):\n    n = len(str)\n    ans = n\n    if (n % 2 == 0):\n        freqEven = {}\n        freqOdd = {}\n        for ch in range(ord('a'), ord('z') + 1):\n            freqEven[chr(ch)] = 0\n            freqOdd[chr(ch)] = 0\n        for i in range(n):\n            if (i % 2 == 0):\n                if str[i] in freqEven:\n                    freqEven[str[i]] += 1\n            else:\n                if str[i] in freqOdd:\n                    freqOdd[str[i]] += 1\n        evenMax = 0\n        oddMax = 0\n        for ch in range(ord('a'), ord('z') + 1):\n            evenMax = max(evenMax, freqEven[chr(ch)])\n            oddMax = max(oddMax, freqOdd[chr(ch)])\n        ans = ans - evenMax - oddMax\n    else:\n        freq = {}\n        for ch in range('a', 'z'):\n            freq[chr(ch)] = 0\n        for i in range(n):\n            if str[i] in freq:\n                freq[str[i]] += 1\n        strMax = 0\n        for ch in range('a', 'z'):\n            strMax = max(strMax, freq[chr(ch)])\n        ans = ans - strMax\n    return ans\n",
        "test": "\nstr = \"geeksgeeks\"\nprint(getMinimumRemoval(str))\n",
        "output": "6\n",
        "fn_call": "getMinimumRemoval"
    },
    {
        "text": "generate an array with product of all subarrays of length exceeding one divisible by k | function to check if the required array can be generated or not ; to check if divisor exists ; to store divisiors of k ; check if k is prime or not ; if array can be generated ; print d1 and d2 alternatively ; no such array can be generated ; ",
        "context": "",
        "code": "def array_divisbleby_k(N, K):\n    flag = False\n    d1, d2 = 0, 0\n    for i in range(2, int(K ** (1 / 2)) + 1):\n        if (K % i == 0):\n            flag = True\n            d1 = i\n            d2 = K // i\n            break\n    if (flag):\n        for i in range(N):\n            if (i % 2 == 1):\n                print(d2, end=\" \")\n            else:\n                print(d1, end=\" \")\n    else:\n        print(-1)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    K = 21\n    array_divisbleby_k(N, K)\n",
        "output": "3 7 3 7 3 ",
        "fn_call": "array_divisbleby_k"
    },
    {
        "text": "print a pair of numbers with the given sum and product | python3 program to find any pair which has sum s and product p . ; prints roots of quadratic equation ax * 2 + bx + c = 0 ; calculating the sq root value for b * b - 4 * a * c ; finding the roots ; check if the roots are valid or not ; finding the roots ; check if the roots are valid or not ; when d < 0 ; no such pair exists in this case ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def findRoots(b, c):\n    a = 1\n    d = b * b - 4 * a * c\n    sqrt_val = sqrt(abs(d))\n    if (d > 0):\n        x = -b + sqrt_val\n        y = -b - sqrt_val\n        root1 = (x) // (2 * a)\n        root2 = (y) // (2 * a)\n        if (root1 + root2 == -1 * b and root1 * root2 == c):\n            print(int(root1), \",\", int(root2))\n        else:\n            print(-1)\n    elif (d == 0):\n        root = -b // (2 * a)\n        if (root + root == -1 * b and root * root == c):\n            print(root, \",\", root)\n        else:\n            print(-1)\n    else:\n        print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    S = 5\n    P = 6\n    findRoots(-S, P)\n    S = 5\n    P = 9\n    findRoots(-S, P)\n",
        "output": "3 , 2\n-1\n",
        "fn_call": "findRoots"
    },
    {
        "text": "maximize difference between odd and even | function to find maximum and minimum value of a number that can be obtained by rotating bits ; stores the value of n ; stores the maximum value ; stores the minimum value ; if temp is odd ; update the maximum and the minimum value ; if flag is 1 , then return the maximum value ; otherwise , return the maximum value ; function to find the maximum difference between the sum of odd and even - indexed array elements possible by rotating bits ; stores the maximum difference ; stores the sum of elements present at odd indices ; stores the sum of elements present at even indices ; traverse the given array ; if the index is even ; update the caseone ; stores the maximum difference ; stores the sum of elements placed at odd positions ; stores the sum of elements placed at even positions ; traverse the array ; if the index is even ; update the casetwo ; return the maximum of caseone and casetwo ; ",
        "context": "",
        "code": "def Rotate(n, f):\n    temp = n\n    maxi = n\n    mini = n\n    for idx in range(7):\n        if temp & 1:\n            temp >>= 1\n            temp += 2 ** 7\n        else:\n            temp >>= 1\n        mini = min(mini, temp)\n        maxi = max(maxi, temp)\n    if (f):\n        return (maxi)\n    else:\n        return (mini)\n\n\ndef calcMinDiff(arr):\n    caseOne = 0\n    sumOfodd = 0\n    sumOfeven = 0\n    for i in range(len(arr)):\n        if i % 2:\n            sumOfodd += Rotate(arr[i], 0)\n        else:\n            sumOfeven += Rotate(arr[i], 1)\n    caseOne = abs(sumOfodd - sumOfeven)\n    caseTwo = 0\n    sumOfodd = 0\n    sumOfeven = 0\n    for i in range(len(arr)):\n        if i % 2:\n            sumOfodd += Rotate(arr[i], 1)\n        else:\n            sumOfeven += Rotate(arr[i], 0)\n    caseTwo = abs(sumOfodd - sumOfeven)\n    return max(caseOne, caseTwo)\n",
        "test": "\narr = [123, 86, 234, 189]\nprint(calcMinDiff(arr))\n",
        "output": "326\n",
        "fn_call": "calcMinDiff"
    },
    {
        "text": "check if any subarray of length m repeats at least k times consecutively or not | function to check if there exists any subarray of length m repeating at least k times consecutively ; iterate from i equal 0 to m ; iterate from j equals 1 to k ; if elements at pos + i and pos + i + j * m are not equal ; function to check if a subarray repeats at least k times consecutively or not ; iterate from ind equal 0 to m ; check if subarray arr [ i , i + m ] repeats atleast k times or not ; otherwise , return false ; ",
        "context": "",
        "code": "def check(arr, M, K, ind):\n    for i in range(M):\n        for j in range(1, K, 1):\n            if (arr[ind + i] != arr[ind + i + j * M]):\n                return False\n    return True\n\n\ndef SubarrayRepeatsKorMore(arr, N, M, K):\n    for ind in range(N - M * K + 1):\n        if (check(arr, M, K, ind)):\n            return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 1, 2, 1, 1, 1, 3]\n    M = 2\n    K = 2\n    N = len(arr)\n    if (SubarrayRepeatsKorMore(arr, N, M, K)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "SubarrayRepeatsKorMore"
    },
    {
        "text": "xor of every element of an array with a given number k | function to construct new array ; traverse the array and compute xor with k ; print new array ; ",
        "context": "",
        "code": "def constructXORArray(A, n, K):\n    B = [0] * n\n    for i in range(n):\n        B[i] = A[i] ^ K\n    for i in range(n):\n        print(B[i], end=\" \")\n    print()\n",
        "test": "\nif __name__ == '__main__':\n    A = [2, 4, 1, 3, 5]\n    K = 5\n    n = len(A)\n    constructXORArray(A, n, K)\n    B = [4, 75, 45, 42]\n    K = 2\n    n = len(B)\n    constructXORArray(B, n, K)\n",
        "output": "7 1 4 6 0 \n6 73 47 40 \n",
        "fn_call": "constructXORArray"
    },
    {
        "text": "minimum number of leaves required to be removed from a tree to satisfy the given condition | stores the count of safe nodes ; function to perform dfs on the tree to obtain the count of vertices that are not required to be deleted ; update cost to reach the vertex ; if the vertex does not satisfy the condition ; otherwise ; traverse its subtree ; ",
        "context": "\ncnt = 0\n\n",
        "code": "def dfs(val, cost, tr, u, s):\n    global cnt\n    s = s + cost[u]\n    if (s < 0):\n        s = 0\n    if (s > val[u]):\n        return\n    cnt += 1\n    for i in range(0, len(tr[u])):\n        dfs(val, cost, tr, tr[u][i], s)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 9\n    val = [88, 22, 83, 14, 95, 91, 98, 53, 11]\n    cost = [-1, 24, -8, 67, 64, 65, 12, -80, 8]\n    tr = [[]for i in range(n + 1)]\n    tr[0].append(3)\n    tr[0].append(4)\n    tr[4].append(6)\n    tr[6].append(2)\n    tr[2].append(1)\n    tr[2].append(8)\n    tr[8].append(5)\n    tr[5].append(7)\n    dfs(val, cost, tr, 0, 0)\n    print(n - cnt)\n",
        "output": "5\n",
        "fn_call": "dfs"
    },
    {
        "text": "icositrigonal number | function to find n - th icositrigonal number ; formula to calculate nth icositrigonal number ; ",
        "context": "",
        "code": "def IcositrigonalNum(n):\n    return (21 * n * n - 19 * n) / 2\n",
        "test": "\nn = 3\nprint(IcositrigonalNum(n))\nn = 10\nprint(IcositrigonalNum(n))\n",
        "output": "66.0\n955.0\n",
        "fn_call": "IcositrigonalNum"
    },
    {
        "text": "check if n numbers with even sum can be selected from a given array | function to check if an odd sum can be made using n integers from the array ; initialize odd and even counts ; iterate over the array to count the no . of even and odd integers ; if element is odd ; if element is even ; check if even_freq is more than n ; if odd_freq is odd ; consider even count of odd ; calculate even required ; if even count is less than required count ; calculate even required ; if even count is less than required count ; ",
        "context": "",
        "code": "def checkEvenSum(arr, N, size):\n    even_freq, odd_freq = 0, 0\n    for i in range(size):\n        if (arr[i] & 1):\n            odd_freq += 1\n        else:\n            even_freq += 1\n    if (even_freq >= N):\n        return True\n    else:\n        if (odd_freq & 1):\n            taken = odd_freq - 1\n            req = N - taken\n            if (even_freq < req):\n                return False\n            else:\n                return True\n        else:\n            taken = odd_freq\n            req = N - taken\n            if (even_freq < req):\n                return False\n            else:\n                return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [9, 2, 3, 4, 18, 7, 7, 6]\n    size = len(arr)\n    N = 5\n    if (checkEvenSum(arr, N, size)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkEvenSum"
    },
    {
        "text": "generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | function to print the required string ; count number of 1 s ; to check if the all the 1 s have been used or not ; print all the 1 s if any 2 is encountered ; if str1 [ i ] = 0 or str1 [ i ] = 2 ; if 1 s are not printed yet ; ",
        "context": "",
        "code": "def printString(Str1, n):\n    ones = 0\n    for i in range(n):\n        if (Str1[i] == '1'):\n            ones += 1\n    used = False\n    for i in range(n):\n        if (Str1[i] == '2' and used == False):\n            used = 1\n            for j in range(ones):\n                print(\"1\", end=\"\")\n        if (Str1[i] != '1'):\n            print(Str1[i], end=\"\")\n    if (used == False):\n        for j in range(ones):\n            print(\"1\", end=\"\")\n",
        "test": "\nStr1 = \"100210\"\nn = len(Str1)\nprintString(Str1, n)\n",
        "output": "001120",
        "fn_call": "printString"
    },
    {
        "text": "all possible numbers of n digits and base b without leading zeros | function to count all permutations ; count of all permutations ; count of permutations with leading zeros ; return the permutations without leading zeros ; ",
        "context": "",
        "code": "def countPermutations(N, B):\n    x = B ** N\n    y = B ** (N - 1)\n    print(x - y)\n",
        "test": "\nif __name__ == \"__main__\":\n    N, B = 6, 4\n    countPermutations(N, B)\n",
        "output": "3072\n",
        "fn_call": "countPermutations"
    },
    {
        "text": "largest number less than or equal to n / 2 which is coprime to n | function to find largest integer less than or equal to n / 2 and is coprime with n ; handle the case for n = 6 ; ",
        "context": "",
        "code": "def largestCoprime(N):\n    if N == 6:\n        return 1\n    elif N % 4 == 0:\n        return N // 2 - 1\n    elif N % 2 == 0:\n        return N // 2 - 2\n    else:\n        return (N - 1) // 2\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 50\n    print(largestCoprime(n))\n",
        "output": "23\n",
        "fn_call": "largestCoprime"
    },
    {
        "text": "find the two repeating elements in a given array | python3 code for find the two repeating elements in a given array ; printrepeating function ; s is for sum of elements in arr [ ] ; p is for product of elements in arr [ ] ; calculate sum and product of all elements in arr [ ] ; s is x + y now ; p is x * y now ; d is x - y now ; factorial of n ; ",
        "context": "\nimport math\n\n",
        "code": "def fact(n):\n    if (n == 0):\n        return 1\n    else:\n        return (n * fact(n - 1))\n\n\ndef printRepeating(arr, size):\n    S = 0\n    P = 1\n    n = size - 2\n    for i in range(0, size):\n        S = S + arr[i]\n        P = P * arr[i]\n    S = S - n * (n + 1) // 2\n    P = P // fact(n)\n    D = math .sqrt(S * S - 4 * P)\n    x = (D + S) // 2\n    y = (S - D) // 2\n    print(\"The two Repeating elements are \", (int)(x), \" & \", (int)(y))\n",
        "test": "\narr = [4, 2, 4, 5, 2, 3, 1]\narr_size = len(arr)\nprintRepeating(arr, arr_size)\n",
        "output": "The two Repeating elements are  4  &  2\n",
        "fn_call": "printRepeating"
    },
    {
        "text": "largest subarray having sum greater than k | comparison function used to sort presum vector . ; function to find index in presum vector upto which all prefix sum values are less than or equal to val . ; starting and ending index of search space . ; to store required index value . ; if middle value is less than or equal to val then index can lie in mid + 1. . n else it lies in 0. . mid - 1. ; function to find largest subarray having sum greater than or equal to k . ; length of largest subarray . ; vector to store pair of prefix sum and corresponding ending index value . ; to store the current value of prefix sum . ; to store minimum index value in range 0. . i of presum vector . ; insert values in presum vector . ; update minind array . ; if sum is greater than k , then answer is i + 1. ; if sum is less than or equal to k , then find if there is a prefix array having sum that needs to be added to current sum to make its value greater than k . if yes , then compare length of updated subarray with maximum length found so far . ; ",
        "context": "",
        "code": "def compare(a, b):\n    if a[0] == b[0]:\n        return a[1] < b[1]\n    return a[0] < b[0]\n\n\ndef findInd(preSum, n, val):\n    l, h = 0, n - 1\n    ans = -1\n    while l <= h:\n        mid = (l + h) // 2\n        if preSum[mid][0] <= val:\n            ans = mid\n            l = mid + 1\n        else:\n            h = mid - 1\n    return ans\n\n\ndef largestSub(arr, n, k):\n    maxlen = 0\n    preSum = []\n    Sum = 0\n    minInd = [None] * (n)\n    for i in range(0, n):\n        Sum = Sum + arr[i]\n        preSum .append([Sum, i])\n    preSum .sort()\n    minInd[0] = preSum[0][1]\n    for i in range(1, n):\n        minInd[i] = min(minInd[i - 1], preSum[i][1])\n    Sum = 0\n    for i in range(0, n):\n        Sum = Sum + arr[i]\n        if Sum > k:\n            maxlen = i + 1\n        else:\n            ind = findInd(preSum, n, Sum - k - 1)\n            if ind != -1 and minInd[ind] < i:\n                maxlen = max(maxlen, i - minInd[ind])\n    return maxlen\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [-2, 1, 6, -3]\n    n = len(arr)\n    k = 5\n    print(largestSub(arr, n, k))\n",
        "output": "2\n",
        "fn_call": "largestSub"
    },
    {
        "text": "perfect reversible string | this function basically checks if string is palindrome or not ; iterate from left and right ; ",
        "context": "",
        "code": "def isReversible(str):\n    i = 0\n    j = len(str) - 1\n    while (i < j):\n        if (str[i] != str[j]):\n            return False\n        i += 1\n        j -= 1\n    return True\n",
        "test": "\nstr = \"aba\"\nif (isReversible(str)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "isReversible"
    },
    {
        "text": "icosihexagonal number | finding the nth icosihexagonal number ; ",
        "context": "",
        "code": "def IcosihexagonalNum(n):\n    return (24 * n * n - 22 * n) // 2\n",
        "test": "\nn = 3\nprint(\"3rd Icosihexagonal Number is = \", IcosihexagonalNum(n))\n",
        "output": "3rd Icosihexagonal Number is =  75\n",
        "fn_call": "IcosihexagonalNum"
    },
    {
        "text": "compute n ! under modulo p | returns value of n ! % p ; ",
        "context": "",
        "code": "def modFact(n, p):\n    if n >= p:\n        return 0\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % p\n    return result\n",
        "test": "\nn = 25\np = 29\nprint(modFact(n, p))\n",
        "output": "5\n",
        "fn_call": "modFact"
    },
    {
        "text": "search in an almost sorted array | a recursive binary search based function . it returns index of x in given array arr [ l . . r ] is present , otherwise - 1 ; if the element is present at one of the middle 3 positions ; if element is smaller than mid , then it can only be present in left subarray ; else the element can only be present in right subarray ; we reach here when element is not present in array ; ",
        "context": "",
        "code": "def binarySearch(arr, l, r, x):\n    if (r >= l):\n        mid = int(l + (r - l) / 2)\n        if (arr[mid] == x):\n            return mid\n        if (mid > l and arr[mid - 1] == x):\n            return (mid - 1)\n        if (mid < r and arr[mid + 1] == x):\n            return (mid + 1)\n        if (arr[mid] > x):\n            return binarySearch(arr, l, mid - 2, x)\n        return binarySearch(arr, mid + 2, r, x)\n    return -1\n",
        "test": "\narr = [3, 2, 10, 4, 40]\nn = len(arr)\nx = 4\nresult = binarySearch(arr, 0, n - 1, x)\nif (result == -1):\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index\", result)\n",
        "output": "Element is present at index 3\n",
        "fn_call": "binarySearch"
    },
    {
        "text": "sum of digits written in different bases from 2 to n | def to calculate sum of digit for a given base ; sum of digits ; calculating the number ( n ) by taking mod with the base and adding remainder to the result and parallelly reducing the num value . ; returning the result ; def calling for multiple bases ; ",
        "context": "",
        "code": "def solve(n, base):\n    result = 0\n    while (n > 0):\n        remainder = n % base\n        result = result + remainder\n        n = int(n / base)\n    return result\n\n\ndef printSumsOfDigits(n):\n    for base in range(2, n):\n        print(solve(n, base), end=\" \")\n",
        "test": "\nn = 8\nprintSumsOfDigits(n)\n",
        "output": "1 4 2 4 3 2 ",
        "fn_call": "printSumsOfDigits"
    },
    {
        "text": "count all substrings having character k | function to return the index of the next occurrence of character ch in strr starting from the given index ; return the index of the first occurrence of ch ; no occurrence found ; function to return the count of all the substrings of strr which contain the character ch at least one ; to store the count of valid substrings ; index of the first occurrence of ch in strr ; no occurrence of ch after index i in strr ; substrings starting at index i and ending at indices j , j + 1 , ... , n - 1 are all valid substring ; ",
        "context": "",
        "code": "def nextOccurrence(strr, n, start, ch):\n    for i in range(start, n):\n        if (strr[i] == ch):\n            return i\n    return -1\n\n\ndef countSubStr(strr, n, ch):\n    cnt = 0\n    j = nextOccurrence(strr, n, 0, ch)\n    for i in range(n):\n        while (j != -1 and j < i):\n            j = nextOccurrence(strr, n, j + 1, ch)\n        if (j == -1):\n            break\n        cnt += (n - j)\n    return cnt\n",
        "test": "\nstrr = \"geeksforgeeks\"\nn = len(strr)\nch = 'k'\nprint(countSubStr(strr, n, ch))\n",
        "output": "56\n",
        "fn_call": "countSubStr"
    },
    {
        "text": "fraction | function to return gcd of a and b ; function to convert the obtained fraction into it 's simplest form ; finding gcd of both terms ; converting both terms into simpler terms by dividing them by common factor ; function to add two fractions ; finding gcd of den1 and den2 ; denominator of final fraction obtained finding lcm of den1 and den2 lcm * gcd = a * b ; changing the fractions to have same denominator numerator of the final fraction obtained ; calling function to convert final fraction into it 's  simplest form ; ",
        "context": "",
        "code": "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\n\ndef lowest(den3, num3):\n    common_factor = gcd(num3, den3)\n    den3 = int(den3 / common_factor)\n    num3 = int(num3 / common_factor)\n    print(num3, \"/\", den3)\n\n\ndef addFraction(num1, den1, num2, den2):\n    den3 = gcd(den1, den2)\n    den3 = (den1 * den2) / den3\n    num3 = ((num1) * (den3 / den1) + (num2) * (den3 / den2))\n    lowest(den3, num3)\n",
        "test": "\nnum1 = 1\nden1 = 500\nnum2 = 2\nden2 = 1500\nprint(num1, \"/\", den1, \" + \", num2, \"/\", den2, \" is equal to \", end=\"\")\naddFraction(num1, den1, num2, den2)\n",
        "output": "1 / 500  +  2 / 1500  is equal to 1 / 300\n",
        "fn_call": "addFraction"
    },
    {
        "text": "equal sum and xor | function to count number of values less than equal to n that satisfy the given condition ; traverse all numbers from 0 to n and increment result only when given condition is satisfied . ; ",
        "context": "",
        "code": "def countValues(n):\n    countV = 0\n    for i in range(n + 1):\n        if ((n + i) == (n ^ i)):\n            countV += 1\n    return countV\n",
        "test": "\nn = 12\nprint(countValues(n))\n",
        "output": "4\n",
        "fn_call": "countValues"
    },
    {
        "text": "absolute distinct count in a sorted array | the function returns return number of distinct absolute values among the elements of the array ; initialize count as number of elements ; remove duplicate elements from the left of the current window ( i , j ) and also decrease the count ; remove duplicate elements from the right of the current window ( i , j ) and also decrease the count ; break if only one element is left ; now look for the zero sum pair in current window ( i , j ) ; decrease the count if ( positive , negative ) pair is encountered ; ",
        "context": "",
        "code": "def distinctCount(arr, n):\n    count = n\n    i = 0\n    j = n - 1\n    sum = 0\n    while (i < j):\n        while (i != j and arr[i] == arr[i + 1]):\n            count = count - 1\n            i = i + 1\n        while (i != j and arr[j] == arr[j - 1]):\n            count = count - 1\n            j = j - 1\n        if (i == j):\n            break\n        sum = arr[i] + arr[j]\n        if (sum == 0):\n            count = count - 1\n            i = i + 1\n            j = j - 1\n        elif (sum < 0):\n            i = i + 1\n        else:\n            j = j - 1\n    return count\n",
        "test": "\narr = [-2, -1, 0, 1, 1]\nn = len(arr)\nprint(\"Count of absolute distinct values : \", distinctCount(arr, n))\n",
        "output": "Count of absolute distinct values :  3\n",
        "fn_call": "distinctCount"
    },
    {
        "text": "longest alternative parity subsequence | function to find the longest ; marks the starting of odd number as sequence and alternatively changes ; finding the longest odd / even sequence ; find odd number ; find even number ; length of the longest even / odd sequence ; find odd number ; find even number ; answer is maximum of both odd / even or even / odd subsequence ; ",
        "context": "",
        "code": "def longestAlternativeSequence(a, n):\n    maxi1 = 0\n    f1 = 0\n    for i in range(n):\n        if (f1 == 0):\n            if (a[i] % 2):\n                f1 = 1\n                maxi1 += 1\n        else:\n            if (a[i] % 2 == 0):\n                maxi1 += 1\n                f1 = 0\n    maxi2 = 0\n    f2 = 0\n    for i in range(n):\n        if (f2):\n            if (a[i] % 2):\n                f2 = 1\n                maxi2 += 1\n        else:\n            if (a[i] % 2 == 0):\n                maxi2 += 1\n                f2 = 0\n    return max(maxi1, maxi2)\n",
        "test": "\na = [13, 16, 8, 9, 32, 10]\nn = len(a)\nprint(longestAlternativeSequence(a, n))\n",
        "output": "4\n",
        "fn_call": "longestAlternativeSequence"
    },
    {
        "text": "count of sets possible using integers from a range [ 2 , n ] using given operations that are in equivalence relation | python3 program for the above approach ; sieve of eratosthenes to find primes less than or equal to n ; function to find number of sets ; handle base case ; set which contains less than or equal to n / 2 ; number greater than n / 2 and are prime increment it by 1 ; if the number is prime increment answer by 1 ; ",
        "context": "\nprime = [True] * 100001\n\n",
        "code": "def SieveOfEratosthenes(n):\n    global prime\n    for p in range(2, n + 1):\n        if p * p > n:\n            break\n        if (prime[p]):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n\n\ndef NumberofSets(N):\n    SieveOfEratosthenes(N)\n    if (N == 2):\n        print(1)\n    elif (N == 3):\n        print(2)\n    else:\n        ans = 1\n        for i in range(N // 2, N + 1):\n            if (prime[i]):\n                ans += 1\n        print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    N = 9\n    NumberofSets(N)\n",
        "output": "3\n",
        "fn_call": "NumberofSets"
    },
    {
        "text": "nesbitt 's inequality | python3 code to verify nesbitt 's inequality ; 3 parts of the inequality sum ; ",
        "context": "",
        "code": "def isValidNesbitt(a, b, c):\n    A = a / (b + c)\n    B = b / (a + c)\n    C = c / (a + b)\n    inequality = A + B + C\n    return (inequality >= 1.5)\n",
        "test": "\na = 1.0\nb = 2.0\nc = 3.0\nif (isValidNesbitt(a, b, c)):\n    print(\n        \"Nesbitt's inequality satisfied.\",\n        \" for real numbers \",\n        a,\n        \", \",\n        b,\n        \", \",\n        c)\nelse:\n    print(\"Not satisfied\")\n",
        "output": "Nesbitt's inequality satisfied.  for real numbers  1.0 ,  2.0 ,  3.0\n",
        "fn_call": "isValidNesbitt"
    },
    {
        "text": "number of trailing zeros in n * ( n | function to return the count of trailing 0 s in the given function ; if n is odd ; if n is even ; find the trailing zeros in n / 2 factorial ; return the required answer ; ",
        "context": "",
        "code": "def findTrailingZeros(n):\n    if (n & 1):\n        return 0\n    else:\n        ans = 0\n        n //= 2\n        while (n):\n            ans += n // 5\n            n //= 5\n        return ans\n",
        "test": "\nn = 12\nprint(findTrailingZeros(n))\n",
        "output": "1\n",
        "fn_call": "findTrailingZeros"
    },
    {
        "text": "count twin prime pairs in an array | python 3 program to count twin prime pairs in array ; a utility function to check if the number n is prime or not ; base cases ; check to skip middle five numbers in below loop ; if n is divisible by i and i + 2 then it is not prime ; a utility function that check if n1 and n2 are twin primes or not ; function to find twin prime pairs from the given array ; iterate through all pairs ; increment count if twin prime pair ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    for i in range(5, int(sqrt(n)) + 1, 6):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n    return True\n\n\ndef twinPrime(n1, n2):\n    return (isPrime(n1) and isPrime(n2) and abs(n1 - n2) == 2)\n\n\ndef countTwinPairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (twinPrime(arr[i], arr[j])):\n                count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 5, 11]\n    n = len(arr)\n    print(countTwinPairs(arr, n))\n",
        "output": "1\n",
        "fn_call": "countTwinPairs"
    },
    {
        "text": "replace every element of the array with bitwise xor of all other | function to replace the elements ; calculate the xor of all the elements ; replace every element by the xor of all other elements ; ",
        "context": "",
        "code": "def ReplaceElements(arr, n):\n    X = 0\n    for i in range(n):\n        X ^= arr[i]\n    for i in range(n):\n        arr[i] = X ^ arr[i]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 3, 3, 5, 5]\n    n = len(arr)\n    ReplaceElements(arr, n)\n    for i in range(n):\n        print(arr[i], end=\" \")\n",
        "output": "0 1 1 7 7 ",
        "fn_call": "ReplaceElements"
    },
    {
        "text": "longest rod that can be inserted within a right circular cylinder | python 3 program to find the longest rod that can be fit within a right circular cylinder ; function to find the side of the cube ; height and radius cannot be negative ; length of rod ; ",
        "context": "\nimport math\n\n",
        "code": "def rod(h, r):\n    if (h < 0 and r < 0):\n        return -1\n    l = (math .sqrt(math .pow(h, 2) + 4 * math .pow(r, 2)))\n    return float(l)\n",
        "test": "\nh, r = 4, 1.5\nprint(rod(h, r))\n",
        "output": "5.0\n",
        "fn_call": "rod"
    },
    {
        "text": "check if a number can be expressed as sum of two perfect powers | function that returns true if n can be written as a ^ m + b ^ n ; taking issum boolean array for check the sum exist or not ; to store perfect squares ; initially all sums as false ; if sum exist then push that sum into perfect square vector ; mark all perfect powers as false ; traverse each perfectpowers ; calculating sum with perfect powers array ; ",
        "context": "",
        "code": "def isSumOfPower(n):\n    isSum = [0] * (n + 1)\n    perfectPowers = []\n    perfectPowers .append(1)\n    for i in range(n + 1):\n        isSum[i] = False\n    for i in range(2, n + 1):\n        if (isSum[i]):\n            perfectPowers .append(i)\n            continue\n        j = i * i\n        while (j > 0 and j < (n + 1)):\n            isSum[j] = True\n            j *= i\n    for i in range(len(perfectPowers)):\n        isSum[perfectPowers[i]] = False\n    for i in range(len(perfectPowers)):\n        for j in range(len(perfectPowers)):\n            sum = (perfectPowers[i] + perfectPowers[j])\n            if (sum < (n + 1)):\n                isSum[sum] = True\n    return isSum[n]\n",
        "test": "\nn = 9\nif (isSumOfPower(n)):\n    print(\"true\")\nelse:\n    print(\"false\")\n",
        "output": "true\n",
        "fn_call": "isSumOfPower"
    },
    {
        "text": "maximum steps to transform 0 to x with bitwise and | function to get no of set bits in binary representation of positive integer n ; ",
        "context": "",
        "code": "def countSetBits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count\n",
        "test": "\ni = 3\nprint(countSetBits(i))\n",
        "output": "2\n",
        "fn_call": "countSetBits"
    },
    {
        "text": "memoization ( 1d , 2d and 3d ) | returns length of lcs for x [ 0. . m - 1 ] , y [ 0. . n - 1 ] ; ",
        "context": "",
        "code": "def lcs(X, Y, m, n):\n    if (m == 0 or n == 0):\n        return 0\n    if (X[m - 1] == Y[n - 1]):\n        return 1 + lcs(X, Y, m - 1, n - 1)\n    else:\n        return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n))\n",
        "test": "\nif __name__ == '__main__':\n    X = \"AGGTAB\"\n    Y = \"GXTXAYB\"\n    m = len(X)\n    n = len(Y)\n    print(\"Length of LCS is {}n\".format(lcs(X, Y, m, n)))\n",
        "output": "Length of LCS is 4n\n",
        "fn_call": "lcs"
    },
    {
        "text": "find zeroes to be flipped so that number of consecutive 1 's is maximized | m is maximum of number zeroes allowed to flip , n is size of array ; left and right indexes of current window ; left index and size of the widest window ; count of zeroes in current window ; while right boundary of current window doesn 't cross right end ; if zero count of current window is less than m , widen the window toward right ; if zero count of current window is more than m , reduce the window from left ; updqate widest window if this window size is more ; print positions of zeroes in the widest window ; ",
        "context": "",
        "code": "def findZeroes(arr, n, m):\n    wL = wR = 0\n    bestL = bestWindow = 0\n    zeroCount = 0\n    while wR < n:\n        if zeroCount <= m:\n            if arr[wR] == 0:\n                zeroCount += 1\n            wR += 1\n        if zeroCount > m:\n            if arr[wL] == 0:\n                zeroCount -= 1\n            wL += 1\n        if (wR - wL > bestWindow) and (zeroCount <= m):\n            bestWindow = wR - wL\n            bestL = wL\n    for i in range(0, bestWindow):\n        if arr[bestL + i] == 0:\n            print(bestL + i, end=\" \")\n",
        "test": "\narr = [1, 0, 0, 1, 1, 0, 1, 0, 1, 1]\nm = 2\nn = len(arr)\nprint(\"Indexes of zeroes to be flipped are\", end=\" \")\nfindZeroes(arr, n, m)\n",
        "output": "Indexes of zeroes to be flipped are 5 7 ",
        "fn_call": "findZeroes"
    },
    {
        "text": "swap the elements between any two given quadrants of a matrix | python3 program for the above approach ; function to iterate over the x quadrant and swap its element with y quadrant ; iterate over x quadrant ; swap operations ; function to swap the elements of the two given quadrants ; for swapping 1 st and 2 nd quadrant ; for swapping 1 st and 3 rd quadrant ; for swapping 1 st and 4 th quadrant ; for swapping 2 nd and 3 rd quadrant ; for swapping 2 nd and 4 th quadrant ; for swapping 3 rd and 4 th quadrant ; print the resultant matrix ; function to print the matrix ; iterate over the rows ; iterate over the cols ; given matrix ; ",
        "context": "\nN, M = 6, 6\n\n",
        "code": "def swap(mat, startx_X, starty_X, startx_Y, starty_Y):\n    row, col = 0, 0\n    i = startx_X\n    while (bool(True)):\n        col = 0\n        j = startx_X\n        while (bool(True)):\n            temp = mat[i][j]\n            mat[i][j] = mat[startx_Y + row][starty_Y + col]\n            mat[startx_Y + row][starty_Y + col] = temp\n            col += 1\n            if col >= M // 2:\n                break\n            j += 1\n        row += 1\n        if row >= N // 2:\n            break\n        i += 1\n\n\ndef printMat(mat):\n    for i in range(N):\n        for j in range(M):\n            print(mat[i][j], end=\" \")\n        print()\n\n\ndef swapQuadOfMatrix(mat, X, Y):\n    if (X == 1 and Y == 2):\n        swap(mat, 0, 0, 0, M // 2)\n    elif (X == 1 and Y == 3):\n        swap(mat, 0, 0, N // 2, 0)\n    elif (X == 1 and Y == 4):\n        swap(mat, 0, 0, N // 2, M // 2)\n    elif (X == 2 and Y == 3):\n        swap(mat, 0, M // 2, N // 2, 0)\n    elif (X == 2 and Y == 4):\n        swap(mat, 0, M // 2, N // 2, M // 2)\n    elif (X == 3 and Y == 4):\n        swap(mat, N // 2, 0, N // 2, M // 2)\n    printMat(mat)\n",
        "test": "\nmat = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [\n    19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]]\nX, Y = 1, 4\nswapQuadOfMatrix(mat, X, Y)\n",
        "output": "22 23 24 4 5 6 \n28 29 30 10 11 12 \n34 35 36 16 17 18 \n19 20 21 1 2 3 \n25 26 27 7 8 9 \n31 32 33 13 14 15 \n",
        "fn_call": "swapQuadOfMatrix"
    },
    {
        "text": "length of longest subarray with positive product | function to find the length of longest subarray whose product is positive ; stores the length of current subarray with positive product ; stores the length of current subarray with negative product ; stores the length of the longest subarray with positive product ; reset the value ; if current element is positive ; increment the length of subarray with positive product ; if at least one element is present in the subarray with negative product ; update res ; if current element is negative ; increment the length of subarray with negative product ; if at least one element is present in the subarray with positive product ; update res ; ",
        "context": "",
        "code": "def maxLenSub(arr, N):\n    Pos = 0\n    Neg = 0\n    res = 0\n    for i in range(N):\n        if (arr[i] == 0):\n            Pos = Neg = 0\n        elif (arr[i] > 0):\n            Pos += 1\n            if (Neg != 0):\n                Neg += 1\n            res = max(res, Pos)\n        else:\n            Pos, Neg = Neg, Pos\n            Neg += 1\n            if (Pos != 0):\n                Pos += 1\n            res = max(res, Pos)\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr = [-1, -2, -3, 0, 1]\n    N = len(arr)\n    print(maxLenSub(arr, N))\n",
        "output": "2\n",
        "fn_call": "maxLenSub"
    },
    {
        "text": "number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y are integers | function to find the number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y integers . ; to store answer ; iterate explicitly over all possible values of x ; return answer ; ",
        "context": "",
        "code": "def NumberOfSolutions(a, b, c, d):\n    ans = 0\n    for i in range(a, b + 1):\n        if d >= max(c, i + 1):\n            ans += d - max(c, i + 1) + 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    a, b, c, d = 2, 3, 3, 4\n    print(NumberOfSolutions(a, b, c, d))\n",
        "output": "3\n",
        "fn_call": "NumberOfSolutions"
    },
    {
        "text": "program to calculate area of a parallelogram | python3 program for the above approach ; function to return the area of parallelogram using sides and angle at the intersection of diagonal ; calculate area of parallelogram ; return the answer ; function to return the area of parallelogram using sides and angle at the intersection of sides ; calculate area of parallelogram ; return the answer ; function to return the area of parallelogram using diagonals and angle at the intersection of diagonals ; calculate area of parallelogram ; return the answer ; ",
        "context": "\nimport math\n\n",
        "code": "def Area_Parallelogram1(a, b, theta):\n    area = (abs(math .tan(math .radians(theta))) / 2) * abs(a ** 2 - b ** 2)\n    return area\n\n\ndef Area_Parallelogram2(a, b, gamma):\n    area = (abs(math .sin(math .radians(gamma)))) * abs(a * b)\n    return area\n\n\ndef Area_Parallelogram3(d1, d2, theta):\n    area = (abs(math .sin(math .radians(theta))) / 2) * abs(d1 * d2)\n    return area\n",
        "test": "\nd1 = 3\nd2 = 5\ntheta = 90\narea = Area_Parallelogram3(d1, d2, theta)\nprint(round(area, 2))\n",
        "output": "7.5\n",
        "fn_call": "Area_Parallelogram3"
    },
    {
        "text": "find maximum value of x such that n ! % ( k ^ x ) = 0 | python 3 program to maximize the value of x such that n ! % ( k ^ x ) = 0 ; function to maximize the value of x such that n ! % ( k ^ x ) = 0 ; find square root of k and add 1 to it ; run the loop from 2 to m and k should be greater than 1 ; optimize the value of k ; minimum store ; ",
        "context": "\nimport math\n\n",
        "code": "def findX(n, k):\n    r = n\n    m = int(math .sqrt(k)) + 1\n    i = 2\n    while i  1:\n        if (i == m):\n            i = k\n        u = 0\n        v = 0\n        while k % i == 0:\n            k //= i\n            v += 1\n        if (v > 0):\n            t = n\n            while (t > 0):\n                t //= i\n                u += t\n            r = min(r, u // v)\n        i += 1\n    return r\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    k = 2\n    print(findX(n, k))\n",
        "output": "3\n",
        "fn_call": "findX"
    },
    {
        "text": "lcm of first n natural numbers | to calculate hcf ; to calculate lcm ; lcm ( a , b ) = ( a * b ) hcf ( a , b ) ; assign a = lcm of n , n - 1 ; b = b - 1 ; ",
        "context": "",
        "code": "def hcf(a, b):\n    if (b == 0):\n        return a\n    return hcf(b, a % b)\n\n\ndef findlcm(a, b):\n    if (b == 1):\n        return a\n    a = (a * b) // hcf(a, b)\n    b -= 1\n    return findlcm(a, b)\n",
        "test": "\nn = 7\nif (n < 3):\n    print(n)\nelse:\n    print(findlcm(n, n - 1))\n",
        "output": "420\n",
        "fn_call": "findlcm"
    },
    {
        "text": "how to check if two given sets are disjoint ? | returns true if set1 [ ] and set2 [ ] are disjoint , else false ; sort the given two sets ; check for same elements using merge like process ; if set1 [ i ] == set2 [ j ] ; ",
        "context": "",
        "code": "def areDisjoint(set1, set2, m, n):\n    set1 .sort()\n    set2 .sort()\n    i = 0\n    j = 0\n    while (i < m and j < n):\n        if (set1[i] < set2[j]):\n            i += 1\n        elif (set2[j] < set1[i]):\n            j += 1\n        else:\n            return False\n    return True\n",
        "test": "\nset1 = [12, 34, 11, 9, 3]\nset2 = [7, 2, 1, 5]\nm = len(set1)\nn = len(set2)\nprint(\"Yes\")if areDisjoint(set1, set2, m, n)else print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "areDisjoint"
    },
    {
        "text": "maximum difference of sum of elements in two rows in a matrix | function to find maximum difference of sum of elements of two rows such that second row appears before first row . ; auxiliary array to store sum of all elements of each row ; calculate sum of each row and store it in rowsum array ; calculating maximum difference of two elements such that rowsum [ i ] < rowsum [ j ] ; if current difference is greater than previous then update it ; if new element is less than previous minimum element then update it so that we may get maximum difference in remaining array ; ",
        "context": "",
        "code": "def maxRowDiff(mat, m, n):\n    rowSum = [0] * m\n    for i in range(0, m):\n        sum = 0\n        for j in range(0, n):\n            sum += mat[i][j]\n        rowSum[i] = sum\n    max_diff = rowSum[1] - rowSum[0]\n    min_element = rowSum[0]\n    for i in range(1, m):\n        if (rowSum[i] - min_element > max_diff):\n            max_diff = rowSum[i] - min_element\n        if (rowSum[i] < min_element):\n            min_element = rowSum[i]\n    return max_diff\n",
        "test": "\nm = 5\nn = 4\nmat = [[-1, 2, 3, 4], [5, 3, -2, 1],\n       [6, 7, 2, -3], [2, 9, 1, 4], [2, 1, -2, 0]]\nprint(maxRowDiff(mat, m, n))\n",
        "output": "9\n",
        "fn_call": "maxRowDiff"
    },
    {
        "text": "edit distance | dp |  ; if any string is empty , return the remaining characters of other string ; to check if the recursive tree for given n & m has already been executed ; if characters are equal , execute recursive function for n - 1 , m - 1 ; if characters are nt equal , we need to find the minimum cost out of all 3 operations . ; temp variables ; ",
        "context": "",
        "code": "def minDis(s1, s2, n, m, dp):\n    if (n == 0):\n        return m\n    if (m == 0):\n        return n\n    if (dp[n][m] != -1):\n        return dp[n][m]\n    if (s1[n - 1] == s2[m - 1]):\n        if (dp[n - 1][m - 1] == -1):\n            dp[n][m] = minDis(s1, s2, n - 1, m - 1, dp)\n            return dp[n][m]\n        else:\n            dp[n][m] = dp[n - 1][m - 1]\n            return dp[n][m]\n    else:\n        if (dp[n - 1][m] != -1):\n            m1 = dp[n - 1][m]\n        else:\n            m1 = minDis(s1, s2, n - 1, m, dp)\n\n        if (dp[n][m - 1] != -1):\n            m2 = dp[n][m - 1]\n        else:\n            m2 = minDis(s1, s2, n, m - 1, dp)\n        if (dp[n - 1][m - 1] != -1):\n            m3 = dp[n - 1][m - 1]\n        else:\n            m3 = minDis(s1, s2, n - 1, m - 1, dp)\n\n        dp[n][m] = 1 + min(m1, min(m2, m3))\n        return dp[n][m]\n",
        "test": "\nstr1 = \"voldemort\"\nstr2 = \"dumbledore\"\n\nn = len(str1)\nm = len(str2)\ndp = [[-1 for i in range(m + 1)] for j in range(n + 1)]\n\nprint(minDis(str1, str2, n, m, dp))\n",
        "output": "7\n",
        "fn_call": "minDis"
    },
    {
        "text": "longest subsequence of the form 0 * 1 * 0 * in a binary string | returns length of the longest subsequence of the form 0 * 1 * 0 * ; precomputing values in three arrays pre_count_0 [ i ] is going to store count of 0 s in prefix str [ 0. . i - 1 ] pre_count_1 [ i ] is going to store count of 1 s in prefix str [ 0. . i - 1 ] post_count_0 [ i ] is going to store count of 0 s in suffix str [ i - 1. . n - 1 ] ; string is made up of all 0 s or all 1 s ; compute result using precomputed values ; ",
        "context": "",
        "code": "def longestSubseq(s):\n    n = len(s)\n    pre_count_0 = [0 for i in range(n + 2)]\n    pre_count_1 = [0 for i in range(n + 1)]\n    post_count_0 = [0 for i in range(n + 2)]\n    pre_count_0[0] = 0\n    post_count_0[n + 1] = 0\n    pre_count_1[0] = 0\n    for j in range(1, n + 1):\n        pre_count_0[j] = pre_count_0[j - 1]\n        pre_count_1[j] = pre_count_1[j - 1]\n        post_count_0[n - j + 1] = post_count_0[n - j + 2]\n        if (s[j - 1] == '0'):\n            pre_count_0[j] += 1\n        else:\n            pre_count_1[j] += 1\n        if (s[n - j] == '0'):\n            post_count_0[n - j + 1] += 1\n    if (pre_count_0[n] == n or pre_count_0[n] == 0):\n        return n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, 1):\n            ans = max(pre_count_0[i - 1] + pre_count_1[j] -\n                      pre_count_1[i - 1] + post_count_0[j + 1], ans)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    s = \"000011100000\"\n    print(longestSubseq(s))\n",
        "output": "12\n",
        "fn_call": "longestSubseq"
    },
    {
        "text": "minimum insertions to form a palindrome | dp | a utility function to find minimum of two integers ; a dp function to find minimum number of insertions ; create a table of size n * n . table [ i ] [ j ] will store minimum number of insertions needed to convert str1 [ i . . j ] to a palindrome . ; fill the table ; return minimum number of insertions for str1 [ 0. . n - 1 ] ; ",
        "context": "",
        "code": "def Min(a, b):\n    return min(a, b)\n\n\ndef findMinInsertionsDP(str1, n):\n    table = [[0 for i in range(n)]for i in range(n)]\n    l, h, gap = 0, 0, 0\n    for gap in range(1, n):\n        l = 0\n        for h in range(gap, n):\n            if str1[l] == str1[h]:\n                table[l][h] = table[l + 1][h - 1]\n            else:\n                table[l][h] = (Min(table[l][h - 1], table[l + 1][h]) + 1)\n            l += 1\n    return table[0][n - 1]\n",
        "test": "\nstr1 = \"geeks\"\nprint(findMinInsertionsDP(str1, len(str1)))\n",
        "output": "3\n",
        "fn_call": "findMinInsertionsDP"
    },
    {
        "text": "write a program to find the maximum depth or height of a tree | a binary tree node ; compute the \" maxdepth \" of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node ; compute the depth of each subtree ; use the larger one ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def maxDepth(node):\n    if node is None:\n        return 0\n    else:\n        lDepth = maxDepth(node .left)\n        rDepth = maxDepth(node .right)\n        if (lDepth > rDepth):\n            return lDepth + 1\n        else:\n            return rDepth + 1\n",
        "test": "\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nroot .left .left = Node(4)\nroot .left .right = Node(5)\nprint(\"Height of tree is %d\" % (maxDepth(root)))\n",
        "output": "Height of tree is 3\n",
        "fn_call": "maxDepth"
    },
    {
        "text": "count of squares that can be drawn without lifting the pencil | function to return the count of squares that can be formed ; ",
        "context": "",
        "code": "def countSquares(n):\n    return (pow(n, 2) - (2 * n) + 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 2\n    print(countSquares(n))\n",
        "output": "2\n",
        "fn_call": "countSquares"
    },
    {
        "text": "find difference between sums of two diagonals | python3 program to find the difference between the sum of diagonal . ; initialize sums of diagonals ; finding sum of primary diagonal ; finding sum of secondary diagonal ; absolute difference of the sums across the diagonals ; ",
        "context": "",
        "code": "def difference(arr, n):\n    d1 = 0\n    d2 = 0\n    for i in range(0, n):\n        for j in range(0, n):\n            if (i == j):\n                d1 += arr[i][j]\n            if (i == n - j - 1):\n                d2 += arr[i][j]\n    return abs(d1 - d2)\n",
        "test": "\nn = 3\narr = [[11, 2, 4], [4, 5, 6], [10, 8, -12]]\nprint(difference(arr, n))\n",
        "output": "15\n",
        "fn_call": "difference"
    },
    {
        "text": "value of the series ( 1 ^ 3 + 2 ^ 3 + 3 ^ 3 + ... + n ^ 3 ) mod 4 for a given n | function for obtaining the value of f ( n ) mod 4 ; find the remainder of n when divided by 4 ; if n is of the form 4 k or 4 k + 3 ; if n is of the form 4 k + 1 or 4 k + 2 ; ",
        "context": "",
        "code": "def fnMod(n):\n    rem = n % 4\n    if (rem == 0 or rem == 3):\n        return 0\n    elif (rem == 1 or rem == 2):\n        return 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 6\n    print(fnMod(n))\n",
        "output": "1\n",
        "fn_call": "fnMod"
    },
    {
        "text": "maximize sum of assigned weights by flipping at most k bits in given binary string | function to find maximum sum of weights of binary string after at most k flips ; stores lengths of substrings of the form 1. . 00. . 1 s ; stores the index of last 1 encountered in the string ; stores the index of first 1 encountered ; stores lengths of all substrings having of 0 s enclosed by 1 s at both ends ; traverse the string ; if character is 0 ; if character is 1 first priority ; second priority ; add according to the first priority ; stores length of the shortest substring of 0 s ; convert shortest substrings of 0 s to 1 s ; add according to the first priority ; add according to the third priority ; if more 0 s can be made into 1 , then check for 0 s at ends ; update the ans ; if k is non - zero , then flip 0 s at the beginning ; return the final weights ; ",
        "context": "",
        "code": "def findMax(s, n, k):\n\n    ans = 0\n    l = 0\n    ind = -1\n    indf = -1\n    ls = set([])\n    for i in range(n):\n        if (s[i] == '0'):\n            l += 1\n        elif (s[i] == '1'\n              and l > 0 and ans != 0):\n            ls.add(l)\n            l = 0\n        if (s[i] == '1'):\n            ind = i\n            l = 0\n            if (indf == -1):\n                indf = i\n            if (i > 0 and s[i - 1] == '1'):\n                ans += 2\n            else:\n                ans += 1\n    curr = 0\n    while (k > 0 and len(ls) != 0):\n        for i in ls:\n            curr = i\n            break\n        if (k >= curr):\n            ans += (2 * curr + 1)\n            k -= curr\n        else:\n            ans += (2 * k)\n            k = 0\n\n        ls.remove(curr)\n    if (k > 0):\n        ans += (2 * min(k,\n                        n - (ind + 1))\n                - 1)\n        k -= min(k, n - (ind + 1))\n\n        if (ind > -1):\n            ans += 1\n    if (k > 0):\n        ans += (min(indf, k) * 2 - 1)\n\n        if (indf > -1):\n            ans += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"1110000101\"\n    N = len(s)\n    K = 3\n    print(findMax(s, N, K))\n",
        "output": "14\n",
        "fn_call": "findMax"
    },
    {
        "text": "Minimum number of swaps required for arranging pairs adjacent to each other | This function updates indexes of elements ' a ' and 'b   ; This function returns minimum number of swaps required to arrange all elements of arr [ i . . n ] become arranged ; If all pairs procesed so no swapping needed return 0 ; If current pair is valid so DO NOT DISTURB this pair and move ahead . ; Swap pair of arr [ i ] with arr [ i + 1 ] and recursively compute minimum swap required if this move is made . ; Backtrack to previous configuration . Also restore the previous indices , of one and two ; Now swap arr [ i ] with pair of arr [ i + 1 ] and recursively compute minimum swaps required for the subproblem after this move ; Backtrack to previous configuration . Also restore 3 the previous indices , of one and two ; Return minimum of two cases ; Returns minimum swaps required ; To store indices of array elements ; Store index of each element in array index ; Call the recursive function ; For simplicity , it is assumed that arr [ 0 ] is not used . The elements from index 1 to n are only valid elements ; if ( a , b ) is pair than we have assigned elements in array such that pairs [ a ] = b and pairs [ b ] = a ; Number of pairs n is half of total elements ; If there are n elements in array , then there are n pairs",
        "context": "",
        "code": "def updateindex(index, a, ai, b, bi):\n    index[a] = ai\n    index[b] = bi\n\n\ndef minSwapsUtil(arr, pairs, index, i, n):\n    if (i > n):\n        return 0\n    if (pairs[arr[i]] == arr[i + 1]):\n        return minSwapsUtil(arr, pairs, index, i + 2, n)\n    one = arr[i + 1]\n    indextwo = i + 1\n    indexone = index[pairs[arr[i]]]\n    two = arr[index[pairs[arr[i]]]]\n    arr[i + 1], arr[indexone] = arr[indexone], arr[i + 1]\n    updateindex(index, one, indexone, two, indextwo)\n    a = minSwapsUtil(arr, pairs, index, i + 2, n)\n    arr[i + 1], arr[indexone] = arr[indexone], arr[i + 1]\n    updateindex(index, one, indextwo, two, indexone)\n    one = arr[i]\n    indexone = index[pairs[arr[i + 1]]]\n    two = arr[index[pairs[arr[i + 1]]]]\n    indextwo = i\n    arr[i], arr[indexone] = arr[indexone], arr[i]\n    updateindex(index, one, indexone, two, indextwo)\n    b = minSwapsUtil(arr, pairs, index, i + 2, n)\n    arr[i], arr[indexone] = arr[indexone], arr[i]\n    updateindex(index, one, indextwo, two, indexone)\n    return 1 + min(a, b)\n\n\ndef minSwaps(n, pairs, arr):\n    index = []\n    for i in range(2 * n + 1 + 1):\n        index .append(0)\n    for i in range(1, 2 * n + 1):\n        index[arr[i]] = i\n    return minSwapsUtil(arr, pairs, index, 1, 2 * n)\n",
        "test": "\narr = [0, 3, 5, 6, 4, 1, 2]\npairs = [0, 3, 6, 1, 5, 4, 2]\nm = len(pairs)\nn = m // 2\nprint(\"Min swaps required is \", minSwaps(n, pairs, arr))\n",
        "output": "Min swaps required is  2\n",
        "fn_call": "minSwaps"
    },
    {
        "text": "print the longest palindromic prefix of a given string | function to find the longest prefix which is palindrome ; find the length of the given string ; for storing the length of longest prefix palindrome ; loop to check the substring of all length from 1 to n which is palindrome ; string of length i ; to store the value of temp ; reversing the value of temp ; if string temp is palindromic then update the length ; print the palindromic string of max_len ; ",
        "context": "",
        "code": "def LongestPalindromicPrefix(string):\n    n = len(string)\n    max_len = 0\n    for length in range(0, n + 1):\n        temp = string[0:length]\n        temp2 = temp\n        temp3 = temp2[::-1]\n        if temp == temp3:\n            max_len = length\n    print(string[0:max_len])\n",
        "test": "\nif __name__ == '__main__':\n    string = \"abaac\"\n    LongestPalindromicPrefix(string)\n",
        "output": "aba\n",
        "fn_call": "LongestPalindromicPrefix"
    },
    {
        "text": "minimum number of coins that can generate all the values in the given range | python3 program to find minimum number of coins ; function to find minimum number of coins ; ",
        "context": "\nimport math\n\n",
        "code": "def findCount(n):\n    return int(math .log(n, 2)) + 1\n",
        "test": "\nN = 10\nprint(findCount(N))\n",
        "output": "4\n",
        "fn_call": "findCount"
    },
    {
        "text": "shortest path to reach one prime to other by changing single digit at a time | python3 program to reach a prime number from another by changing single digits and using only prime numbers . ; finding all 4 digit prime numbers ; create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . a value in prime [ i ] will finally be false if i is not a prime , else true . ; if prime [ p ] is not changed , then it is a prime ; update all multiples of p ; forming a vector of prime numbers ; in1 and in2 are two vertices of graph which are actually indexes in pset [ ] ; returns true if num1 and num2 differ by single digit . ; to compare the digits ; if the numbers differ only by a single digit return true else false ; generate all 4 digit ; create a graph where node numbers are indexes in pset [ ] and there is an edge between two nodes only if they differ by single digit . ; since graph nodes represent indexes of numbers in pset [ ] , we find indexes of num1 and num2 . ; ",
        "context": "\nimport queue\n\n\nclass Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.l = [[] for i in range(V)]\n\n    def addedge(self, V1, V2):\n        self.l[V1].append(V2)\n        self.l[V2].append(V1)\n\n    def bfs(self, in1, in2):\n        visited = [0] * self.V\n        que = queue.Queue()\n        visited[in1] = 1\n        que.put(in1)\n        while (not que.empty()):\n            p = que.queue[0]\n            que.get()\n            i = 0\n            while i < len(self.l[p]):\n                if (not visited[self.l[p][i]]):\n                    visited[self.l[p][i]] = visited[p] + 1\n                    que.put(self.l[p][i])\n                if (self.l[p][i] == in2):\n                    return visited[self.l[p][i]] - 1\n                i += 1\n\n",
        "code": "def SieveOfEratosthenes(v):\n    n = 9999\n    prime = [True] * (n + 1)\n\n    p = 2\n    while p * p <= n:\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(1000, n + 1):\n        if (prime[p]):\n            v.append(p)\n\n\ndef compare(num1, num2):\n    s1 = str(num1)\n    s2 = str(num2)\n    c = 0\n    if (s1[0] != s2[0]):\n        c += 1\n    if (s1[1] != s2[1]):\n        c += 1\n    if (s1[2] != s2[2]):\n        c += 1\n    if (s1[3] != s2[3]):\n        c += 1\n    return (c == 1)\n\n\ndef shortestPath(num1, num2):\n    pset = []\n    SieveOfEratosthenes(pset)\n    g = Graph(len(pset))\n    for i in range(len(pset)):\n        for j in range(i + 1, len(pset)):\n            if (compare(pset[i], pset[j])):\n                g.addedge(i, j)\n    in1, in2 = None, None\n    for j in range(len(pset)):\n        if (pset[j] == num1):\n            in1 = j\n    for j in range(len(pset)):\n        if (pset[j] == num2):\n            in2 = j\n\n    return g.bfs(in1, in2)\n",
        "test": "\nif __name__ == '__main__':\n    num1 = 1033\n    num2 = 8179\n    print(shortestPath(num1, num2))\n",
        "output": "6\n",
        "fn_call": "shortestPath"
    },
    {
        "text": "find the winner by adding pairwise difference of elements in the array until possible | python3 implementation of the approach ; function to return the winner of the game ; to store the gcd of the original array ; to store the maximum element from the original array ; if number of moves are odd ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def getWinner(arr, n):\n    __gcd = arr[0]\n    maxEle = arr[0]\n    for i in range(1, n):\n        __gcd = gcd(__gcd, arr[i])\n        maxEle = max(maxEle, arr[i])\n    totalMoves = (maxEle / __gcd) - n\n    if (totalMoves % 2 == 1):\n        return 'A'\n    return 'B'\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 6, 7]\n    n = len(arr)\n    print(getWinner(arr, n))\n",
        "output": "B\n",
        "fn_call": "getWinner"
    },
    {
        "text": "generate an alternate increasing and decreasing array | function that returns generated array ; dynamically allocate array ; start , end = 0 , n ; iterate over array ; if str [ i ] = = ' i ' assign arr [ i ] as start and increment start ; if str [ i ] = = ' d ' assign arr [ i ] as end and decrement end ; assign a [ n ] as start ; return starting address of array a ; ",
        "context": "",
        "code": "def DiStirngMatch(Str):\n    N = len(Str)\n    arr = (N + 1) * [0]\n    START, END = 0, N\n    for i in range(N):\n        if (Str[i] == 'I'):\n            arr[i] = START\n            START += 1\n        if (Str[i] == 'D'):\n            arr[i] = END\n            END -= 1\n    arr[N] = START\n    return arr\n",
        "test": "\nif __name__ == \"__main__\":\n    Str = \"IDID\"\n    N = len(Str)\n    ptr = DiStirngMatch(Str)\n    for i in range(N + 1):\n        print(ptr[i], end=\" \")\n",
        "output": "0 4 1 3 2 ",
        "fn_call": "DiStirngMatch"
    },
    {
        "text": "find maximum sum taking every kth element in the array | python 3 implementation of the approach ; function to return the maximum sum for every possible sequence such that a [ i ] + a [ i + k ] + a [ i + 2 k ] + ... + a [ i + qk ] is maximized ; initialize the maximum with the smallest value ; find maximum from all sequences ; sum of the sequence starting from index i ; update maximum ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxSum(arr, n, K):\n    maximum = -sys .maxsize - 1\n    for i in range(n):\n        sumk = 0\n        for j in range(i, n, K):\n            sumk = sumk + arr[j]\n        maximum = max(maximum, sumk)\n    return maximum\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 6, 4, 7, 2]\n    n = len(arr)\n    K = 2\n    print(maxSum(arr, n, K))\n",
        "output": "13\n",
        "fn_call": "maxSum"
    },
    {
        "text": "sum of the series kn + ( k ( n |  ; recursive python3 program to compute modular power ; base cases ; if b is even ; if b is odd ; function to return sum ; ",
        "context": "",
        "code": "def exponent(A, B):\n    if (A == 0):\n        return 0\n    if (B == 0):\n        return 1\n    if (B % 2 == 0):\n        y = exponent(A, B / 2)\n        y = (y * y)\n    else:\n        y = A\n        y = (y * exponent(A, B - 1))\n    return y\n\n\ndef sum(k, n):\n    sum = exponent(k, n + 1) - exponent(k - 1, n + 1)\n    return sum\n",
        "test": "\nn = 3\nK = 3\nprint(sum(K, n))\n",
        "output": "65\n",
        "fn_call": "sum"
    },
    {
        "text": "minimum steps required to convert x to y where a binary matrix represents the possible conversions | pyton3 implementation of the above approach ; dist [ ] [ ] will be the output matrix that will finally have the shortest distances between every pair of numbers ; initially same as mat ; add all numbers one by one to the set of intermediate numbers . before start of an iteration , we have shortest distances between all pairs of numbers such that the shortest distances consider only the numbers in set { 0 , 1 , 2 , . . k - 1 } as intermediate numbers . after the end of an iteration , vertex no . k is added to the set of intermediate numbers and the set becomes { 0 , 1 , 2 , . . k } ; pick all numbers as source one by one ; pick all numbers as destination for the above picked source ; if number k is on the shortest path from i to j , then update the value of dist [ i ] [ j ] ; if no path ; ",
        "context": "\nINF = 99999\nsize = 10\n\n",
        "code": "def findMinimumSteps(mat, x, y, n):\n    dist = [[0 for i in range(n)]for i in range(n)]\n    i, j, k = 0, 0, 0\n    for i in range(n):\n        for j in range(n):\n            if (mat[i][j] == 0):\n                dist[i][j] = INF\n            else:\n                dist[i][j] = 1\n            if (i == j):\n                dist[i][j] = 1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if (dist[i][k] + dist[k][j] < dist[i][j]):\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    if (dist[x][y] < INF):\n        return dist[x][y]\n    else:\n        return -1\n",
        "test": "\nmat = [\n    [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [\n                0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [\n                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [\n                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [\n                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [\n                                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [\n                                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [\n                                            0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\nx, y = 2, 3\nprint(findMinimumSteps(mat, x, y, size))\n",
        "output": "2\n",
        "fn_call": "findMinimumSteps"
    },
    {
        "text": "find n distinct numbers whose bitwise xor is equal to k | function to find n integers having bitwise xor equal to k ; base cases ; assign values to p and q ; stores bitwise xor of the first ( n - 3 ) elements ; print the first n - 3 elements ; calculate bitwise xor of first ( n - 3 ) elements ; ",
        "context": "",
        "code": "def findArray(N, K):\n    if (N == 1):\n        print(K, end=\" \")\n        return\n    if (N == 2):\n        print(\"0\", end=\" \")\n        print(K, end=\" \")\n        return\n    P = N - 2\n    Q = N - 1\n    VAL = 0\n    for i in range(1, N - 2):\n        print(i, end=\" \")\n        VAL ^= i\n    if (VAL == K):\n        print(P, end=\" \")\n        print(Q, end=\" \")\n        print(P ^ Q, end=\" \")\n    else:\n        print(\"0\", end=\" \")\n        print(P, end=\" \")\n        print(P ^ K ^ VAL, end=\" \")\n",
        "test": "\nN = 4\nX = 6\nfindArray(N, X)\n",
        "output": "1 0 2 5 ",
        "fn_call": "findArray"
    },
    {
        "text": "harshad ( or niven ) number | python implementation of above approach ; converting integer to string ; initialising sum to 0 ; traversing through the string ; converting character to int ; comparing number and sum ; ",
        "context": "",
        "code": "def checkHarshad(n):\n    st = str(n)\n    sum = 0\n    length = len(st)\n    for i in st:\n        sum = sum + int(i)\n    if (n % sum == 0):\n        return \"Yes\"\n    else:\n        return \"No\"\n",
        "test": "\nnumber = 18\nprint(checkHarshad(number))\n",
        "output": "Yes\n",
        "fn_call": "checkHarshad"
    },
    {
        "text": "count of camel case characters present in a given string | function to count all the camelcase characters in the string s ; stores the total count of camelcase characters ; traverse the string s ; if ascii value of character lies over the range [ 65 , 91 ] then increment the count ; print the total count obtained ; ",
        "context": "",
        "code": "def countCamelCase(S):\n    count = 0\n    for i in range(len(S)):\n        if (ord(S[i]) >= 65 and ord(S[i]) <= 91):\n            count += 1\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"ckjkUUYII\"\n    countCamelCase(S)\n",
        "output": "5\n",
        "fn_call": "countCamelCase"
    },
    {
        "text": "smallest number which is not coprime with any element of an array | python 3 program for the above approach ; function check if a number is prime or not ; corner cases ; check if n is divisible by 2 or 3 ; check for every 6 th number . the above checking allows to skip middle 5 numbers ; function to store primes in an array ; function to find the smallest number which is not coprime with any element of the array arr [ ] ; store the prime numbers ; function call to fill the prime numbers ; stores the answer ; generate all non - empty subsets of the primes [ ] array ; stores product of the primes ; checks if temp is coprime with the array or not ; check if the product temp is not coprime with the whole array ; if the product is not co - prime with the array ; print the answer ; ",
        "context": "\nfrom math import sqrt, gcd\nimport sys\nMAX = 50\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    for i in range(5, int(sqrt(n)) + 1, 6):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n    return True\n\n\ndef findPrime(primes):\n    global MAX\n    for i in range(2, MAX + 1, 1):\n        if (isPrime(i)):\n            primes .append(i)\n\n\ndef findMinimumNumber(arr, N):\n    primes = []\n    findPrime(primes)\n    ans = sys .maxsize\n    n = len(primes)\n    for i in range(1, (1 << n), 1):\n        temp = 1\n        for j in range(n):\n            if (i & (1 << j)):\n                temp *= primes[j]\n        check = True\n        for k in range(N):\n            if (gcd(temp, arr[k]) == 1):\n                check = False\n                break\n        if (check):\n            ans = min(ans, temp)\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 4, 6, 7, 8, 9, 10]\n    N = len(arr)\n    findMinimumNumber(arr, N)\n",
        "output": "42\n",
        "fn_call": "findMinimumNumber"
    },
    {
        "text": "longest sub | function to return the length of the longest required sub - sequence ; sort the array ; to store the resultant length ; if array contains only one element then it divides itself ; every element divides itself ; count for all numbers which are lesser than a [ i ] ; if a [ i ] % a [ j ] then update the maximum subsequence length , dp [ i ] = max ( dp [ i ] , 1 + dp [ j ] ) where j is in the range [ 0 , i - 1 ] ; if array contains only one element then i = j which doesn 't satisfy the condition ; ",
        "context": "",
        "code": "def find(n, a):\n    a .sort()\n    res = 1\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = 1\n        for j in range(i):\n            if (a[i] % a[j] == 0):\n                dp[i] = max(dp[i], 1 + dp[j])\n        res = max(res, dp[i])\n    if (res == 1):\n        return -1\n    else:\n        return res\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 4, 6, 1, 3, 11]\n    n = len(a)\n    print(find(n, a))\n",
        "output": "3\n",
        "fn_call": "find"
    },
    {
        "text": "count pairs in an array which have at least one digit common | returns true if the pair is valid , otherwise false ; converting integers to strings ; iterate over the strings and check if a character in first string is also present in second string , return true ; no common digit found ; returns the number of valid pairs ; iterate over all possible pairs ; ",
        "context": "",
        "code": "def checkValidPair(num1, num2):\n    s1 = str(num1)\n    s2 = str(num2)\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            if (s1[i] == s2[j]):\n                return True\n    return False\n\n\ndef countPairs(arr, n):\n    numberOfPairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (checkValidPair(arr[i], arr[j])):\n                numberOfPairs += 1\n    return numberOfPairs\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 12, 24]\n    n = len(arr)\n    print(countPairs(arr, n))\n",
        "output": "2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "content of a polynomial | python3 implementation to find the content of the polynomial ; function to find the content of the polynomial ; loop to iterate over the elements of the array ; __gcd ( a , b ) is a inbuilt function for greatest common divisor ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def findContent(arr, n):\n    content = arr[0]\n    for i in range(1, n):\n        content = gcd(content, arr[i])\n    return content\n",
        "test": "\nif __name__ == '__main__':\n    n = 3\n    arr = [9, 6, 12]\n    print(findContent(arr, n))\n",
        "output": "3\n",
        "fn_call": "findContent"
    },
    {
        "text": "find the area of the shaded region formed by the intersection of four semicircles in a square | function to return the area of the shaded region ; area of the square ; area of the semicircle ; there are 4 semicircles shadedarea = area of 4 semicircles - area of square ; ",
        "context": "",
        "code": "def findAreaShaded(a):\n    sqArea = a * a\n    semiCircleArea = (3.14 * (a * a) / 8)\n    ShadedArea = 4 * semiCircleArea - sqArea\n    return ShadedArea\n",
        "test": "\nif __name__ == '__main__':\n    a = 10\n    print(findAreaShaded(a))\n",
        "output": "57.0\n",
        "fn_call": "findAreaShaded"
    },
    {
        "text": "count all palindromic subsequence in a given string | python 3 program to counts palindromic subsequence in a given string using recursion ; function return the total palindromic subsequence ; ",
        "context": "\nstr = \"abcb\"\n\n",
        "code": "def countPS(i, j):\n    if (i > j):\n        return 0\n    if (dp[i][j] != -1):\n        return dp[i][j]\n    if (i == j):\n        dp[i][j] = 1\n        return dp[i][j]\n    elif (str[i] == str[j]):\n        dp[i][j] = (countPS(i + 1, j) + countPS(i, j - 1) + 1)\n        return dp[i][j]\n    else:\n        dp[i][j] = (\n            countPS(\n                i +\n                1,\n                j) +\n            countPS(\n                i,\n                j -\n                1) -\n            countPS(\n                i +\n                1,\n                j -\n                1))\n        return dp[i][j]\n",
        "test": "\nif __name__ == \"__main__\":\n    dp = [[-1 for x in range(1000)]for y in range(1000)]\n    n = len(str)\n    print(\"Total palindromic subsequence are :\", countPS(0, n - 1))\n",
        "output": "Total palindromic subsequence are : 6\n",
        "fn_call": "countPS"
    },
    {
        "text": "minimum value of k such that sum of cubes of first k natural number is greater than equal to n | function to determine the minimum value of k such that the sum of cubes of first k natural number is greater than or equal to n ; left bound ; right bound ; variable to store the answer ; applying binary search ; calculating mid value of the range ; if the sum of cubes of first mid natural numbers is greater than equal to n iterate the left half ; sum of cubes of first mid natural numbers is less than n , then move to the right segment ; ",
        "context": "",
        "code": "def binary_searched_find_x(k):\n    l = 0\n    r = k\n    ans = 0\n    while l <= r:\n        mid = l + (r - l) // 2\n        if ((mid * (mid + 1)) // 2)**2 >= k:\n            ans = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 100\n    print(binary_searched_find_x(N))\n",
        "output": "4\n",
        "fn_call": "binary_searched_find_x"
    },
    {
        "text": "convert string to integer without using any in | function to convert string to integer without using functions ; initialize a variable ; iterate till length of the string ; subtract 48 from the current digit ; print the answer ; ",
        "context": "",
        "code": "def convert(s):\n    num = 0\n    n = len(s)\n    for i in s:\n        num = num * 10 + (ord(i) - 48)\n    print(num)\n",
        "test": "\nif __name__ == '__main__':\n    s = \"123\"\n    convert(s)\n",
        "output": "123\n",
        "fn_call": "convert"
    },
    {
        "text": "convert decimal to hexa | function to convert decimal no . to hexadecimal number ; map for decimal to hexa , 0 - 9 are straightforward , alphabets a - f used for 10 to 15. ; string to be returned ; check if num is 0 and directly return \"0\" ; if num > 0 , use normal technique as discussed in other post ; if num < 0 , we need to use the elaborated trick above , lets see this ; store num in a u_int , size of u_it is greater , it will be positive since msb is 0 ; use the same remainder technique . ; ",
        "context": "",
        "code": "def Hex(num):\n    m = dict .fromkeys(range(16), 0)\n    digit = ord('0')\n    c = ord('a')\n    for i in range(16):\n        if (i < 10):\n            m[i] = chr(digit)\n            digit += 1\n        else:\n            m[i] = chr(c)\n            c += 1\n    res = \"\"\n    if (not num):\n        return \"0\"\n    if (num > 0):\n        while (num):\n            res = m[num % 16] + res\n            num //= 16\n    else:\n        n = num + 2 ** 32\n        while (n):\n            res = m[n % 16] + res\n            n //= 16\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 134\n    y = -1\n    z = -234\n    print(\"Hexa representation for\")\n    print(x, \"is\", Hex(x))\n    print(y, \"is\", Hex(y))\n    print(z, \"is\", Hex(z))\n",
        "output": "Hexa representation for\n134 is 86\n-1 is ffffffff\n-234 is ffffff16\n",
        "fn_call": "Hex"
    },
    {
        "text": "Cycles of length n in an undirected and connected graph | Number of vertices ; mark the vertex vert as visited ; if the path of length ( n - 1 ) is found ; mark vert as un - visited to make it usable again . ; Check if vertex vert can end with vertex start ; For searching every possible path of length ( n - 1 ) ; DFS for searching path by decreasing length by 1 ; marking vert as unvisited to make it usable again . ; Counts cycles of length N in an undirected and connected graph . ; all vertex are marked un - visited initially . ; Searching for cycle by using v - n + 1 vertices ; ith vertex is marked as visited and will not be visited again . ; main :",
        "context": "\nV = 5\n\n",
        "code": "def DFS(graph, marked, n, vert, start, count):\n    marked[vert] = True\n    if n == 0:\n        marked[vert] = False\n        if graph[vert][start] == 1:\n            count = count + 1\n            return count\n        else:\n            return count\n    for i in range(V):\n        if marked[i] == False and graph[vert][i] == 1:\n            count = DFS(graph, marked, n - 1, i, start, count)\n    marked[vert] = False\n    return count\n\n\ndef countCycles(graph, n):\n    marked = [False] * V\n    count = 0\n    for i in range(V - (n - 1)):\n        count = DFS(graph, marked, n - 1, i, i, count)\n        marked[i] = True\n    return int(count / 2)\n",
        "test": "\ngraph = [[0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [\n    0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]]\nn = 4\nprint(\"Total cycles of length \", n, \" are \", countCycles(graph, n))\n",
        "output": "Total cycles of length  4  are  3\n",
        "fn_call": "countCycles"
    },
    {
        "text": "find distinct integers for a triplet with given product | python3 implementation of the approach ; function to find the required triplets ; to store the factors ; find factors in sqrt ( x ) time ; choose a factor ; choose another factor ; these conditions need to be met for a valid triplet ; print the valid triplet ; triplet found ; triplet not found ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def findTriplets(x):\n    fact = []\n    factors = set()\n    for i in range(2, int(sqrt(x))):\n        if (x % i == 0):\n            fact .append(i)\n            if (x / i != i):\n                fact .append(x // i)\n            factors .add(i)\n            factors .add(x // i)\n    found = False\n    k = len(fact)\n    for i in range(k):\n        a = fact[i]\n        for j in range(k):\n            b = fact[j]\n            if ((a != b) and (x % (a * b) == 0) and (x / (a * b) != a)\n                    and (x / (a * b) != b) and (x / (a * b) != 1)):\n                print(a, b, x // (a * b))\n                found = True\n                break\n        if (found):\n            break\n    if (not found):\n        print(\"-1\")\n",
        "test": "\nif __name__ == \"__main__\":\n    x = 105\n    findTriplets(x)\n",
        "output": "3 5 7\n",
        "fn_call": "findTriplets"
    },
    {
        "text": "find nth term of series 1 , 4 , 15 , 72 , 420. . . | function for finding factorial of n ; return factorial of n ; function for calculating nth term of series ; ",
        "context": "",
        "code": "def factorial(N):\n    fact = 1\n    for i in range(1, N + 1):\n        fact = fact * i\n    return fact\n\n\ndef nthTerm(N):\n    return (factorial(N) * (N + 2) // 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    print(nthTerm(N))\n",
        "output": "2880\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "triplet with no element divisible by 3 and sum n | function to print a , b and c ; first loop ; check for 1 st number ; second loop ; check for 2 nd number ; third loop ; check for 3 rd number ; ",
        "context": "",
        "code": "def printCombination(n):\n    for i in range(1, n):\n        if (i % 3 != 0):\n            for j in range(1, n):\n                if (j % 3 != 0):\n                    for k in range(1, n):\n                        if (k % 3 != 0 and (i + j + k) == n):\n                            print(i, j, k)\n                            return\n",
        "test": "\nn = 233\nprintCombination(n)\n",
        "output": "1 2 230\n",
        "fn_call": "printCombination"
    },
    {
        "text": "check if all people can vote on two machines | returns true if n people can vote using two machines in x time . ; calculate total sum i . e total time taken by all people ; if total time is less than x then all people can definitely vote hence return true ; sort the list ; declare a list presum of same size as that of a and initialize it with 0 ; prefixsum for first element will be element itself ; fill the array ; set i and j and check if array from i to j - 1 gives sum <= x ; ",
        "context": "",
        "code": "def canVote(a, n, x):\n    total_sum = 0\n    for i in range(len(a)):\n        total_sum += a[i]\n    if (total_sum <= x):\n        return True\n    a .sort()\n    presum = [0 for i in range(len(a))]\n    presum[0] = a[0]\n    for i in range(1, len(presum)):\n        presum[i] = presum[i - 1] + a[i]\n    for i in range(0, len(presum)):\n        for j in range(i + 1, len(presum)):\n            arr1_sum = (presum[i] + (total_sum - presum[j]))\n            if ((arr1_sum <= x) and (total_sum - arr1_sum) <= x):\n                return True\n    return False\n",
        "test": "\nn = 3\nx = 4\na = [2, 4, 2]\nif (canVote(a, n, x)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "canVote"
    },
    {
        "text": "distribute m objects starting from sth person such that every ith person gets arr [ i ] objects | function to find distribution of m objects among all array elements ; stores the distribution of m objects ; stores the indices of distribution ; stores the remaining objects ; iterate until rem is positive ; if the number of remaining objects exceeds required the number of objects ; increase the number of objects for the index ptr by arr [ ptr ] ; decrease remaining objects by arr [ ptr ] ; increase the number of objects for the index ptr by rem ; decrease remaining objects to 0 ; increase ptr by 1 ; print the final distribution ; ",
        "context": "",
        "code": "def distribute(N, K, M, arr):\n    distribution = [0] * N\n    ptr = K - 1\n    rem = M\n    while (rem > 0):\n        if (rem >= arr[ptr]):\n            distribution[ptr] += arr[ptr]\n            rem -= arr[ptr]\n        else:\n            distribution[ptr] += rem\n            rem = 0\n        ptr = (ptr + 1) % N\n    for i in range(N):\n        print(distribution[i], end=\" \")\n",
        "test": "\narr = [2, 3, 2, 1, 4]\nM = 11\nS = 2\nN = len(arr)\ndistribute(N, S, M, arr)\n",
        "output": "1 3 2 1 4 ",
        "fn_call": "distribute"
    },
    {
        "text": "m coloring problem | backtracking | a utility function to prsolution ; check if the colored graph is safe or not ; check for every edge ; this function solves the m coloring problem using recursion . it returns false if the m colours cannot be assigned , otherwise , return true and prints assignments of colours to all vertices . please note that there may be more than one solutions , this function prints one of the feasible solutions . ; if current index reached end ; if coloring is safe ; prthe solution ; assign each color from 1 to m ; recur of the rest vertices ; ",
        "context": "",
        "code": "def printSolution(color):\n    print(\"Solution Exists:\" \" Following are the assigned colors \")\n    for i in range(4):\n        print(color[i], end=\" \")\n\n\ndef isSafe(graph, color):\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if (graph[i][j] and color[j] == color[i]):\n                return False\n    return True\n\n\ndef graphColoring(graph, m, i, color):\n    if (i == 4):\n        if (isSafe(graph, color)):\n            printSolution(color)\n            return True\n        return False\n    for j in range(1, m + 1):\n        color[i] = j\n        if (graphColoring(graph, m, i + 1, color)):\n            return True\n        color[i] = 0\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    graph = [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0], ]\n    m = 3\n    color = [0 for i in range(4)]\n    if (not graphColoring(graph, m, 0, color)):\n        print(\"Solution does not exist\")\n",
        "output": "Solution Exists: Following are the assigned colors \n1 2 3 2 ",
        "fn_call": "graphColoring"
    },
    {
        "text": "number of digits in the product of two numbers | function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product 'p ; required count of digits ; ",
        "context": "",
        "code": "def countDigits(a, b):\n    count = 0\n    p = abs(a * b)\n    if (p == 0):\n        return 1\n    while (p > 0):\n        count = count + 1\n        p = p // 10\n    return count\n",
        "test": "\na = 33\nb = -24\nprint((\"Number of digits = \", countDigits(a, b)))\n",
        "output": "('Number of digits = ', 3)\n",
        "fn_call": "countDigits"
    },
    {
        "text": "find kth largest string from the permutations of the string with two characters | function to print the kth largest string ; loop to iterate through series ; total takes the position of second y ; i takes the position of first y ; calculating first y position ; calculating second y position from first y ; print all x before first y ; print first y ; print all x between first y and second y ; print second y ; print x which occur after second y ; ",
        "context": "",
        "code": "def kthString(n, k):\n    total = 0\n    i = 1\n    while (total < k):\n        total = total + n - i\n        i += 1\n    first_y_position = i - 1\n    second_y_position = k - (total - n + first_y_position)\n    for j in range(1, first_y_position, 1):\n        print(\"x\", end=\"\")\n    print(\"y\", end=\"\")\n    j = first_y_position + 1\n    while (second_y_position > 1):\n        print(\"x\", end=\"\")\n        second_y_position -= 1\n        j += 1\n    print(\"y\", end=\"\")\n    while (j < n):\n        print(\"x\")\n        j += 1\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    k = 7\n    kthString(n, k)\n",
        "output": "xyxxy",
        "fn_call": "kthString"
    },
    {
        "text": "bin packing problem ( minimize number of used bins ) | returns number of bins required using first fit online algorithm ; initialize result ( count of bins ) ; create an array to store remaining space in bins there can be at most n bins ; place items one by one ; find the first bin that can accommodate weight [ i ] ; if no bin could accommodate weight [ i ] ; ",
        "context": "",
        "code": "def firstFit(weight, n, c):\n    res = 0\n    bin_rem = [0] * n\n    for i in range(n):\n        j = 0\n        while (j < res):\n            if (bin_rem[j] >= weight[i]):\n                bin_rem[j] = bin_rem[j] - weight[i]\n                break\n            j += 1\n        if (j == res):\n            bin_rem[res] = c - weight[i]\n            res = res + 1\n    return res\n",
        "test": "\nweight = [2, 5, 4, 7, 1, 3, 8]\nc = 10\nn = len(weight)\nprint(\"Number of bins required in First Fit : \", firstFit(weight, n, c))\n",
        "output": "Number of bins required in First Fit :  4\n",
        "fn_call": "firstFit"
    },
    {
        "text": "find the number of binary strings of length n with at least 3 consecutive 1 s | function to return the count of required strings ; '0' at ith position ; '1' at ith position ; ",
        "context": "",
        "code": "def solve(i, x, dp):\n    if (i < 0):\n        return x == 3\n    if (dp[i][x] != -1):\n        return dp[i][x]\n    dp[i][x] = solve(i - 1, 0, dp)\n    dp[i][x] += solve(i - 1, x + 1, dp)\n    return dp[i][x]\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 4\n    dp = [[0 for i in range(n)]for j in range(4)]\n    for i in range(n):\n        for j in range(4):\n            dp[i][j] = -1\n    for i in range(n):\n        dp[i][3] = (1 << (i + 1))\n    print(solve(n - 1, 0, dp))\n",
        "output": "3\n",
        "fn_call": "solve"
    },
    {
        "text": "count full prime numbers in a given range | function to check if a number is prime or not ; if a divisor of n exists ; function to check if a number is full prime or not ; if n is not a prime ; otherwise ; extract digit ; if any digit of n is non - prime ; function to prcount of full primes in a range [ l , r ] ; stores count of full primes ; check if i is full prime ; ",
        "context": "",
        "code": "def isPrime(num):\n    if (num <= 1):\n        return False\n    for i in range(2, num + 1):\n        if i * i > num:\n            break\n        if (num % i == 0):\n            return False\n    return True\n\n\ndef isFulPrime(n):\n    if (not isPrime(n)):\n        return False\n    else:\n        while (n > 0):\n            rem = n % 10\n            if (not (rem == 2 or rem == 3 or rem == 5 or rem == 7)):\n                return False\n            n = n // 10\n    return True\n\n\ndef countFulPrime(L, R):\n    cnt = 0\n    for i in range(L, R + 1):\n        if ((i % 2) != 0 and isFulPrime(i)):\n            cnt += 1\n    return cnt\n",
        "test": "\nif __name__ == '__main__':\n    L = 1\n    R = 100\n    ans = 0\n    if (L < 3):\n        ans += 1\n    print(ans + countFulPrime(L, R))\n",
        "output": "8\n",
        "fn_call": "countFulPrime"
    },
    {
        "text": "ways to arrange balls such that adjacent balls are of different types | returns count of arrangements where last placed ball is ' last ' . ' last ' is 0 for ' p ' , 1 for ' q ' and 2 for 'r ; if number of balls of any color becomes less than 0 the number of ways arrangements is 0. ; if last ball required is of type p and the number of balls of p type is 1 while number of balls of other color is 0 the number of ways is 1. ; same case as above for ' q ' and 'r ; if last ball required is p and the number of ways is the sum of number of ways to form sequence with ' p - 1' p balls , q q balls and r r balls ending with q and r . ; same as above case for ' q ' and 'r ; returns count of required arrangements ; three cases arise : last required balls is type p last required balls is type q last required balls is type r ; ",
        "context": "",
        "code": "def countWays(p, q, r, last):\n    if (p < 0 or q < 0 or r < 0):\n        return 0\n    if (p == 1 and q == 0 and\n            r == 0 and last == 0):\n        return 1\n    if (p == 0 and q == 1 and\n            r == 0 and last == 1):\n        return 1\n\n    if (p == 0 and q == 0 and\n            r == 1 and last == 2):\n        return 1\n    if (last == 0):\n        return (countWays(p - 1, q, r, 1) +\n                countWays(p - 1, q, r, 2))\n    if (last == 1):\n        return (countWays(p, q - 1, r, 0) +\n                countWays(p, q - 1, r, 2))\n    if (last == 2):\n        return (countWays(p, q, r - 1, 0) +\n                countWays(p, q, r - 1, 1))\n\n\ndef countUtil(p, q, r):\n    return (countWays(p, q, r, 0) +\n            countWays(p, q, r, 1) +\n            countWays(p, q, r, 2))\n",
        "test": "\np = 1\nq = 1\nr = 1\nprint(countUtil(p, q, r))\n",
        "output": "6\n",
        "fn_call": "countUtil"
    },
    {
        "text": "length of longest prefix anagram which are common in given two strings | python3 program for the above approach ; function to check if two arrays are identical or not ; iterate over the range [ 0 , size ] ; if frequency any character is not same in both the strings ; otherwise ; function to find the maximum length of the required string ; store the count of characters in str1 ; store the count of characters in str2 ; stores the maximum length ; minimum length of str1 and str2 ; increment the count of characters of str1 [ i ] in freq1 [ ] by one ; increment the count of characters of stord ( r2 [ i ] ) in freq2 [ ] by one ; checks if prefixes are anagram or not ; finally prthe ans ; ",
        "context": "\nSIZE = 26\n\n",
        "code": "def longHelper(freq1, freq2):\n    for i in range(26):\n        if (freq1[i] != freq2[i]):\n            return False\n    return True\n\n\ndef longCommomPrefixAnagram(s1, s2, n1, n2):\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    ans = 0\n    mini_len = min(n1, n2)\n    for i in range(mini_len):\n        freq1[ord(s1[i]) - ord('a')] += 1\n        freq2[ord(s2[i]) - ord('a')] += 1\n        if (longHelper(freq1, freq2)):\n            ans = i + 1\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"abaabcdezzwer\"\n    str2 = \"caaabbttyh\"\n    N = len(str1)\n    M = len(str2)\n    longCommomPrefixAnagram(str1, str2, N, M)\n",
        "output": "6\n",
        "fn_call": "longCommomPrefixAnagram"
    },
    {
        "text": "next smaller element | prints element and nse pair for all elements of list ; ",
        "context": "",
        "code": "def printNSE(arr):\n    for i in range(0, len(arr), 1):\n        next = -1\n        for j in range(i + 1, len(arr), 1):\n            if arr[i] > arr[j]:\n                next = arr[j]\n                break\n        print(str(arr[i]) + \" -- \" + str(next))\n",
        "test": "\narr = [11, 13, 21, 3]\nprintNSE(arr)\n",
        "output": "11 -- 3\n13 -- 3\n21 -- 3\n3 -- -1\n",
        "fn_call": "printNSE"
    },
    {
        "text": "modify given array by reducing each element by its next smaller element | function to print the final array after reducing each array element by its next smaller element ; initialize stack ; to store the corresponding element ; if stack is not empty ; if top element is smaller than the current element ; keep popping until stack is empty or top element is greater than the current element ; if stack is not empty ; push current element ; final array ; ",
        "context": "",
        "code": "def printFinalPrices(arr):\n    minStk = []\n    reduce = [0] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        if minStk:\n            if minStk[-1] <= arr[i]:\n                reduce[i] = minStk[-1]\n            else:\n                while minStk and minStk[-1] > arr[i]:\n                    minStk .pop()\n                if minStk:\n                    reduce[i] = minStk[-1]\n        minStk .append(arr[i])\n    for i in range(len(arr)):\n        print(arr[i] - reduce[i], end=' ')\n",
        "test": "\nif __name__ == '__main__':\n    arr = [8, 4, 6, 2, 3]\n    printFinalPrices(arr)\n",
        "output": "4 2 4 2 3 ",
        "fn_call": "printFinalPrices"
    },
    {
        "text": "count common subsequence in two strings | return the number of common subsequence in two strings ; for each character of s ; for each character in t ; if character are same in both the string ; ",
        "context": "",
        "code": "def CommomSubsequencesCount(s, t):\n    n1 = len(s)\n    n2 = len(t)\n    dp = [[0 for i in range(n2 + 1)]for i in range(n1 + 1)]\n    for i in range(1, n1 + 1):\n        for j in range(1, n2 + 1):\n            if (s[i - 1] == t[j - 1]):\n                dp[i][j] = (1 + dp[i][j - 1] + dp[i - 1][j])\n            else:\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1])\n    return dp[n1][n2]\n",
        "test": "\ns = \"ajblqcpdz\"\nt = \"aefcnbtdi\"\nprint(CommomSubsequencesCount(s, t))\n",
        "output": "11\n",
        "fn_call": "CommomSubsequencesCount"
    },
    {
        "text": "minimum replacements such that no palindromic substring of length exceeding 1 is present in the given string | function to count the changes required such that no palindromic subof length exceeding 1 is present in the string ;  ; stores the count ; iterate over the string ; palindromic subof length 2 ; replace the next character ; increment changes ; palindromic subof length 3 ; replace the next character ; increment changes ; ",
        "context": "",
        "code": "def maxChange(str):\n    str = [i for i in str]\n    if (len(str) <= 1):\n        return 0\n    minChanges = 0\n    for i in range(len(str) - 1):\n        if (str[i] == str[i + 1]):\n            str[i + 1] = 'N'\n            minChanges += 1\n        elif (i > 0 and str[i - 1] == str[i + 1]):\n            str[i + 1] = 'N'\n            minChanges += 1\n    return minChanges\n",
        "test": "\nif __name__ == '__main__':\n    str = \"bbbbbbb\"\n    print(maxChange(str))\n",
        "output": "4\n",
        "fn_call": "maxChange"
    },
    {
        "text": "find if string is k | find if string is k - palindrome or not using all characters exactly once python 3 program to find if string is k - palindrome or not using all characters exactly once ; when size of string is less than k ; when size of string is equal to k ; when size of string is greater than k to store the frequencies of the characters ; to store the count of characters whose number of occurrences is odd . ; iterating over the map ; ",
        "context": "",
        "code": "def iskPalindromesPossible(s, k):\n    if (len(s) < k):\n        print(\"Not Possible\")\n        return\n    if (len(s) == k):\n        print(\"Possible\")\n        return\n    freq = dict .fromkeys(s, 0)\n    for i in range(len(s)):\n        freq[s[i]] += 1\n    count = 0\n    for value in freq .values():\n        if (value % 2 == 1):\n            count += 1\n    if (count > k):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"poor\"\n    K = 3\n    iskPalindromesPossible(str1, K)\n    str = \"geeksforgeeks\"\n    K = 10\n    iskPalindromesPossible(str, K)\n",
        "output": "Yes\nYes\n",
        "fn_call": "iskPalindromesPossible"
    },
    {
        "text": "minimum value of k such that each substring of size k has the given character | function to find the minimum value of k such that char c occurs in all k sized substrings of string s ; store the string length ; store difference of lengths of segments of every two consecutive occurrences of c ; stores the maximum difference ; store the previous occurence of char c ; check if the current character is c or not ; stores the difference of consecutive occurrences of c ; update previous occurrence of c with current occurence ; comparing diff with max ; if string doesn 't contain c ; return max ; ",
        "context": "",
        "code": "def findK(s, c):\n    n = len(s)\n    diff = 0\n    max = 0\n    prev = 0\n    for i in range(0, n):\n        if (s[i] == c):\n            diff = i - prev\n            prev = i\n            if (diff > max):\n                max = diff\n    if (max == 0):\n        return -1\n    return max\n",
        "test": "\nif __name__ == \"__main__\":\n    S = \"abdegb\"\n    ch = 'b'\n    print(findK(S, ch))\n",
        "output": "4\n",
        "fn_call": "findK"
    },
    {
        "text": "find n | utility function ; since first element of the series is 7 , we initialise a variable with 7 ; using iteration to find nth term ; ",
        "context": "",
        "code": "def findTerm(n):\n    if n == 1:\n        return n\n    else:\n        term = 7\n        for i in range(2, n + 1):\n            term = term * 2 + (i - 1)\n    return term\n",
        "test": "\nprint(findTerm(5))\n",
        "output": "138\n",
        "fn_call": "findTerm"
    },
    {
        "text": "sum of all possible triplet products from given ranges | python3 program to implement the above approach ; function to find the sum of all possible triplet products ( i * j * k ) ; stores sum required sum ; iterate over all possible values of i ; iterate over all possible values of j ; iterate over all possible values of k ; stores the product of ( i * j * k ) ; update sum ; ",
        "context": "\nM = 1000000007\n\n",
        "code": "def findTripleSum(A, B, C):\n    sum = 0\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            for k in range(1, C + 1):\n                prod = (((i % M) * (j % M)) % M * (k % M)) % M\n                sum = (sum + prod) % M\n    return sum\n",
        "test": "\nif __name__ == '__main__':\n    A = 10\n    B = 100\n    C = 1000\n    print(findTripleSum(A, B, C))\n",
        "output": "13874027\n",
        "fn_call": "findTripleSum"
    },
    {
        "text": "minimum number of sub | function that returns true if n is a power of 5 ; function to return the decimal value of binary equivalent ; function to return the minimum cuts required ; allocating memory for dp [ ] array ; from length 1 to n ; if previous character is '0' then ignore to avoid number with leading 0 s . ; ignore s [ j ] = '0' starting numbers ; number formed from s [ j ... . i ] ; check for power of 5 ; assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; ",
        "context": "",
        "code": "def ispower(n):\n    if (n < 125):\n        return (n == 1 or n == 5 or n == 25)\n    if (n % 125 != 0):\n        return 0\n    else:\n        return ispower(n // 125)\n\n\ndef number(s, i, j):\n    ans = 0\n    for x in range(i, j):\n        ans = ans * 2 + (ord(s[x]) - ord('0'))\n    return ans\n\n\ndef minCuts(s, n):\n    dp = [n + 1 for i in range(n + 1)]\n    dp[0] = 0\n    for i in range(1, n + 1):\n        if (s[i - 1] == '0'):\n            continue\n        for j in range(i):\n            if (s[j] == '0'):\n                continue\n            num = number(s, j, i)\n            if (not ispower(num)):\n                continue\n            dp[i] = min(dp[i], dp[j] + 1)\n    if dp[n] < n + 1:\n        return dp[n]\n    else:\n        return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"101101101\"\n    n = len(s)\n    print(minCuts(s, n))\n",
        "output": "3\n",
        "fn_call": "minCuts"
    },
    {
        "text": "convert an array into another by repeatedly removing the last element and placing it at any arbitrary index | function to count the minimum number of operations required to convert the array a [ ] into array b [ ] ; stores the index in the first permutation a [ ] which is same as the subsequence in b [ ] ; find the first i elements in a [ ] which is a subsequence in b [ ] ; if element a [ i ] is same as b [ j ] ; return the count of operations required ; ",
        "context": "",
        "code": "def minCount(A, B, N):\n    i = 0\n    for j in range(N):\n        if (A[i] == B[j]):\n            i += 1\n    return N - i\n",
        "test": "\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5]\n    B = [1, 5, 2, 3, 4]\n    N = len(A)\n    print(minCount(A, B, N))\n",
        "output": "1\n",
        "fn_call": "minCount"
    },
    {
        "text": "minimum repeated addition of even divisors of n required to convert n to m | inf is the maximum value which indicates impossible state ; stores the dp states ; recursive function that considers all possible even divisors of cur ; indicates impossible state ; check dp [ cur ] is already calculated or not ; initially it is set to inf that meanswe cur can 't be transform to m ; loop to find even divisors of cur ; if i is divisor of cur ; if i is even ; find recursively for cur + i ; check another divisor ; find recursively for cur + ( cur / i ) ; finally store the current state result and return the answer ; function that counts the minimum operation to reduce n to m ; initialise dp state ; function call ; ",
        "context": "\nINF = 10000007\nmax_size = 100007\ndp = [0 for i in range(max_size)]\n\n",
        "code": "def min_op(cur, M):\n    if (cur > M):\n        return INF\n    if (cur == M):\n        return 0\n    if (dp[cur] != -1):\n        return dp[cur]\n    op = INF\n    i = 2\n    while (i * i <= cur):\n        if (cur % i == 0):\n            if (i % 2 == 0):\n                op = min(op, 1 + min_op(cur + i, M))\n            if ((cur // i) != i and (cur // i) % 2 == 0):\n                op = min(op, 1 + min_op(cur + (cur // i), M))\n        i += 1\n    dp[cur] = op\n    return op\n\n\ndef min_operations(N, M):\n    for i in range(N, M + 1):\n        dp[i] = -1\n    return min_op(N, M)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 6\n    M = 24\n    op = min_operations(N, M)\n    if (op >= INF):\n        print(-1)\n    else:\n        print(op)\n",
        "output": "4\n",
        "fn_call": "min_operations"
    },
    {
        "text": "count pairs with average present in the same array | python 3 implementation of the approach ; function to return the count of valid pairs ; frequency array twice the original size to hold negative elements as well ; update the frequency of each of the array element ; if say x = - 1000 then we will place the frequency of - 1000 at ( - 1000 + 1000 = 0 ) a [ 0 ] index ; to store the count of valid pairs ; remember we will check only for ( even , even ) or ( odd , odd ) pairs of indexes as the average of two consecutive elements is a floating point number ; ",
        "context": "\nN = 1000\n\n",
        "code": "def countPairs(arr, n):\n    size = (2 * N) + 1\n    freq = [0 for i in range(size)]\n    for i in range(n):\n        x = arr[i]\n        freq[x + N] += 1\n    ans = 0\n    for i in range(size):\n        if (freq[i] > 0):\n            ans += int(((freq[i]) * (freq[i] - 1)) / 2)\n            for j in range(i + 2, 2001, 2):\n                if (freq[j] > 0 and (freq[int((i + j) / 2)] > 0)):\n                    ans += (freq[i] * freq[j])\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 2, 5, 1, 3, 5]\n    n = len(arr)\n    print(countPairs(arr, n))\n",
        "output": "7\n",
        "fn_call": "countPairs"
    },
    {
        "text": "maximize array elements upto given number | function to find maximum possible value of number that can be obtained using array elements . ; variable to represent current index . ; variable to show value between 0 and maxlimit . ; table to store whether a value can be obtained or not upto a certain index 1. dp [ i , j ] = 1 if value j can be obtained upto index i . 2. dp [ i , j ] = 0 if value j cannot be obtained upto index i . ; check for index 0 if given value val can be obtained by either adding to or subtracting arr [ 0 ] from num . ; 1. if arr [ ind ] is added to obtain given val then val - arr [ ind ] should be obtainable from index ind - 1. 2. if arr [ ind ] is subtracted to obtain given val then val + arr [ ind ] should be obtainable from index ind - 1. check for both the conditions . ; if either of one condition is true , then val is obtainable at index ind . ; find maximum value that is obtained at index n - 1. ; if no solution exists return - 1. ; ",
        "context": "",
        "code": "def findMaxVal(arr, n, num, maxLimit):\n    ind = -1\n    val = -1\n    dp = [[0 for i in range(maxLimit + 1)]for j in range(n)]\n    for ind in range(n):\n        for val in range(maxLimit + 1):\n            if (ind == 0):\n                if (num - arr[ind] == val or num + arr[ind] == val):\n                    dp[ind][val] = 1\n                else:\n                    dp[ind][val] = 0\n            else:\n                if (val - arr[ind] >= 0 and val + arr[ind] <= maxLimit):\n                    if (dp[ind - 1][val - arr[ind]] ==\n                            1 or dp[ind - 1][val + arr[ind]] == 1):\n                        dp[ind][val] = 1\n                elif (val - arr[ind] >= 0):\n                    dp[ind][val] = dp[ind - 1][val - arr[ind]]\n                elif (val + arr[ind] <= maxLimit):\n                    dp[ind][val] = dp[ind - 1][val + arr[ind]]\n                else:\n                    dp[ind][val] = 0\n    for val in range(maxLimit, -1, -1):\n        if (dp[n - 1][val] == 1):\n            return val\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    num = 1\n    arr = [3, 10, 6, 4, 5]\n    n = len(arr)\n    maxLimit = 15\n    print(findMaxVal(arr, n, num, maxLimit))\n",
        "output": "9\n",
        "fn_call": "findMaxVal"
    },
    {
        "text": "length of the longest valid substring | python3 program to find length of the longest valid substring ; initialize curmax to zero ; iterate over the string starting from second index ; ",
        "context": "",
        "code": "def findMaxLen(s):\n    if (len(s) <= 1):\n        return 0\n    curMax = 0\n    longest = [0] * (len(s))\n    for i in range(1, len(s)):\n        if ((s[i] == ')' and i - longest[i - 1] - 1 >=\n                0 and s[i - longest[i - 1] - 1] == '(')):\n            longest[i] = longest[i - 1] + 2\n            if (i - longest[i - 1] - 2 >= 0):\n                longest[i] += (longest[i - longest[i - 1] - 2])\n            else:\n                longest[i] += 0\n            curMax = max(longest[i], curMax)\n    return curMax\n",
        "test": "\nif __name__ == '__main__':\n    Str = \"((()()\"\n    print(findMaxLen(Str))\n    Str = \"()(()))))\"\n    print(findMaxLen(Str))\n",
        "output": "4\n6\n",
        "fn_call": "findMaxLen"
    },
    {
        "text": "maximum width of a binary tree | a binary tree node ; function to get the maximum width of a binary tree ; get width of each level and compare the width with maximum width so far ; get width of a ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def getWidth(root, level):\n    if root is None:\n        return 0\n    if level == 1:\n        return 1\n    elif level > 1:\n        return (\n            getWidth(\n                root .left,\n                level -\n                1) +\n            getWidth(\n                root .right,\n                level -\n                1))\n\n\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        lHeight = height(node .left)\n        rHeight = height(node .right)\n        return (lHeight + 1)if (lHeight > rHeight)else (rHeight + 1)\n\ndef getMaxWidth(root):\n    maxWidth = 0\n    h = height(root)\n    for i in range(1, h + 1):\n        width = getWidth(root, i)\n        if (width > maxWidth):\n            maxWidth = width\n    return maxWidth\n",
        "test": "\nroot = Node(1)\nroot .left = Node(2)\nroot .right = Node(3)\nroot .left .left = Node(4)\nroot .left .right = Node(5)\nroot .right .right = Node(8)\nroot .right .right .left = Node(6)\nroot .right .right .right = Node(7)\nprint(\"Maximum width is %d\" % (getMaxWidth(root)))\n",
        "output": "Maximum width is 3\n",
        "fn_call": "getMaxWidth"
    },
    {
        "text": "find the mid | function to find the mid alphabets ; for every character pair ; get the average of the characters ; ",
        "context": "",
        "code": "def findMidAlphabet(s1, s2, n):\n    for i in range(n):\n        mid = (ord(s1[i]) + ord(s2[i])) // 2\n        print(chr(mid), end=\"\")\n",
        "test": "\ns1 = \"akzbqzgw\"\ns2 = \"efhctcsz\"\nn = len(s1)\nfindMidAlphabet(s1, s2, n)\n",
        "output": "chqbrnmx",
        "fn_call": "findMidAlphabet"
    },
    {
        "text": "how to validate ssn ( social security number ) using regular expression | python3 program to validate ssn ( social security number ) using regular expression ; function to validate ssn ( social security number ) . ; regex to check valid ssn ( social security number ) . ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidSSN(str):\n    regex = \"^(?!666 000 9\\\\d{2})\\\\d{3}-(?!00)\\\\d{2}-(?!0{4})\\\\d{4}$\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"856-45-6789\"\nprint(isValidSSN(str1))\nstr2 = \"000-45-6789\"\nprint(isValidSSN(str2))\nstr3 = \"856-452-6789\"\nprint(isValidSSN(str3))\nstr4 = \"856-45-0000\"\nprint(isValidSSN(str4))\n",
        "output": "True\nTrue\nFalse\nFalse\n",
        "fn_call": "isValidSSN"
    },
    {
        "text": "find height of binary tree represented by parent array | this functio fills depth of i 'th element in parent[] the depth is filled in depth[i] ; if depth [ i ] is already filled ; if node at index i is root ; if depth of parent is not evaluated before , then evaluate depth of parent first ; depth of this node is depth of parent plus 1 ; this function reutns height of binary tree represented by parent array ; create an array to store depth of all nodes and ",
        "context": "",
        "code": "def fillDepth(parent, i, depth):\n    if depth[i] != 0:\n        return\n    if parent[i] == -1:\n        depth[i] = 1\n        return\n    if depth[parent[i]] == 0:\n        fillDepth(parent, parent[i], depth)\n    depth[i] = depth[parent[i]] + 1\n\n\ndef findHeight(parent):\n    n = len(parent)\n    depth = [0 for i in range(n)]\n    for i in range(n):\n        fillDepth(parent, i, depth)\n    ht = depth[0]\n    for i in range(1, n):\n        ht = max(ht, depth[i])\n    return ht\n",
        "test": "\nparent = [-1, 0, 0, 1, 1, 3, 5]\nprint(\"Height is %d\" % (findHeight(parent)))\n",
        "output": "Height is 5\n",
        "fn_call": "findHeight"
    },
    {
        "text": "sum of squares of differences between all pairs of an array | function to calculate sum of squares of differences of all possible pairs ; stores the final sum ; stores temporary values ; traverse the array ; final sum ; prthe answer ; ",
        "context": "",
        "code": "def sumOfSquaredDifferences(arr, N):\n    ans = 0\n    sumA, sumB = 0, 0\n    for i in range(N):\n        sumA += (arr[i] * arr[i])\n        sumB += arr[i]\n    sumA = N * sumA\n    sumB = (sumB * sumB)\n    ans = sumA - sumB\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 8, 4]\n    N = len(arr)\n    sumOfSquaredDifferences(arr, N)\n",
        "output": "56\n",
        "fn_call": "sumOfSquaredDifferences"
    },
    {
        "text": "maximum sum of products of two arrays by toggling adjacent bits | python3 program to find the maximum sop of two arrays by toggling adjacent bits in the second array ; function to return max sum ; intialparity and finalparity are 0 if total no . of 1 's is even else 1 ; minpositive and maxnegative will store smallest positive and smallest negative integer respectively . ; count of initial parity ; if arr1 [ i ] is positive then add 1 in finalparity to get 1 at arr2 [ i ] ; if both parity are odd or even then return sum ; else add one more 1 or remove 1 ; if minpositive > maxnegative , put 1 at maxnegative and add it to our sum ; else remove minpositive no . ; ",
        "context": "\nimport sys\n\n",
        "code": "def maxSum(arr1, arr2, n):\n    initialParity, finalParity = 0, 0\n    sum = 0\n    minPositive = sys .maxsize\n    maxNegative = -sys .maxsize - 1\n    for i in range(n):\n        initialParity += arr2[i]\n        if (arr1[i] >= 0):\n            finalParity += 1\n            sum += arr1[i]\n            minPositive = min(minPositive, arr1[i])\n        else:\n            maxNegative = max(maxNegative, arr1[i])\n    if (initialParity % 2 == finalParity % 2):\n        return sum\n    else:\n        if (minPositive + maxNegative >= 0):\n            return sum + maxNegative\n        else:\n            return sum - minPositive\n",
        "test": "\narr1 = [2, -4, 5, 3]\narr2 = [0, 1, 0, 1]\nn = len(arr1)\nprint(maxSum(arr1, arr2, n))\n",
        "output": "8\n",
        "fn_call": "maxSum"
    },
    {
        "text": "minimum cost required to connect all houses in a city | python3 program for the above approach ; utility function to find set of an element v using path compression technique ; if v is the parent ; otherwise , recursively find its parent ; function to perform union of the sets a and b ; find parent of a and b ; if parent are different ; swap operation ; update parent of b as a ; otherwise , return 0 ; function to create a minimum cost spanning tree for given houses ; stores adjacency list of graph ; traverse each coordinate ; find the manhattan distance ; add the edges ; sort all the edges ; initialize parent [ ] and size [ ] ; stores the minimum cost ; finding the minimum cost ; perform the unioun operation ; print the minimum cost ; ",
        "context": "\nparent = [0] * 100\nsize = [0] * 100\n\n",
        "code": "def find_set(v):\n    if (v == parent[v]):\n        return v\n    parent[v] = find_set(parent[v])\n    return parent[v]\n\n\ndef union_sets(a, b):\n    a = find_set(a)\n    b = find_set(b)\n    if (a != b):\n        if (size[a] < size[b]):\n            a, b = b, a\n        parent[b] = a\n        size[a] += size[b]\n        return 1\n    return 0\n\n\ndef MST(houses, n):\n    v = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            p = abs(houses[i][0] - houses[j][0])\n            p += abs(houses[i][1] - houses[j][1])\n            v .append([p, i, j])\n    v = sorted(v)\n    for i in range(n):\n        parent[i] = i\n        size[i] = 1\n    ans = 0\n    for x in v:\n        if (union_sets(x[1], x[2])):\n            ans += x[0]\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    houses = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    N = len(houses)\n    MST(houses, N)\n",
        "output": "20\n",
        "fn_call": "MST"
    },
    {
        "text": "queries to find frequencies of a string within specified substrings | python3 program to find frequency of a string k in a substring [ l , r ] in s ; store the frequency of string for each index ; compute and store frequencies for every index ; ",
        "context": "\nmax_len = 100005\ncnt = [0] * max_len\n\n",
        "code": "def precompute(s, K):\n    n = len(s)\n    for i in range(n - 1):\n        cnt[i + 1] = cnt[i]\n        if s[i:len(K) + i] == K:\n            cnt[i + 1] += 1\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"ABCABCABABC\"\n    K = \"ABC\"\n    precompute(s, K)\n    Q = [[1, 6], [5, 11]]\n    for it in Q:\n        print(cnt[it[1] - 1] - cnt[it[0] - 1])\n",
        "output": "2\n1\n",
        "fn_call": "precompute"
    },
    {
        "text": "minimum number of elements to be removed to make xor maximum | python 3 to find minimum number of elements to remove to get maximum xor value ; first n in the below condition is for the case where n is 0 ; function to find minimum number of elements to be removed . ; ",
        "context": "",
        "code": "def nextPowerOf2(n):\n    count = 0\n    if (n and not (n and (n - 1))):\n        return n\n    while n != 0:\n        n >>= 1\n        count += 1\n    return 1 << count\n\n\ndef removeElement(n):\n    if n == 1 or n == 2:\n        return 0\n    a = nextPowerOf2(n)\n    if n == a or n == a - 1:\n        return 1\n    elif n == a - 2:\n        return 0\n    elif n % 2 == 0:\n        return 1\n    else:\n        return 2\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    print(removeElement(n))\n",
        "output": "2\n",
        "fn_call": "removeElement"
    },
    {
        "text": "number of ways to swap two bit of s1 so that bitwise or of s1 and s2 changes | function to find number of ways ; initialise result that store no . of swaps required ; traverse both strings and check the bits as explained ; calculate result ; ",
        "context": "",
        "code": "def countWays(s1, s2, n):\n    a = b = c = d = 0\n    result = 0\n    for i in range(0, n, 1):\n        if (s2[i] == '0'):\n            if (s1[i] == '0'):\n                c += 1\n            else:\n                d += 1\n        else:\n            if (s1[i] == '0'):\n                a += 1\n            else:\n                b += 1\n    result = a * d + b * c + c * d\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    s1 = \"01011\"\n    s2 = \"11001\"\n    print(countWays(s1, s2, n))\n",
        "output": "4\n",
        "fn_call": "countWays"
    },
    {
        "text": "print matrix in diagonal pattern | python 3 program to print matrix in diagonal order ; initialize indexes of element to be printed next ; direction is initially from down to up ; traverse the matrix till all elements get traversed ; if isup = true then traverse from downward to upward ; set i and j according to direction ; if isup = 0 then traverse up to down ; set i and j according to direction ; revert the isup to change the direction ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def printMatrixDiagonal(mat, n):\n    i = 0\n    j = 0\n    k = 0\n    isUp = True\n    while k < n * n:\n        if isUp:\n            while i >= 0 and j < n:\n                print(str(mat[i][j]), end=\" \")\n                k += 1\n                j += 1\n                i -= 1\n            if i < 0 and j <= n - 1:\n                i = 0\n            if j == n:\n                i = i + 2\n                j -= 1\n        else:\n            while j >= 0 and i < n:\n                print(mat[i][j], end=\" \")\n                k += 1\n                i += 1\n                j -= 1\n            if j < 0 and i <= n - 1:\n                j = 0\n            if i == n:\n                j = j + 2\n                i -= 1\n        isUp = not isUp\n",
        "test": "\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    n = 3\n    printMatrixDiagonal(mat, n)\n",
        "output": "1 2 4 7 5 3 6 8 9 ",
        "fn_call": "printMatrixDiagonal"
    },
    {
        "text": "length of the longest substring without repeating characters | creating a set to store the last positions of occurrence ; starting the initial point of window to index 0 ; checking if we have already seen the element or not ; if we have seen the number , move the start pointer to position after the last occurrence ; updating the last seen value of the character ; ",
        "context": "",
        "code": "def longestUniqueSubsttr(string):\n    seen = {}\n    maximum_length = 0\n    start = 0\n    for end in range(len(string)):\n        if string[end] in seen:\n            start = max(start, seen[string[end]] + 1)\n        seen[string[end]] = end\n        maximum_length = max(maximum_length, end - start + 1)\n    return maximum_length\n",
        "test": "\nstring = \"geeksforgeeks\"\nprint(\"The input string is\", string)\nlength = longestUniqueSubsttr(string)\nprint(\"The length of the longest non-repeating character substring is\", length)\n",
        "output": "The input string is geeksforgeeks\nThe length of the longest non-repeating character substring is 7\n",
        "fn_call": "longestUniqueSubsttr"
    },
    {
        "text": "addition of two numbers without propagating carry | function to prsum of 2 numbers without propagating carry ; reverse a ; reverse b ; generate sum since length of both a and b are same , take any one of them . ; extract digits from a and b and add ; if sum is single digit ; if sum is not single digit reverse sum ; extract digits from sum and append to result ; ",
        "context": "",
        "code": "def printSum(a, b):\n    res, temp1, temp2 = 0, 0, 0\n    while a > 0:\n        temp1 = temp1 * 10 + (a % 10)\n        a //= 10\n    a = temp1\n    while b > 0:\n        temp2 = temp2 * 10 + (b % 10)\n        b //= 10\n    b = temp2\n    while a:\n        Sum = a % 10 + b % 10\n        if Sum // 10 == 0:\n            res = res * 10 + Sum\n        else:\n            temp1 = 0\n            while Sum > 0:\n                temp1 = temp1 * 10 + (Sum % 10)\n                Sum //= 10\n            Sum = temp1\n            while Sum > 0:\n                res = res * 10 + (Sum % 10)\n                Sum //= 10\n        a //= 10\n        b //= 10\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    a, b = 7752, 8834\n    print(printSum(a, b))\n",
        "output": "151586\n",
        "fn_call": "printSum"
    },
    {
        "text": "number of substrings having an equal number of lowercase and uppercase letters | function to find the count of substrings having an equal number of uppercase and lowercase characters ; stores the count of prefixes having sum s considering uppercase and lowercase characters as 1 and - 1 ; stores the count of substrings having equal number of lowercase and uppercase characters ; stores the sum obtained so far ; if the character is uppercase ; otherwise ; if currsum is o ; if the current sum exists in the hashmap prevsum ; increment the resultant count by 1 ; update the frequency of the current sum by 1 ; return the resultant count of the subarrays ; ",
        "context": "",
        "code": "def countSubstring(S, N):\n    prevSum = {}\n    res = 0\n    currentSum = 0\n    for i in range(N):\n        if (S[i] >= 'A' and S[i] <= 'Z'):\n            currentSum += 1\n        else:\n            currentSum -= 1\n        if (currentSum == 0):\n            res += 1\n        if (currentSum in prevSum):\n            res += (prevSum[currentSum])\n        if currentSum in prevSum:\n            prevSum[currentSum] += 1\n        else:\n            prevSum[currentSum] = 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    S = \"gEEk\"\n    print(countSubstring(S, len(S)))\n",
        "output": "3\n",
        "fn_call": "countSubstring"
    },
    {
        "text": "minimum difference between groups of size two | python3 program to find minimum difference between groups of highest and lowest sums . ; sorting the whole array . ; generating sum groups . ; ",
        "context": "",
        "code": "def calculate(a, n):\n    a .sort()\n    s = []\n    i = 0\n    j = n - 1\n    while (i < j):\n        s .append((a[i] + a[j]))\n        i += 1\n        j -= 1\n    mini = min(s)\n    maxi = max(s)\n    return abs(maxi - mini)\n",
        "test": "\na = [2, 6, 4, 3]\nn = len(a)\nprint(calculate(a, n))\n",
        "output": "1\n",
        "fn_call": "calculate"
    },
    {
        "text": "pairs of positive negative values in an array | print pair with negative and positive value ; for each element of array . ; try to find the negative value of arr [ i ] from i + 1 to n ; if absolute values are equal print pair . ; if size of vector is 0 , therefore there is no element with positive negative value , print \"0\" ; sort the vector ; print the pair with negative positive value . ; ",
        "context": "",
        "code": "def printPairs(arr, n):\n    v = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (abs(arr[i]) == abs(arr[j])):\n                v .append(abs(arr[i]))\n    if (len(v) == 0):\n        return\n    v .sort()\n    for i in range(len(v)):\n        print(-v[i], \"\", v[i], end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 8, 9, -4, 1, -1, -8, -9]\n    n = len(arr)\n    printPairs(arr, n)\n",
        "output": "-1  1 -4  4 -8  8 -9  9 ",
        "fn_call": "printPairs"
    },
    {
        "text": "boyer moore algorithm for pattern searching | python3 program for bad character heuristic of boyer moore string matching algorithm ; the preprocessing function for boyer moore 's bad character heuristic   ; initialize all occurrence as - 1 ; fill the actual value of last occurrence ; a pattern searching function that uses bad character heuristic of boyer moore algorithm ; create the bad character list by calling the preprocessing function badcharheuristic ( ) for given pattern ; s is shift of the pattern with respect to text ; there are n - m + 1 potential allignments ; keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; if the pattern is present at current shift , then index j will become - 1 after the above loop ; shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . the condition s + m < n is necessary for the case when pattern occurs at the end of text ; shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . the max function is used to make sure that we get a positive shift . we may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character . ; ",
        "context": "\nNO_OF_CHARS = 256\n\n",
        "code": "def badCharHeuristic(string, size):\n    badChar = [-1] * NO_OF_CHARS\n    for i in range(size):\n        badChar[ord(string[i])] = i\n    return badChar\n\n\ndef search(txt, pat):\n    m = len(pat)\n    n = len(txt)\n    badChar = badCharHeuristic(pat, m)\n    s = 0\n    while (s <= n - m):\n        j = m - 1\n        while j >= 0 and pat[j] == txt[s + j]:\n            j -= 1\n        if j < 0:\n            print(\"Pattern occur at shift = {}\".format(s))\n            s += (m - badChar[ord(txt[s + m])]if s + m < n else 1)\n        else:\n            s += max(1, j - badChar[ord(txt[s + j])])\n\n\ndef main():\n    txt = \"ABAAABCD\"\n    pat = \"ABC\"\n    search(txt, pat)\n",
        "test": "\nif __name__ == '__main__':\n    main()\n",
        "output": "Pattern occur at shift = 4\n",
        "fn_call": "main"
    },
    {
        "text": "find probability that a player wins when probabilities of hitting the target are given | function to return the probability of the winner ; ",
        "context": "",
        "code": "def find_probability(p, q, r, s):\n    t = (1 - p / q) * (1 - r / s)\n    ans = (p / q) / (1 - t)\n    return round(ans, 9)\n",
        "test": "\nif __name__ == \"__main__\":\n    p, q, r, s = 1, 2, 1, 2\n    print(find_probability(p, q, r, s))\n",
        "output": "0.666666667\n",
        "fn_call": "find_probability"
    },
    {
        "text": "optimal strategy for a game with modifications | python3 implementation of the above approach ; function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; ",
        "context": "\nimport numpy as np\n\n",
        "code": "def Sum(arr, l, r):\n    s = 0\n    for i in range(l, r + 1):\n        s += arr[i]\n    return s\n\n\ndp = np .zeros((101, 101, 101))\n\n\ndef solve(arr, l, r, k):\n    if (r - l + 1 <= k):\n        return Sum(arr, l, r)\n    if (dp[l][r][k]):\n        return dp[l][r][k]\n    sum_ = Sum(arr, l, r)\n    len_r = (r - l + 1) - k\n    length = (r - l + 1)\n    ans = 0\n    for i in range(length - len_r + 1):\n        sum_sub = Sum(arr, i + l, i + l + len_r - 1)\n        ans = max(ans, (sum_ - sum_sub) + (sum_sub -\n                  solve(arr, i + l, i + l + len_r - 1, k)))\n    dp[l][r][k] = ans\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [10, 15, 20, 9, 2, 5]\n    k = 2\n    n = len(arr)\n    print(solve(arr, 0, n - 1, k))\n",
        "output": "32\n",
        "fn_call": "solve"
    },
    {
        "text": "abundant number | an optimized solution to check abundant number in python ; function to calculate sum of divisors ; note that this loop runs till square root of n ; if divisors are equal , take only one of them ; else : otherwise take both ; calculate sum of all proper divisors only ; function to check abundant number ; return true if sum of divisors is greater than n . ; ",
        "context": "\nimport math\n\n",
        "code": "def getSum(n):\n    sum = 0\n    i = 1\n    while i <= (math .sqrt(n)):\n        if n % i == 0:\n            if n / i == i:\n                sum = sum + i\n                sum = sum + i\n                sum = sum + (n / i)\n        i = i + 1\n    sum = sum - n\n    return sum\n\n\ndef checkAbundant(n):\n    if (getSum(n) > n):\n        return 1\n    else:\n        return 0\n",
        "test": "\nif (checkAbundant(12) == 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\nif (checkAbundant(15) == 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n",
        "output": "NO\nNO\n",
        "fn_call": "checkAbundant"
    },
    {
        "text": "minimum flips or swapping of adjacent characters required to make a string equal to another | function to find minimum operations required to convert a to b ; store the size of the string ; store the required result ; traverse the string , a ; if a [ i ] is equal to b [ i ] ; check if swapping adjacent characters make the same - indexed characters equal or not ; otherwise , flip the current bit ; print the minimum number of operations ; ",
        "context": "",
        "code": "def minimumOperation(a, b):\n    n = len(a)\n    i = 0\n    minoperation = 0\n    while (i < n):\n        if (a[i] == b[i]):\n            i = i + 1\n            continue\n        elif (a[i] == b[i + 1] and a[i + 1] == b[i] and i < n - 1):\n            minoperation += 1\n            i = i + 2\n        elif (a[i] != b[i]):\n            minoperation += 1\n            i = i + 1\n        else:\n            i += 1\n    print(minoperation)\n",
        "test": "\nif __name__ == '__main__':\n    a = \"10010010\"\n    b = \"00001000\"\n    minimumOperation(a, b)\n",
        "output": "3\n",
        "fn_call": "minimumOperation"
    },
    {
        "text": "program to find the surface area of the square pyramid | function to find the surface area ; ",
        "context": "",
        "code": "def surfaceArea(b, s):\n    return 2 * b * s + pow(b, 2)\n",
        "test": "\nif __name__ == \"__main__\":\n    b = 3\n    s = 4\n    print(surfaceArea(b, s))\n",
        "output": "33\n",
        "fn_call": "surfaceArea"
    },
    {
        "text": "check whether a subsequence exists with sum equal to k if arr [ i ] > 2 * arr [ i | function to check whether sum of any set of the array element is equal to k or not ; traverse the array from end to start ; if k is greater than arr [ i ] then subtract it from k ; if there is any subsequence whose sum is equal to k ; ",
        "context": "",
        "code": "def CheckForSequence(arr, n, k):\n    for i in range(n - 1, -1, -1):\n        if (k >= arr[i]):\n            k -= arr[i]\n    if (k != 0):\n        return False\n    else:\n        return True\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 3, 7, 15, 31]\n    n = len(A)\n    if (CheckForSequence(A, n, 18)):\n        print(True)\n    else:\n        print(False)\n",
        "output": "True\n",
        "fn_call": "CheckForSequence"
    },
    {
        "text": "sum of series ( n ^ 2 | function that calculate the sum of the nth series ; using formula of the nth term ; ",
        "context": "",
        "code": "def sum_series(n):\n    nSquare = n * n\n    return int(nSquare * (nSquare - 1) / 4)\n",
        "test": "\nn = 2\nprint(sum_series(n))\n",
        "output": "3\n",
        "fn_call": "sum_series"
    },
    {
        "text": "maximize the sum of differences of consecutive elements after removing exactly k elements | function to return the maximized sum ; remove any k internal elements ; ",
        "context": "",
        "code": "def findSum(arr, n, k):\n    if (k <= n - 2):\n        return (arr[n - 1] - arr[0])\n    return 0\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4]\n    n = len(arr)\n    k = 1\n    print(findSum(arr, n, k))\n",
        "output": "3\n",
        "fn_call": "findSum"
    },
    {
        "text": "construct the largest number whose sum of cost of digits is k | function to find the maximum number among the two numbers s and t ; if \"0\" exists in the string s ; if \"0\" exists in the string t ; else return the maximum number formed ; recursive function to find maximum number formed such that the sum of cost of digits of formed number is k ; base case ; return the stored state ; including the digit ( idx + 1 ) ; excluding the digit ( idx + 1 ) ; store the result and return ; function to find the maximum number formed such that the sum of the cost digits in the formed number is k ; stores all dp - states ; recursive call ; return the result ; ",
        "context": "",
        "code": "def getMaximum(S, T):\n    if (S .count(\"0\") > 0):\n        return T\n    if (T .count(\"0\") > 0):\n        return S\n    return S if len(S) > len(T)else T\n\n\ndef recursion(arr, idx, N, K, dp):\n    if (K == 0):\n        return \"\"\n    if (K < 0 or idx == N):\n        return \"0\"\n    if (dp[idx][K] != \"-1\"):\n        return dp[idx][K]\n    include = str(idx + 1) + recursion(arr, 0, N, K - arr[idx], dp)\n    exclude = recursion(arr, idx + 1, N, K, dp)\n    dp[idx][K] = getMaximum(include, exclude)\n    return (dp[idx][K])\n\n\ndef largestNumber(arr, N, K):\n    dp = [[\"-1\"for i in range(K + 1)]for i in range(N + 1)]\n    ans = recursion(arr, 0, N, K, dp)\n    return \"0\"if ans == \"\"else ans\n",
        "test": "\narr = [3, 12, 9, 5, 3, 4, 6, 5, 10]\nK = 14\nN = len(arr)\nprint(largestNumber(arr, N, K))\n",
        "output": "8555\n",
        "fn_call": "largestNumber"
    },
    {
        "text": "reverse all elements of given circular array starting from index k | function to print array arr [ ] ; print the array ; function to reverse elements of given circular array starting from index k ; initialize two variables as start = k and end = k - 1 ; initialize count = n / 2 ; loop while count > 0 ; swap the elements at index ( start % n ) and ( end % n ) ; update the start and end ; if end equals to - 1 set end = n - 1 ; print the circular array ; ",
        "context": "",
        "code": "def printArray(arr, N):\n    for i in range(N):\n        print(arr[i], end=\" \")\n\n\ndef reverseCircularArray(arr, N, K):\n    start, end = K, K - 1\n    count = N // 2\n    while (count):\n        temp = arr[start % N]\n        arr[start % N] = arr[end % N]\n        arr[end % N] = temp\n        start += 1\n        end -= 1\n        if (end == -1):\n            end = N - 1\n        count -= 1\n    printArray(arr, N)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 5, 2, 4, 1]\n    K = 2\n    N = len(arr)\n    reverseCircularArray(arr, N, K)\n",
        "output": "4 2 5 3 1 ",
        "fn_call": "reverseCircularArray"
    },
    {
        "text": "generate first k multiples of n using bitwise operators | function to print the first k multiples of n ; print the value of n * i ; iterate each bit of n and add pow ( 2 , pos ) , where pos is the index of each set bit ; check if current bit at pos j is fixed or not ; for next set bit ; ",
        "context": "",
        "code": "def Kmultiples(n, k):\n    a = n\n    for i in range(1, k + 1):\n        print(\"{} * {} = {}\".format(n, i, a))\n        j = 0\n        while (n >= (1 << j)):\n            a += n & (1 << j)\n            j += 1\n",
        "test": "\nN = 16\nK = 7\nKmultiples(N, K)\n",
        "output": "16 * 1 = 16\n16 * 2 = 32\n16 * 3 = 48\n16 * 4 = 64\n16 * 5 = 80\n16 * 6 = 96\n16 * 7 = 112\n",
        "fn_call": "Kmultiples"
    },
    {
        "text": "longest palindromic subsequence | dp | a utility function to get max of two integers ; returns the length of the longest palindromic subsequence in seq ; base case 1 : if there is only 1 character ; base case 2 : if there are only 2 characters and both are same ; if the first and last characters match ; if the first and last characters do not match ; ",
        "context": "",
        "code": "def max(x, y):\n    if (x > y):\n        return x\n    return y\n\n\ndef lps(seq, i, j):\n    if (i == j):\n        return 1\n    if (seq[i] == seq[j] and i + 1 == j):\n        return 2\n    if (seq[i] == seq[j]):\n        return lps(seq, i + 1, j - 1) + 2\n    return max(lps(seq, i, j - 1), lps(seq, i + 1, j))\n",
        "test": "\nif __name__ == '__main__':\n    seq = \"GEEKSFORGEEKS\"\n    n = len(seq)\n    print(\"The length of the LPS is\", lps(seq, 0, n - 1))\n",
        "output": "The length of the LPS is 5\n",
        "fn_call": "lps"
    },
    {
        "text": "reverse substrings between each pair of parenthesis | function to return the modified string ; push the index of the current opening bracket ; reverse the substarting after the last encountered opening bracket till the current character ; to store the modified string ; ",
        "context": "",
        "code": "def reverseParentheses(strr, lenn):\n    st = []\n    for i in range(lenn):\n        if (strr[i] == '('):\n            st .append(i)\n        elif (strr[i] == ')'):\n            temp = strr[st[-1]:i + 1]\n            strr = strr[:st[-1]] + temp[::-1] + strr[i + 1:]\n            del st[-1]\n    res = \"\"\n    for i in range(lenn):\n        if (strr[i] != ')' and strr[i] != '('):\n            res += (strr[i])\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"(skeeg(for)skeeg)\"\n    lenn = len(strr)\n    st = [i for i in strr]\n    print(reverseParentheses(strr, lenn))\n",
        "output": "geeksforgeeks\n",
        "fn_call": "reverseParentheses"
    },
    {
        "text": "gill 's 4th order method to solve differential equations | python3 program to implement gill 's method ; a sample differential equation \" dy / dx \u2581 = \u2581 ( x \u2581 - \u2581 y ) /2\" ; finds value of y for a given x using step size h and initial value y0 at x0 ; count number of iterations using step size or height h ; initial value of y ( 0 ) ; iterate for number of iteration ; value of k1 ; value of k2 ; value of k3 ; value of k4 ; find the next value of y ( n + 1 ) using y ( n ) and values of k in the above steps ; update next value of x ; return the final value of dy / dx ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def dydx(x, y):\n    return (x - y) / 2\n\n\ndef Gill(x0, y0, x, h):\n    n = ((x - x0) / h)\n    y = y0\n    for i in range(1, int(n + 1), 1):\n        k1 = h * dydx(x0, y)\n        k2 = h * dydx(x0 + 0.5 * h, y + 0.5 * k1)\n        k3 = h * dydx(x0 + 0.5 * h, y + 0.5 * (-1 + sqrt(2))\n                      * k1 + k2 * (1 - 0.5 * sqrt(2)))\n        k4 = h * dydx(x0 + h, y - (0.5 * sqrt(2)) *\n                      k2 + k3 * (1 + 0.5 * sqrt(2)))\n        y = y + (1 / 6) * (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4)\n        x0 = x0 + h\n    return y\n",
        "test": "\nif __name__ == '__main__':\n    x0 = 0\n    y = 3.0\n    x = 5.0\n    h = 0.2\n    print(\"y(x) =\", round(Gill(x0, y, x, h), 6))\n",
        "output": "y(x) = 3.410426\n",
        "fn_call": "Gill"
    },
    {
        "text": "minimum number of squares whose sum equals to given number n | returns count of minimum squares that sum to n ; base cases ; getminsquares rest of the table using recursive formula maximum squares required is n ( 1 * 1 + 1 * 1 + . . ) ; go through all smaller numbers to recursively find minimum ; ",
        "context": "",
        "code": "def getMinSquares(n):\n    if n <= 3:\n        return n\n    res = n\n    for x in range(1, n + 1):\n        temp = x * x\n        if temp > n:\n            break\n        else:\n            res = min(res, 1 + getMinSquares(n - temp))\n    return res\n",
        "test": "\nprint(getMinSquares(6))\n",
        "output": "3\n",
        "fn_call": "getMinSquares"
    },
    {
        "text": "maximum even numbers present in any subarray of size k | function to find the maximum count of even numbers from all the subarrays of size m ; stores the count of even numbers in a subarray of size m ; calculate the count of even numbers in the current subarray ; if current element is an even number ; stores the maximum count of even numbers from all the subarrays of size m ; traverse remaining subarrays of size m using sliding window technique ; if the first element of the subarray is even ; update curr ; if i - th element is even increment the count ; update the answer ; return answer ; ",
        "context": "",
        "code": "def maxEvenIntegers(arr, N, M):\n    curr = 0\n    for i in range(0, M):\n        if (arr[i] % 2 == 0):\n            curr += 1\n    ans = curr\n    for i in range(M, N):\n        if (arr[i - M] % 2 == 0):\n            curr -= 1\n        if (arr[i] % 2 == 0):\n            curr += 1\n            ans = max(curr, ans)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 5, 4, 7, 6]\n    M = 3\n    N = len(arr)\n    print(maxEvenIntegers(arr, N, M))\n",
        "output": "2\n",
        "fn_call": "maxEvenIntegers"
    },
    {
        "text": "roots of the quadratic equation when a + b + c = 0 without using shridharacharya formula | function to print the roots of the quadratic equation when a + b + c = 0 ; ",
        "context": "",
        "code": "def printRoots(a, b, c):\n    print(1, \",\", c / (a * 1.0))\n",
        "test": "\na = 2\nb = 3\nc = -5\nprintRoots(a, b, c)\n",
        "output": "1 , -2.5\n",
        "fn_call": "printRoots"
    },
    {
        "text": "split array into min number of subsets with difference between each pair greater than 1 | function to split the array into minimum number of subsets with difference strictly > 1 ; sort the array ; traverse through the sorted array ; check the pairs of elements with difference 1 ; if we find even a single pair with difference equal to 1 , then 2 partitions else only 1 partition ; print the count of partitions ; ",
        "context": "",
        "code": "def split(arr, n):\n    arr .sort()\n    count = 1\n    for i in range(1, n):\n        if (arr[i] - arr[i - 1] == 1):\n            count = 2\n            break\n    print(count)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 4, 6]\n    n = len(arr)\n    split(arr, n)\n",
        "output": "1\n",
        "fn_call": "split"
    },
    {
        "text": "minimum steps to delete a string by deleting substring comprising of same characters | function to return the minimum number of delete operations ; when a single character is deleted ; when a group of consecutive characters are deleted if any of them matches ; when both the characters are same then delete the letters in between them ; memoize ; ",
        "context": "",
        "code": "def findMinimumDeletion(l, r, dp, s):\n    if l > r:\n        return 0\n    if l == r:\n        return 1\n    if dp[l][r] != -1:\n        return dp[l][r]\n    res = 1 + findMinimumDeletion(l + 1, r, dp, s)\n    for i in range(l + 1, r + 1):\n        if s[l] == s[i]:\n            res = min(\n                res,\n                findMinimumDeletion(\n                    l +\n                    1,\n                    i -\n                    1,\n                    dp,\n                    s) +\n                findMinimumDeletion(\n                    i,\n                    r,\n                    dp,\n                    s))\n    dp[l][r] = res\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abcddcba\"\n    n = len(s)\n    N = 10\n    dp = [[-1 for i in range(N)]for j in range(N)]\n    print(findMinimumDeletion(0, n - 1, dp, s))\n",
        "output": "4\n",
        "fn_call": "findMinimumDeletion"
    },
    {
        "text": "count all possible n | function to find the number of vowel permutations possible ; to avoid the large output value ; initialize 2d dp array ; initialize dp [ 1 ] [ i ] as 1 since string of length 1 will consist of only one vowel in the string ; directed graph using the adjacency matrix ; iterate over the range [ 1 , n ] ; traverse the directed graph ; traversing the list ; update dp [ i + 1 ] [ u ] ; stores total count of permutations ; return count of permutations ; ",
        "context": "",
        "code": "def countVowelPermutation(n):\n    MOD = 1e9 + 7\n    dp = [[0 for i in range(5)]for j in range(n + 1)]\n    for i in range(5):\n        dp[1][i] = 1\n    relation = [[1], [0, 2], [0, 1, 3, 4], [2, 4], [0]]\n    for i in range(1, n, 1):\n        for u in range(5):\n            dp[i + 1][u] = 0\n            for v in relation[u]:\n                dp[i + 1][u] += dp[i][v] % MOD\n    ans = 0\n    for i in range(5):\n        ans = (ans + dp[n][i]) % MOD\n    return int(ans)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    print(countVowelPermutation(N))\n",
        "output": "10\n",
        "fn_call": "countVowelPermutation"
    },
    {
        "text": "check whether n can be a perfect cube after adding or subtracting k | function to check if a number is a perfect cube or not ; ",
        "context": "",
        "code": "def isPerfectCube(x):\n    cr = int(x ** (1 / 3))\n    return (cr * cr * cr == x)\n\n\ndef canBePerfectCube(N, K):\n    if (isPerfectCube(N + K) or isPerfectCube(N - K)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 7\n    K = 1\n    canBePerfectCube(N, K)\n    N = 5\n    K = 4\n    canBePerfectCube(N, K)\n    N = 7\n    K = 2\n    canBePerfectCube(N, K)\n",
        "output": "Yes\nYes\nNo\n",
        "fn_call": "canBePerfectCube"
    },
    {
        "text": "length of the normal from origin on a straight line whose intercepts are given | python3 implementation of the approach ; function to find the normal of the straight line ; length of the normal ; ",
        "context": "\nimport math\n\n",
        "code": "def normal(m, n):\n    N = ((abs(m) * abs(n)) / math .sqrt((abs(m) * abs(m)) + (abs(n) * abs(n))))\n    return N\n",
        "test": "\nm = -5\nn = 3\nprint(normal(m, n))\n",
        "output": "2.5724787771376323\n",
        "fn_call": "normal"
    },
    {
        "text": "smallest subarray with gcd as 1 | segment tree | python3 implementation of the approach ; array to store segment - tree ; function to build segment - tree to answer range gcd queries ; base - case ; mid element of the range ; merging the result of left and right sub - tree ; function to perform range gcd queries ; base - cases ; mid - element ; calling left and right child ; function to find the required length ; buildinng the segment tree ; two pointer variables ; to store the final answer ; loopinng ; incrementing j till we don 't get a gcd value of 1 ; updating the final answer ; incrementing i ; updating j ; returning the final answer ; ",
        "context": "\nfrom math import gcd as __gcd\nmaxLen = 30\nseg = [0 for i in range(3 * maxLen)]\n\n",
        "code": "def build(l, r, inn, arr):\n    if (l == r):\n        seg[inn] = arr[l]\n        return seg[inn]\n    mid = (l + r) // 2\n    seg[inn] = __gcd(\n        build(\n            l,\n            mid,\n            2 * inn + 1,\n            arr),\n        build(\n            mid + 1,\n            r,\n            2 * inn + 2,\n            arr))\n    return seg[inn]\n\n\ndef query(l, r, l1, r1, inn):\n    if (l1 <= l and r <= r1):\n        return seg[inn]\n    if (l > r1 or r < l1):\n        return 0\n    mid = (l + r) // 2\n    x = __gcd(\n        query(\n            l,\n            mid,\n            l1,\n            r1,\n            2 * inn + 1),\n        query(\n            mid + 1,\n            r,\n            l1,\n            r1,\n            2 * inn + 2))\n    return x\n\n\ndef findLen(arr, n):\n    build(0, n - 1, 0, arr)\n    i = 0\n    j = 0\n    ans = 10 ** 9\n    while (i < n):\n        while (j < n and query(0, n - 1, i, j, 0) != 1):\n            j += 1\n        if (j == n):\n            break\n        ans = minn((j - i + 1), ans)\n        i += 1\n        j = max(j, i)\n    if (ans == 10 ** 9):\n        return -1\n    else:\n        return ans\n",
        "test": "\narr = [2, 2, 2]\nn = len(arr)\nprint(findLen(arr, n))\n",
        "output": "-1\n",
        "fn_call": "findLen"
    },
    {
        "text": "program for identity matrix | python3 program to check if a given matrix is identity ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def isIdentity(mat, N):\n    for row in range(N):\n        for col in range(N):\n            if (row == col and mat[row][col] != 1):\n                return False\n            elif (row != col and mat[row][col] != 0):\n                return False\n    return True\n",
        "test": "\nN = 4\nmat = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]\nif (isIdentity(mat, N)):\n    print(\"Yes \")\nelse:\n    print(\"No \")\n",
        "output": "Yes \n",
        "fn_call": "isIdentity"
    },
    {
        "text": "maximum xor value in matrix | python3 program to find maximum xor value in matrix either row / column wise maximum number of row and column ; function return the maximum xor value that is either row or column wise ; for row xor and column xor ; traverse matrix ; xor row element ; for each column : j is act as row & i act as column xor column element ; update maximum between r_xor , c_xor ; return maximum xor value ; ",
        "context": "\nMAX = 1000\n\n",
        "code": "def maxXOR(mat, N):\n    max_xor = 0\n    for i in range(N):\n        r_xor = 0\n        c_xor = 0\n        for j in range(N):\n            r_xor = r_xor ^ mat[i][j]\n            c_xor = c_xor ^ mat[j][i]\n        if (max_xor < max(r_xor, c_xor)):\n            max_xor = max(r_xor, c_xor)\n    return max_xor\n",
        "test": "\nN = 3\nmat = [[1, 5, 4], [3, 7, 2], [5, 9, 10]]\nprint(\"maximum XOR value : \", maxXOR(mat, N))\n",
        "output": "maximum XOR value :  12\n",
        "fn_call": "maxXOR"
    },
    {
        "text": "check if an array is sorted and rotated | python3 program to check if an array is sorted and rotated clockwise ; function to check if an array is sorted and rotated clockwise ; find the minimum element and it 's index ; check if all elements before minindex are in increasing order ; check if all elements after minindex are in increasing order ; check if last element of the array is smaller than the element just before the element at minindex starting element of the array for arrays like [ 3 , 4 , 6 , 1 , 2 , 5 ] - not sorted circular array ; ",
        "context": "\nimport sys\n\n",
        "code": "def checkIfSortRotated(arr, n):\n    minEle = sys .maxsize\n    maxEle = -sys .maxsize - 1\n    minIndex = -1\n    for i in range(n):\n        if arr[i] < minEle:\n            minEle = arr[i]\n            minIndex = i\n    flag1 = 1\n    for i in range(1, minIndex):\n        if arr[i] < arr[i - 1]:\n            flag1 = 0\n            break\n    flag2 = 2\n    for i in range(minIndex + 1, n):\n        if arr[i] < arr[i - 1]:\n            flag2 = 0\n            break\n    if (flag1 and flag2 and arr[n - 1] < arr[0]):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "test": "\narr = [3, 4, 5, 1, 2]\nn = len(arr)\ncheckIfSortRotated(arr, n)\n",
        "output": "YES\n",
        "fn_call": "checkIfSortRotated"
    },
    {
        "text": "find sum of even index binomial coefficients | python program to find sum even indexed binomial coefficient ; returns value of even indexed binomial coefficient sum which is 2 raised to power n - 1. ; ",
        "context": "\nimport math\n\n",
        "code": "def evenbinomialCoeffSum(n):\n    return (1 << (n - 1))\n",
        "test": "\nif __name__ == '__main__':\n    n = 4\n    print(evenbinomialCoeffSum(n))\n",
        "output": "8\n",
        "fn_call": "evenbinomialCoeffSum"
    },
    {
        "text": "find the angle between tangents drawn from a given external point to a circle | python 3 program for the above approach ; function to find the distance between center and the exterior point ; find the difference between the x and y coordinates ; using the distance formula ; function to find the angle between the pair of tangents drawn from the point ( x2 , y2 ) to the circle . ; calculate the distance between the center and exterior point ; invalid case ; find the angle using the formula ; print the resultant angle ; ",
        "context": "\nimport math\n\n",
        "code": "def point_distance(x1, y1, x2, y2):\n    p = (x2 - x1)\n    q = (y2 - y1)\n    distance = math .sqrt(p * p + q * q)\n    return distance\n\n\ndef tangentAngle(x1, y1, x2, y2, radius):\n    distance = point_distance(x1, y1, x2, y2)\n    if (radius / distance > 1 or radius / distance < -1):\n        print(-1)\n    result = 2 * math .asin(radius / distance) * 180 / 3.1415\n    print(result, \" degrees\")\n",
        "test": "\nif __name__ == \"__main__\":\n    radius = 4\n    x1 = 7\n    y1 = 12\n    x2 = 3\n    y2 = 4\n    tangentAngle(x1, y1, x2, y2, radius)\n",
        "output": "53.131669342763075  degrees\n",
        "fn_call": "tangentAngle"
    },
    {
        "text": "make a palindromic string from given string | function to find winner of the game ; array to maintain frequency of the characters in s initialise freq array with 0 ; maintain count of all distinct characters ; finding frequency of each character ; count unique duplicate characters ; loop to count the unique duplicate characters ; condition for player - 1 to be winner ; else player - 2 is always winner ; ",
        "context": "",
        "code": "def palindromeWinner(S):\n    freq = [0 for i in range(0, 26)]\n    count = 0\n    for i in range(0, len(S)):\n        if (freq[ord(S[i]) - 97] == 0):\n            count += 1\n        freq[ord(S[i]) - 97] += 1\n    unique = 0\n    duplicate = 0\n    for i in range(0, 26):\n        if (freq[i] == 1):\n            unique += 1\n        elif (freq[i] >= 2):\n            duplicate += 1\n    if (unique == 1 and (unique + duplicate) == count):\n        return 1\n    return 2\n",
        "test": "\nS = \"abcbc\"\nprint(\"Player-\", palindromeWinner(S))\n",
        "output": "Player- 1\n",
        "fn_call": "palindromeWinner"
    },
    {
        "text": "count of distinct remainders when n is divided by all the numbers from the range [ 1 , n ] | function to return the count of distinct remainders that can be obtained when n is divided by every element from the range [ 1 , n ] ; if n is even ; if n is odd ; ",
        "context": "",
        "code": "def distinctRemainders(n):\n    if n % 2 == 0:\n        return n // 2\n    return ((n // 2) + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    print(distinctRemainders(n))\n",
        "output": "3\n",
        "fn_call": "distinctRemainders"
    },
    {
        "text": "program to print characters present at prime indexes in a given string | python3 program to print characters at prime index in a given string ; corner case ; check from 2 to n - 1 ; function to print character at prime index ; loop to check if index prime or not ; ",
        "context": "",
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_index(input):\n    p = list(input)\n    s = \"\"\n    for i in range(2, len(p) + 1):\n        if isPrime(i):\n            s = s + input[i - 1]\n    print(s)\n",
        "test": "\ninput = \"GeeksforGeeks\"\nprime_index(input)\n",
        "output": "eesoes\n",
        "fn_call": "prime_index"
    },
    {
        "text": "check a number is odd or even without modulus operator | returns true if n is even , else odd ; return true if n / 2 does not result in a float value . ; ",
        "context": "",
        "code": "def isEven(n):\n    return (int(n / 2) * 2 == n)\n",
        "test": "\nn = 101\nif (isEven(n)):\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n",
        "output": "Odd\n",
        "fn_call": "isEven"
    },
    {
        "text": "pyramid form ( increasing then decreasing ) consecutive array using reduce operations | returns minimum cost to form a pyramid ; store the maximum possible pyramid height ; maximum height at start is 1 ; for each position calculate maximum height ; maximum height at end is 1 ; for each position calculate maximum height ; find minimum possible among calculated values ; find maximum height of pyramid ; calculate cost of this pyramid ; calculate cost of left half ; calculate cost of right half ; ",
        "context": "",
        "code": "def minPyramidCost(arr: list, N):\n    left = [0] * N\n    right = [0] * N\n    left[0] = min(arr[0], 1)\n    for i in range(1, N):\n        left[i] = min(arr[i], min(left[i - 1] + 1, i + 1))\n    right[N - 1] = min(arr[N - 1], 1)\n    for i in range(N - 2, -1, -1):\n        right[i] = min(arr[i], min(right[i + 1] + 1, N - i))\n    tot = [0] * N\n    for i in range(N):\n        tot[i] = min(right[i], left[i])\n    max_ind = 0\n    for i in range(N):\n        if tot[i] > tot[max_ind]:\n            max_ind = i\n    cost = 0\n    height = tot[max_ind]\n    for x in range(max_ind, -1, -1):\n        cost += arr[x] - height\n        if height > 0:\n            height -= 1\n    height = tot[max_ind] - 1\n    for x in range(max_ind + 1, N):\n        cost += arr[x] - height\n        if height > 0:\n            height -= 1\n    return cost\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 2, 1]\n    N = len(arr)\n    print(minPyramidCost(arr, N))\n",
        "output": "4\n",
        "fn_call": "minPyramidCost"
    },
    {
        "text": "longest increasing subsequence consisting of elements from indices divisible by previously selected indices | function to find length of longest subsequence generated that satisfies the specified conditions ; stores the length of longest subsequences of all lengths ; iterate through the given array ; iterate through the multiples i ; update dp [ j ] as maximum of dp [ j ] and dp [ i ] + 1 ; return the maximum element in dp [ ] as the length of longest subsequence ; ",
        "context": "",
        "code": "def findMaxLength(N, arr):\n    dp = [1] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(2 * i, N + 1, i):\n            if (arr[i - 1] < arr[j - 1]):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return max(dp)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3, 4, 5, 6, 7, 8, 9]\n    N = len(arr)\n    print(findMaxLength(N, arr))\n",
        "output": "4\n",
        "fn_call": "findMaxLength"
    },
    {
        "text": "sum of last digit of all integers from 1 to n divisible by m | function to return the required sum ; number of element between 1 to n divisible by m ; array to store the last digit of elements in a cycle ; storing and adding last digit of cycle ; number of elements present in last cycle ; sum of k / 10 cycle ; adding value of digits of last cycle to the answer ; ",
        "context": "",
        "code": "def sumOfLastDig(n, m):\n    sum = 0\n    k = n // m\n    arr = [0] * 10\n    for i in range(10):\n        arr[i] = m * (i + 1) % 10\n        sum += arr[i]\n    rem = k % 10\n    ans = (k // 10) * sum\n    for i in range(rem):\n        ans += arr[i]\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 100\n    m = 3\n    print(sumOfLastDig(n, m))\n",
        "output": "153\n",
        "fn_call": "sumOfLastDig"
    },
    {
        "text": "construct a graph from given degrees of all vertices | a function to print the adjacency matrix . ; n is number of vertices ; for each pair of vertex decrement the degree of both vertex . ; print the result in specified form ; ",
        "context": "",
        "code": "def printMat(degseq, n):\n    mat = [[0] * n for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (degseq[i] > 0 and degseq[j] > 0):\n                degseq[i] -= 1\n                degseq[j] -= 1\n                mat[i][j] = 1\n                mat[j][i] = 1\n    print(\" \", end=\" \")\n    for i in range(n):\n        print(\" \", \"(\", i, \")\", end=\"\")\n    print()\n    print()\n    for i in range(n):\n        print(\" \", \"(\", i, \")\", end=\"\")\n        for j in range(n):\n            print(\" \", mat[i][j], end=\"\")\n        print()\n",
        "test": "\nif __name__ == '__main__':\n    degseq = [2, 2, 1, 1, 1]\n    n = len(degseq)\n    printMat(degseq, n)\n",
        "output": "    ( 0 )  ( 1 )  ( 2 )  ( 3 )  ( 4 )\n\n  ( 0 )  0  1  1  0  0\n  ( 1 )  1  0  0  1  0\n  ( 2 )  1  0  0  0  0\n  ( 3 )  0  1  0  0  0\n  ( 4 )  0  0  0  0  0\n",
        "fn_call": "printMat"
    },
    {
        "text": "largest even digit number not greater than n | function to check if all digits are even of a given number ; iterate for all digits ; if digit is odd ; all digits are even ; function to return the largest number with all digits even ; iterate till we find a number with all digits even ; ",
        "context": "",
        "code": "def checkDigits(n):\n    while (n > 0):\n        if ((n % 10) % 2):\n            return False\n        n = int(n / 10)\n    return True\n\n\ndef largestNumber(n):\n    for i in range(n, -1, -1):\n        if (checkDigits(i)):\n            return i\n",
        "test": "\nN = 23\nprint(largestNumber(N))\n",
        "output": "22\n",
        "fn_call": "largestNumber"
    },
    {
        "text": "check whether ( i , j ) exists such that arr [ i ] != arr [ j ] and arr [ arr [ i ] ] is equal to arr [ arr [ j ] ] | function that will tell whether such indices present or not . ; checking 1 st condition i . e whether arr [ i ] equal to arr [ j ] or not ; checking 2 nd condition i . e whether arr [ arr [ i ] ] equal to arr [ arr [ j ] ] or not . ; ",
        "context": "",
        "code": "def checkIndices(Arr, N):\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if (Arr[i] != Arr[j]):\n                if (Arr[Arr[i] - 1] == Arr[Arr[j] - 1]):\n                    return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    Arr = [3, 2, 1, 1, 4]\n    N = len(Arr)\n    if checkIndices(Arr, N):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkIndices"
    },
    {
        "text": "find the smallest window in a string containing all characters of another string | python solution ; starting index of ans ; answer length of ans ; creating map ; references of window ; traversing the window ; calculating ; condition matching ; calculating answer . ; sliding i calculation for removing i ; ",
        "context": "",
        "code": "def smallestWindow(s, p):\n    n = len(s)\n    if n < len(p):\n        return -1\n    mp = [0] * 256\n    start = 0\n    ans = n + 1\n    cnt = 0\n    for i in p:\n        mp[ord(i)] += 1\n        if mp[ord(i)] == 1:\n            cnt += 1\n    j = 0\n    i = 0\n    while (j < n):\n        mp[ord(s[j])] -= 1\n        if mp[ord(s[j])] == 0:\n            cnt -= 1\n            while cnt == 0:\n                if ans > j - i + 1:\n                    ans = j - i + 1\n                    start = i\n                mp[ord(s[i])] += 1\n                if mp[ord(s[i])] > 0:\n                    cnt += 1\n                i += 1\n        j += 1\n    if ans > n:\n        return \"-1\"\n    return s[start:start + ans]\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"ADOBECODEBANC\"\n    p = \"ABC\"\n    result = smallestWindow(s, p)\n    print(\"-->Smallest window that contain all character :\", result)\n",
        "output": "-->Smallest window that contain all character : BANC\n",
        "fn_call": "smallestWindow"
    },
    {
        "text": "minimum k such that every substring of length atleast k contains a character c | this function checks if there exists some character which appears in all k length substrings ; iterate over all possible characters ; stores the last occurrence ; set answer as true ; no occurrence found of current character in first substring of length k ; check for every last substring of length k where last occurr - ence exists in substring ; if last occ is not present in substring ; current character is k amazing ; this function performs binary search over the answer to minimise it ; check if answer is found try to minimise it ; ",
        "context": "",
        "code": "def check(s, K):\n    for ch in range(0, 26):\n        c = chr(97 + ch)\n        last = -1\n        found = True\n        for i in range(0, K):\n            if s[i] == c:\n                last = i\n        if last == -1:\n            continue\n        for i in range(K, len(s)):\n            if s[i] == c:\n                last = i\n            if last <= (i - K):\n                found = False\n                break\n        if found:\n            return 1\n    return 0\n\n\ndef binarySearch(s):\n    low, high, ans = 1, len(s), None\n    while low <= high:\n        mid = (high + low) >> 1\n        if check(s, mid):\n            ans, high = mid, mid - 1\n        else:\n            low = mid + 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abcde\"\n    print(binarySearch(s))\n    s = \"aaaa\"\n    print(binarySearch(s))\n",
        "output": "3\n1\n",
        "fn_call": "binarySearch"
    },
    {
        "text": "number of asymmetric relations on a set of n elements | python3 program for the above approach ; function to calculate x ^ y modulo ( 10 ^ 9 + 7 ) ; stores the result of x ^ y ; update x if it exceeds mod ; if x is divisible by mod ; if y is odd , then multiply x with result ; divide y by 2 ; update the value of x ; return the final value of x ^ y ; function to count the number of asymmetric relations in a set consisting of n elements ; return the resultant count ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def power(x, y):\n    res = 1\n    x = x % mod\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return res\n\n\ndef asymmetricRelation(N):\n    return power(3, (N * N - N) // 2)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    print(asymmetricRelation(N))\n",
        "output": "3\n",
        "fn_call": "asymmetricRelation"
    },
    {
        "text": "modify a numeric string to a balanced parentheses by replacements | function to check if the given string can be converted to a balanced bracket sequence or not ; check if the first and last characters are equal ; initialize two variables to store the count of open and closed brackets ; if the current character is same as the first character ; if the current character is same as the last character ; if count of open brackets becomes less than 0 ; print the new string ; if the current character is same as the first character ; if bracket sequence is not balanced ; check for unbalanced bracket sequence ; print the sequence ; ",
        "context": "",
        "code": "def balBracketSequence(str):\n    n = len(str)\n    if (str[0] == str[n - 1]):\n        print(\"No\", end=\"\")\n    else:\n        cntForOpen = 0\n        cntForClose = 0\n        check = 1\n        for i in range(n):\n            if (str[i] == str[0]):\n                cntForOpen += 1\n            elif str[i] == str[n - 1]:\n                cntForOpen -= 1\n            else:\n                cntForOpen += 1\n            if (cntForOpen < 0):\n                check = 0\n                break\n        if (check and cntForOpen == 0):\n            print(\"Yes, \", end=\"\")\n            for i in range(n):\n                if (str[i] == str[n - 1]):\n                    print(')', end=\"\")\n                else:\n                    print('(', end=\"\")\n            return\n        else:\n            for i in range(n):\n                if (str[i] == str[0]):\n                    cntForClose += 1\n                else:\n                    cntForClose -= 1\n                if (cntForClose < 0):\n                    check = 0\n                    break\n            if (check and cntForClose == 0):\n                print(\"Yes, \", end=\"\")\n                for i in range(n):\n                    if (str[i] == str[0]):\n                        print('(', end=\"\")\n                    else:\n                        print(')', end=\"\")\n                return\n        print(\"NO\", end=\"\")\n",
        "test": "\nstr = \"123122\"\nbalBracketSequence(str)\n",
        "output": "Yes, ()(())",
        "fn_call": "balBracketSequence"
    },
    {
        "text": "sum of array elements which are prime factors of a given number | function to check if a number is prime or not ; corner cases ; check if n is a multiple of 2 or 3 ; above condition allows to check only for every 6 th number , starting from 5 ; if n is a multiple of i and i + 2 ; function to find the sum of array elements which are prime factors of k ; stores the required sum ; traverse the given array ; if current element is a prime factor of k , add it to the sum ; print the result ; ",
        "context": "",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    i = 5\n    while (i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i = i + 6\n    return True\n\n\ndef primeFactorSum(arr, n, k):\n    sum = 0\n    for i in range(n):\n        if (k % arr[i] == 0 and isPrime(arr[i])):\n            sum = sum + arr[i]\n    print(sum)\n",
        "test": "\narr = [1, 2, 3, 5, 6, 7, 15]\nN = len(arr)\nK = 35\nprimeFactorSum(arr, N, K)\n",
        "output": "12\n",
        "fn_call": "primeFactorSum"
    },
    {
        "text": "maximum absolute difference of value and index sums | function to return maximum absolute difference in linear time . ; max and min variables as described in algorithm . ; updating max and min variables as described in algorithm . ; calculating maximum absolute difference . ; ",
        "context": "",
        "code": "def maxDistance(array):\n    max1 = -2147483648\n    min1 = +2147483647\n    max2 = -2147483648\n    min2 = +2147483647\n    for i in range(len(array)):\n        max1 = max(max1, array[i] + i)\n        min1 = min(min1, array[i] + i)\n        max2 = max(max2, array[i] - i)\n        min2 = min(min2, array[i] - i)\n    return max(max1 - min1, max2 - min2)\n",
        "test": "\narray = [-70, -64, -6, -56, 64, 61, -57, 16, 48, -98]\nprint(maxDistance(array))\n",
        "output": "167\n",
        "fn_call": "maxDistance"
    },
    {
        "text": "check whether a given number is an ugly number or not | function to check if a number is an ugly number or not ; base cases ; condition to check if the number is divided by 2 , 3 , or 5 ; ",
        "context": "",
        "code": "def isUgly(n):\n    if (n == 1):\n        return 1\n    if (n <= 0):\n        return 0\n    if (n % 2 == 0):\n        return (isUgly(n // 2))\n    if (n % 3 == 0):\n        return (isUgly(n // 3))\n    if (n % 5 == 0):\n        return (isUgly(n // 5))\n    return 0\n",
        "test": "\nif __name__ == \"__main__\":\n    no = isUgly(14)\n    if (no == 1):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isUgly"
    },
    {
        "text": "convert an array to reduced form | set 3 ( binary search ) | function to find the reduced form of the given array arr [ ] ; stores the sorted form of the the given array arr [ ] ; sort the array brr [ ] ; traverse the given array arr [ ] ; perform the binary search ; calculate the value of mid ; prthe current index and break ; update the value of l ; update the value of r ; ",
        "context": "",
        "code": "def convert(arr, n):\n    brr = [i for i in arr]\n    brr = sorted(brr)\n    for i in range(n):\n        l, r, mid = 0, n - 1, 0\n        while (l <= r):\n            mid = (l + r) // 2\n            if (brr[mid] == arr[i]):\n                print(mid, end=\" \")\n                break\n            elif (brr[mid] < arr[i]):\n                l = mid + 1\n            else:\n                r = mid - 1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [10, 20, 15, 12, 11, 50]\n    N = len(arr)\n    convert(arr, N)\n",
        "output": "0 4 3 2 1 5 ",
        "fn_call": "convert"
    },
    {
        "text": "meta binary search | one | function to show the working of meta binary search ; set number of bits to represent ; largest array index while ( ( 1 << lg ) < n - 1 ) : lg += 1 ; incrementally construct the index of the target value ; find the element in one direction and update position ; if element found return pos otherwise - 1 ; ",
        "context": "\nimport math\n\n",
        "code": "def bsearch(A, key_to_search):\n    n = len(A)\n    lg = int(math .log2(n - 1)) + 1\n    pos = 0\n    for i in range(lg - 1, -1, -1):\n        if (A[pos] == key_to_search):\n            return pos\n        new_pos = pos | (1 << i)\n        if ((new_pos < n) and (A[new_pos] <= key_to_search)):\n            pos = new_pos\n    return (pos if (A[pos] == key_to_search)else -1)\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [-2, 10, 100, 250, 32315]\n    print(bsearch(A, 10))\n",
        "output": "1\n",
        "fn_call": "bsearch"
    },
    {
        "text": "find the number of occurrences of a character upto preceding position | function to find the number of occurrences of a character at position p upto p - 1 ; iterate over the string ; store the occurrence of same character ; increase its frequency ; return the required count ; ",
        "context": "",
        "code": "def countOccurrence(s, position):\n    alpha = [0] * 26\n    b = [0] * len(s)\n    for i in range(0, len(s)):\n        b[i] = alpha[ord(s[i]) - 97]\n        alpha[ord(s[i]) - 97] = alpha[ord(s[i]) - 97] + 1\n    return b[position - 1]\n",
        "test": "\ns = \"ababababab\"\np = 9\nprint(countOccurrence(s, p))\n",
        "output": "4\n",
        "fn_call": "countOccurrence"
    },
    {
        "text": "count numbers whose xor with n is equal to or with n | function to calculate count of numbers with xor equals or ; variable to store count of unset bits ; ",
        "context": "",
        "code": "def xorEqualsOrCount(N):\n    count = 0\n    while (N > 0):\n        bit = N % 2\n        if bit == 0:\n            count += 1\n        N //= 2\n    return int(pow(2, count))\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 7\n    print(xorEqualsOrCount(N))\n",
        "output": "1\n",
        "fn_call": "xorEqualsOrCount"
    },
    {
        "text": "friends pairing problem | returns count of ways n people can remain single or paired up . ; ",
        "context": "",
        "code": "def countFriendsPairings(n):\n    a, b, c = 1, 2, 0\n    if (n <= 2):\n        return n\n    for i in range(3, n + 1):\n        c = b + (i - 1) * a\n        a = b\n        b = c\n    return c\n",
        "test": "\nn = 4\nprint(countFriendsPairings(n))\n",
        "output": "10\n",
        "fn_call": "countFriendsPairings"
    },
    {
        "text": "happy numbers | returns sum of squares of digits of a number n . for example for n = 12 it returns 1 + 4 = 5 ; returns true if n is happy number else returns false . ; a set to store numbers during repeated square sum process ; keep replacing n with sum of squares of digits until we either reach 1 or we endup in a cycle ; number is happy if we reach 1 ; replace n with sum of squares of digits ; if n is already visited , a cycle is formed , means not happy ; mark n as visited ; ",
        "context": "",
        "code": "def sumDigitSquare(n):\n    sq = 0\n    while (n != 0):\n        digit = n % 10\n        sq += digit * digit\n        n = n // 10\n    return sq\n\n\ndef isHappy(n):\n    s = set()\n    s .add(n)\n    while (True):\n        if (n == 1):\n            return True\n        n = sumDigitSquare(n)\n        if n in s:\n            return False\n        s .add(n)\n    return false\n",
        "test": "\nn = 4\nif (isHappy(n)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isHappy"
    },
    {
        "text": "number of unmarked integers in a special sieve | python3 program to determine the number of unmarked integers in a special sieve ; ",
        "context": "",
        "code": "def countUnmarked(N):\n    if (N % 2 == 0):\n        return N / 2\n    else:\n        return N / 2 + 1\n",
        "test": "\nN = 4\nprint(\"Number of unmarked elements:\", int(countUnmarked(N)))\n",
        "output": "Number of unmarked elements: 2\n",
        "fn_call": "countUnmarked"
    },
    {
        "text": "maximize length of longest non | function to find the length of the longest non - decreasing array that can be generated ; stores the length of the longest non - decreasing array that can be generated from the array ; stores index of start pointer ; stores index of end pointer ; stores previously inserted element into the new array ; traverse the array ; if a [ start ] is less than or equal to a [ end ] ; if no element inserted into the newly generated array ; update prev ; update res ; update start ; if a [ start ] is greater than or equal to prev ; update res ; update prev ; update start ; if a [ end ] is greater than or equal to prev ; update res ; update prev ; update end ; if a [ end ] is greater than a [ start ] ; if no element inserted into the newly generated array ; update prev ; update res ; update end ; if a [ end ] is greater than or equal to prev ; update res ; update prev ; update end ; if a [ start ] is greater than or equal to prev ; update res ; update prev ; update start ; ",
        "context": "",
        "code": "def findLongestNonDecreasing(A, N):\n    res = 0\n    start = 0\n    end = N - 1\n    prev = -1\n    while (start <= end):\n        if (A[start] <= A[end]):\n            if (prev == -1):\n                prev = A[start]\n                res += 1\n                start += 1\n            else:\n                if (A[start] >= prev):\n                    res += 1\n                    prev = A[start]\n                    start += 1\n                elif (A[end] >= prev):\n                    res += 1\n                    prev = A[end]\n                    end -= 1\n                else:\n                    break\n        else:\n            if (prev == -1):\n                prev = A[end]\n                res += 1\n                end -= 1\n            else:\n                if (A[end] >= prev):\n                    res += 1\n                    prev = A[end]\n                    end -= 1\n                elif (A[start] >= prev):\n                    res += 1\n                    prev = A[start]\n                    start += 1\n                else:\n                    break\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    A = [1, 1, 3, 5, 4, 3, 6, 2, 1]\n    N = len(A)\n    print(findLongestNonDecreasing(A, N))\n",
        "output": "7\n",
        "fn_call": "findLongestNonDecreasing"
    },
    {
        "text": "edit distance | dp | a space efficient dynamic programming based python3 program to find minimum number operations to convert str1 to str2 ; create a dp array to memoize result of previous computations ; base condition when second string is empty then we remove all characters ; start filling the dp this loop run for every character in second string ; this loop compares the char from second string with first string characters ; if first string is empty then we have to perform add character operation to get second string ; if character from both string is same then we do not perform any operation . here i % 2 is for bound the row number . ; if character from both string is not same then we take the minimum from three specified operation ; after complete fill the dp array if the len2 is even then we end up in the 0 th row else we end up in the 1 th row so we take len2 % 2 to get row ; ",
        "context": "",
        "code": "def EditDistDP(str1, str2):\n    len1 = len(str1)\n    len2 = len(str2)\n    DP = [[0 for i in range(len1 + 1)]for j in range(2)]\n    for i in range(0, len1 + 1):\n        DP[0][i] = i\n    for i in range(1, len2 + 1):\n        for j in range(0, len1 + 1):\n            if (j == 0):\n                DP[i % 2][j] = i\n            elif (str1[j - 1] == str2[i - 1]):\n                DP[i % 2][j] = DP[(i - 1) % 2][j - 1]\n            else:\n                DP[i %\n                   2][j] = (1 + min(DP[(i - 1) %\n                                       2][j], min(DP[i %\n                                                     2][j - 1], DP[(i - 1) %\n                                                                   2][j - 1])))\n    print(DP[len2 % 2][len1], \"\")\n",
        "test": "\nif __name__ == '__main__':\n    str1 = \"food\"\n    str2 = \"money\"\n    EditDistDP(str1, str2)\n",
        "output": "4 \n",
        "fn_call": "EditDistDP"
    },
    {
        "text": "check if a given string is even | function to check if the string str is palindromic or not ; pointers to iterate the string from both ends ; if characters are found to be distinct ; return true if the string is palindromic ; function to generate string from characters at odd indices ; function to generate string from characters at even indices ; functions to checks if string is even - odd palindrome or not ; generate odd indexed string ; generate even indexed string ; check for palindrome ; ",
        "context": "",
        "code": "def isPalindrome(Str):\n    l = 0\n    h = len(Str) - 1\n    while (h > l):\n        if (Str[l] != Str[h]):\n            return False\n        l += 1\n        h -= 1\n    return True\n\n\ndef makeOddString(Str):\n    odd = \"\"\n    for i in range(1, len(Str), 2):\n        odd += Str[i]\n    return odd\n\n\ndef makeevenString(Str):\n    even = \"\"\n    for i in range(0, len(Str), 2):\n        even += Str[i]\n    return even\n\n\ndef checkevenOddPalindrome(Str):\n    odd = makeOddString(Str)\n    even = makeevenString(Str)\n    if (isPalindrome(odd) and isPalindrome(even)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "test": "\nStr = \"abzzab\"\ncheckevenOddPalindrome(Str)\n",
        "output": "Yes\n",
        "fn_call": "checkevenOddPalindrome"
    },
    {
        "text": "reverse words in a given string | set 2 | function to reverse the words of a given string ; stack to store each word of the string ; store the whole string in stream ; push each word of the into the stack ; print the in reverse order of the words ; ",
        "context": "",
        "code": "def printRev(strr):\n    strr = strr .split(\" \")\n    st = []\n    for i in strr:\n        st .append(i)\n    while len(st) > 0:\n        print(st[-1], end=\" \")\n        del st[-1]\n",
        "test": "\nif __name__ == '__main__':\n    strr = \"geeks quiz practice code\"\n    printRev(strr)\n",
        "output": "code practice quiz geeks ",
        "fn_call": "printRev"
    },
    {
        "text": "minimize the difference between minimum and maximum elements | function to minimize the difference between minimum and maximum elements ; find max and min elements of the array ; check whether the difference between the max and min element is less than or equal to k or not ; calculate average of max and min ; if the array element is greater than the average then decrease it by k ; if the array element is smaller than the average then increase it by k ; find max and min of the modified array ; return the new difference ; ",
        "context": "",
        "code": "def minimizeDiff(arr, n, k):\n    max_element = max(arr)\n    min_element = min(arr)\n    if ((max_element - min_element) <= k):\n        return (max_element - min_element)\n    avg = (max_element + min_element) // 2\n    for i in range(n):\n        if (arr[i] > avg):\n            arr[i] -= k\n        else:\n            arr[i] += k\n    max_element = max(arr)\n    min_element = min(arr)\n    return (max_element - min_element)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [3, 16, 12, 9, 20]\n    n = 5\n    k = 3\n    print(\"Max height difference =\", minimizeDiff(arr, n, k))\n",
        "output": "Max height difference = 11\n",
        "fn_call": "minimizeDiff"
    },
    {
        "text": "find the k | function to find the kth string in lexicographical order which consists of n - 2 xs and 2 ys ; iterate for all possible positions of left most y ; if i is the left most position of y ; put y in their positions ; ",
        "context": "",
        "code": "def kth_string(n, k):\n    for i in range(n - 2, -1, -1):\n        if k <= (n - i - 1):\n            for j in range(n):\n                if (j == i or j == n - k):\n                    print('Y', end=\"\")\n                else:\n                    print('X', end=\"\")\n            break\n        k -= (n - i - 1)\n",
        "test": "\nn = 5\nk = 7\nkth_string(n, k)\n",
        "output": "YXXXY",
        "fn_call": "kth_string"
    },
    {
        "text": "rectangular ( or pronic ) numbers | returns n - th rectangular number ; ",
        "context": "",
        "code": "def findRectNum(n):\n    return n * (n + 1)\n",
        "test": "\nn = 6\nprint(findRectNum(n))\n",
        "output": "42\n",
        "fn_call": "findRectNum"
    },
    {
        "text": "number of ways in which an item returns back to its initial position in n swaps in array of size k | python3 program to find the number of ways in which an item returns back to its initial position in n swaps in an array of size k ; function to calculate ( x ^ y ) % p in o ( log y ) ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def power(x, y):\n    p = mod\n    res = 1\n    x = x % p\n    while (y > 0):\n        if (y & 1) != 0:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\n\ndef solve(n, k):\n    if (n == 1):\n        return 0\n    return (power((k - 1), n - 1) % mod - solve(n - 1, k) + mod) % mod\n",
        "test": "\nmod = 1000000007\nn, k = 4, 5\nprint(solve(n, k))\n",
        "output": "52\n",
        "fn_call": "solve"
    },
    {
        "text": "sum of all possible strings obtained by removal of non | python 3 program for the above approach ; function to convert a character to its equivalent digit ; function to precompute powers of 10 ; function to precompute prefix sum of numerical strings ; function to return the i - th term of triangular number ; function to return the sum of all resulting strings ; precompute powers of 10 ; precompute prefix sum ; initialize result ; apply the above general formula for every i ; return the answer ; ",
        "context": "\nN = 10\npref = [0] * N\npower = [0] * N\n\n",
        "code": "def toDigit(ch):\n    return (ord(ch) - ord('0'))\n\n\ndef powerOf10():\n    power[0] = 1\n    for i in range(1, N):\n        power[i] = power[i - 1] * 10\n\n\ndef precomputePrefix(st, n):\n    pref[0] = (ord(st[0]) - ord('0'))\n    for i in range(1, n):\n        pref[i] = (pref[i - 1] + toDigit(st[i]))\n\n\ndef triangularNumber(i):\n    res = i * (i + 1) // 2\n    return res\n\n\ndef sumOfSubstrings(st):\n    n = len(st)\n    powerOf10()\n    precomputePrefix(st, n)\n    ans = 0\n    for i in range(n - 1):\n        ans += ((pref[n - i - 2] * (i + 1) + toDigit(st[n - i - 1])\n                * triangularNumber(n - i - 1)) * power[i])\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"1234\"\n    print(sumOfSubstrings(st))\n",
        "output": "680\n",
        "fn_call": "sumOfSubstrings"
    },
    {
        "text": "count number of triplets in an array having sum in the range [ a , b ] | function to count triplets ; initialize result ; fix the first element as a [ i ] ; fix the second element as a [ j ] ; now look for the third number ; ",
        "context": "",
        "code": "def countTriplets(arr, n, a, b):\n    ans = 0\n    for i in range(0, n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if ((arr[i] + arr[j] + arr[k] >= a)\n                        and (arr[i] + arr[j] + arr[k] <= b)):\n                    ans += 1\n    return ans\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 7, 5, 3, 8, 4, 1, 9]\n    n = len(arr)\n    a = 8\n    b = 16\n    print(countTriplets(arr, n, a, b))\n",
        "output": "36\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "find the surface area of a 3d figure | declaring the size of the matrix ; absolute difference between the height of two consecutive blocks ; function to calculate the total surfacearea . ; traversing the matrix . ; if we are traveling the topmost row in the matrix , we declare the wall above it as 0 as there is no wall above it . ; if we are traveling the leftmost column in the matrix , we declare the wall left to it as 0 as there is no wall left it . ; if its not the topmost row ; if its not the leftmost column ; summing up the contribution of by the current block ; if its the rightmost block of the matrix it will contribute area equal to its height as a wall on the right of the figure ; if its the lowest block of the matrix it will contribute area equal to its height as a wall on the bottom of the figure ; adding the contribution by the base and top of the figure ; ",
        "context": "\nM = 3\nN = 3\n\n",
        "code": "def contribution_height(current, previous):\n    return abs(current - previous)\n\n\ndef surfaceArea(A):\n    ans = 0\n    for i in range(N):\n        for j in range(M):\n            up = 0\n            left = 0\n            if (i > 0):\n                up = A[i - 1][j]\n            if (j > 0):\n                left = A[i][j - 1]\n            ans += contribution_height(A[i][j], up) + \\\n                contribution_height(A[i][j], left)\n            if (i == N - 1):\n                ans += A[i][j]\n            if (j == M - 1):\n                ans += A[i][j]\n    ans += N * M * 2\n    return ans\n",
        "test": "\nA = [[1, 3, 4], [2, 2, 3], [1, 2, 4]]\nprint(surfaceArea(A))\n",
        "output": "60\n",
        "fn_call": "surfaceArea"
    },
    {
        "text": "count pairs whose product contains single distinct prime factor | function to find a single distinct prime factor of n ; stores distinct prime factors of n ; calculate prime factor of n ; calculate distinct prime factor ; insert i into disprimefact ; update n ; if n is not equal to 1 ; insert n into disprimefact ; if n contains a single distinct prime factor ; return single distinct prime factor of n ; if n contains more than one distinct prime factor ; function to count pairs in the array whose product contains only single distinct prime factor ; stores count of 1 s in the array ; mp [ i ] : stores count of array elements whose distinct prime factor is only i ; traverse the array arr [ ] ; if current element is 1 ; store distinct prime factor of arr [ i ] ; if arr [ i ] contains more than one prime factor ; if arr [ i ] contains a single prime factor ; stores the count of pairs whose product of elements contains only a single distinct prime factor ; traverse the map mp [ ] ; stores count of array elements whose prime factor is ( it . first ) ; update res ; ",
        "context": "",
        "code": "def singlePrimeFactor(N):\n    disPrimeFact = {}\n    for i in range(2, N + 1):\n        if i * i > N:\n            break\n        while (N % i == 0):\n            disPrimeFact[i] = 1\n            N //= i\n    if (N != 1):\n        disPrimeFact[N] = 1\n    if (len(disPrimeFact) == 1):\n        return list(disPrimeFact .keys())[0]\n    return -1\n\n\ndef cntsingleFactorPair(arr, N):\n    countOf1 = 0\n    mp = {}\n    for i in range(N):\n        if (arr[i] == 1):\n            countOf1 += 1\n            continue\n        factorValue = singlePrimeFactor(arr[i])\n        if (factorValue == -1):\n            continue\n        else:\n            mp[factorValue] = mp .get(factorValue, 0) + 1\n    res = 0\n    for it in mp:\n        X = mp[it]\n        res += countOf1 * X + (X * (X - 1)) // 2\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    N = len(arr)\n    print(cntsingleFactorPair(arr, N))\n",
        "output": "4\n",
        "fn_call": "cntsingleFactorPair"
    },
    {
        "text": "find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | python program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; ",
        "context": "",
        "code": "def radius(n, d):\n    print(\"The side of each square is \", d / (n - 1))\n",
        "test": "\nd = 42\nn = 4\nradius(n, d)\n",
        "output": "The side of each square is  14.0\n",
        "fn_call": "radius"
    },
    {
        "text": "construct the cypher string based on the given conditions | python3 program for the above approach ; function to check whether a number is prime or not ; function to check if a prime number can be expressed as sum of two prime numbers ; if the n && ( n - 2 ) is prime ; function to check semiprime ; loop from 2 to sqrt ( num ) ; increment the count of prime numbers ; if num is greater than 1 , then add 1 to it ; return '1' if count is 2 else return '0 ; function to make the cypher string ; resultant string ; make string for the number n ; check for semiprime ; traverse to make cypher string ; if index is odd add the current character ; else current character is changed ; check for sum of two primes ; traverse to make cypher string ; if index is odd then current character is changed ; else add the current character ; if the resultant string is \" \" then print - 1 ; else print the resultant string ; ",
        "context": "\nimport math\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    sqt = (int)(math .sqrt(n))\n    for i in range(2, sqt):\n        if (n % i == 0):\n            return False\n    return True\n\n\ndef isPossibleSum(N):\n    if (isPrime(N) and isPrime(N - 2)):\n        return True\n    else:\n        return False\n\n\ndef checkSemiprime(num):\n    cnt = 0\n    i = 2\n    while cnt < 2 and i * i <= num:\n        while (num % i == 0):\n            num //= i\n            cnt += 1\n        i += 1\n    if (num > 1):\n        cnt += 1\n\n    return cnt == 2\n\n\ndef makeCypherString(N):\n    semiPrime = \"\"\n    sumOfPrime = \"\"\n    st = str(N)\n    if (checkSemiprime(N)):\n        for i in range(len(st)):\n            if (i & 1):\n                semiPrime += st[i]\n            else:\n                semiPrime += chr(ord(st[i]) - ord('0') + 65)\n    if (isPossibleSum(N)):\n        for i in range(len(st)):\n            if (i & 1):\n                sumOfPrime += chr(ord(st[i]) - ord('0') + 65)\n            else:\n                sumOfPrime += st[i]\n    if (semiPrime + sumOfPrime == \"\"):\n        print(\"-1\")\n    else:\n        print(semiPrime + sumOfPrime)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 1011243\n    makeCypherString(N)\n",
        "output": "B0B1C4D\n",
        "fn_call": "makeCypherString"
    },
    {
        "text": "program to find the lcm of two prime numbers | function to return the lcm of two prime numbers ; if the two numbers are equal then return any one of a and b ; else return product of the numbers ; ",
        "context": "",
        "code": "def findLCMPrime(a, b):\n    if (a == b):\n        return a\n    return a * b\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 3\n    b = 5\n    print(findLCMPrime(a, b))\n",
        "output": "15\n",
        "fn_call": "findLCMPrime"
    },
    {
        "text": "count of distinct sums formed by n numbers taken form range [ l , r ] | function to find total number of different sums of n numbers in the range [ l , r ] ; to store minimum possible sum with n numbers with all as l ; to store maximum possible sum with n numbers with all as r ; all other numbers in between maxsum and minsum can also be formed so numbers in this range is the final answer ; ",
        "context": "",
        "code": "def countDistinctSums(N, L, R):\n    minSum = L * N\n    maxSum = R * N\n    return maxSum - minSum + 1\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 2\n    L = 1\n    R = 3\n    print(countDistinctSums(N, L, R))\n",
        "output": "5\n",
        "fn_call": "countDistinctSums"
    },
    {
        "text": "count subarrays for every array element in which they are the minimum | set 2 | function to calculate total number of sub - arrays for each element where that element is occurring as the minimum element ; map for storing the number of sub - arrays for each element ; traverse over all possible subarrays ; minimum in each subarray ; print result ; ",
        "context": "",
        "code": "def minSubarray(arr, N):\n    m = {}\n    for i in range(N):\n        mini = 10 ** 9\n        for j in range(i, N):\n            mini = min(mini, arr[j])\n            m[mini] = m .get(mini, 0) + 1\n    for i in arr:\n        print(m[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 2, 1, 4]\n    N = len(arr)\n    minSubarray(arr, N)\n",
        "output": "1 2 6 1 ",
        "fn_call": "minSubarray"
    },
    {
        "text": "modify the string such that every character gets replaced with the next character in the keyboard | python3 implementation of the approach ; function to return the modified string ; map to store the next character on the keyboard for every possible lowercase character ; update the string ; ",
        "context": "\nCHARS = \"qwertyuiopasdfghjklzxcvbnm\"\nMAX = 26\n\n",
        "code": "def getString(string, n):\n    string = list(string)\n    uMap = {}\n    for i in range(MAX):\n        uMap[CHARS[i]] = CHARS[(i + 1) % MAX]\n    for i in range(n):\n        string[i] = uMap[string[i]]\n    return \"\".join(string)\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeks\"\n    n = len(string)\n    print(getString(string, n))\n",
        "output": "hrrld\n",
        "fn_call": "getString"
    },
    {
        "text": "check if a number has an odd count of odd divisors and even count of even divisors | function to find the count of even and odd factors of n ; loop runs till square root ; condition to check if the even factors of the number n is is even and count of odd factors is odd ; ",
        "context": "",
        "code": "def checkFactors(N):\n    ev_count = 0\n    od_count = 0\n    for i in range(1, int(pow(N, 1 / 2)) + 1):\n        if (N % i == 0):\n            if (i == N / i):\n                if (i % 2 == 0):\n                    ev_count += 1\n                else:\n                    od_count += 1\n            else:\n                if (i % 2 == 0):\n                    ev_count += 1\n                else:\n                    od_count += 1\n                if ((N / i) % 2 == 0):\n                    ev_count += 1\n                else:\n                    od_count += 1\n    if (ev_count % 2 == 0 and od_count % 2 == 1):\n        print(\"Yes\" + \"\")\n    else:\n        print(\"No\" + \"\")\n",
        "test": "\nif __name__ == '__main__':\n    N = 36\n    checkFactors(N)\n",
        "output": "Yes\n",
        "fn_call": "checkFactors"
    },
    {
        "text": "count triplets with sum smaller than a given value | python3 program to count triplets with sum smaller than a given value ; sort input array ; initialize result ; every iteration of loop counts triplet with first element as arr [ i ] . ; initialize other two elements as corner elements of subarray arr [ j + 1. . k ] ; use meet in the middle concept ; if sum of current triplet is more or equal , move right corner to look for smaller values ; else move left corner ; this is important . for current i and j , there can be total k - j third elements . ; ",
        "context": "",
        "code": "def countTriplets(arr, n, sum):\n    arr .sort()\n    ans = 0\n    for i in range(0, n - 2):\n        j = i + 1\n        k = n - 1\n        while (j < k):\n            if (arr[i] + arr[j] + arr[k] >= sum):\n                k = k - 1\n            else:\n                ans += (k - j)\n                j = j + 1\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 1, 3, 4, 7]\n    n = len(arr)\n    sum = 12\n    print(countTriplets(arr, n, sum))\n",
        "output": "4\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "all possible strings of any length that can be formed from a given string | python3 code to generate all possible strings that can be formed from given string ; number of subsequences is ( 2 * * n - 1 ) ; generate all subsequences of a given string . using counter 000. . 1 to 111. . 1 ; check if jth bit in the counter is set if set then print jth element from arr [ ] ; print all permutations of current subsequence ; ",
        "context": "\nfrom itertools import permutations\n\n",
        "code": "def printAll(st):\n    n = len(st)\n    opsize = pow(2, n)\n    for counter in range(1, opsize):\n        subs = \"\"\n        for j in range(n):\n            if (counter & (1 << j)):\n                subs += (st[j])\n        perm = permutations(subs)\n        for i in perm:\n            print(''.join(i), end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    st = \"abc\"\n    printAll((st))\n",
        "output": "a b ab ba c ac ca bc cb abc acb bac bca cab cba ",
        "fn_call": "printAll"
    },
    {
        "text": "number of unique triplets whose xor is zero | function to count the number of unique triplets whose xor is 0 ; to store values that are present ; stores the count of unique triplets ; traverse for all i , j pairs such that j > i ; xor of a [ i ] and a [ j ] ; if xr of two numbers is present , then increase the count ; returns answer ; ",
        "context": "",
        "code": "def countTriplets(a, n):\n    s = set()\n    for i in range(n):\n        s .add(a[i])\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n, 1):\n            xr = a[i] ^ a[j]\n            if (xr in s and xr != a[i] and xr != a[j]):\n                count += 1\n    return int(count / 3)\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 3, 5, 10, 14, 15]\n    n = len(a)\n    print(countTriplets(a, n))\n",
        "output": "2\n",
        "fn_call": "countTriplets"
    },
    {
        "text": "minimum cost to fill given weight in a bag | python program to find minimum cost to get exactly w kg with given packets ; cost [ ] initial cost array including unavailable packet w capacity of bag ; val [ ] and wt [ ] arrays val [ ] array to store cost of ' i ' kg packet of orange wt [ ] array weight of packet of orange ; traverse the original cost [ ] array and skip unavailable packets and make val [ ] and wt [ ] array . size variable tells the available number of distinct weighted packets . ; fill 0 th row with infinity ; fill 0 th column with 0 ; now check for each weight one by one and fill the matrix according to the condition ; wt [ i - 1 ] > j means capacity of bag is less than weight of item ; here we check we get minimum cost either by including it or excluding it ; exactly weight w can not be made by given weights ; ",
        "context": "\nINF = 1000000\n\n",
        "code": "def MinimumCost(cost, n, W):\n    val = list()\n    wt = list()\n    size = 0\n    for i in range(n):\n        if (cost[i] != -1):\n            val .append(cost[i])\n            wt .append(i + 1)\n            size += 1\n    n = size\n    min_cost = [[0 for i in range(W + 1)]for j in range(n + 1)]\n    for i in range(W + 1):\n        min_cost[0][i] = INF\n    for i in range(1, n + 1):\n        min_cost[i][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, W + 1):\n            if (wt[i - 1] > j):\n                min_cost[i][j] = min_cost[i - 1][j]\n            else:\n                min_cost[i][j] = min(min_cost[i - 1][j],\n                                     min_cost[i][j - wt[i - 1]] + val[i - 1])\n    if (min_cost[n][W] == INF):\n        return -1\n    else:\n        return min_cost[n][W]\n",
        "test": "\ncost = [1, 2, 3, 4, 5]\nW = 5\nn = len(cost)\nprint(MinimumCost(cost, n, W))\n",
        "output": "5\n",
        "fn_call": "MinimumCost"
    },
    {
        "text": "find the area of rhombus from given angle and side length | python3 program to calculate area of rhombus from given angle and side length ; function to return the area of rhombus using one angle and side . ; ",
        "context": "\nimport math\n\n",
        "code": "def Area_of_Rhombus(a, theta):\n    area = (a ** 2) * math .sin(math .radians(theta))\n    return area\n",
        "test": "\na = 4\ntheta = 60\nans = Area_of_Rhombus(a, theta)\nprint(round(ans, 2))\n",
        "output": "13.86\n",
        "fn_call": "Area_of_Rhombus"
    },
    {
        "text": "minimum number of alternate subsequences required to be removed to empty a binary string | function to find the minimum number of operations to empty a binary string ; stores the resultant number of operations ; stores the number of 0 s ; stores the number of 1 s ; traverse the given string ; to balance 0 with 1 if possible ; increment the value of cn0 by 1 ; to balance 1 with 0 if possible ; increment the value of cn1 ; update the maximum number of unused 0 s and 1 s ; print resultant count ; ",
        "context": "",
        "code": "def minOpsToEmptyString(s):\n    ans = -10 ** 9\n    cn0 = 0\n    cn1 = 0\n    for i in range(len(s)):\n        if (s[i] == '0'):\n            if (cn1 > 0):\n                cn1 -= 1\n            cn0 += 1\n        else:\n            if (cn0 > 0):\n                cn0 -= 1\n            cn1 += 1\n        ans = max([ans, cn0, cn1])\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"010101\"\n    minOpsToEmptyString(S)\n",
        "output": "1\n",
        "fn_call": "minOpsToEmptyString"
    },
    {
        "text": "find index of an extra element present in one sorted array | returns index of extra element in arr1 [ ] . n is size of arr2 [ ] . size of arr1 [ ] is n - 1. ; left and right are end points denoting the current range . ; if middle element is same of both arrays , it means that extra element is after mid so we update left to mid + 1 ; if middle element is different of the arrays , it means that the index we are searching for is either mid , or before mid . hence we update right to mid - 1. ; when right is greater than left our search is complete . ; ",
        "context": "",
        "code": "def findExtra(arr1, arr2, n):\n\n    index = n\n    left = 0\n    right = n - 1\n    while (left <= right):\n        mid = (int)((left + right) / 2)\n        if (arr2[mid] == arr1[mid]):\n            left = mid + 1\n        else:\n            index = mid\n            right = mid - 1\n    return index\n",
        "test": "\narr1 = [2, 4, 6, 8, 10, 12, 13]\narr2 = [2, 4, 6, 8, 10, 12]\nn = len(arr2)\nprint(findExtra(arr1, arr2, n))\n",
        "output": "6\n",
        "fn_call": "findExtra"
    },
    {
        "text": "k length words that can be formed from given characters without repetition | python3 implementation of the approach ; function to return the required count ; to store the count of distinct characters in str ; traverse str character by character ; if current character is appearing for the first time in str ; increment the distinct character count ; update the appearance of the current character ; since p ( n , r ) = n ! / ( n - r ) ! ; return the answer ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def findPermutation(string, k):\n    has = [False for i in range(26)]\n    cnt = 0\n    for i in range(len(string)):\n        if (has[ord(string[i]) - ord('a')] == False):\n            cnt += 1\n            has[ord(string[i]) - ord('a')] = True\n    ans = 1\n    for i in range(2, cnt + 1):\n        ans *= i\n    for i in range(cnt - k, 1, -1):\n        ans //= i\n    return ans\n",
        "test": "\nstring = \"geeksforgeeks\"\nk = 4\nprint(findPermutation(string, k))\n",
        "output": "840\n",
        "fn_call": "findPermutation"
    },
    {
        "text": "count all unique outcomes possible by performing s flips on n coins | dimensions of the dp table ; stores the dp states ; function to recursively count the number of unique outcomes possible by performing s flips on n coins ; base case ; if the count for the current state is not calculated , then calculate it recursively ; otherwise return the already calculated value ; ",
        "context": "\nsize = 100\nans = [[0 for i in range(size)]for j in range(size)]\n\n",
        "code": "def numberOfUniqueOutcomes(n, s):\n    if (s < n):\n        ans[n][s] = 0\n    elif (n == 1 or n == s):\n        ans[n][s] = 1\n    elif (ans[n][s] == 0):\n        ans[n][s] = (\n            numberOfUniqueOutcomes(\n                n -\n                1,\n                s -\n                1) +\n            numberOfUniqueOutcomes(\n                n -\n                1,\n                s -\n                2))\n    return ans[n][s]\n",
        "test": "\nN = 5\nS = 8\nprint(numberOfUniqueOutcomes(N, S))\n",
        "output": "15\n",
        "fn_call": "numberOfUniqueOutcomes"
    },
    {
        "text": "nth natural number after removing all numbers consisting of the digit 9 | function to find nth number in base 9 ; stores the nth number ; iterate while n is greater than 0 ; update result ; divide n by 9 ; multiply p by 10 ; return result ; ",
        "context": "",
        "code": "def findNthNumber(N):\n    result = 0\n    p = 1\n    while (N > 0):\n        result += (p * (N % 9))\n        N = N // 9\n        p = p * 10\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    N = 9\n    print(findNthNumber(N))\n",
        "output": "10\n",
        "fn_call": "findNthNumber"
    },
    {
        "text": "Get maximum items when other items of total cost of an item are free | Function to count the total number of items ; Sort the prices ; Choose the last element ; Initial count of item ; Sum to keep track of the total price of free items ; If total is less than or equal to z then we will add 1 to the answer ;",
        "context": "",
        "code": "def items(n, a):\n    a .sort()\n    z = a[n - 1]\n    x = 1\n    s = 0\n    for i in range(0, n - 1):\n        s += a[i]\n        if (s <= z):\n            x += 1\n        else:\n            break\n    return x\n",
        "test": "\nn = 5\na = [5, 3, 1, 5, 6]\nprint(items(n, a))\n",
        "output": "3\n",
        "fn_call": "items"
    },
    {
        "text": "find optimal weights which can be used to weigh all the weights in the range [ 1 , x ] | function to find the optimal weights ; number of weights required ; finding the value of required powers of 3 ; optimal weights are powers of 3 ; ",
        "context": "",
        "code": "def findWeights(X):\n    sum = 0\n    power = 0\n    while (sum < X):\n        sum = pow(3, power + 1) - 1\n        sum //= 2\n        power += 1\n    ans = 1\n    for i in range(1, power + 1):\n        print(ans, end=\" \")\n        ans = ans * 3\n",
        "test": "\nX = 2\nfindWeights(X)\n",
        "output": "1 3 ",
        "fn_call": "findWeights"
    },
    {
        "text": "counts 1 s that can be obtained in an array by performing given operations | function to count total number of 1 s in array by performing given operations ; stores count of 1 s in the array by performing the operations ; iterate over the range [ 1 , n ] ; flip all array elements whose index is multiple of i ; update arr [ i ] ; traverse the array ; if current element is 1 ; update cntones ; ",
        "context": "",
        "code": "def cntOnesArrWithGivenOp(arr, N):\n    cntOnes = 0\n    for i in range(1, N + 1):\n        for j in range(i - 1, N, i):\n            arr[j] = 1 if arr[j] == 0 else 0\n    for i in range(N):\n        if (arr[i] == 1):\n            cntOnes += 1\n    return cntOnes\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 0, 0, 0, 0]\n    N = len(arr)\n    print(cntOnesArrWithGivenOp(arr, N))\n",
        "output": "2\n",
        "fn_call": "cntOnesArrWithGivenOp"
    },
    {
        "text": "find minimum sum of factors of number | to find minimum sum of product of number ; find factors of number and add to the sum ; return sum of numbers having minimum product ; ",
        "context": "",
        "code": "def findMinSum(num):\n    sum = 0\n    i = 2\n    while (i * i <= num):\n        while (num % i == 0):\n            sum += i\n            num /= i\n        i += 1\n    sum += num\n    return sum\n",
        "test": "\nnum = 12\nprint(findMinSum(num))\n",
        "output": "7.0\n",
        "fn_call": "findMinSum"
    },
    {
        "text": "frequency of an integer in the given array using divide and conquer | function to return the frequency of x in the subarray arr [ low ... high ] ; if the subarray is invalid or the element is not found ; if there 's only a single element  which is equal to x ; divide the array into two parts and then find the count of occurrences of x in both the parts ; ",
        "context": "",
        "code": "def count(arr, low, high, x):\n    if ((low > high) or (low == high and arr[low] != x)):\n        return 0\n    if (low == high and arr[low] == x):\n        return 1\n    return count(arr, low, (low + high) // 2, x) + \\\n        count(arr, 1 + (low + high) // 2, high, x)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [30, 1, 42, 5, 56, 3, 56, 9]\n    n = len(arr)\n    x = 56\n    print(count(arr, 0, n - 1, x))\n",
        "output": "2\n",
        "fn_call": "count"
    },
    {
        "text": "total pairs in an array such that the bitwise and , bitwise or and bitwise xor of lsb is 1 | function to find the count of required pairs ; to store the count of elements which give remainder 0 i . e . even values ; to store the count of elements which give remainder 1 i . e . odd values ; ",
        "context": "",
        "code": "def CalculatePairs(a, n):\n    cnt_zero = 0\n    cnt_one = 0\n    for i in range(0, n):\n        if (a[i] % 2 == 0):\n            cnt_zero += 1\n        else:\n            cnt_one += 1\n    total_XOR_pairs = cnt_zero * cnt_one\n    total_AND_pairs = (cnt_one) * (cnt_one - 1) / 2\n    total_OR_pairs = cnt_zero * cnt_one + (cnt_one) * (cnt_one - 1) / 2\n    print(\"cntXOR = \", int(total_XOR_pairs))\n    print(\"cntAND = \", int(total_AND_pairs))\n    print(\"cntOR = \", int(total_OR_pairs))\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 3, 4, 2]\n    n = len(a)\n    CalculatePairs(a, n)\n",
        "output": "cntXOR =  4\ncntAND =  1\ncntOR =  5\n",
        "fn_call": "CalculatePairs"
    },
    {
        "text": "program to construct dfa accepting odd number of 0 s and odd number of 1 s | function to check whether the given is accepted by dfa or not ; stores initial state of dfa ; stores final state of dfa ; stores previous state of dfa ; iterate through the string ; checking for all combinations ; update the previous_state ; if final state is reached ; otherwise ; ",
        "context": "",
        "code": "def checkValidDFA(s):\n    initial_state = 0\n    final_state = 0\n    previous_state = 0\n    for i in range(len(s)):\n        if ((s[i] == '0' and previous_state == 0) or (\n                s[i] == '1' and previous_state == 3)):\n            final_state = 1\n        elif ((s[i] == '0' and previous_state == 3) or (s[i] == '1' and previous_state == 0)):\n            final_state = 2\n        elif ((s[i] == '0' and previous_state == 1) or (s[i] == '1' and previous_state == 2)):\n            final_state = 0\n        elif ((s[i] == '0' and previous_state == 2) or (s[i] == '1' and previous_state == 1)):\n            final_state = 3\n        previous_state = final_state\n    if (final_state == 3):\n        print(\"Accepted\")\n    else:\n        print(\"Not Accepted\")\n",
        "test": "\nif __name__ == '__main__':\n    s = \"010011\"\n    checkValidDFA(s)\n",
        "output": "Accepted\n",
        "fn_call": "checkValidDFA"
    },
    {
        "text": "maximize count of pairs whose bitwise xor is even by replacing such pairs with their bitwise xor | function to maximize the count of pairs with even xor possible in an array by given operations ; stores count of odd array elements ; traverse the array ; if arr [ i ] is odd ; stores the total number of even pairs ; ",
        "context": "",
        "code": "def countPairs(arr, N):\n    odd = 0\n    for i in range(N):\n        if (arr[i] & 1):\n            odd += 1\n    ans = (N - odd + odd // 2 - 1) + odd // 2\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 6, 1, 3]\n    N = len(arr)\n    print(countPairs(arr, N))\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "find the index of the left pointer after possible moves in the array | function that returns the index of the left pointer ; there 's only one element  in the array ; initially both are at end ; ",
        "context": "",
        "code": "def getIndex(a, n):\n    if (n == 1):\n        return 0\n    ptrL = 0\n    ptrR = n - 1\n    sumL = a[0]\n    sumR = a[n - 1]\n    while (ptrR - ptrL > 1):\n        if (sumL < sumR):\n            ptrL += 1\n            sumL += a[ptrL]\n        elif (sumL > sumR):\n            ptrR -= 1\n            sumR += a[ptrR]\n        else:\n            break\n    return ptrL\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [2, 7, 9, 8, 7]\n    n = len(a)\n    print(getIndex(a, n))\n",
        "output": "2\n",
        "fn_call": "getIndex"
    },
    {
        "text": "product of all subarrays of an array | set 2 | function to find the product of elements of all subarray ; initialize the result ; computing the product of subarray using formula ; return the product of all elements of each subarray ; ",
        "context": "",
        "code": "def SubArrayProdct(arr, n):\n    result = 1\n    for i in range(0, n):\n        result *= pow(arr[i], (i + 1) * (n - i))\n    return result\n",
        "test": "\narr = [2, 4]\nN = len(arr)\nprint(SubArrayProdct(arr, N))\n",
        "output": "64\n",
        "fn_call": "SubArrayProdct"
    },
    {
        "text": "find the array element having equal count of prime numbers on its left and right | python 3 program for the above approach ; function to find the index of the array such that the count of prime numbers to its either ends are same ; store the maximum value in the array ; traverse the array arr [ ] ; / stores all the numbers ; iterate over the range [ 1 , max ] ; increment the value of st [ i ] ; removes 1 from the map st ; perform sieve of prime numbers ; while i * j is less than the maxvalue ; if i * j is in map st ; erase the value ( i * j ) ; increment the value of j ; stores the count of prime from index 0 to i ; stores the count of prime numbers ; traverse the array arr [ ] ; if arr [ i ] is present in the map st ; stores the count of prime from index i to n - 1 ; stores the count of prime numbers ; iterate over the range [ 0 , n - 1 ] in reverse order ; if arr [ i ] is in map st ; iterate over the range [ 0 , n - 1 ] ; if prefix [ i ] is equal to the suffix [ i ] ; return - 1 if no such index is present ; ",
        "context": "\nfrom collections import defaultdict\nimport sys\nimport math\n\n",
        "code": "def findIndex(arr, N):\n    maxValue = -sys .maxsize - 1\n    for i in range(N):\n        maxValue = max(maxValue, arr[i])\n    St = defaultdict(int)\n    for i in range(1, maxValue + 1):\n        St[i] += 1\n    if (1 in St):\n        St .pop(1)\n    for i in range(2, int(math .sqrt(maxValue)) + 1):\n        j = 2\n        while ((i * j) <= maxValue):\n            if (i * j) in St:\n                St .pop(i * j)\n            j += 1\n    LeftCount = 0\n    Prefix = [0] * N\n    for i in range(N):\n        Prefix[i] = LeftCount\n        if (arr[i] in St):\n            LeftCount += 1\n    RightCount = 0\n    Suffix = [0] * N\n    for i in range(N - 1, -1, -1):\n        Suffix[i] = RightCount\n        if arr[i] in St:\n            RightCount += 1\n    for i in range(N):\n        if (Prefix[i] == Suffix[i]):\n            return i\n    return -1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 7, 5, 10, 1, 8]\n    N = len(arr)\n    print(findIndex(arr, N))\n",
        "output": "2\n",
        "fn_call": "findIndex"
    },
    {
        "text": "queries for counts of array elements with values in given range | function to count elements within given range ; initialize result ; check if element is in range ; ",
        "context": "",
        "code": "def countInRange(arr, n, x, y):\n    count = 0\n    for i in range(n):\n        if (arr[i] >= x and arr[i] <= y):\n            count += 1\n    return count\n",
        "test": "\narr = [1, 3, 4, 9, 10, 3]\nn = len(arr)\ni = 1\nj = 4\nprint(countInRange(arr, n, i, j))\ni = 9\nj = 12\nprint(countInRange(arr, n, i, j))\n",
        "output": "4\n2\n",
        "fn_call": "countInRange"
    },
    {
        "text": "minimum time to return array to its original state after given modifications | python implementation of above approach ; function to return lcm of two numbers ; make a graph ; add edge ; count reachable nodes from every node . ; ",
        "context": "\nimport math\n\n",
        "code": "def lcm(a, b):\n    return (a * b) // (math .gcd(a, b))\n\n\ndef dfs(src, adj, visited):\n    visited[src] = True\n    count = 1\n    if adj[src] != 0:\n        for i in range(len(adj[src])):\n            if (not visited[adj[src][i]]):\n                count += dfs(adj[src][i], adj, visited)\n    return count\n\n\ndef findMinTime(arr, P, n):\n    adj = [0] * (n + 1)\n    for i in range(n):\n        if adj[arr[i]] == 0:\n            adj[arr[i]] = []\n        adj[arr[i]].append(P[i])\n    visited = [0] * (n + 1)\n    ans = 1\n    for i in range(n):\n        if (not visited[i]):\n            ans = lcm(ans, dfs(i, adj, visited))\n    return ans\n",
        "test": "\narr = [1, 2, 3]\nP = [3, 2, 1]\nn = len(arr)\nprint(findMinTime(arr, P, n))\n",
        "output": "2\n",
        "fn_call": "findMinTime"
    },
    {
        "text": "program to build a dfa that checks if a string ends with \"01\" or \"10\" | end position is checked using the string length value . q0 is the starting state . q1 and q2 are intermediate states . q3 and q4 are final states . ; state transitions 0 takes to q1 , 1 takes to q3 ; state transitions 0 takes to q4 , 1 takes to q2 ; state transitions 0 takes to q4 , 1 takes to q2 ; state transitions 0 takes to q1 , 1 takes to q3 ; state transitions 0 takes to q1 , 1 takes to q2 ; ",
        "context": "",
        "code": "def q1(s, i):\n    print(\"q1->\", end=\"\")\n    if (i == len(s)):\n        print(\"NO\")\n        return\n    if (s[i] == '0'):\n        q1(s, i + 1)\n    else:\n        q3(s, i + 1)\n\n\ndef q2(s, i):\n    print(\"q2->\", end=\"\")\n    if (i == len(s)):\n        print(\"NO\")\n        return\n    if (s[i] == '0'):\n        q4(s, i + 1)\n    else:\n        q2(s, i + 1)\n\n\ndef q3(s, i):\n    print(\"q3->\", end=\"\")\n    if (i == len(s)):\n        print(\"YES\")\n        return\n    if (s[i] == '0'):\n        q4(s, i + 1)\n    else:\n        q2(s, i + 1)\n\n\ndef q4(s, i):\n    print(\"q4->\", end=\"\")\n    if (i == len(s)):\n        print(\"YES\")\n        return\n    if (s[i] == '0'):\n        q1(s, i + 1)\n    else:\n        q3(s, i + 1)\n\n\ndef q0(s, i):\n    print(\"q0->\", end=\"\")\n    if (i == len(s)):\n        print(\"NO\")\n        return\n    if (s[i] == '0'):\n        q1(s, i + 1)\n    else:\n        q2(s, i + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"010101\"\n    print(\"State transitions are\", end=\" \")\n    q0(s, 0)\n",
        "output": "State transitions are q0->q1->q3->q4->q3->q4->q3->YES\n",
        "fn_call": "q0"
    },
    {
        "text": "program to find the nth natural number with exactly two bits set | function to find the nth number with exactly two bits set ; keep incrementing until we reach the partition of ' n ' stored in bit_l ; set the rightmost bit based on bit_r ; ",
        "context": "",
        "code": "def findNthNum(N):\n    bit_L = 1\n    last_num = 0\n    while (bit_L * (bit_L + 1) / 2 < N):\n        last_num = last_num + bit_L\n        bit_L += 1\n    bit_R = N - last_num - 1\n    print((1 << bit_L) + (1 << bit_R))\n",
        "test": "\nif __name__ == '__main__':\n    N = 13\n    findNthNum(N)\n",
        "output": "36\n",
        "fn_call": "findNthNum"
    },
    {
        "text": "maximise the sum of two numbers using at most one swap between them | python program to maximise the sum of two numbers using at most one swap between them ; function to maximize the sum by swapping only one digit ; store digits of max ( n1 , n2 ) ; store digits of min ( n1 , n2 ) ; if length of the two numbers are unequal ; find the most significant number and the most significant index for swapping ; if both numbers are of equal length ; fetch the index of current maximum digit present in both the arrays ; compute the difference ; find the most significant index and the most significant digit to be swapped ; restore the new numbers ; display the maximized sum ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def findMaxSum(n1, n2):\n    arr1 = [0] * (MAX)\n    arr2 = [0] * (MAX)\n    l1 = 0\n    l2 = 0\n    max1 = max(n1, n2)\n    min1 = min(n1, n2)\n    i = max1\n    while i > 0:\n        arr1[l1] = (i % 10)\n        l1 += 1\n        i //= 10\n    i = min1\n    while i > 0:\n        arr2[l2] = (i % 10)\n        l2 += 1\n        i //= 10\n    f = 0\n    if (l1 != l2):\n        index = arr2 .index(max(arr2))\n        for i in range(l1 - 1, (l2 - 1), -1):\n            if (arr1[i] < arr2[index]):\n                (arr1[i], arr2[index]) = (arr2[index], arr1[i])\n                f = 1\n                break\n    if (f != 1):\n        index1 = 0\n        index2 = 0\n        diff1 = 0\n        diff2 = 0\n        for i in range(l2 - 1, -1, -1):\n            index1 = arr1 .index(max(arr1[:i]))\n            index2 = arr2 .index(max(arr2[:i]))\n            diff1 = (arr2[index2] - arr1[i])\n            diff2 = (arr1[index1] - arr2[i])\n            if (diff1 > 0 or diff2 > 0):\n                if (diff1 > diff2):\n                    arr1[i], arr2[index2] = arr2[index2], arr1[i]\n                    break\n                elif (diff2 > diff1):\n                    arr2[i], arr1[index1] = arr1[index1], arr2[i]\n                    break\n                elif (diff1 == diff2):\n                    if (index1 <= index2):\n                        arr2[i], arr1[index1] = arr1[index1], arr2[i]\n                        break\n                    elif (index2 <= index1):\n                        arr1[i], arr2[index2] = arr2[index2], arr1[i]\n                        break\n    f_n1 = 0\n    f_n2 = 0\n    for i in range(l1 - 1, -1, -1):\n        f_n1 = (f_n1 * 10) + arr1[i]\n        f_n2 = (f_n2 * 10) + arr2[i]\n    print(f_n1 + f_n2)\n",
        "test": "\nN1 = 9987\nN2 = 123\nfindMaxSum(N1, N2)\n",
        "output": "10740\n",
        "fn_call": "findMaxSum"
    },
    {
        "text": "maximum subsequence sum such that no k elements are consecutive | function to find the maximum sum of a subsequence consisting of no k consecutive array elements ; stores states of dp ; stores the prefix sum ; update the prefix sum ; base case for i = k case ; skip each element from i to ( i - k + 1 ) to ensure that no k elements are consecutive ; update the current dp state ; dp [ n ] stores the maximum sum ; ",
        "context": "",
        "code": "def Max_Sum(arr, K, N):\n    dp = [0] * (N + 1)\n    prefix = [None] * (N + 1)\n    prefix[0] = 0\n    for i in range(1, N + 1):\n        prefix[i] = prefix[i - 1] + arr[i - 1]\n    dp[0] = 0\n    for i in range(1, K):\n        dp[i] = prefix[i]\n    for i in range(K, N + 1):\n        for j in range(i, i - K, -1):\n            dp[i] = max(dp[i], dp[j - 1] + prefix[i] - prefix[j])\n    return dp[N]\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [4, 12, 22, 18, 34, 12, 25]\n    N = len(arr)\n    K = 5\n    print(Max_Sum(arr, K, N))\n",
        "output": "111\n",
        "fn_call": "Max_Sum"
    },
    {
        "text": "queries on sum of odd number digit sums of all the factors of a number | python program to answer queries on sum of sum of odd number digits of all the factors of a number ; finding sum of odd digit number in each integer . ; for each number ; using previous number sum , finding the current number num of odd digit also , adding last digit if it is odd . ; finding sum of sum of odd digit of all the factors of a number . ; for each possible factor ; adding the contribution . ; wrapper def ; ",
        "context": "\nN = 100\ndigitSum = [0] * N\nfactorDigitSum = [0] * N\n\n",
        "code": "def sumOddDigit():\n    global N, digitSum, factorDigitSum\n    for i in range(1, N):\n        digitSum[i] = (digitSum[int(i / 10)] + int(i & 1) * (i % 10))\n\n\ndef sumFactor():\n    global N, digitSum, factorDigitSum\n    j = 0\n    for i in range(1, N):\n        j = i\n        while (j < N):\n            factorDigitSum[j] = (factorDigitSum[j] + digitSum[i])\n            j = j + i\n\n\ndef wrapper(q, n):\n    global N, digitSum, factorDigitSum\n    for i in range(0, N):\n        digitSum[i] = 0\n        factorDigitSum[i] = 0\n    sumOddDigit()\n    sumFactor()\n    for i in range(0, q):\n        print(\"{} \".format(factorDigitSum[n[i]]), end=\"\")\n",
        "test": "\nq = 2\nn = [10, 36]\nwrapper(q, n)\n",
        "output": "7 18 ",
        "fn_call": "wrapper"
    },
    {
        "text": "count numbers upto n which are both perfect square and perfect cube | function to return required count ; ",
        "context": "",
        "code": "def SquareCube(N):\n    cnt, i = 0, 1\n    while (i ** 6 <= N):\n        cnt += 1\n        i += 1\n    return cnt\n",
        "test": "\nN = 100000\nprint(SquareCube(N))\n",
        "output": "6\n",
        "fn_call": "SquareCube"
    },
    {
        "text": "sum of first n even numbers | function to find sum of first n even numbers ; required sum ; ",
        "context": "",
        "code": "def evensum(n):\n    return n * (n + 1)\n",
        "test": "\nn = 20\nprint(\"sum of first\", n, \"even number is: \", evensum(n))\n",
        "output": "sum of first 20 even number is:  420\n",
        "fn_call": "evensum"
    },
    {
        "text": "triangle with no point inside | python3 program to find triangle with no point inside ; method to get square of distance between ( x1 , y1 ) and ( x2 , y2 ) ; method prints points which make triangle with no point inside ; any point can be chosen as first point of triangle ; choose nearest point as second point of triangle ; get distance from first point and choose nearest one ; pick third point by finding the second closest point with different slope . ; if already chosen point then skip them ; get distance from first point ; here cross multiplication is compared instead of division comparison ; ",
        "context": "\nimport sys\n\n",
        "code": "def getDistance(x1, y1, x2, y2):\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n\n\ndef triangleWithNoPointInside(points, N):\n    first = 0\n    second = 0\n    third = 0\n    minD = sys .maxsize\n    for i in range(0, N):\n        if i == first:\n            continue\n        d = getDistance(\n            points[i][0],\n            points[i][1],\n            points[first][0],\n            points[first][1])\n        if minD > d:\n            minD = d\n            second = i\n    minD = sys .maxsize\n    for i in range(0, N):\n        if i == first or i == second:\n            continue\n        d = getDistance(\n            points[i][0],\n            points[i][1],\n            points[first][0],\n            points[first][1])\n        if ((points[i][0] -\n             points[first][0]) *\n            (points[second][1] -\n             points[first][1]) != (points[second][0] -\n                                   points[first][0]) *\n            (points[i][1] -\n             points[first][1]) and minD > d):\n            minD = d\n            third = i\n    print(points[first][0], ', ', points[first][1])\n    print(points[second][0], ', ', points[second][1])\n    print(points[third][0], ', ', points[third][1])\n",
        "test": "\npoints = [[0, 0], [0, 2], [2, 0], [2, 2], [1, 1]]\nN = len(points)\ntriangleWithNoPointInside(points, N)\n",
        "output": "0 ,  0\n1 ,  1\n0 ,  2\n",
        "fn_call": "triangleWithNoPointInside"
    },
    {
        "text": "count divisors of n that have at | python3 program to count divisors of n that have at least one digit common with n ; function to return true if any digit of m is present in hash [ ] . ; check till last digit ; if number is also present in original number then return true ; if no number matches then return 1 ; count the no of divisors that have at least 1 digits same ; store digits present in n in a hash [ ] ; marks that the number is present ; last digit removed ; loop to traverse from 1 to sqrt ( n ) to count divisors ; if i is the factor ; call the function to check if any digits match or not ; if n / i != i then a different number , then check it also ; return the answer ; ",
        "context": "\nimport math\n\n",
        "code": "def isDigitPresent(m, Hash):\n    while (m):\n        if (Hash[m % 10]):\n            return True\n        m = m // 10\n    return False\n\n\ndef countDivisibles(n):\n    Hash = [False for i in range(10)]\n    m = n\n    while (m):\n        Hash[m % 10] = True\n        m = m // 10\n    ans = 0\n    for i in range(1, int(math .sqrt(n)) + 1):\n        if (n % i == 0):\n            if (isDigitPresent(i, Hash)):\n                ans += 1\n            if (n // i != i):\n                if (isDigitPresent(n // i, Hash)):\n                    ans += 1\n    return ans\n",
        "test": "\nn = 15\nprint(countDivisibles(n))\n",
        "output": "3\n",
        "fn_call": "countDivisibles"
    },
    {
        "text": "count of ' gfg ' subsequences in the given string | python 3 program to find the \" gfg \" subsequence in the given string ; print the count of \" gfg \" subsequence in the string ; traversing the given string ; if the character is ' g ' , increment the count of ' g ' , increase the result and update the array . ; if the character is ' f ' , increment the count of ' f ' and update the array . ; ignore other character . ; ",
        "context": "\nMAX = 100\n\n",
        "code": "def countSubsequence(s, n):\n    cntG = 0\n    cntF = 0\n    result = 0\n    C = 0\n    for i in range(n):\n        if (s[i] == 'G'):\n            cntG += 1\n            result += C\n            continue\n        if (s[i] == 'F'):\n            cntF += 1\n            C += cntG\n            continue\n        else:\n            continue\n    print(result)\n",
        "test": "\nif __name__ == '__main__':\n    s = \"GFGFG\"\n    n = len(s)\n    countSubsequence(s, n)\n",
        "output": "4\n",
        "fn_call": "countSubsequence"
    },
    {
        "text": "schr\u00e3 \u00b6 der\u00e2 \u20ac\u201c hipparchus number | a memoization based optimized python3 program to find n - th schraderahipparchus number ; ",
        "context": "",
        "code": "def nthSHN(n, dp):\n    if (n == 1 or n == 2):\n        dp[n] = 1\n        return dp[n]\n    if (dp[n] != -1):\n        return dp[n]\n    dp[n] = ((6 * n - 9) * nthSHN(n - 1, dp) - (n - 3) * nthSHN(n - 2, dp)) / n\n    return dp[n]\n",
        "test": "\nn = 6\ndp = [-1 for i in range(500)]\nprint(nthSHN(n, dp))\n",
        "output": "197.0\n",
        "fn_call": "nthSHN"
    },
    {
        "text": "minimize moves required to make array elements equal by incrementing and decrementing pairs | set 2 | function to find the minimum number of increment and decrement of pairs required to make all array elements equal ; stores the sum of the array ; if sum is not divisible by n ; update sum ; store the minimum number of operations ; iterate while i is less than n ; add absolute difference of current element with k to ans ; increase i bye 1 ; return the value in ans2 ; ",
        "context": "",
        "code": "def find(arr, N):\n    Sum = sum(arr)\n    if Sum % N:\n        return -1\n    else:\n        k = Sum // N\n        ans = 0\n        i = 0\n        while i < N:\n            ans = ans + abs(k - arr[i])\n            i += 1\n        return ans // 2\n",
        "test": "\nif __name__ == '__main__':\n    arr = [5, 4, 1, 10]\n    N = len(arr)\n    print(find(arr, N))\n",
        "output": "5\n",
        "fn_call": "find"
    },
    {
        "text": "lexicographically smallest string possible by performing k operations on a given string | function to find the lexicographically smallest possible string by performing k operations on string s ; store the size of string , s ; check if k >= n , if true , convert every character to 'a ; iterate in range [ 0 , n - 1 ] using i ; when k reaches 0 , break the loop ; if current character is ' a ' , continue ; otherwise , iterate in the range [ i + 1 , n - 1 ] using j ; check if s [ j ] > s [ i ] ; if true , set s [ j ] = s [ i ] and break out of the loop ; check if j reaches the last index ; update s [ i ] ; decrement k by 1 ; print string ; ",
        "context": "",
        "code": "def smallestlexicographicstring(s, k):\n    n = len(s)\n\n    if (k >= n):\n        for i in range(n):\n\n            s[i] = 'a'\n\n        print(s, end='')\n        return\n    for i in range(n):\n        if (k == 0):\n            break\n\n        if (s[i] == 'a'):\n            continue\n        for j in range(i + 1, n):\n\n            if (s[j] > s[i]):\n\n                s[j] = s[i]\n                break\n\n            elif (j == n - 1):\n                s[j] = s[i]\n\n        s[i] = 'a'\n\n        k -= 1\n    print(''.join(s), end='')\n",
        "test": "\nif __name__ == '__main__':\n\n    s = list(\"geeksforgeeks\")\n\n    k = 6\n\n    smallestlexicographicstring(s, k)\n",
        "output": "aaaaaaeegeeks",
        "fn_call": "smallestlexicographicstring"
    },
    {
        "text": "Sum of all armstrong numbers lying in the range [ L , R ] for Q queries | pref [ ] array to precompute the sum of all armstrong number ; Function that return number num if num is armstrong else return 0 ; Function to precompute the sum of all armstrong numbers upto 100000 ; checkarmstrong ( ) return the number i if i is armstrong else return 0 ; Function to print the sum for each query ; Function to prsum of all armstrong numbers between [ L , R ] ; Function that pre computes the sum of all armstrong numbers ; Iterate over all Queries to print the sum ; Queries ; Function that print the the sum of all armstrong number in Range [ L , R ]",
        "context": "\npref = [0] * 100001\n\n",
        "code": "def checkArmstrong(x):\n    n = len(str(x))\n    sum1 = 0\n    temp = x\n    while temp > 0:\n        digit = temp % 10\n        sum1 += digit ** n\n        temp //= 10\n    if sum1 == x:\n        return x\n    return 0\n\n\ndef preCompute():\n    for i in range(1, 100001):\n        pref[i] = pref[i - 1] + checkArmstrong(i)\n\n\ndef printSum(L, R):\n    print(pref[R] - pref[L - 1])\n\n\ndef printSumarmstrong(arr, Q):\n    preCompute()\n    for i in range(Q):\n        printSum(arr[i][0], arr[i][1])\n",
        "test": "\nQ = 2\narr = [[1, 13], [121, 211]]\nprintSumarmstrong(arr, Q)\n",
        "output": "45\n153\n",
        "fn_call": "printSumarmstrong"
    },
    {
        "text": "minimum count of indices to be skipped for every index of array to keep sum till that index at most t | function to calculate minimum indices to be skipped so that sum till i remains smaller than t ; store the sum of all indices before i ; store the elements that can be skipped ; traverse the array , a [ ] ; store the total sum of elements that needs to be skipped ; store the number of elements need to be removed ; traverse from the back of map so as to take bigger elements first ; update sum ; update map with the current element ; ",
        "context": "",
        "code": "def skipIndices(N, T, arr):\n    sum = 0\n    count = {}\n    for i in range(N):\n        d = sum + arr[i] - T\n        k = 0\n        if (d > 0):\n            for u in list(count .keys())[::-1]:\n                j = u\n                x = j * count[j]\n                if (d <= x):\n                    k += (d + j - 1) // j\n                    break\n                k += count[j]\n                d -= x\n        sum += arr[i]\n        count[arr[i]] = count .get(arr[i], 0) + 1\n        print(k, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    N = 7\n    T = 15\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    skipIndices(N, T, arr)\n",
        "output": "0 0 0 0 0 2 3 ",
        "fn_call": "skipIndices"
    },
    {
        "text": "trapping rain water | function to return the maximum water that can be stored ; indices to traverse the array ; to store left max and right max for two pointers left and right ; to store the total amount of rain water trapped ; we need check for minimum of left and right max for each element ; add the difference between current value and right max at index r ; update right max ; update right pointer ; add the difference between current value and left max at index l ; update left max ; update left pointer ; ",
        "context": "",
        "code": "def maxWater(arr, n):\n    left = 0\n    right = n - 1\n    l_max = 0\n    r_max = 0\n    result = 0\n    while (left <= right):\n        if r_max <= l_max:\n            result += max(0, r_max - arr[right])\n            r_max = max(r_max, arr[right])\n            right -= 1\n        else:\n            result += max(0, l_max - arr[left])\n            l_max = max(l_max, arr[left])\n            left += 1\n    return result\n",
        "test": "\narr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nn = len(arr)\nprint(maxWater(arr, n))\n",
        "output": "6\n",
        "fn_call": "maxWater"
    },
    {
        "text": "find last 2 survivors in n persons standing in a circle after killing next to immediate neighbour | node for a linked list ; function to find the last 2 survivors ; total is the count of alive people ; initiating the list of n people ; total != 2 is terminating condition because at last only two - person will remain alive ; de represent next person to be deleted or killed ; last two person to survive ( in any order ) ; ",
        "context": "\nclass newNode:\n    def __init__(self, val):\n        self .val = val\n        self .next = None\n\n",
        "code": "def getLastTwoPerson(n):\n    total = n\n    head = newNode(1)\n    temp = head\n    for i in range(2, n + 1, 1):\n        temp .next = newNode(i)\n        temp = temp .next\n    temp .next = head\n    temp = head\n    de = None\n    while (total != 2):\n        de = temp .next .next\n        temp .next .next = temp .next .next .next\n        temp = temp .next\n        del de\n        total -= 1\n    print(temp .val, temp .next .val)\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    getLastTwoPerson(n)\n",
        "output": "1 2\n",
        "fn_call": "getLastTwoPerson"
    },
    {
        "text": "hardy | python3 program to count all prime factors ; a function to count prime factors of a given number n ; n must be odd at this point . so we can skip one element ( note i = i + 2 ) ; this condition is to handle the case when n is a prime number greater than 2 ; ",
        "context": "\nimport math\n\n",
        "code": "def exactPrimeFactorCount(n):\n    count = 0\n    if (n % 2 == 0):\n        count = count + 1\n        while (n % 2 == 0):\n            n = int(n / 2)\n    i = 3\n    while (i <= int(math .sqrt(n))):\n        if (n % i == 0):\n            count = count + 1\n            while (n % i == 0):\n                n = int(n / i)\n        i = i + 2\n    if (n > 2):\n        count = count + 1\n    return count\n",
        "test": "\nn = 51242183\nprint(\"The number of distinct prime factors is/are {}\".format(exactPrimeFactorCount(n), end=\"\"))\nprint(\"The value of log(log(n)) is {0:.4f}\".format(math .log(math .log(n))))\n",
        "output": "The number of distinct prime factors is/are 3\nThe value of log(log(n)) is 2.8765\n",
        "fn_call": "exactPrimeFactorCount"
    },
    {
        "text": "maximum score possible by removing substrings made up of single distinct character | initialize a dictionary to store the precomputed results ; function to calculate the maximum score possible by removing substrings ; if s is present in dp [ ] array ; base cases : ; if length of string is 0 ; if length of string is 1 ; put head pointer at start ; initialize the max variable ; generate the substrings using two pointers ; if s [ head ] and s [ tail ] are different ; move head to tail and break ; store the substring ; update the maximum ; move the tail ; store the score ; ",
        "context": "\ndp = dict()\n\n",
        "code": "def maxScore(s, a):\n    if s in dp:\n        return dp[s]\n    n = len(s)\n    if n == 0:\n        return 0\n    if n == 1:\n        return a[0]\n    head = 0\n    mx = -1\n    while head < n:\n        tail = head\n        while tail < n:\n            if s[tail] != s[head]:\n                head = tail\n                break\n            sub = s[head:tail + 1]\n            mx = max(mx, a[len(sub) - 1] +\n                     maxScore(s[:head] + s[tail + 1:], a))\n            tail += 1\n        if tail == n:\n            break\n    dp[s] = mx\n    return mx\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"abb\"\n    a = [1, 3, 1]\n    print(maxScore(s, a))\n",
        "output": "4\n",
        "fn_call": "maxScore"
    },
    {
        "text": "find the number obtained after concatenation of binary representation of m and n | python3 implementation of the approach ; function to convert decimal number n to its binary representation stored as an array arr [ ] ; funtion to convert the number represented as a binary array arr [ ] its decimal equivalent ; function to concatenate the binary numbers and return the decimal result ; number of bits in both the numbers ; convert the bits in both the gers to the arrays a [ ] and b [ ] ; c [ ] will be the binary array for the result ; update the c [ ] array ; return the decimal equivalent of the result ; ",
        "context": "\nimport math\n\n",
        "code": "def decBinary(arr, n):\n    k = int(math .log2(n))\n    while (n > 0):\n        arr[k] = n % 2\n        k = k - 1\n        n = n // 2\n\n\ndef binaryDec(arr, n):\n    ans = 0\n    for i in range(0, n):\n        ans = ans + (arr[i] << (n - i - 1))\n    return ans\n\n\ndef concat(m, n):\n    k = int(math .log2(m)) + 1\n    l = int(math .log2(n)) + 1\n    a = [0 for i in range(0, k)]\n    b = [0 for i in range(0, l)]\n    c = [0 for i in range(0, k + l)]\n    decBinary(a, m)\n    decBinary(b, n)\n    iin = 0\n    for i in range(0, k):\n        c[iin] = a[i]\n        iin = iin + 1\n    for i in range(0, l):\n        c[iin] = b[i]\n        iin = iin + 1\n    return (binaryDec(c, k + l))\n",
        "test": "\nm = 4\nn = 5\nprint(concat(m, n))\n",
        "output": "37\n",
        "fn_call": "concat"
    },
    {
        "text": "find position of an element in a sorted array of infinite numbers | binary search algorithm implementation ; function takes an infinite size array and a key to be searched and returns its position if found else - 1. we don 't know size of a[] and we can assume size to be infinite in this function. note that this function assumes a[] to be of infinite size therefore, there is no index out of bound checking ; find h to do binary search ; store previous high ; double high index ; update new val ; at this point we have updated low and high indices , thus use binary search between them ; ",
        "context": "",
        "code": "def binary_search(arr, l, r, x):\n\n    if r >= l:\n        mid = l+(r-l)//2\n\n        if arr[mid] == x:\n            return mid\n\n        if arr[mid] > x:\n            return binary_search(arr, l, mid-1, x)\n\n        return binary_search(arr, mid+1, r, x)\n\n    return -1\n\n\ndef findPos(a, key):\n\n    l, h, val = 0, 1, arr[0]\n    while val < key:\n        l = h\n        h = 2*h\n        val = arr[h]\n    return binary_search(a, l, h, key)\n",
        "test": "\narr = [3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170]\nans = findPos(arr, 10)\nif ans == -1:\n    print((\"Element not found\"))\nelse:\n    print(\"Element found at index\", ans)\n",
        "output": "Element found at index 4\n",
        "fn_call": "findPos"
    },
    {
        "text": "maximum possible value of array elements that can be made based on given capacity conditions | function to find the maximum element after shifting operations in arr [ ] ; stores the sum of array element ; stores the maximum element in cap [ ] ; iterate to find maximum element ; return the resultant maximum value ; ",
        "context": "",
        "code": "def maxShiftArrayValue(arr, cap, N):\n    sumVals = 0\n    for i in range(N):\n        sumVals += arr[i]\n    maxCapacity = 0\n    for i in range(N):\n        maxCapacity = max(cap[i], maxCapacity)\n    return min(maxCapacity, sumVals)\n",
        "test": "\nif __name__ == '__main__':\n    arr = [2, 3]\n    cap = [5, 6]\n    N = len(arr)\n    print(maxShiftArrayValue(arr, cap, N))\n",
        "output": "5\n",
        "fn_call": "maxShiftArrayValue"
    },
    {
        "text": "minimize number of boxes by putting small box inside bigger one | function to minimize the count ; initial number of box ; sort array of box size in increasing order ; check is current box size is smaller than next box size ; decrement box count increment current box count increment next box count ; check if both box have same size ; print the result ; ",
        "context": "",
        "code": "def minBox(arr, n):\n    box = n\n    arr .sort()\n    curr_box, next_box = 0, 1\n    while (curr_box < n and next_box < n):\n        if (arr[curr_box] < arr[next_box]):\n            box = box - 1\n            curr_box = curr_box + 1\n            next_box = next_box + 1\n        elif (arr[curr_box] == arr[next_box]):\n            next_box = next_box + 1\n    print(box)\n",
        "test": "\nsize = [1, 2, 3]\nn = len(size)\nminBox(size, n)\n",
        "output": "1\n",
        "fn_call": "minBox"
    },
    {
        "text": "maximum sum subsequence made up of consecutive elements of different parity | function to calculate the maximum sum subsequence with consecutive terms having different parity ; base case ; store the parity of number at the ith position ; if the dp state has already been calculated , return it ; if the array is traversed and no element has been selected yet then select the current element ; if the parity of the current and previously selected element are different , then select the current element ; skip the current element and move to the next element ; return the result ; function to calculate the maximum sum subsequence with consecutive terms having different parity ; initialize the dp [ ] array with - 1 ; initially the prev value is set to say 2 , as the first element can anyways be selected ; ",
        "context": "",
        "code": "def maxSum(arr, i, n, prev, is_selected, dp):\n    if (i == n):\n        return 0\n    cur = abs(arr[i]) % 2\n    if (dp[i][prev] != -1):\n        return dp[i][prev]\n    if (i == n - 1 and is_selected == 0):\n        dp[i][prev] = arr[i]\n        return dp[i][prev]\n    if (cur != prev):\n        dp[i][prev] = arr[i] + maxSum(arr, i + 1, n, cur, 1, dp)\n    dp[i][prev] = max(\n        dp[i][prev],\n        maxSum(\n            arr,\n            i + 1,\n            n,\n            prev,\n            is_selected,\n            dp))\n    return dp[i][prev]\n\n\ndef maxSumUtil(arr, n):\n    dp = [[-1 for i in range(3)]for j in range(100)]\n    print(maxSum(arr, 0, n, 2, 0, dp))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 6, 8, -5, 10]\n    N = len(arr)\n    maxSumUtil(arr, N)\n",
        "output": "14\n",
        "fn_call": "maxSumUtil"
    },
    {
        "text": "length of diagonal of a parallelogram using adjacent sides and angle between them | python3 program to find length of diagonal of a parallelogram using sides and angle between them . ; function to return the length of diagonal of a parallelogram using sides and angle between them . ; given sides ; ",
        "context": "\nimport math\n\n",
        "code": "def Length_Diagonal(a, b, theta):\n    diagonal = math .sqrt(((a ** 2) + (b ** 2)) - 2 *\n                          a * b * math .cos(math .radians(theta)))\n    return diagonal\n",
        "test": "\na = 3\nb = 5\ntheta = 45\nans = Length_Diagonal(a, b, theta)\nprint(round(ans, 2))\n",
        "output": "3.58\n",
        "fn_call": "Length_Diagonal"
    },
    {
        "text": "maximum number of envelopes that can be put inside other bigger envelopes | function that returns the maximum number of envelopes that can be inserted into another envelopes ; number of envelopes ; sort the envelopes in non - decreasing order ; initialize dp [ ] array ; to store the result ; loop through the array ; find envelopes count for each envelope ; store maximum envelopes count ; return the result ; ",
        "context": "",
        "code": "def maxEnvelopes(envelopes):\n    N = len(envelopes)\n    if (N == 0):\n        return N\n    envelopes = sorted(envelopes)\n    dp = [0] * N\n    max_envelope = 1\n    dp[0] = 1\n    for i in range(1, N):\n        dp[i] = 1\n        for j in range(i):\n            if (envelopes[i][0] > envelopes[j][0] and envelopes[i]\n                    [1] > envelopes[j][1] and dp[i] < dp[j] + 1):\n                dp[i] = dp[j] + 1\n        max_envelope = max(max_envelope, dp[i])\n    return max_envelope\n",
        "test": "\nif __name__ == '__main__':\n    envelopes = [[4, 3], [5, 3], [5, 6], [1, 2]]\n    print(maxEnvelopes(envelopes))\n",
        "output": "3\n",
        "fn_call": "maxEnvelopes"
    },
    {
        "text": "floor and ceil from a bst | a binary tree node ; function to find ceil of a given input in bst . if input is more than the max key in bst , return - 1 ; base case ; we found equal key ; if root 's key is smaller, ceil must be in right subtree ; else , either left subtre or root has the ceil value ; ",
        "context": "\nclass Node:\n    def __init__(self, data):\n        self .key = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def ceil(root, inp):\n    if root is None:\n        return -1\n    if root .key == inp:\n        return root .key\n    if root .key < inp:\n        return ceil(root .right, inp)\n    val = ceil(root .left, inp)\n    return val if val >= inp else root .key\n",
        "test": "\nroot = Node(8)\nroot .left = Node(4)\nroot .right = Node(12)\nroot .left .left = Node(2)\nroot .left .right = Node(6)\nroot .right .left = Node(10)\nroot .right .right = Node(14)\nfor i in range(16):\n    print(\"% d % d\" % (i, ceil(root, i)))\n",
        "output": " 0  2\n 1  2\n 2  2\n 3  4\n 4  4\n 5  6\n 6  6\n 7  8\n 8  8\n 9  10\n 10  10\n 11  12\n 12  12\n 13  14\n 14  14\n 15 -1\n",
        "fn_call": "ceil"
    },
    {
        "text": "minimum cost to make all array elements equal using given operations | python3 implementation to find the minimum cost to make all array elements equal ; checks if the value is less than middle element of the array ; function that returns the cost of making all elements equal to current element ; compute the lower bound of current element ; calculate the requirement of add operation ; calculate the requirement of subtract operation ; compute minimum of left and right ; computing the total cost of add and subtract operations ; function that prints minimum cost of making all elements equal ; sort the given array ; calculate minimum from a + r and m ; compute prefix sum and store in pref array ; find the minimum cost from the given elements ; finding the minimum cost from the other cases where minimum cost can occur ; printing the minimum cost of making all elements equal ; ",
        "context": "",
        "code": "def lowerBound(array, length, value):\n    low = 0\n    high = length\n    while (low < high):\n        mid = (low + high) // 2\n        if (value <= array[mid]):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n\ndef costCalculation(current, arr, n, pref, a, r, minimum):\n    index = lowerBound(arr, len(arr), current)\n    left = index * current - pref[index]\n    right = (pref[n] - pref[index] - (n - index) * current)\n    res = min(left, right)\n    left -= res\n    right -= res\n    total = res * minimum\n    total += left * a\n    total += right * r\n    return total\n\n\ndef solve(arr, n, a, r, m):\n    arr .sort()\n    minimum = min(a + r, m)\n    pref = [0] * (n + 1)\n    for i in range(n):\n        pref[i + 1] = pref[i] + arr[i]\n    ans = 10000\n    for i in range(n):\n        ans = min(ans, costCalculation(arr[i], arr, n, pref, a, r, minimum))\n    ans = min(ans, costCalculation(pref[n] // n, arr, n, pref, a, r, minimum))\n    ans = min(\n        ans,\n        costCalculation(\n            pref[n] //\n            n +\n            1,\n            arr,\n            n,\n            pref,\n            a,\n            r,\n            minimum))\n    print(ans)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [5, 5, 3, 6, 5]\n    A = 1\n    R = 2\n    M = 4\n    size = len(arr)\n    solve(arr, size, A, R, M)\n",
        "output": "4\n",
        "fn_call": "solve"
    },
    {
        "text": "count of divisors having more set bits than quotient on dividing n | python3 program to find number of divisors which on integer division produce quotient having less set bit than divisor ; return the count of set bit . ; check if q and d have same number of set bit . ; binary search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; ",
        "context": "\nimport math\n\n",
        "code": "def bit(x):\n    ans = 0\n    while (x):\n        x /= 2\n        ans = ans + 1\n    return ans\n\n\ndef check(d, x):\n    if (bit(x / d) <= bit(d)):\n        return True\n    return False\n\n\ndef bs(n):\n    l = 1\n    r = int(math .sqrt(n))\n    while (l < r):\n        m = int((l + r) / 2)\n        if (check(m, n)):\n            r = m\n        else:\n            l = m + 1\n    if (check(l, n) == False):\n        return math .floor(l + 1)\n    else:\n        return math .floor(l)\n\n\ndef countDivisor(n):\n    return n - bs(n) + 1\n",
        "test": "\nn = 5\nprint(countDivisor(n))\n",
        "output": "4\n",
        "fn_call": "countDivisor"
    },
    {
        "text": "count of subarrays of size k with average at least m | function to count the subarrays of size k having average at least m ; stores the resultant count of subarray ; stores the sum of subarrays of size k ; add the values of first k elements to the sum ; increment the count if the current subarray is valid ; traverse the given array ; find the updated sum ; check if current subarray is valid or not ; return the count of subarrays ; ",
        "context": "",
        "code": "def countSubArrays(arr, N, K, M):\n    count = 0\n    sum = 0\n    for i in range(K):\n        sum += arr[i]\n    if sum >= K * M:\n        count += 1\n    for i in range(K, N):\n        sum += (arr[i] - arr[i - K])\n        if sum >= K * M:\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 6, 3, 2, 1, 3, 9]\n    K = 2\n    M = 4\n    N = len(arr)\n    count = countSubArrays(arr, N, K, M)\n    print(count)\n",
        "output": "3\n",
        "fn_call": "countSubArrays"
    },
    {
        "text": "find the position of box which occupies the given ball | python3 implementation of the approach ; function to print the position of each boxes where a ball has to be placed ; find the cumulative sum of array a [ ] ; find the position of box for each ball ; row number ; column ( position of box in particular row ) ; row + 1 denotes row if indexing of array start from 1 ; ",
        "context": "\nimport bisect\n\n",
        "code": "def printPosition(A, B, sizeOfA, sizeOfB):\n    for i in range(1, sizeOfA):\n        A[i] += A[i - 1]\n    for i in range(sizeOfB):\n        row = bisect .bisect_left(A, B[i])\n        if row >= 1:\n            boxNumber = B[i] - A[row - 1]\n        else:\n            boxNumber = B[i]\n        print(row + 1, \",\", boxNumber)\n",
        "test": "\nA = [2, 2, 2, 2]\nB = [1, 2, 3, 4]\nsizeOfA = len(A)\nsizeOfB = len(B)\nprintPosition(A, B, sizeOfA, sizeOfB)\n",
        "output": "1 , 1\n1 , 2\n2 , 1\n2 , 2\n",
        "fn_call": "printPosition"
    },
    {
        "text": "maximum size of square such that all submatrices of that size have sum less than k | size of matrix ; function to preprocess the matrix for computing the sum of every possible matrix of the given size ; loop to copy the first row of the matrix into the aux matrix ; computing the sum column - wise ; computing row wise sum ; function to find the sum of a submatrix with the given indices ; overall sum from the top to right corner of matrix ; removing the sum from the top corer of the matrix ; remove the overlapping sum ; add the sum of top corner which is subtracted twice ; function to find the maximum square size possible with the such that every submatrix have sum less than the given sum ; loop to choose the size of matrix ; loop to find the sum of the matrix of every possible submatrix ; ",
        "context": "\nN = 4\nM = 5\n\n",
        "code": "def preProcess(mat, aux):\n    for i in range(M):\n        aux[0][i] = mat[0][i]\n    for i in range(1, N):\n        for j in range(M):\n            aux[i][j] = (mat[i][j] + aux[i - 1][j])\n    for i in range(N):\n        for j in range(1, M):\n            aux[i][j] += aux[i][j - 1]\n\n\ndef sumQuery(aux, tli, tlj, rbi, rbj):\n    res = aux[rbi][rbj]\n    if (tli > 0):\n        res = res - aux[tli - 1][rbj]\n    if (tlj > 0):\n        res = res - aux[rbi][tlj - 1]\n    if (tli > 0 and tlj > 0):\n        res = (res + aux[tli - 1][tlj - 1])\n    return res\n\n\ndef maximumSquareSize(mat, K):\n    aux = [[0 for x in range(M)]for y in range(N)]\n    preProcess(mat, aux)\n    for i in range(min(N, M), 0, -1):\n        satisfies = True\n        for x in range(N):\n            for y in range(M):\n                if (x + i - 1 <= N - 1 and y + i - 1 <= M - 1):\n                    if (sumQuery(aux, x, y, x + i - 1, y + i - 1) > K):\n                        satisfies = False\n        if (satisfies):\n            return (i)\n    return 0\n",
        "test": "\nif __name__ == \"__main__\":\n    K = 30\n    mat = [[1, 2, 3, 4, 6], [5, 3, 8, 1, 2], [4, 6, 7, 5, 5], [2, 4, 8, 9, 4]]\n    print(maximumSquareSize(mat, K))\n",
        "output": "2\n",
        "fn_call": "maximumSquareSize"
    },
    {
        "text": "count pairs in an array containing at least one even value | function to count the pairs in the array such as there is at least one even element in each pair ; store count of even and odd elements ; check element is even or odd ; ",
        "context": "",
        "code": "def CountPairs(arr, n):\n    even = 0\n    odd = 0\n    for i in range(n):\n        if (arr[i] % 2 == 0):\n            even += 1\n        else:\n            odd += 1\n    return ((even * (even - 1)) // 2 + (even * odd))\n",
        "test": "\narr = [8, 2, 3, 1, 4, 2]\nn = len(arr)\nprint(CountPairs(arr, n))\n",
        "output": "14\n",
        "fn_call": "CountPairs"
    },
    {
        "text": "equilibrium index of an array | function to find the equilibrium index ; check for indexes one by one until an equilibrium index is found ; get left sum ; get right sum ; if leftsum and rightsum are same , then we are done ; return - 1 if no equilibrium index is found ; ",
        "context": "",
        "code": "def equilibrium(arr):\n    leftsum = 0\n    rightsum = 0\n    n = len(arr)\n    for i in range(n):\n        leftsum = 0\n        rightsum = 0\n        for j in range(i):\n            leftsum += arr[j]\n        for j in range(i + 1, n):\n            rightsum += arr[j]\n        if leftsum == rightsum:\n            return i\n    return -1\n",
        "test": "\narr = [-7, 1, 5, 2, -4, 3, 0]\nprint(equilibrium(arr))\n",
        "output": "3\n",
        "fn_call": "equilibrium"
    },
    {
        "text": "count trailing zeroes present in binary representation of a given number using xor | python3 implementation of the above approach ; function to print count of trailing zeroes present in binary representation of n ; count set bits in ( n ^ ( n - 1 ) ) ; if res < 0 , return 0 ; ",
        "context": "\nfrom math import log2\n\n",
        "code": "def countTrailingZeroes(N):\n    res = int(log2(N ^ (N - 1)))\n    return res if res >= 0 else 0\n",
        "test": "\nif __name__ == '__main__':\n    N = 12\n    print(countTrailingZeroes(N))\n",
        "output": "2\n",
        "fn_call": "countTrailingZeroes"
    },
    {
        "text": "find the k | python3 program to find the k - th smallest factor ; function to find the k 'th divisor ; initialize vectors v1 and v2 ; store all the divisors in the two vectors accordingly ; reverse the vector v2 to sort it in increasing order ; if k is greater than the size of vectors then no divisor can be possible ; else print the ( k - 1 ) th value of vector ; if k is lying in first vector ; if k is lying in second vector ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def findkth(n, k):\n    v1 = list()\n    v2 = list()\n    for i in range(1, mt .ceil(n ** (.5))):\n        if (n % i == 0):\n            v1 .append(i)\n            if (i != mt .ceil(mt .sqrt(n))):\n                v2 .append(n // i)\n    v2[::-1]\n    if (k > (len(v1) + len(v2))):\n        print(\"Doesn't Exist\", end=\"\")\n    else:\n        if (k <= len(v1)):\n            print(v1[k - 1])\n        else:\n            print(v2[k - len(v1) - 1])\n",
        "test": "\nn = 15\nk = 2\nfindkth(n, k)\n",
        "output": "3\n",
        "fn_call": "findkth"
    },
    {
        "text": "maximize count of nodes disconnected from all other nodes in a graph | function which returns the maximum number of isolated nodes ; used nodes ; remaining edges ; count nodes used ; if given edges are non - zero ; ",
        "context": "",
        "code": "def maxDisconnected(N, E):\n    curr = 1\n    rem = E\n    while (rem > 0):\n        rem = rem - min(curr, rem)\n        curr += 1\n    if (curr > 1):\n        return N - curr\n    else:\n        return N\n",
        "test": "\nif __name__ == '__main__':\n    N = 5\n    E = 1\n    print(maxDisconnected(N, E))\n",
        "output": "3\n",
        "fn_call": "maxDisconnected"
    },
    {
        "text": "print all the combinations of n elements by changing sign such that their sum is divisible by m | function to print all the combinations ; iterate for all combinations ; initially 100 in binary if n is 3 as 1 << ( 3 - 1 ) = 100 in binary ; iterate in the array and assign signs to the array elements ; if the j - th bit from left is set take ' + ' sign ; right shift to check if jth bit is set or not ; re - initialize ; iterate in the array elements ; if the jth from left is set ; right shift ; ",
        "context": "",
        "code": "def printCombinations(a, n, m):\n    for i in range(0, (1 << n)):\n        sum = 0\n        num = 1 << (n - 1)\n        for j in range(0, n):\n            if ((i & num) > 0):\n                sum += a[j]\n            else:\n                sum += (-1 * a[j])\n            num = num >> 1\n        if (sum % m == 0):\n            num = 1 << (n - 1)\n            for j in range(0, n):\n                if ((i & num) > 0):\n                    print(\"+\", a[j], end=\" \", sep=\"\")\n                else:\n                    print(\"-\", a[j], end=\" \", sep=\"\")\n                num = num >> 1\n            print(\"\")\n",
        "test": "\na = [3, 5, 6, 8]\nn = len(a)\nm = 5\nprintCombinations(a, n, m)\n",
        "output": "-3 -5 +6 -8 \n-3 +5 +6 -8 \n+3 -5 -6 +8 \n+3 +5 -6 +8 \n",
        "fn_call": "printCombinations"
    },
    {
        "text": "expand the string according to the given conditions | function to expand and print the given string ; subtract '0' to convert char to int ; characters within brackets ; expanding ; reset the variables ; ",
        "context": "",
        "code": "def expandString(strin):\n    temp = \"\"\n    j = 0\n    i = 0\n    while (i < len(strin)):\n        if (strin[i] >= \"0\"):\n            num = ord(strin[i]) - ord(\"0\")\n            if (strin[i + 1] == '('):\n                j = i + 1\n                while (strin[j] != ')'):\n                    if ((strin[j] >= 'a' and strin[j] <= 'z') or (\n                            strin[j] >= 'A' and strin[j] <= 'Z')):\n                        temp += strin[j]\n                    j += 1\n                for k in range(1, num + 1):\n                    print(temp, end=\"\")\n                num = 0\n                temp = \"\"\n                if (j < len(strin)):\n                    i = j\n        i += 1\n",
        "test": "\nstrin = \"3(ab)4(cd)\"\nexpandString(strin)\n",
        "output": "abababcdcdcdcd",
        "fn_call": "expandString"
    },
    {
        "text": "maximum bitwise xor of node values of an acyclic graph made up of n given vertices using m edges | function to find the maximum bitwise xor of any subset of the array of size k ; number of node must k + 1 for k edges ; stores the maximum bitwise xor ; generate all subsets of the array ; __builtin_popcount ( ) returns the number of sets bits in an integer ; initialize current xor as 0 ; if jth bit is set in i then include jth element in the current xor ; update the maximum bitwise xor obtained so far ; return the maximum xor ; ",
        "context": "",
        "code": "def maximumXOR(arr, n, K):\n    K += 1\n    maxXor = -10 ** 9\n    for i in range(1 << n):\n        if (bin(i).count('1') == K):\n            cur_xor = 0\n            for j in range(n):\n                if (i & (1 << j)):\n                    cur_xor = cur_xor ^ arr[j]\n            maxXor = max(maxXor, cur_xor)\n    return maxXor\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    N = len(arr)\n    M = 2\n    print(maximumXOR(arr, N, M))\n",
        "output": "7\n",
        "fn_call": "maximumXOR"
    },
    {
        "text": "maximum number which can divide all array element after one replacement | function to return gcd1 of two numbers ; if one of numbers is 0 then gcd1 is other number ; if both are equal then that value is gcd1 ; one is greater ; function to return minimum sum ; initialize min_sum with large value ; initialize variable gcd1 ; storing value of arr [ i ] in c ; update maxgcd1 if gcd1 is greater than maxgcd1 ; returning the maximum divisor of all elements ; ",
        "context": "",
        "code": "def gcd1OfTwoNos(num1, num2):\n    if (num1 == 0):\n        return num2\n    if (num2 == 0):\n        return num1\n    if (num1 == num2):\n        return num1\n    if (num1 > num2):\n        return gcd1OfTwoNos(num1 - num2, num2)\n    return gcd1OfTwoNos(num1, num2 - num1)\n\n\ndef Min_sum(arr, N):\n    min_sum = 1000000\n    maxgcd1 = 1\n    for i in range(N):\n        gcd1 = 1\n        if (i == 0):\n            gcd1 = arr[1]\n        else:\n            gcd1 = arr[i - 1]\n        for j in range(N):\n            if (j != i):\n                gcd1 = gcd1OfTwoNos(gcd1, arr[j])\n        c = arr[i]\n        if (gcd1 > maxgcd1):\n            maxgcd1 = gcd1\n    return maxgcd1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [16, 5, 10, 25]\n    N = len(arr)\n    print(Min_sum(arr, N))\n",
        "output": "5\n",
        "fn_call": "Min_sum"
    },
    {
        "text": "how to validate mastercard number using regular expression | python3 program to validate master card number using regular expression ; function to validate master card number using regular expression . ; regex to check valid master card number . ; compile the regex ; if the string is empty return false ; return if the string matched the regex ; test case 1 : ; test case 2 : ; test case 3 : ; test case 4 : ; ",
        "context": "\nimport re\n\n",
        "code": "def isValidMasterCardNo(str):\n    regex = \"^5[1-5][0-9]{14}|\" + \"^(222[1-9] 22[3-9]\\d \" + \\\n        \"2[3-6]\\d{2} 27[0-1]\\d \" + \"2720)[0-9]{12}$\"\n    p = re .compile(regex)\n    if (str is None):\n        return False\n    if (re .search(p, str)):\n        return True\n    else:\n        return False\n",
        "test": "\nstr1 = \"5114496353984312\"\nprint(isValidMasterCardNo(str1))\nstr2 = \"2720822463109651\"\nprint(isValidMasterCardNo(str2))\nstr3 = \"5582822410\"\nprint(isValidMasterCardNo(str3))\nstr4 = \"6082822463100051\"\nprint(isValidMasterCardNo(str4))\n",
        "output": "True\nFalse\nFalse\nFalse\n",
        "fn_call": "isValidMasterCardNo"
    },
    {
        "text": "count possible n | dp array for memoization ; utility function to count n digit numbers with digit i not appearing more than max_digit [ i ] consecutively ; if number with n digits is generated ; create a reference variable ; check if the current state is already computed before ; initialize ans as zero ; check if count of previous digit has reached zero or not ; fill current position only with digits that are unequal to previous digit ; else set the value of count for this new digit accordingly from max_digit [ ] ; function to count n digit numbers with digit i not appearing more than max_digit [ i ] consecutive times ; stores the final count ; print the total count ; ",
        "context": "\ndp = [[[-1 for i in range(5005)]for i in range(12)]for i in range(12)]\n\n",
        "code": "def findCountUtil(N, maxDigit, position, previous, count):\n    global dp\n    if (position == N):\n        return 1\n    ans = dp[position][previous][count]\n    if (ans != -1):\n        return ans\n    ans = 0\n    for i in range(10):\n        if (count == 0 and previous != i):\n            ans = (ans + (findCountUtil(N, maxDigit, position + 1,\n                   i, maxDigit[i] - 1)) % 1000000007) % 1000000007\n        elif (count != 0):\n            ans = (ans + (findCountUtil(N, maxDigit, position + 1, i, count - 1 if (previous ==\n                   i and position != 0)else maxDigit[i] - 1)) % 1000000007) % 1000000007\n    dp[position][previous][count] = ans\n    return ans\n\n\ndef findCount(N, maxDigit):\n    ans = findCountUtil(N, maxDigit, 0, 0, 1)\n    print(ans)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    maxDigit = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    findCount(N, maxDigit)\n",
        "output": "90\n",
        "fn_call": "findCount"
    },
    {
        "text": "maximum subset with bitwise or equal to k | function to find the maximum subset with bitwise or equal to k ; if the bitwise or of k and element is equal to k , then include that element in the subset ; store the bitwise or of elements in v ; if ans is not equal to k , subset doesn 't exist ; ",
        "context": "",
        "code": "def subsetBitwiseORk(arr, n, k):\n    v = []\n    for i in range(0, n):\n        if ((arr[i] | k) == k):\n            v .append(arr[i])\n    ans = 0\n    for i in range(0, len(v)):\n        ans |= v[i]\n    if (ans != k):\n        print(\"Subsetdoesnotexist\")\n        return\n    for i in range(0, len(v)):\n        print(\"{} \".format(v[i]), end=\"\")\n",
        "test": "\nk = 3\narr = [1, 4, 2]\nn = len(arr)\nsubsetBitwiseORk(arr, n, k)\n",
        "output": "1 2 ",
        "fn_call": "subsetBitwiseORk"
    },
    {
        "text": "maximize sum of k corner elements in array | function to return maximum sum ; base case ; pick the start index ; pick the end index ; recursive function call ; return the final answer ; function to find the maximized sum ; ",
        "context": "",
        "code": "def maxSum(arr, K, start, end, max_sum):\n    if (K == 0):\n        return max_sum\n    max_sum_start = max_sum + arr[start]\n    max_sum_end = max_sum + arr[end]\n    ans = max(\n        maxSum(\n            arr,\n            K - 1,\n            start + 1,\n            end,\n            max_sum_start),\n        maxSum(\n            arr,\n            K - 1,\n            start,\n            end - 1,\n            max_sum_end))\n    return ans\n\n\ndef maximizeSum(arr, K, n):\n    max_sum = 0\n    start = 0\n    end = n - 1\n    print(maxSum(arr, K, start, end, max_sum))\n",
        "test": "\nif __name__ == '__main__':\n    arr = [8, 4, 4, 8, 12, 3, 2, 9]\n    K = 3\n    n = len(arr)\n    maximizeSum(arr, K, n)\n",
        "output": "21\n",
        "fn_call": "maximizeSum"
    },
    {
        "text": "find the smallest number x such that x ! contains at least y trailing zeros . | function to count the number of factors p in x ! ; function to find the smallest x such that x ! contains y trailing zeros ; ",
        "context": "",
        "code": "def countFactor(P, X):\n    if (X < P):\n        return 0\n    return (X // P + countFactor(P, X // P))\n\n\ndef findSmallestX(Y):\n    low = 0\n    high = 5 * Y\n    N = 0\n    while (low <= high):\n        mid = (high + low) // 2\n        if (countFactor(5, mid) < Y):\n            low = mid + 1\n        else:\n            N = mid\n            high = mid - 1\n    return N\n",
        "test": "\nY = 10\nprint(findSmallestX(Y))\n",
        "output": "45\n",
        "fn_call": "findSmallestX"
    },
    {
        "text": "count of subarrays with average k | function to count subarray having average exactly equal to k ; to store the final answer ; calculate all subarrays ; calculate required average ; check if average is equal to k ; required average found ; increment res ; ",
        "context": "",
        "code": "def countKAverageSubarrays(arr, n, k):\n    res = 0\n    for L in range(n):\n        sum = 0\n        for R in range(L, n, 1):\n            sum += arr[R]\n            len1 = (R - L + 1)\n            if (sum % len1 == 0):\n                avg = sum // len1\n                if (avg == k):\n                    res += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    K = 6\n    arr = [12, 5, 3, 10, 4, 8, 10, 12, -6, -1]\n    N = len(arr)\n    print(countKAverageSubarrays(arr, N, K))\n",
        "output": "4\n",
        "fn_call": "countKAverageSubarrays"
    },
    {
        "text": "split a string in equal parts such that all parts are palindromes | function to return the frequency array for the given string ; function to return the required count ; add frequencies of the even appearing characters ; count of the characters that appeared odd number of times ; if there are no characters with odd frequency ; if there are no characters with even frequency ; only a single character with odd frequency ; more than 1 character with odd frequency string isn 't a palindrome ; all odd appearing characters can also contribute to the even length palindrome if one character is removed from the frequency leaving it as even ; if k palindromes are possible where k is the number of characters with odd frequency ; current character can no longer be an element in a string other than the mid character ; if current character has odd frequency > 1 take two characters which can be used in any of the parts ; update the frequency ; if not possible , then every character of the string will act as a separate palindrome ; ",
        "context": "",
        "code": "def getFrequencies(string):\n    freq = [0] * 26\n    for i in range(len(string)):\n        freq[ord(string[i]) - ord('a')] += 1\n    return freq\n\n\ndef countMinParts(string):\n    n = len(string)\n    freq = getFrequencies(string)\n    oddFreq = []\n    evenFreq = []\n    sumEven = 0\n    for i in range(26):\n        if freq[i] == 0:\n            continue\n        if freq[i] % 2 == 0:\n            evenFreq .append(freq[i])\n        else:\n            oddFreq .append(freq[i])\n    for i in range(len(evenFreq)):\n        sumEven += evenFreq[i]\n    if len(oddFreq) == 0:\n        return 1\n    if sumEven == 0:\n        if len(oddFreq) == 1:\n            return 1\n        return 0\n    i = 0\n    while (i < len(oddFreq)):\n        if ((sumEven / 2) % len(oddFreq) == 0):\n            return len(oddFreq)\n        if (oddFreq[i] == 1):\n            i += 1\n            continue\n        sumEven += 2\n        oddFreq[i] = oddFreq[i] - 2\n    return n\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"noonpeep\"\n    print(countMinParts(s))\n",
        "output": "1\n",
        "fn_call": "countMinParts"
    },
    {
        "text": "find the sum of the first nth centered tridecagonal numbers | function to calculate the n - th centered tridecagonal number ; formula to calculate nth centered tridecagonal number & return it ; function to find the sum of the first n centered tridecagonal numbers ; variable to store the sum ; loop to iterate and find the sum of first n centered tridecagonal numbers ; ",
        "context": "",
        "code": "def Centered_tridecagonal_num(n):\n    return (13 * n * (n - 1) + 2) // 2\n\n\ndef sum_Centered_tridecagonal_num(n):\n    summ = 0\n    for i in range(1, n + 1):\n        summ += Centered_tridecagonal_num(i)\n    return summ\n",
        "test": "\nif __name__ == '__main__':\n    n = 5\n    print(sum_Centered_tridecagonal_num(n))\n",
        "output": "265\n",
        "fn_call": "sum_Centered_tridecagonal_num"
    },
    {
        "text": "sort an alphanumeric string such that the positions of alphabets and numbers remain unchanged | function that returns the string s in sorted form such that the positions of alphabets and numeric digits remain unchanged ; string to character array ; sort the array ; count of alphabets and numbers ; get the index from where the alphabets start ; now replace the string with sorted string ; if the position was occupied by an alphabet then replace it with alphabet ; else replace it with a number ; return the sorted string ; ",
        "context": "",
        "code": "def sort(s):\n    c, s = list(s), list(s)\n    c .sort()\n    al_c = 0\n    nu_c = 0\n    while ord(c[al_c]) < 97:\n        al_c += 1\n    for i in range(len(s)):\n        if s[i] < 'a':\n            s[i] = c[nu_c]\n            nu_c += 1\n        else:\n            s[i] = c[al_c]\n            al_c += 1\n    return ''.join(s)\n",
        "test": "\nif __name__ == \"__main__\":\n    s = \"d4c3b2a1\"\n    print(sort(s))\n",
        "output": "a1b2c3d4\n",
        "fn_call": "sort"
    },
    {
        "text": "mobile numeric keypad problem | return count of all possible numbers of length n in a given numeric keyboard ; odd [ i ] , even [ i ] arrays represent count of numbers starting with digit i for any length j ; for j = 1 ; bottom up calculation from j = 2 to n ; here we are explicitly writing lines for each number 0 to 9. but it can always be written as dfs on 4 x3 grid using row , column array valid moves ; get count of all possible numbers of length \" n \" starting with digit 0 , 1 , 2 , ... , 9 ; ",
        "context": "",
        "code": "def getCount(keypad, n):\n    if (not keypad or n <= 0):\n        return 0\n    if (n == 1):\n        return 10\n    odd = [0] * 10\n    even = [0] * 10\n    i = 0\n    j = 0\n    useOdd = 0\n    totalCount = 0\n    for i in range(10):\n        odd[i] = 1\n    for j in range(2, n + 1):\n        useOdd = 1 - useOdd\n        if (useOdd == 1):\n            even[0] = odd[0] + odd[8]\n            even[1] = odd[1] + odd[2] + odd[4]\n            even[2] = odd[2] + odd[1] + odd[3] + odd[5]\n            even[3] = odd[3] + odd[2] + odd[6]\n            even[4] = odd[4] + odd[1] + odd[5] + odd[7]\n            even[5] = odd[5] + odd[2] + odd[4] + odd[8] + odd[6]\n            even[6] = odd[6] + odd[3] + odd[5] + odd[9]\n            even[7] = odd[7] + odd[4] + odd[8]\n            even[8] = odd[8] + odd[0] + odd[5] + odd[7] + odd[9]\n            even[9] = odd[9] + odd[6] + odd[8]\n        else:\n            odd[0] = even[0] + even[8]\n            odd[1] = even[1] + even[2] + even[4]\n            odd[2] = even[2] + even[1] + even[3] + even[5]\n            odd[3] = even[3] + even[2] + even[6]\n            odd[4] = even[4] + even[1] + even[5] + even[7]\n            odd[5] = even[5] + even[2] + even[4] + even[8] + even[6]\n            odd[6] = even[6] + even[3] + even[5] + even[9]\n            odd[7] = even[7] + even[4] + even[8]\n            odd[8] = even[8] + even[0] + even[5] + even[7] + even[9]\n            odd[9] = even[9] + even[6] + even[8]\n    totalCount = 0\n    if (useOdd == 1):\n        for i in range(10):\n            totalCount += even[i]\n    else:\n        for i in range(10):\n            totalCount += odd[i]\n    return totalCount\n",
        "test": "\nif __name__ == \"__main__\":\n    keypad = [['1', '2', '3'], ['4', '5', '6'],\n              ['7', '8', '9'], ['*', '0', '#']]\n    print(\"Count for numbers of length \", 1, \": \", getCount(keypad, 1))\n    print(\"Count for numbers of length \", 2, \": \", getCount(keypad, 2))\n    print(\"Count for numbers of length \", 3, \": \", getCount(keypad, 3))\n    print(\"Count for numbers of length \", 4, \": \", getCount(keypad, 4))\n    print(\"Count for numbers of length \", 5, \": \", getCount(keypad, 5))\n",
        "output": "Count for numbers of length  1 :  10\nCount for numbers of length  2 :  36\nCount for numbers of length  3 :  138\nCount for numbers of length  4 :  532\nCount for numbers of length  5 :  2062\n",
        "fn_call": "getCount"
    },
    {
        "text": "maximize difference between odd and even indexed array elements by swapping unequal adjacent bits in their binary representations | python program for the above approach ; function to count total number of bits present in a number ; function to count total set bits in a number ; stores the count of set bits ; right shift by 1 ; return the final count ; function to find maximum number by shifting two unequal bits ; count set bits in number n ; iterate the string bits ; function to find minimum number by shifting two unequal bits ; iterate the set bit ; function to find the maximum difference ; stores the maximum difference ; stores the sum of elements placed at odd positions ; stores the sum of elements placed at even positions ; traverse the array ; update caseone ; stores the maximum difference ; assign value o ; traverse the array ; update casetwo ; return maximum of caseone and casetwo ; ",
        "context": "\nimport math\n\n",
        "code": "def countBit(n):\n    return int(math .log(n, 2)) + 1\n\n\ndef countSetBit(n):\n    ans = 0\n    while n:\n        ans += n & 1\n        n >>= 1\n    return ans\n\n\ndef maximize(n):\n    bits = countBit(n)\n    setBits = countSetBit(n)\n    ans = 0\n    for i in range(bits):\n        if i < setBits:\n            ans |= 1\n        if i != setBits - 1:\n            ans <<= 1\n    return ans\n\n\ndef minimize(n):\n    setBits = countSetBit(n)\n    ans = 0\n    for i in range(setBits):\n        ans |= 1\n        if i != setBits - 1:\n            ans <<= 1\n    return ans\n\n\ndef maxDiff(arr):\n    caseOne = 0\n    SumOfOdd = 0\n    SumOfeven = 0\n    for i in range(len(arr)):\n        if i % 2:\n            SumOfOdd += minimize(arr[i])\n        else:\n            SumOfeven += maximize(arr[i])\n    caseOne = abs(SumOfOdd - SumOfeven)\n    caseTwo = 0\n    SumOfOdd = 0\n    SumOfeven = 0\n    for i in range(len(arr)):\n        if i % 2:\n            SumOfOdd += maximize(arr[i])\n        else:\n            SumOfeven += minimize(arr[i])\n    caseTwo = abs(SumOfOdd - SumOfeven)\n    return max(caseOne, caseTwo)\n",
        "test": "\narr = [54, 32, 11, 23]\nprint(maxDiff(arr))\n",
        "output": "58\n",
        "fn_call": "maxDiff"
    },
    {
        "text": "print matrix elements from top | function to traverse the matrix diagonally upwards ; stores the maximum size of vector from all row of matrix nums [ ] [ ] ; store elements in desired order ; store every element on the basis of sum of index ( i + j ) ; print the stored result ; reverse all sublist ; ",
        "context": "",
        "code": "def printDiagonalTraversal(nums):\n    max_size = len(nums)\n    for i in range(len(nums)):\n        if (max_size < len(nums[i])):\n            max_size = len(nums[i])\n    v = [[]for i in range(2 * max_size - 1)]\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            v[i + j].append(nums[i][j])\n    for i in range(len(v)):\n        v[i] = v[i][::-1]\n        for j in range(len(v[i])):\n            print(v[i][j], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    printDiagonalTraversal(arr)\n",
        "output": "1 4 2 7 5 3 8 6 9 ",
        "fn_call": "printDiagonalTraversal"
    },
    {
        "text": "remove brackets from an algebraic string containing + and | function to simplify the string ; resultant string of max length equal to length of input string ; create empty stack ; if top is 1 , flip the operator ; if top is 0 , append the same operator ; x is opposite to the top of stack ; append value equal to top of the stack ; if closing parentheses pop the stack once ; copy the character to the result ; ",
        "context": "",
        "code": "def simplify(Str):\n    Len = len(Str)\n    res = [None] * Len\n    index = 0\n    i = 0\n    s = []\n    s .append(0)\n    while (i < Len):\n        if (Str[i] == '+'):\n            if (s[-1] == 1):\n                res[index] = '-'\n                index += 1\n            if (s[-1] == 0):\n                res[index] = '+'\n                index += 1\n        elif (Str[i] == '-'):\n            if (s[-1] == 1):\n                res[index] = '+'\n                index += 1\n            elif (s[-1] == 0):\n                res[index] = '-'\n                index += 1\n        elif (Str[i] == '(' and i > 0):\n            if (Str[i - 1] == '-'):\n                x = 0 if (s[-1] == 1)else 1\n                s .append(x)\n            elif (Str[i - 1] == '+'):\n                s .append(s[-1])\n        elif (Str[i] == ')'):\n            s .pop()\n        else:\n            res[index] = Str[i]\n            index += 1\n        i += 1\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    s1 = \"a-(b+c)\"\n    s2 = \"a-(b-c-(d+e))-f\"\n    r1 = simplify(s1)\n    for i in r1:\n        if i is not None:\n            print(i, end=\" \")\n        else:\n            break\n    print()\n    r2 = simplify(s2)\n    for i in r2:\n        if i is not None:\n            print(i, end=\" \")\n        else:\n            break\n",
        "output": "a - b - c \na - b + c + d + e - f ",
        "fn_call": "simplify"
    },
    {
        "text": "lcs formed by consecutive segments of at least length k | returns the length of the longest common subsequence with a minimum of length of k consecutive segments ; length of strings ; declare the lcs and cnt array ; iterate from i = 1 to n and j = 1 to j = m ; stores the maximum of lcs [ i - 1 ] [ j ] and lcs [ i ] [ j - 1 ] ; when both the characters are equal of s1 and s2 ; when length of common segment is more than k , then update lcs answer by adding that segment to the answer ; formulate for all length of segments to get the longest subsequence with consecutive common segment of length of min k length ; update lcs value by adding segment length ; ",
        "context": "",
        "code": "def longestSubsequenceCommonSegment(k, s1, s2):\n    n = len(s1)\n    m = len(s2)\n    lcs = [[0 for x in range(m + 1)]for y in range(n + 1)]\n    cnt = [[0 for x in range(m + 1)]for y in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1])\n            if (s1[i - 1] == s2[j - 1]):\n                cnt[i][j] = cnt[i - 1][j - 1] + 1\n            if (cnt[i][j] >= k):\n                for a in range(k, cnt[i][j] + 1):\n                    lcs[i][j] = max(lcs[i][j], lcs[i - a][j - a] + a)\n    return lcs[n][m]\n",
        "test": "\nk = 4\ns1 = \"aggasdfa\"\ns2 = \"aggajasdfa\"\nprint(longestSubsequenceCommonSegment(k, s1, s2))\n",
        "output": "8\n",
        "fn_call": "longestSubsequenceCommonSegment"
    },
    {
        "text": "sum of lengths of all 12 edges of any rectangular parallelepiped | python3 program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; ",
        "context": "\nimport math\n\n",
        "code": "def findEdges(s1, s2, s3):\n    a = math .sqrt(s1 * s2 / s3)\n    b = math .sqrt(s3 * s1 / s2)\n    c = math .sqrt(s3 * s2 / s1)\n    sum = a + b + c\n    return 4 * sum\n",
        "test": "\nif __name__ == '__main__':\n    s1 = 65\n    s2 = 156\n    s3 = 60\n    print(int(findEdges(s1, s2, s3)))\n",
        "output": "120\n",
        "fn_call": "findEdges"
    },
    {
        "text": "check if a given integer is the product of k consecutive integers | function to check if n can be expressed as the product of k consecutive integers ; stores the k - th root of n ; stores the product of k consecutive integers ; traverse over the range [ 1 , k ] ; update the product ; if product is n , then return \" yes \" ; otherwise , traverse over the range [ 2 , kthroot ] ; update the value of product ; if product is equal to n ; otherwise , return \" no \" ; ",
        "context": "",
        "code": "def checkPro(n, k):\n    KthRoot = int(n ** (1 / k))\n    product = 1\n    for i in range(1, k + 1):\n        product = product * i\n    print(product)\n    if (product == N):\n        return (\"Yes\")\n    for i in range(2, KthRoot + 1):\n        product = product * (i + k - 1)\n        product = product / (i - 1)\n        print(product)\n        if (product == N):\n            return (\"Yes\")\n    return (\"No\")\n",
        "test": "\nN = 210\nK = 3\nprint(checkPro(N, K))\n",
        "output": "6\n24.0\n60.0\n120.0\n210.0\nYes\n",
        "fn_call": "checkPro"
    },
    {
        "text": "reverse the words of a string using stack | function to reverse the words of the given sentence ; create an empty character array stack ; push words into the stack ; get the words in reverse order ; ",
        "context": "",
        "code": "def reverse(k):\n    s = []\n    token = k .split()\n    for word in token:\n        s .append(word)\n    while (len(s)):\n        print(s .pop(), end=\" \")\n",
        "test": "\nif __name__ == \"__main__\":\n    k = \"geeks for geeks\"\n    reverse(k)\n",
        "output": "geeks for geeks ",
        "fn_call": "reverse"
    },
    {
        "text": "program to find the next prime number | python3 implementation of the approach ; function that returns true if n is prime else returns false ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to return the smallest prime number greater than n ; base case ; loop continuously until isprime returns true for a number greater than n ; ",
        "context": "\nimport math\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    for i in range(5, int(math .sqrt(n) + 1), 6):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n    return True\n\n\ndef nextPrime(N):\n    if (N <= 1):\n        return 2\n    prime = N\n    found = False\n    while (not found):\n        prime = prime + 1\n        if (isPrime(prime)):\n            found = True\n    return prime\n",
        "test": "\nN = 3\nprint(nextPrime(N))\n",
        "output": "5\n",
        "fn_call": "nextPrime"
    },
    {
        "text": "check if elements of an array can be arranged satisfying the given condition | python implementation of the approach ; function to return true if the elements can be arranged in the desired order ; if 2 * x is not found to pair ; remove an occurrence of x and an occurrence of 2 * x ; ",
        "context": "\nimport collections\n\n",
        "code": "def canReorder(A):\n    count = collections .Counter(A)\n    for x in sorted(A, key=abs):\n        if count[x] == 0:\n            continue\n        if count[2 * x] == 0:\n            return False\n        count[x] -= 1\n        count[2 * x] -= 1\n    return True\n",
        "test": "\nA = [4, -2, 2, -4]\nprint(canReorder(A))\n",
        "output": "True\n",
        "fn_call": "canReorder"
    },
    {
        "text": "kth smallest element in the array using constant space when array can 't be modified | function to return the kth smallest element from the array ; minimum and maximum element from the array ; modified binary search ; to store the count of elements from the array which are less than mid and the elements which are equal to mid ; if mid is the kth smallest ; if the required element is less than mid ; if the required element is greater than mid ; ",
        "context": "",
        "code": "def kthSmallest(arr, k, n):\n    low = min(arr)\n    high = max(arr)\n    while (low <= high):\n        mid = low + (high - low) // 2\n        countless = 0\n        countequal = 0\n        for i in range(n):\n            if (arr[i] < mid):\n                countless += 1\n            elif (arr[i] == mid):\n                countequal += 1\n        if (countless = k):\n            return mid\n        elif (countless >= k):\n            high = mid - 1\n        elif (countless < k and countless + countequal < k):\n            low = mid + 1\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [7, 10, 4, 3, 20, 15]\n    n = len(arr)\n    k = 3\n    print(kthSmallest(arr, k, n))\n",
        "output": "7\n",
        "fn_call": "kthSmallest"
    },
    {
        "text": "maximum number of buckets that can be filled | function to find the maximum number of buckets that can be filled with the amount of water available ; find the total available water ; sort the array in ascending order ; check if bucket can be filled with available water ; print count of buckets ; ",
        "context": "",
        "code": "def getBuckets(arr, N):\n    availableWater = N * (N - 1) // 2\n    arr .sort()\n    i, Sum = 0, 0\n    while (Sum <= availableWater):\n        Sum += arr[i]\n        i += 1\n    print(i - 1, end=\"\")\n",
        "test": "\narr = [1, 5, 3, 4, 7, 9]\nN = len(arr)\ngetBuckets(arr, N)\n",
        "output": "4",
        "fn_call": "getBuckets"
    },
    {
        "text": "sum of gcd of all possible sequences | pyhton3 implementation of the above approach ; a recursive function that generates all the sequence and find gcd ; if we reach the sequence of length n g is the gcd of the sequence ; initialise answer to 0 ; placing all possible values at this position and recursively find the gcd of the sequence ; take gcd of gcd calculated uptill now i . e . g with current element ; take modulo to avoid overflow ; return the final answer ; function that finds the sum of gcd of all the subsequence of n length ; recursive function that generates the sequence and return the gcd ; ",
        "context": "\nMOD = 1e9 + 7\n\n",
        "code": "def gcd(a, b):\n    if (b == 0):\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef calculate(pos, g, n, k):\n    if (pos == n):\n        return g\n    answer = 0\n    for i in range(1, k + 1):\n        answer = (answer % MOD + calculate(pos + 1, gcd(g, i), n, k) % MOD)\n        answer %= MOD\n    return answer\n\n\ndef sumofGCD(n, k):\n    return calculate(0, 0, n, k)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 3\n    K = 2\n    print(sumofGCD(N, K))\n",
        "output": "9.0\n",
        "fn_call": "sumofGCD"
    },
    {
        "text": "find two numbers whose sum and gcd are given | python 3 program to find two numbers whose sum and gcd is given ; function to find two numbers whose sum and gcd is given ; sum != gcd checks that both the numbers are positive or not ; ",
        "context": "\nfrom math import gcd as __gcd\n\n",
        "code": "def findTwoNumbers(sum, gcd):\n    if (__gcd(gcd, sum - gcd) == gcd and sum != gcd):\n        print(\"a =\", min(gcd, sum - gcd), \", b =\", sum - min(gcd, sum - gcd))\n    else:\n        print(-1)\n",
        "test": "\nif __name__ == '__main__':\n    sum = 8\n    gcd = 2\n    findTwoNumbers(sum, gcd)\n",
        "output": "a = 2 , b = 6\n",
        "fn_call": "findTwoNumbers"
    },
    {
        "text": "paper cut into minimum number of squares | set 2 | python3 program to find minimum number of squares to cut a paper using dynamic programming ; returns min number of squares needed ; initializing max values to vertical_min and horizontal_min ; n = 11 & m = 13 is a special case ; if the given rectangle is already a square ; if the answer for the given rectangle is previously calculated return that answer ; the rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; minimum of the vertical cut or horizontal cut to form a square is the answer ; ",
        "context": "\nMAX = 300\ndp = [[0 for i in range(MAX)]for i in range(MAX)]\n\n",
        "code": "def minimumSquare(m, n):\n    vertical_min = 10000000000\n    horizontal_min = 10000000000\n    if n == 13 and m == 11:\n        return 6\n    if m == 13 and n == 11:\n        return 6\n    if m == n:\n        return 1\n    if dp[m][n] != 0:\n        return dp[m][n]\n    for i in range(1, m // 2 + 1):\n        horizontal_min = min(\n            minimumSquare(\n                i,\n                n) +\n            minimumSquare(\n                m -\n                i,\n                n),\n            horizontal_min)\n    for j in range(1, n // 2 + 1):\n        vertical_min = min(\n            minimumSquare(\n                m,\n                j) +\n            minimumSquare(\n                m,\n                n -\n                j),\n            vertical_min)\n    dp[m][n] = min(vertical_min, horizontal_min)\n    return dp[m][n]\n",
        "test": "\nif __name__ == '__main__':\n    m = 30\n    n = 35\n    print(minimumSquare(m, n))\n",
        "output": "5\n",
        "fn_call": "minimumSquare"
    },
    {
        "text": "print all distinct characters of a string in order ( 3 methods ) | python3 program to print distinct characters of a string . ; print duplicates present in the passed string ; create an array of size 256 and count of every character in it ; count array with frequency of characters ; print characters having count more than 0 ; ",
        "context": "\nNO_OF_CHARS = 256\n\n",
        "code": "def printDistinct(str):\n    count = [0] * NO_OF_CHARS\n    for i in range(len(str)):\n        if (str[i] != ' '):\n            count[ord(str[i])] += 1\n    n = i\n    for i in range(n):\n        if (count[ord(str[i])] == 1):\n            print(str[i], end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"GeeksforGeeks\"\n    printDistinct(str)\n",
        "output": "for",
        "fn_call": "printDistinct"
    },
    {
        "text": "check whether an array can be made strictly increasing by modifying atmost one element | function that returns true if arr [ ] can be made strictly increasing after modifying at most one element ; to store the number of modifications required to make the array strictly increasing ; check whether the first element needs to be modify or not ; loop from 2 nd element to the 2 nd last element ; check whether arr [ i ] needs to be modified ; modifying arr [ i ] ; check if arr [ i ] is equal to any of arr [ i - 1 ] or arr [ i + 1 ] ; check whether the last element needs to be modify or not ; if more than 1 modification is required ; ",
        "context": "",
        "code": "def check(arr, n):\n    modify = 0\n    if (arr[0] > arr[1]):\n        arr[0] = arr[1] // 2\n        modify += 1\n    for i in range(1, n - 1):\n        if ((arr[i - 1] < arr[i] and arr[i + 1] < arr[i])\n                or (arr[i - 1] > arr[i] and arr[i + 1] > arr[i])):\n            arr[i] = (arr[i - 1] + arr[i + 1]) // 2\n            if (arr[i] == arr[i - 1] or arr[i] == arr[i + 1]):\n                return False\n            modify += 1\n    if (arr[n - 1] < arr[n - 2]):\n        modify += 1\n    if (modify > 1):\n        return False\n    return True\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [2, 4, 8, 6, 9, 12]\n    n = len(arr)\n    if (check(arr, n)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "check"
    },
    {
        "text": "find an integer that is common in the maximum number of given arithmetic progressions | python implementation of the approach ; function to return element common in maximum number of aps ; initialize the count variable ; increment count for every element of an ap ; find the index with maximum count ; return the maximum common element ; ",
        "context": "\nMAXN = 1000000\n\n",
        "code": "def maxCommonElement(A, D, N):\n    cnt = [0] * MAXN\n    for i in range(N):\n        for j in range(A[i], MAXN, D[i]):\n            cnt[j] += 1\n    ans = 0\n    com = 0\n    for i in range(MAXN):\n        if cnt[i] > ans:\n            ans = cnt[i]\n            com = i\n    return com\n",
        "test": "\nA = [13, 1, 2, 5]\nD = [5, 10, 1, 12]\nN = len(A)\nprint(maxCommonElement(A, D, N))\n",
        "output": "41\n",
        "fn_call": "maxCommonElement"
    },
    {
        "text": "minimum number of edges required to be removed from an undirected graph to make it acyclic | stores the adjacency list ; stores if a vertex is visited or not ; function to perform dfs traversal to count the number and size of all connected components ; mark the current node as visited ; traverse the adjacency list of the current node ; for every unvisited node ; recursive dfs call ; function to add undirected edge in the graph ; function to calculate minimum number of edges to be removed ; create adjacency list ; iterate over all the nodes ; print the final count ; ",
        "context": "",
        "code": "def dfs(node):\n\n    global cc\n    vis[node] = True\n    for x in vec[node]:\n        if (vis[x] == 0):\n            cc += 1\n            dfs(x)\n\n\ndef addEdge(u, v):\n\n    vec[u].append(v)\n    vec[v].append(u)\n\n\ndef minEdgeRemoved(N, M, Edges):\n\n    global cc\n    for i in range(M):\n        addEdge(Edges[i][0], Edges[i][1])\n    k = 0\n    for i in range(1, N + 1):\n        if (not vis[i]):\n            cc = 1\n            dfs(i)\n            k += 1\n    print(M - N + k)\n",
        "test": "\nif __name__ == '__main__':\n    vec = [[] for i in range(100001)]\n    vis = [False] * 100001\n    cc = 1\n    N = 3\n    M = 2\n\n    Edges = [[1, 2], [2, 3]]\n\n    minEdgeRemoved(N, M, Edges)\n",
        "output": "0\n",
        "fn_call": "minEdgeRemoved"
    },
    {
        "text": "count pairs having distinct sum from a given range | function to count pairs made up of elements from the range [ l , r ] having distinct sum ; stores the least sum which can be formed by the pairs ; stores the highest sum which can be formed by the pairs ; stores the count of pairs having distinct sum ; print the count of pairs ; ",
        "context": "",
        "code": "def countPairs(L, R):\n    firstNum = 2 * L\n    lastNum = 2 * R\n    Cntpairs = lastNum - firstNum + 1\n    print(Cntpairs)\n",
        "test": "\nif __name__ == '__main__':\n    L, R = 2, 3\n    countPairs(L, R)\n",
        "output": "3\n",
        "fn_call": "countPairs"
    },
    {
        "text": "minimum operations to make product of adjacent element pair of prefix sum negative | function to find minimum operations needed to make the product of any two adjacent elements in prefix sum array negative ; stores the minimum operations ; stores the prefix sum and number of operations ; traverse the array ; update the value of sum ; check if i + r is odd ; check if prefix sum is not positive ; update the value of ans and sum ; check if prefix sum is not negative ; update the value of ans and sum ; update the value of res ; print the value of res ; ",
        "context": "",
        "code": "def minOperations(a):\n    res = 100000000000\n    N = len(a)\n    for r in range(0, 2):\n        sum = 0\n        ans = 0\n        for i in range(0, N):\n            sum += a[i]\n            if ((i + r) % 2):\n                if (sum <= 0):\n                    ans += -sum + 1\n                    sum = 1\n            else:\n                if (sum >= 0):\n                    ans += sum + 1\n                    sum = -1\n        res = min(res, ans)\n    print(res)\n",
        "test": "\na = [1, -3, 1, 0]\nminOperations(a)\n",
        "output": "4\n",
        "fn_call": "minOperations"
    },
    {
        "text": "count maximum concatenation of pairs from given array that are divisible by 3 | function to count pairs whose concatenation is divisible by 3 and each element can be present in at most one pair ; stores count of array elements whose remainder is 0 by taking modulo by 3 ; stores count of array elements whose remainder is 1 by taking modulo by 3 ; stores count of array elements whose remainder is 2 by taking modulo by 3 ; traverse the array ; stores sum of digits of arr [ i ] ; update digitsum ; if remainder of digitsum by by taking modulo 3 is 0 ; update rem0 ; if remainder of digitsum by by taking modulo 3 is 1 ; update rem1 ; update rem2 ; ",
        "context": "",
        "code": "def countDiv(arr):\n    rem0 = 0\n    rem1 = 0\n    rem2 = 0\n    for i in arr:\n        digitSum = 0\n        for digit in str(i):\n            digitSum += int(digit)\n        if digitSum % 3 == 0:\n            rem0 += 1\n        elif digitSum % 3 == 1:\n            rem1 += 1\n        else:\n            rem2 += 1\n    return (rem0 // 2 + min(rem1, rem2))\n",
        "test": "\narr = [5, 3, 2, 8, 7]\nprint(countDiv(arr))\n",
        "output": "1\n",
        "fn_call": "countDiv"
    },
    {
        "text": "number of days after which tank will become empty | utility method to get sum of first n numbers ; method returns minimum number of days after which tank will become empty ; if water filling is more than capacity then after c days only tank will become empty ; initialize binary search variable ; loop until low is less than high ; if cumulate sum is greater than ( c - l ) then search on left side ; if ( c - l ) is more then search on right side ; final answer will be obtained by adding l to binary search result ; ",
        "context": "",
        "code": "def getCumulateSum(n):\n    return int((n * (n + 1)) / 2)\n\n\ndef minDaysToEmpty(C, l):\n    if (C <= l):\n        return C\n    lo, hi = 0, 1e4\n    while (lo < hi):\n        mid = int((lo + hi) / 2)\n        if (getCumulateSum(mid) >= (C - l)):\n            hi = mid\n        else:\n            lo = mid + 1\n    return (l + lo)\n",
        "test": "\nC, l = 5, 2\nprint(minDaysToEmpty(C, l))\n",
        "output": "4\n",
        "fn_call": "minDaysToEmpty"
    },
    {
        "text": "maximize subsequences having array elements not exceeding length of the subsequence | python3 program for the above approach ; function to calculate the number of subsequences that can be formed ; stores the number of subsequences ; iterate over the map ; count the number of subsequences that can be formed from x . first ; number of occurrences of x . first which are left ; return the number of subsequences ; function to create the maximum count of subsequences that can be formed ; stores the frequency of arr [ ] ; update the frequency ; print the number of subsequences ; ",
        "context": "\nfrom collections import defaultdict\n\n",
        "code": "def No_Of_subsequences(mp):\n    count = 0\n    left = 0\n    for x in mp:\n        mp[x] += left\n        count += (mp[x] // x)\n        left = mp[x] % x\n    return count\n\n\ndef maximumsubsequences(arr, n):\n    mp = defaultdict(int)\n    for i in range(n):\n        mp[arr[i]] += 1\n    print(No_Of_subsequences(mp))\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 1, 1, 1]\n    N = len(arr)\n    maximumsubsequences(arr, N)\n",
        "output": "4\n",
        "fn_call": "maximumsubsequences"
    },
    {
        "text": "find two equal subsequences of maximum length with at least one different index | python implementation of the approach ; function to return the required length of the subsequences ; to store the result ; to store the last visited position of lowercase letters ; initialisation of frequency array to - 1 to indicate no character has previously occured ; for every character of the string ; get the index of the current character ; if the current character has appeared before in the string ; update the result ; update the last position of the current character ; ",
        "context": "\nMAX = 26\n\n",
        "code": "def maxLength(str, len):\n    res = 0\n    lastPos = [0] * MAX\n    for i in range(MAX):\n        lastPos[i] = -1\n    for i in range(len):\n        C = ord(str[i]) - ord('a')\n        if (lastPos[C] != -1):\n            res = max(len - (i - lastPos[C] - 1) - 1, res)\n        lastPos[C] = i\n    return res\n",
        "test": "\nif __name__ == '__main__':\n    str = \"geeksforgeeks\"\n    len = len(str)\n    print(maxLength(str, len))\n",
        "output": "12\n",
        "fn_call": "maxLength"
    },
    {
        "text": "find index of given fibonacci number in constant time | a simple python 3 program to find index of given fibonacci number . ; if fibonacci number is less than 2 , its index will be same as number ; iterate until generated fibonacci number is less than given fibonacci number ; res keeps track of number of generated fibonacci number ; ",
        "context": "",
        "code": "def findIndex(n):\n    if (n <= 1):\n        return n\n    a = 0\n    b = 1\n    c = 1\n    res = 1\n    while (c < n):\n        c = a + b\n        res = res + 1\n        a = b\n        b = c\n    return res\n",
        "test": "\nresult = findIndex(21)\nprint(result)\n",
        "output": "8\n",
        "fn_call": "findIndex"
    },
    {
        "text": "find the word from a given sentence having given word as prefix | function to find the position of the string having word as prefix ; initialize an list ; extract words from the sentence ; traverse each word ; traverse the characters of word ; if prefix does not match ; otherwise ; return the word ; return - 1 if not present ; ",
        "context": "",
        "code": "def isPrefixOfWord(sentence, word):\n    a = sentence .split(\" \")\n    v = []\n    for i in a:\n        v .append(i)\n    for i in range(len(v)):\n        for j in range(len(v[i])):\n            if (v[i][j] != word[j]):\n                break\n            elif (j == len(word) - 1):\n                return v[i]\n    return -1\n",
        "test": "\ns = \"Welcome to Geeksforgeeks\"\nword = \"Gee\"\nprint(isPrefixOfWord(s, word))\n",
        "output": "Geeksforgeeks\n",
        "fn_call": "isPrefixOfWord"
    },
    {
        "text": "longest subsequence whose average is less than k | python3 program to perform q queries to find longest subsequence whose average is less than k ; function to print the length for evey query ; sort array of n elements ; array to store average from left ; sort array of average ; number of queries ; print answer to every query using binary search ; ",
        "context": "\nimport bisect\n\n",
        "code": "def longestSubsequence(a, n, q, m):\n    a .sort()\n    Sum = 0\n    b = [None] * n\n    for i in range(0, n):\n        Sum += a[i]\n        av = Sum // (i + 1)\n        b[i] = av + 1\n    b .sort()\n    for i in range(0, m):\n        k = q[i]\n        longest = bisect .bisect_right(b, k)\n        print(\"Answer to Query\", i + 1, \":\", longest)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [1, 3, 2, 5, 4]\n    n = len(a)\n    q = [4, 2, 1, 5]\n    m = len(q)\n    longestSubsequence(a, n, q, m)\n",
        "output": "Answer to Query 1 : 5\nAnswer to Query 2 : 2\nAnswer to Query 3 : 0\nAnswer to Query 4 : 5\n",
        "fn_call": "longestSubsequence"
    },
    {
        "text": "make sum of all subarrays of length k equal by only inserting elements | function that prints another array whose all subarray of length k have an equal sum ; store all distinct elements in the unordered map ; condition if the number of distinct elements is greater than k ; push all distinct elements in a vector ; push 1 while the size of vector not equal to k ; print the vector 2 times ; ",
        "context": "",
        "code": "def MakeArray(a, n, k):\n    mp = dict()\n    for i in a:\n        if i not in mp:\n            mp[a[i]] = 1\n    if (len(mp) > k):\n        print(\"Not possible\")\n        return\n    ans = []\n    for i in mp:\n        ans .append(i)\n    while (len(ans) < k):\n        ans .append(1)\n    for i in range(2):\n        for j in range(k):\n            print(ans[j], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [1, 2, 2, 1]\n    K = 2\n    size = len(arr)\n    MakeArray(arr, size, K)\n",
        "output": "2 1 2 1 ",
        "fn_call": "MakeArray"
    },
    {
        "text": "program to find remainder when large number is divided by r | function to return remainder ; len is variable to store the length of number string . ; loop that find remainder ; return the remainder ; ",
        "context": "",
        "code": "def Remainder(str, R):\n    l = len(str)\n    Rem = 0\n    for i in range(l):\n        Num = Rem * 10 + (ord(str[i]) - ord('0'))\n        Rem = Num % R\n    return Rem\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"13589234356546756\"\n    R = 13\n    print(Remainder(str, R))\n",
        "output": "11\n",
        "fn_call": "Remainder"
    },
    {
        "text": "sum of leaf nodes at minimum level | python3 implementation to find the sum of leaf node at minimum level ; structure of a node in binary tree ; function to find the sum of leaf nodes at minimum level ; if tree is empty ; if there is only root node ; queue used for level order traversal ; push rioot node in the queue ; count no . of nodes present at current level ; traverse current level nodes ; get front element from ' q ' ; if node is leaf node ; accumulate data to ' sum ' ; set flag = 1 to signify that we have encountered the minimum level ; if top 's left or right child exist  push them to queue ; return the sum ; ",
        "context": "\nfrom collections import deque\n\n\nclass Node:\n    def __init__(self, data):\n        self .data = data\n        self .left = None\n        self .right = None\n\n",
        "code": "def sumOfLeafNodesAtLeafLevel(root):\n    if not root:\n        return 0\n    if not root .left and not root .right:\n        return root .data\n    Queue = deque()\n    sum = f = 0\n    Queue .append(root)\n    while not f:\n        nc = len(Queue)\n        while nc:\n            top = Queue .popleft()\n            if not top .left and not top .right:\n                sum += top .data\n                f = 1\n            else:\n                if top .left:\n                    Queue .append(top .left)\n                if top .right:\n                    Queue .append(top .right)\n            nc -= 1\n    return sum\n",
        "test": "\nif __name__ == \"__main__\":\n    root = Node(1)\n    root .left = Node(2)\n    root .right = Node(3)\n    root .left .left = Node(4)\n    root .left .right = Node(5)\n    root .right .left = Node(6)\n    root .right .right = Node(7)\n    root .left .right .left = Node(8)\n    root .right .left .right = Node(9)\n    print(\"Sum = \", sumOfLeafNodesAtLeafLevel(root))\n",
        "output": "Sum =  11\n",
        "fn_call": "sumOfLeafNodesAtLeafLevel"
    },
    {
        "text": "sort elements of an array in increasing order of absolute difference of adjacent elements | function to sort the elements of the array by difference ; sorting the array ; array to store the elements of the array ; iterating over the length of the array to include each middle element of array ; appending the middle element of the array ; ",
        "context": "",
        "code": "def sortDiff(arr, n):\n    arr .sort()\n    out = []\n    while n:\n        out .append(arr .pop(n // 2))\n        n = n - 1\n    print(*out)\n    return out\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [8, 1, 2, 3, 0]\n    n = 5\n    sortDiff(arr, n)\n",
        "output": "2 3 1 8 0\n",
        "fn_call": "sortDiff"
    },
    {
        "text": "possible moves of knight | python3 program to find number of possible moves of knight ; to calculate possible moves ; all possible moves of a knight ; check if each possible move is valid or not ; position of knight after move ; count valid moves ; return number of possible moves ; ",
        "context": "\nn = 4\nm = 4\n\n",
        "code": "def findPossibleMoves(mat, p, q):\n    global n, m\n    X = [2, 1, -1, -2, -2, -1, 1, 2]\n    Y = [1, 2, 2, 1, -1, -2, -2, -1]\n    count = 0\n    for i in range(8):\n        x = p + X[i]\n        y = q + Y[i]\n        if (x >= 0 and y >= 0 and x < n and y < m and mat[x][y] == 0):\n            count += 1\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    mat = [[1, 0, 1, 0], [0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 1, 1]]\n    p, q = 2, 2\n    print(findPossibleMoves(mat, p, q))\n",
        "output": "4\n",
        "fn_call": "findPossibleMoves"
    },
    {
        "text": "count of values of x <= n for which ( n xor x ) = ( n | function to return the count of valid values of x ; convert n into binary string ; to store the count of 1 s ; if current bit is 1 ; calculating answer ; ",
        "context": "",
        "code": "def countX(n):\n    binary = \"{0:b}\".format(n)\n    count = 0\n    for i in range(len(binary)):\n        if (binary[i] == '1'):\n            count += 1\n    answer = int(pow(2, count))\n    return answer\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    answer = countX(n)\n    print(answer)\n",
        "output": "4\n",
        "fn_call": "countX"
    },
    {
        "text": "diagonal of a regular heptagon | function to return the diagonal of a regular heptagon ; side cannot be negative ; length of the diagonal ; ",
        "context": "",
        "code": "def heptdiagonal(a):\n    if (a < 0):\n        return -1\n    d = 1.802 * a\n    return round(d, 3)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = 6\n    print(heptdiagonal(a))\n",
        "output": "10.812\n",
        "fn_call": "heptdiagonal"
    },
    {
        "text": "minimize sum of product of same | function to print the arrays ; function to reverse the subarray ; function to calculate the minimum product of same - indexed elements of two given arrays ; calculate initial product ; traverse all odd length subarrays ; remove the previous product ; add the current product ; check if current product is minimum or not ; traverse all even length subarrays ; remove the previous product ; add to the current product ; check if current product is minimum or not ; update the pointers ; reverse the subarray ; print the subarray ; ",
        "context": "",
        "code": "def Print(a, b):\n    minProd = 0\n    for i in range(len(a)):\n        print(a[i], end=\" \")\n    print()\n    for i in range(len(b)):\n        print(b[i], end=\" \")\n        minProd += a[i] * b[i]\n    print()\n    print(minProd)\n\n\ndef reverse(left, right, arr):\n    while (left < right):\n        temp = arr[left]\n        arr[left] = arr[right]\n        arr[right] = temp\n        left += 1\n        right -= 1\n\n\ndef minimumProdArray(a, b, l):\n    total = 0\n    for i in range(len(a)):\n        total += a[i] * b[i]\n    Min = 2147483647\n    first = 0\n    second = 0\n    for i in range(len(a)):\n        left = i - 1\n        right = i + 1\n        total1 = total\n        while (left >= 0 and right < len(a)):\n            total1 -= a[left] * b[left] + a[right] * b[right]\n            total1 += a[left] * b[right] + a[right] * b[left]\n            if (Min >= total1):\n                Min = total1\n                first = left\n                second = right\n            left -= 1\n            right += 1\n    for i in range(len(a)):\n        left = i\n        right = i + 1\n        total1 = total\n        while (left >= 0 and right < len(a)):\n            total1 -= a[left] * b[left] + a[right] * b[right]\n            total1 += a[left] * b[right] + a[right] * b[left]\n            if (Min >= total1):\n                Min = total1\n                first = left\n                second = right\n            left -= 1\n            right += 1\n    if (Min < total):\n        reverse(first, second, a)\n        Print(a, b)\n    else:\n        Print(a, b)\n",
        "test": "\nn = 4\na = [2, 3, 1, 5]\nb = [8, 2, 4, 3]\nminimumProdArray(a, b, n)\n",
        "output": "1 3 2 5 \n8 2 4 3 \n37\n",
        "fn_call": "minimumProdArray"
    },
    {
        "text": "print matrix elements using dfs traversal | direction vectors ; function to check if curruent position is valid or not ; check if the cell is out of bounds ; check if the cell is visited ; function to print the matrix elements ; stores if a position in the matrix been visited or not ; initialize stack to implement dfs ; push the first position of grid [ ] [ ] in the stack ; mark the cell ( 0 , 0 ) visited ; stores top element of stack ; delete the top ( ) element of stack ; print element at the cell ; traverse in all four adjacent sides of current positions ; check if x and y is valid position and then push the position of current cell in the stack ; push the current cell ; mark current cell visited ; ",
        "context": "\ndRow = [-1, 0, 1, 0]\ndCol = [0, 1, 0, -1]\nvis = []\n\n",
        "code": "def isValid(row, col, COL, ROW):\n    global vis\n    if (row  COL - 1 or row > ROW - 1):\n        return False\n    if (vis[row][col]):\n        return False\n    return True\n\n\ndef DFS_iterative(grid, M, N):\n    global vis\n    vis = []\n    for i in range(M + 5):\n        vis .append([])\n        for j in range(N + 5):\n            vis[i].append(False)\n    st = []\n    st .append([0, 0])\n    vis[0][0] = True\n    while (len(st) > 0):\n        p = st[-1]\n        st .pop()\n        row = p[0]\n        col = p[1]\n        print(grid[row][col], \"\", end=\"\")\n        for i in range(4):\n            x = row + dRow[i]\n            y = col + dCol[i]\n            if (isValid(x, y, M, N)):\n                st .append([x, y])\n                vis[x][y] = True\n",
        "test": "\ngrid = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\nM = len(grid)\nN = len(grid[0])\nDFS_iterative(grid, M, N)\n",
        "output": "1 5 9 13 14 15 16 12 8 7 3 4 11 10 6 2 ",
        "fn_call": "DFS_iterative"
    },
    {
        "text": "find the player who will win by choosing a number in range [ 1 , k ] with sum total n | function to predict the winner ; ",
        "context": "",
        "code": "def predictTheWinner(K, N):\n    if (N % (K + 1) == 0):\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\n",
        "test": "\nif __name__ == '__main__':\n    K = 7\n    N = 50\n    predictTheWinner(K, N)\n",
        "output": "Alice\n",
        "fn_call": "predictTheWinner"
    },
    {
        "text": "find the smallest positive integer value that cannot be represented as sum of any subset of a given array | returns the smallest number that cannot be represented as sum of subset of elements from set represented by sorted array arr [ 0. . n - 1 ] ; initialize result ; traverse the array and increment ' res ' if arr [ i ] is smaller than or equal to ' res ' . ; ",
        "context": "",
        "code": "def findSmallest(arr, n):\n    res = 1\n    for i in range(0, n):\n        if arr[i] <= res:\n            res = res + arr[i]\n        else:\n            break\n    return res\n",
        "test": "\narr1 = [1, 3, 4, 5]\nn1 = len(arr1)\nprint(findSmallest(arr1, n1))\narr2 = [1, 2, 6, 10, 11, 15]\nn2 = len(arr2)\nprint(findSmallest(arr2, n2))\narr3 = [1, 1, 1, 1]\nn3 = len(arr3)\nprint(findSmallest(arr3, n3))\narr4 = [1, 1, 3, 4]\nn4 = len(arr4)\nprint(findSmallest(arr4, n4))\n",
        "output": "2\n4\n5\n10\n",
        "fn_call": "findSmallest"
    },
    {
        "text": "for each lowercase english alphabet find the count of strings having these alphabets | function to find the countstrings for each letter [ a - z ] ; initialize result as zero ; mark all letter as not visited ; loop through each strings ; increment the global counter for current character of string ; instead of re - initialising boolean vector every time we just reset all visited letter to false ; print count for each letter ; ",
        "context": "",
        "code": "def CountStrings(s):\n    size = len(s)\n    count = [0] * 26\n    visited = [False] * 26\n    for i in range(size):\n        for j in range(len(s[i])):\n            if visited[ord(s[i][j]) - ord('a')] == False:\n                count[ord(s[i][j]) - ord('a')] += 1\n            visited[ord(s[i][j]) - ord('a')] = True\n        for j in range(len(s[i])):\n            visited[ord(s[i][j]) - ord('a')] = False\n    for i in range(26):\n        print(count[i], end=' ')\n",
        "test": "\nif __name__ == '__main__':\n    s = [\"i\", \"will\", \"practice\", \"everyday\"]\n    CountStrings(s)\n",
        "output": "2 0 1 1 2 0 0 0 3 0 0 1 0 0 0 1 0 2 0 1 0 1 1 0 1 0 ",
        "fn_call": "CountStrings"
    },
    {
        "text": "count of even set bits between xor of two arrays | function that count the xor of b with all the element in a having even set bit ; count the set bits in a [ i ] ; check for even or odd ; to store the count of element for b such that xor with all the element in a having even set bit ; count set bit for b [ i ] ; check for even or odd ; ",
        "context": "",
        "code": "def countEvenBit(A, B, n, m):\n    i, j, cntOdd = 0, 0, 0\n    cntEven = 0\n    for i in range(n):\n        x = bin(A[i])[2:].count('1')\n        if (x & 1):\n            cntEven += 1\n        else:\n            cntOdd += 1\n    CountB = [0] * m\n    for i in range(m):\n        x = bin(B[i])[2:].count('1')\n        if (x & 1):\n            CountB[i] = cntEven\n        else:\n            CountB[i] = cntOdd\n    for i in range(m):\n        print(CountB[i], end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    A = [4, 2, 15, 9, 8, 8]\n    B = [3, 4, 22]\n    countEvenBit(A, B, 6, 3)\n",
        "output": "2 4 4 ",
        "fn_call": "countEvenBit"
    },
    {
        "text": "minimum k such that every substring of length at least k contains a character c | set | function to find minimum value of k such that there exist atleast one k amazing character ; stores the answer ; update the s ; iterate over the characters in range [ a , z ] ; stores the last index where c appears ; stores the maximum possible length ; update s ; iterate over characters of string s ; if s [ i ] is equal to c ; stores the distance between positions of two same c ; update max_len ; update the value of prev ; update the value of ans ; return the answer ; ",
        "context": "",
        "code": "def MinimumLengthSubstring(S, N):\n    ans = N\n    S = \"0\" + S + \"0\"\n    S = [i for i in S]\n    for c in range(ord('a'), ord('z') + 1):\n        prev = 0\n        max_len = 0\n        S[0] = chr(c)\n        S[N + 1] = chr(c)\n        for i in range(1, N + 2):\n            if (S[i] == chr(c)):\n                len = i - prev\n                max_len = max(max_len, len)\n                prev = i\n        ans = min(ans, max_len)\n    return ans\n",
        "test": "\nif __name__ == '__main__':\n    S = \"abcde\"\n    N = len(S)\n    print(MinimumLengthSubstring(S, N))\n",
        "output": "3\n",
        "fn_call": "MinimumLengthSubstring"
    },
    {
        "text": "length of diagonals of a cyclic quadrilateral using the length of sides . | python3 program to implement the above approach ; function to calculate the length of diagonals of a cyclic quadrilateral ; ",
        "context": "\nimport math\n\n",
        "code": "def Diagonals(a, b, c, d):\n    p = math .sqrt(((a * c) + (b * d)) *\n                   ((a * d) + (b * c)) / ((a * b) + (c * d)))\n    q = math .sqrt(((a * c) + (b * d)) *\n                   ((a * b) + (c * d)) / ((a * d) + (b * c)))\n    return [p, q]\n",
        "test": "\nA = 10\nB = 15\nC = 20\nD = 25\nans = Diagonals(A, B, C, D)\nprint(round(ans[0], 2), round(ans[1], 2))\n",
        "output": "22.06 26.07\n",
        "fn_call": "Diagonals"
    },
    {
        "text": "possible edges of a tree for given diameter , height and vertices | function to construct the tree ; special case when d == 2 , only one edge ; tree is not possible ; satisfy the height condition by add edges up to h ; add d - h edges from 1 to satisfy diameter condition ; remaining edges at vertex 1 or 2 ( d == h ) ; ",
        "context": "",
        "code": "def constructTree(n, d, h):\n    if d == 1:\n        if n == 2 and h == 1:\n            print(\"1 2\")\n            return 0\n        print(\"-1\")\n        return 0\n    if d > 2 * h:\n        print(\"-1\")\n        return 0\n    for i in range(1, h + 1):\n        print(i, \" \", i + 1)\n    if d > h:\n        print(1, \" \", h + 2)\n        for i in range(h + 2, d + 1):\n            print(i, \" \", i + 1)\n    for i in range(d + 1, n):\n        k = 1\n        if d == h:\n            k = 2\n        print(k, \" \", i + 1)\n",
        "test": "\nn = 5\nd = 3\nh = 2\nconstructTree(n, d, h)\n",
        "output": "1   2\n2   3\n1   4\n1   5\n",
        "fn_call": "constructTree"
    },
    {
        "text": "count quadruplets with sum k from given array | ''function to return the number of quadruplets having given sum ; '' initialize answer ; '' all possible first elements ; '' all possible second element ; '' use map to find the  fourth element ; '' all possible third elements ; '' calculate number of valid  4th elements ; '' update the twice_count ; '' unordered pairs ; '' return answer ; ''",
        "context": "",
        "code": "def countSum(a, n, sum):\n    count = 0\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2, 1):\n            req = sum - a[i] - a[j]\n            m = {}\n            for k in range(j + 1, n, 1):\n                m[a[k]] = m .get(a[k], 0) + 1\n            twice_count = 0\n            for k in range(j + 1, n, 1):\n                twice_count += m .get(req - a[k], 0)\n                if (req - a[k] == a[k]):\n                    twice_count -= 1\n            count += twice_count // 2\n    return count\n",
        "test": "\nif __name__ == '__main__':\n    arr = [4, 5, 3, 1, 2, 4]\n    S = 13\n    N = len(arr)\n    print(countSum(arr, N, S))\n",
        "output": "3\n",
        "fn_call": "countSum"
    },
    {
        "text": "matrix exponentiation | a utility function to multiply two matrices a [ ] [ ] and b [ ] [ ] . multiplication result is stored back in b [ ] [ ] ; creating an auxiliary matrix to store elements of the multiplication matrix ; storing the multiplication result in a [ ] [ ] ; updating our matrix ; function to compute f raise to power n - 2. ; multiply it with initial values i . e with f ( 0 ) = 0 , f ( 1 ) = 1 , f ( 2 ) = 1 ; multiply it with initial values i . e with f ( 0 ) = 0 , f ( 1 ) = 1 , f ( 2 ) = 1 ; return n 'th term of a series defined using below recurrence relation. f(n) is defined as f(n) = f(n-1) + f(n-2) + f(n-3), n>=3 base cases : f(0) = 0, f(1) = 1, f(2) = 1 ; ",
        "context": "",
        "code": "def multiply(a, b):\n    mul = [[0 for x in range(3)]for y in range(3)]\n    for i in range(3):\n        for j in range(3):\n            mul[i][j] = 0\n            for k in range(3):\n                mul[i][j] += a[i][k] * b[k][j]\n    for i in range(3):\n        for j in range(3):\n            a[i][j] = mul[i][j]\n    return a\n\n\ndef power(F, n):\n    M = [[1, 1, 1], [1, 0, 0], [0, 1, 0]]\n    if (n == 1):\n        return F[0][0] + F[0][1]\n    power(F, int(n / 2))\n    F = multiply(F, F)\n    if (n % 2 != 0):\n        F = multiply(F, M)\n    return F[0][0] + F[0][1]\n\n\ndef findNthTerm(n):\n    F = [[1, 1, 1], [1, 0, 0], [0, 1, 0]]\n    return power(F, n - 2)\n",
        "test": "\nn = 5\nprint(\"F(5) is\", findNthTerm(n))\n",
        "output": "F(5) is 7\n",
        "fn_call": "findNthTerm"
    },
    {
        "text": "count of total heads and tails after n flips in a coin | function to find count of head and tail ; check if initially all the coins are facing towards head ; check if initially all the coins are facing towards tail ; ",
        "context": "\nimport math\n\n",
        "code": "def count_ht(s, N):\n    if s == \"H\":\n        h = math .floor(N / 2)\n        t = math .ceil(N / 2)\n    elif s == \"T\":\n        h = math .ceil(N / 2)\n        t = math .floor(N / 2)\n    return [h, t]\n",
        "test": "\nif __name__ == \"__main__\":\n    C = \"H\"\n    N = 5\n    l = count_ht(C, N)\n    print(\"Head = \", l[0])\n    print(\"Tail = \", l[1])\n",
        "output": "Head =  2\nTail =  3\n",
        "fn_call": "count_ht"
    },
    {
        "text": "replace a character c1 with c2 and c2 with c1 in a string s | python3 program to replace c1 with c2 and c2 with c1 ; loop to traverse in the string ; check for c1 and replace ; check for c2 and replace ; ",
        "context": "",
        "code": "def replace(s, c1, c2):\n    l = len(s)\n    for i in range(l):\n        if (s[i] == c1):\n            s = s[0:i] + c2 + s[i + 1:]\n        elif (s[i] == c2):\n            s = s[0:i] + c1 + s[i + 1:]\n    return s\n",
        "test": "\nif __name__ == '__main__':\n    s = \"grrksfoegrrks\"\n    c1 = 'e'\n    c2 = 'r'\n    print(replace(s, c1, c2))\n",
        "output": "geeksforgeeks\n",
        "fn_call": "replace"
    },
    {
        "text": "count substrings made up of a single distinct character | function to count the number of substrings made up of a single distinct character ; stores the required count ; stores the count of substrings possible by using current character ; stores the previous character ; traverse the string ; if current character is same as the previous character ; increase count of substrings possible with current character ; reset count of substrings possible with current character ; update count of substrings ; update previous character ; ",
        "context": "",
        "code": "def countSubstrings(s):\n    ans = 0\n    subs = 1\n    pre = ''\n    for i in s:\n        if pre == i:\n            subs += 1\n        else:\n            subs = 1\n        ans += subs\n        pre = i\n    print(ans)\n",
        "test": "\ns = 'geeksforgeeks'\ncountSubstrings(s)\n",
        "output": "15\n",
        "fn_call": "countSubstrings"
    },
    {
        "text": "program to find third side of triangle using law of cosines | python3 program to find third side of triangle using law of cosines ; function to calculate cos value of angle c ; converting degrees to radian ; maps the sum along the series ; holds the actual value of sin ( n ) ; function to find third side ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def cal_cos(n):\n    accuracy = 0.0001\n    x1, denominator, cosx, cosval = 0, 0, 0, 0\n    n = n * (3.142 / 180.0)\n    x1 = 1\n    cosx = x1\n    cosval = mt .cos(n)\n    i = 1\n    while (accuracy <= abs(cosval - cosx)):\n        denominator = 2 * i * (2 * i - 1)\n        x1 = -x1 * n * n / denominator\n        cosx = cosx + x1\n        i = i + 1\n    return cosx\n\n\ndef third_side(a, b, c):\n    angle = cal_cos(c)\n    return mt .sqrt((a * a) + (b * b) - 2 * a * b * angle)\n",
        "test": "\nc = 49\na, b = 5, 8\nprint(third_side(a, b, c))\n",
        "output": "6.043387862121523\n",
        "fn_call": "third_side"
    },
    {
        "text": "count total bits in a number | python3 program to find total bit in given number ; log function in base 2 take only integer part ; ",
        "context": "\nimport math\n\n",
        "code": "def countBits(number):\n    return int((math .log(number) / math .log(2)) + 1)\n",
        "test": "\nnum = 65\nprint(countBits(num))\n",
        "output": "7\n",
        "fn_call": "countBits"
    },
    {
        "text": "minimum integer such that it leaves a remainder 1 on dividing with any element from the range [ 2 , n ] | python3 implementation of the approach ; function to return the smallest number which on dividing with any element from the range [ 2 , n ] leaves a remainder of 1 ; find the lcm of the elements from the range [ 2 , n ] ; return the required number ; ",
        "context": "\nfrom math import gcd\n\n",
        "code": "def getMinNum(N):\n    lcm = 1\n    for i in range(2, N + 1):\n        lcm = ((i * lcm) // (gcd(i, lcm)))\n    return (lcm + 1)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 5\n    print(getMinNum(N))\n",
        "output": "61\n",
        "fn_call": "getMinNum"
    },
    {
        "text": "remove characters from string that appears strictly less than k times | python 3 program to reduce the string by removing the characters which appears less than k times ; function to reduce the string by removing the characters which appears less than k times ; hash table initialised to 0 ; increment the frequency of the character ; create a new empty string ; append the characters which appears more than equal to k times ; ",
        "context": "\nMAX_CHAR = 26\n\n",
        "code": "def removeChars(str, k):\n    hash = [0] * (MAX_CHAR)\n    n = len(str)\n    for i in range(n):\n        hash[ord(str[i]) - ord('a')] += 1\n    res = \"\"\n    for i in range(n):\n        if (hash[ord(str[i]) - ord('a')] >= k):\n            res += str[i]\n    return res\n",
        "test": "\nif __name__ == \"__main__\":\n    str = \"geeksforgeeks\"\n    k = 2\n    print(removeChars(str, k))\n",
        "output": "geeksgeeks\n",
        "fn_call": "removeChars"
    },
    {
        "text": "Distance between Incenter and Circumcenter of a triangle using Inradius and Circumradius | Python3 program for the above approach ; Function returns the required distance ; Length of Inradius ; Length of Circumradius",
        "context": "\nimport math\n\n",
        "code": "def distance(r, R):\n    d = math .sqrt((R ** 2) - (2 * r * R))\n    return d\n",
        "test": "\nr = 2\nR = 5\nprint(round(distance(r, R), 2))\n",
        "output": "2.24\n",
        "fn_call": "distance"
    },
    {
        "text": "kruskal 's algorithm (simple implementation for adjacency matrix) | find set of vertex i ; does union of i and j . it returns false if i and j are already in same set . ; finds mst using kruskal 's algorithm ; ",
        "context": "",
        "code": "def find(i):\n    while parent[i] != i:\n        i = parent[i]\n    return i\n\n\ndef union(i, j):\n    a = find(i)\n    b = find(j)\n    parent[a] = b\n\n\ndef kruskalMST(cost):\n    mincost = 0\n    for i in range(V):\n        parent[i] = i\n    edge_count = 0\n    while edge_count < V - 1:\n        min = INF\n        a = -1\n        b = -1\n        for i in range(V):\n            for j in range(V):\n                if find(i) != find(j) and cost[i][j] < min:\n                    min = cost[i][j]\n                    a = i\n                    b = j\n        union(a, b)\n        print('Edge {}:({}, {}) cost:{}'.format(edge_count, a, b, min))\n        edge_count += 1\n        mincost += min\n    print(\"Minimum cost= {}\".format(mincost))\n",
        "test": "\nV = 5\nparent = [i for i in range(V)]\nINF = float('inf')\ncost = [[INF, 2, INF, 6, INF], [2, INF, 3, 8, 5], [\n    INF, 3, INF, INF, 7], [6, 8, INF, INF, 9], [INF, 5, 7, 9, INF]]\nkruskalMST(cost)\n",
        "output": "Edge 0:(0, 1) cost:2\nEdge 1:(1, 2) cost:3\nEdge 2:(1, 4) cost:5\nEdge 3:(0, 3) cost:6\nMinimum cost= 16\n",
        "fn_call": "kruskalMST"
    },
    {
        "text": "minimum steps required to reduce all the elements of the array to zero | function to return the minimum steps required to reduce all the elements to 0 ; maximum element from the array ; ",
        "context": "",
        "code": "def minSteps(arr, n):\n    maxVal = max(arr)\n    return maxVal\n",
        "test": "\narr = [1, 2, 4]\nn = len(arr)\nprint(minSteps(arr, n))\n",
        "output": "4\n",
        "fn_call": "minSteps"
    },
    {
        "text": "minimum time required to rot all oranges | dynamic programming | python 3 implementation of the approach ; dp table to memoize the values ; visited array to keep track of visited nodes in order to avoid infinite loops ; function to return the minimum of four numbers ; function to return the minimum distance to any rotten orange from [ i , j ] ; if i , j lie outside the array ; if 0 then it can 't lead to  any path so return int_max ; if 2 then we have reached our rotten oranges so return from here ; if this node is already visited then return to avoid infinite loops ; mark the current node as visited ; check in all four possible directions ; take the minimum of all ; if result already exists in the table check if min_value is less than existing value ; function to return the minimum time required to rot all the oranges ; calculate the minimum distances to any rotten orange from all the fresh oranges ; pick the maximum distance of fresh orange to some rotten orange ; if all oranges can be rotten ; ",
        "context": "\nC = 5\nR = 3\nINT_MAX = 10000000\ntable = [[0 for i in range(C)]for j in range(R)]\nvisited = [[0 for i in range(C)]for j in range(R)]\n\n",
        "code": "def min(p, q, r, s):\n    if (p < q):\n        temp1 = p\n    else:\n        temp1 = q\n    if (r < s):\n        temp2 = r\n    else:\n        temp2 = s\n    if (temp1 < temp2):\n        return temp1\n    return temp2\n\n\ndef Distance(arr, i, j):\n    if (i >= R or j >= C or i < 0 or j < 0):\n        return INT_MAX\n    elif (arr[i][j] == 0):\n        table[i][j] = INT_MAX\n        return INT_MAX\n    elif (arr[i][j] == 2):\n        table[i][j] = 0\n        return 0\n    elif (visited[i][j]):\n        return INT_MAX\n    else:\n        visited[i][j] = 1\n        temp1 = Distance(arr, i + 1, j)\n        temp2 = Distance(arr, i - 1, j)\n        temp3 = Distance(arr, i, j + 1)\n        temp4 = Distance(arr, i, j - 1)\n        min_value = 1 + min(temp1, temp2, temp3, temp4)\n        if table[i][j] > 0 and table[i][j] < INT_MAX:\n            if min_value < table[i][j]:\n                table[i][j] = min_value\n        else:\n            table[i][j] = min_value\n        visited[i][j] = 0\n    return table[i][j]\n\n\ndef minTime(arr):\n    max = 0\n    for i in range(R):\n        for j in range(C):\n            if (arr[i][j] == 1):\n                Distance(arr, i, j)\n    for i in range(R):\n        for j in range(C):\n            if (arr[i][j] == 1 and table[i][j] > max):\n                max = table[i][j]\n    if (max < INT_MAX):\n        return max\n    return -1\n",
        "test": "\nif __name__ == '__main__':\n    arr = [[2, 1, 0, 2, 1], [0, 0, 1, 2, 1], [1, 0, 0, 2, 1]]\n    print(minTime(arr))\n",
        "output": "-1\n",
        "fn_call": "minTime"
    },
    {
        "text": "check whether sum of digits at odd places of a number is divisible by k | function that checks the divisibility of the sum of the digits at odd places of the given number ; if position is odd ; ",
        "context": "",
        "code": "def SumDivisible(n, k):\n    sum = 0\n    position = 1\n    while (n > 0):\n        if (position % 2 == 1):\n            sum += n % 10\n        n = n // 10\n        position += 1\n    if (sum % k == 0):\n        return True\n    return False\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 592452\n    k = 3\n    if (SumDivisible(n, k)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
        "output": "YES\n",
        "fn_call": "SumDivisible"
    },
    {
        "text": "find non | python 3 program for the above approach . ; function to find the possible output array ; base case for the recursion ; if ind becomes half of the size then print the array . ; exit the function . ; iterate in the range . ; put the values in the respective indices . ; call the function to find values for other indices . ; ",
        "context": "\nimport sys\nN = 200 * 1000 + 13\nn = 0\narr = [0 for i in range(N)]\nbrr = [0 for i in range(N)]\n\n",
        "code": "def brute(ind, l, r):\n    if (ind == n / 2):\n        for i in range(n):\n            print(brr[i], end=\" \")\n        sys .exit()\n    for i in range(l, arr[ind] // 2 + 1, 1):\n        if (arr[ind] - i <= r):\n            brr[ind] = i\n            brr[n - ind - 1] = arr[ind] - i\n            brute(ind + 1, i, arr[ind] - i)\n",
        "test": "\nif __name__ == '__main__':\n    n = 2\n    n *= 2\n    arr[0] = 5\n    arr[1] = 6\n    INF64 = 1000000000000000000\n    brute(0, 0, INF64)\n",
        "output": "0 1 5 5 ",
        "fn_call": "brute"
    },
    {
        "text": "Minimum Index Sum for Common Elements of Two Lists | Hashing based Python3 program to find common elements with minimum index sum ; Function to print common strings with minimum index sum ; Mapping strings to their indices ; Resultant list ; If current sum is smaller than minsum ; If index sum is same then put this string in resultant list as well ; Print result ; Creating list1 ; Creating list2",
        "context": "\nimport sys\n\n",
        "code": "def find(list1, list2):\n    Map = {}\n    for i in range(len(list1)):\n        Map[list1[i]] = i\n    res = []\n    minsum = sys .maxsize\n    for j in range(len(list2)):\n        if list2[j] in Map:\n            Sum = j + Map[list2[j]]\n            if (Sum < minsum):\n                minsum = Sum\n                res .clear()\n                res .append(list2[j])\n            elif (Sum == minsum):\n                res .append(list2[j])\n    print(*res, sep=\" \")\n",
        "test": "\nlist1 = []\nlist1 .append(\"GeeksforGeeks\")\nlist1 .append(\"Udemy\")\nlist1 .append(\"Coursera\")\nlist1 .append(\"edX\")\nlist2 = []\nlist2 .append(\"Codecademy\")\nlist2 .append(\"Khan Academy\")\nlist2 .append(\"GeeksforGeeks\")\nfind(list1, list2)\n",
        "output": "GeeksforGeeks\n",
        "fn_call": "find"
    },
    {
        "text": "sum of the series kn + ( k ( n | function to return sum ; ",
        "context": "",
        "code": "def sum(k, n):\n    sum = (pow(k, n + 1) - pow(k - 1, n + 1))\n    return sum\n",
        "test": "\nn = 3\nK = 3\nprint(sum(K, n))\n",
        "output": "65\n",
        "fn_call": "sum"
    },
    {
        "text": "sum of sides of largest and smallest child polygons possible from a given polygon | function to find the sum of largest and smallest secondary polygons if possible ; count edges of primary polygon ; calculate edges present in the largest secondary polygon ; ",
        "context": "",
        "code": "def secondary_polygon(Angle):\n    edges_primary = 360 // Angle\n    if edges_primary >= 6:\n        edges_max_secondary = edges_primary // 2\n        return edges_max_secondary + 3\n    else:\n        return \"Not Possible\"\n",
        "test": "\nif __name__ == '__main__':\n    Angle = 45\n    print(secondary_polygon(Angle))\n",
        "output": "7\n",
        "fn_call": "secondary_polygon"
    },
    {
        "text": "count points from an array that lies inside a semi | python implementation of above approach ; traverse the array ; stores if a point lies above the diameter or not ; stores if the r is less than or equal to the distance between center and point ; ",
        "context": "",
        "code": "def getPointsIns(x1, y1, radius, x2, y2, points):\n    ans = 0\n    for point in points:\n        condOne = (point[1] - y2) * (x2 - x1) - \\\n            (y2 - y1) * (point[0] - x2) >= 0\n        condTwo = radius >= ((y1 - point[1])**2 + (x1 - point[0])**2)**(0.5)\n        if condOne and condTwo:\n            ans += 1\n    return ans\n",
        "test": "\nX = 0\nY = 0\nR = 5\nP = 5\nQ = 0\narr = [[2, 3], [5, 6], [-1, 4], [5, 5]]\nprint(getPointsIns(X, Y, R, P, Q, arr))\n",
        "output": "2\n",
        "fn_call": "getPointsIns"
    },
    {
        "text": "count the minimum steps to reach 0 from the given integer n | function returns min step to reach 0 from n ; direct possible reduction of value n ; remaining steps needs to be reduced by 1 ; summation of both the values ; return the final answer ; ",
        "context": "",
        "code": "def getMinSteps(n, jump):\n    quotient = int(n / jump)\n    remainder = n % jump\n    steps = quotient + remainder\n    return steps\n",
        "test": "\nN = 6\nK = 3\nprint(getMinSteps(N, K))\n",
        "output": "2\n",
        "fn_call": "getMinSteps"
    },
    {
        "text": "partition array into two subsets with minimum bitwise xor between their maximum and minimum | function to split the array into two subset such that the bitwise xor between the maximum of one subset and minimum of other is minimum ; sort the array in increasing order ; calculating the min bitwise xor between consecutive elements ; return the final minimum bitwise xor ; ",
        "context": "",
        "code": "def splitArray(arr, N):\n    arr = sorted(arr)\n    result = 10 ** 9\n    for i in range(1, N):\n        result = min(result, arr[i] ^ arr[i - 1])\n    return result\n",
        "test": "\nif __name__ == '__main__':\n    arr = [3, 1, 2, 6, 4]\n    N = len(arr)\n    print(splitArray(arr, N))\n",
        "output": "1\n",
        "fn_call": "splitArray"
    },
    {
        "text": "program to find the nth term of series 5 , 12 , 21 , 32 , 45. ... . . | calculate nth term of series ; ",
        "context": "",
        "code": "def nthTerm(n):\n    return n ** 2 + 4 * n\n",
        "test": "\nN = 4\nprint(nthTerm(N))\n",
        "output": "32\n",
        "fn_call": "nthTerm"
    },
    {
        "text": "find the deleted value from the array when average of original elements is given | function to return the missing element ; find the sum of the array elements ; the numerator and the denominator of the equation ; if not divisible then x is not an integer it is a floating ponumber ; return x ; ",
        "context": "",
        "code": "def findMissing(arr, n, k, avg):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    num = (avg * (n + k)) - sum\n    den = k\n    if (num % den != 0):\n        return -1\n    return (int)(num / den)\n",
        "test": "\nk = 3\navg = 4\narr = [2, 7, 3]\nn = len(arr)\nprint(findMissing(arr, n, k, avg))\n",
        "output": "4\n",
        "fn_call": "findMissing"
    },
    {
        "text": "remove elements that appear strictly less than k times | python3 program to remove the elements which appear strictly less than k times from the array . ; hash map which will store the frequency of the elements of the array . ; incrementing the frequency of the element by 1. ; print the element which appear more than or equal to k times . ; ",
        "context": "",
        "code": "def removeElements(arr, n, k):\n    mp = dict()\n    for i in range(n):\n        mp[arr[i]] = mp .get(arr[i], 0) + 1\n    for i in range(n):\n        if (arr[i] in mp and mp[arr[i]] >= k):\n            print(arr[i], end=\" \")\n",
        "test": "\narr = [1, 2, 2, 3, 2, 3, 4]\nn = len(arr)\nk = 2\nremoveElements(arr, n, k)\n",
        "output": "2 2 3 2 3 ",
        "fn_call": "removeElements"
    },
    {
        "text": "split the array into odd number of segments of odd lengths | function to check ; check the result by processing the first & last element and size ; ",
        "context": "",
        "code": "def checkArray(arr, n):\n    return ((arr[0] % 2) and (arr[n - 1] % 2) and (n % 2))\n",
        "test": "\narr = [1, 2, 3, 4, 5]\nn = len(arr)\nif checkArray(arr, n):\n    print(1)\nelse:\n    print(0)\n",
        "output": "1\n",
        "fn_call": "checkArray"
    },
    {
        "text": "minimum insertions to form a palindrome with permutations allowed | python3 program to find minimum number of insertions to make a string palindrome ; function will return number of characters to be added ; to store str1ing length ; to store number of characters occurring odd number of times ; to store count of each character ; to store occurrence of each character ; to count characters with odd occurrence ; as one character can be odd return res - 1 but if str1ing is already palindrome return 0 ; ",
        "context": "\nimport math as mt\n\n",
        "code": "def minInsertion(tr1):\n    n = len(str1)\n    res = 0\n    count = [0 for i in range(26)]\n    for i in range(n):\n        count[ord(str1[i]) - ord('a')] += 1\n    for i in range(26):\n        if (count[i] % 2 == 1):\n            res += 1\n    if (res == 0):\n        return 0\n    else:\n        return res - 1\n",
        "test": "\nstr1 = \"geeksforgeeks\"\nprint(minInsertion(str1))\n",
        "output": "2\n",
        "fn_call": "minInsertion"
    },
    {
        "text": "print all numbers up to n in words in lexicographical order | function to convert a number to words ; stores the digits ; base cases ; stores strings of unit place ; stores strings for corner cases ; stores strings for ten 's place digits ; stores strings for powers of 10 ; if given number contains a single digit ; iterate over all the digits ; represent first 2 digits in words ; represent last 2 digits in words ; explicitly handle corner cases [ 10 , 19 ] ; explicitly handle corner case 20 ; for rest of the two digit numbers i . e . , 21 to 99 ; function to print all the numbers up to n in lexicographical order ; convert all numbers in words ; sort all strings ; print answer ; ",
        "context": "",
        "code": "def convert_to_words(n):\n    num = str(n)\n    length = len(num)\n    ans = \"\"\n    if (length == 0):\n        ans += \"Empty String\"\n        return ans\n    single_digits = [\n        \"zero\",\n        \"one\",\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\"]\n    two_digits = [\n        \"\",\n        \"ten\",\n        \"eleven\",\n        \"twelve\",\n        \"thirteen\",\n        \"fourteen\",\n        \"fifteen\",\n        \"sixteen\",\n        \"seventeen\",\n        \"eighteen\",\n        \"nineteen\"]\n    tens_multiple = [\n        \"\",\n        \"\",\n        \"twenty\",\n        \"thirty\",\n        \"forty\",\n        \"fifty\",\n        \"sixty\",\n        \"seventy\",\n        \"eighty\",\n        \"ninety\"]\n    tens_power = [\"hundred\", \"thousand\"]\n    if (length == 1):\n        ans += single_digits[ord(num[0]) - ord('0')]\n        return ans\n    x = 0\n    while (x < len(num)):\n        if (length >= 3):\n            if (num[x] - '0' != 0):\n                ans += single_digits[ord(num[x]) - ord('0')]\n                ans += \" \"\n                ans += tens_power[len - 3]\n                ans += \" \"\n            length -= 1\n        else:\n            if (ord(num[x]) - ord('0') == 1):\n                sum = (ord(num[x]) - ord('0') + ord(num[x]) - ord('0'))\n                ans += two_digits[sum]\n                return ans\n            elif (ord(num[x]) - ord('0') == 2 and ord(num[x + 1]) - ord('0') == 0):\n                ans += \"twenty\"\n                return ans\n            else:\n                i = (ord(num[x]) - ord('0'))\n                if (i > 0):\n                    ans += tens_multiple[i]\n                    ans += \" \"\n                else:\n                    ans += \"\"\n                x += 1\n                if (ord(num[x]) - ord('0') != 0):\n                    ans += single_digits[ord(num[x]) - ord('0')]\n        x += 1\n    return \"\"\n\n\ndef lexNumbers(n):\n    s = []\n    for i in range(1, n + 1):\n        s .append(convert_to_words(i))\n    s .sort()\n    ans = []\n    for i in range(n):\n        ans .append(s[i])\n    for i in range(n - 1):\n        print(ans[i], end=\", \")\n    print(ans[n - 1], end=\"\")\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    lexNumbers(n)\n",
        "output": "five, four, one, three, two",
        "fn_call": "lexNumbers"
    },
    {
        "text": "find the value of max ( f ( x ) ) | python 3 implementation of above approach ; function to calculate the value ; forming the prefix sum arrays ; taking the query ; finding the sum in the range l to r in array a ; finding the sum in the range l to r in array b ; finding the max value of the function ; finding the min value of the function ; ",
        "context": "\nMAX = 200006\nCONS = 32766\n\n",
        "code": "def calc(a, b, lr, q, n):\n    cc = 0\n    for i in range(n - 1):\n        a[i + 1] += a[i]\n        b[i + 1] += b[i]\n    while (q > 0):\n        l = lr[cc]\n        cc += 1\n        r = lr[cc]\n        cc += 1\n        l -= 2\n        r -= 1\n        suma = a[r]\n        sumb = b[r]\n        if (l >= 0):\n            suma -= a[l]\n            sumb -= b[l]\n        M = max(CONS * suma + CONS * sumb, -CONS * suma - CONS * sumb)\n        M = max(M, max(CONS * suma - CONS * sumb, -CONS * suma + CONS * sumb))\n        m = min(CONS * suma + CONS * sumb, -CONS * suma - CONS * sumb)\n        m = min(m, min(CONS * suma - CONS * sumb, -CONS * suma + CONS * sumb))\n        print(M - m)\n        q -= 1\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 5\n    q = 2\n    a = [0, 7, 3, 4, 5]\n    b = [0, 3, 1, 2, 3]\n    lr = [0] * (q * 2)\n    lr[0] = 1\n    lr[1] = 1\n    lr[2] = 1\n    lr[3] = 3\n    calc(a, b, lr, q, n)\n",
        "output": "0\n917448\n",
        "fn_call": "calc"
    },
    {
        "text": "check if frequency of each character is equal to its position in english alphabet | python3 program for the above approach ; initialise frequency array ; traverse the string ; update the frequency ; check for valid string ; if frequency is non - zero ; if freq is not equals to ( i + 1 ) , then return false ; return true ; ",
        "context": "",
        "code": "def checkValidString(str):\n    freq = [0 for i in range(26)]\n    for i in range(len(str)):\n        freq[ord(str[i]) - ord('a')] += 1\n    for i in range(26):\n        if (freq[i] != 0):\n            if (freq[i] != i + 1):\n                return False\n    return True\n",
        "test": "\nstr = \"abbcccdddd\"\nif (checkValidString(str)):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n",
        "output": "Yes\n",
        "fn_call": "checkValidString"
    },
    {
        "text": "count pairs with bitwise | function to count number of pairs with even bitwise and ; count odd numbers ; count odd pairs ; return number of even pair ; ",
        "context": "",
        "code": "def findevenPair(A, N):\n    count = 0\n    for i in range(0, N):\n        if (A[i] % 2 != 0):\n            count += 1\n    oddCount = count * (count - 1) / 2\n    return (int)((N * (N - 1) / 2) - oddCount)\n",
        "test": "\na = [5, 1, 3, 2]\nn = len(a)\nprint(findevenPair(a, n))\n",
        "output": "3\n",
        "fn_call": "findevenPair"
    },
    {
        "text": "minimum positive integer divisible by c and is not in range [ a , b ] | function to return the required number ; if doesn 't belong to the range  then c is the required number ; else get the next multiple of c starting from b + 1 ; ",
        "context": "",
        "code": "def getMinNum(a, b, c):\n    if (c  b):\n        return c\n    x = ((b // c) * c) + c\n    return x\n",
        "test": "\na, b, c = 2, 4, 4\nprint(getMinNum(a, b, c))\n",
        "output": "8\n",
        "fn_call": "getMinNum"
    },
    {
        "text": "count of nested polygons that can be drawn by joining vertices internally | function that counts the nested polygons inside another polygons ; stores the count ; child polygons can only exists if parent polygon has sides > 5 ; get next nested polygon ; return the count ; ",
        "context": "",
        "code": "def countNestedPolygons(sides):\n    count = 0\n    while (sides > 5):\n        sides //= 2\n        count += 1\n    return count\n",
        "test": "\nN = 12\nprint(countNestedPolygons(N))\n",
        "output": "2\n",
        "fn_call": "countNestedPolygons"
    },
    {
        "text": "partition the string in two parts such that both parts have at least k different characters | function to find the partition of the string such that both parts have at least k different characters ; length of the string ; to check if the current character is already found ; count number of different characters in the left part ; if current character is not already found , increase cnt by 1 ; if count becomes equal to k , we 've  got the first part, therefore,  store current index and break the loop ; increment i by 1 ; clear the map ; assign cnt as 0 ; if the current character is not already found , increase cnt by 1 ; if cnt becomes equal to k , the second part also have k different characters so break it ; if the second part has less than k different characters , then print \" not \u2581 possible \" ; otherwise print both parts ; ",
        "context": "",
        "code": "def division_of_string(string, k):\n    n = len(string)\n    has = {}\n    cnt = 0\n    i = 0\n    while (i < n):\n        if string[i]not in has:\n            cnt += 1\n            has[string[i]] = True\n        if (cnt == k):\n            ans = i\n            break\n        i += 1\n    i += 1\n    has .clear()\n    cnt = 0\n    while (i < n):\n        if (string[i]not in has):\n            cnt += 1\n            has[string[i]] = True\n        if (cnt == k):\n            break\n        i += 1\n    if (cnt < k):\n        print(\"Not possible\", end=\"\")\n    else:\n        i = 0\n        while (i <= ans):\n            print(string[i], end=\"\")\n            i += 1\n        print()\n        while (i < n):\n            print(string[i], end=\"\")\n            i += 1\n        print()\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"geeksforgeeks\"\n    k = 4\n    division_of_string(string, k)\n",
        "output": "geeks\nforgeeks\n",
        "fn_call": "division_of_string"
    },
    {
        "text": "print all pairs with given sum | returns number of pairs in arr [ 0. . n - 1 ] with sum equal to 'sum ; consider all possible pairs and check their sums ; ",
        "context": "",
        "code": "def printPairs(arr, n, sum):\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (arr[i] + arr[j] == sum):\n                print(\"(\", arr[i], \", \", arr[j], \")\", sep=\"\")\n",
        "test": "\narr = [1, 5, 7, -1, 5]\nn = len(arr)\nsum = 6\nprintPairs(arr, n, sum)\n",
        "output": "(1, 5)\n(1, 5)\n(7, -1)\n",
        "fn_call": "printPairs"
    },
    {
        "text": "smallest n digit number with none of its digits as its divisor | function to calculate power ; function to check if the n - digit number satisfies the given condition or not ; getting the last digit ; every number is divisible by 1 and dividing a number by 0 isn 't possible. thus  numbers with 0 as a digit  must be discarded. ; if any digit divides the number , return false ; if no digit divides the number , return true ; ; function to find the smallest number not divisible by any of its digits . ; get the lower range of n digit number ; get the high range of n digit number ; check all the n - digit numbers ; if the first number to satify the constraints is found print it , set the flag value and break out of the loop . ; if no such digit found , return - 1 as per problem statement ; ",
        "context": "",
        "code": "def power(a, b):\n    if (b == 0):\n        return 1\n    if (b == 1):\n        return a\n    tmp = power(a, b // 2)\n    result = tmp * tmp\n    if (b % 2 == 1):\n        result *= a\n    return result\n\n\ndef check(n):\n    temp = n\n    while (temp > 0):\n        last_digit = temp % 10\n        if (last_digit == 0 or last_digit == 1):\n            return False\n        if (n % last_digit == 0):\n            return False\n        temp = temp // 10\n    return True\n\n\ndef solve(n):\n    L = power(10, n - 1)\n    R = power(10, n) - 1\n    flag = 0\n    for i in range(L, R + 1):\n        answer = check(i)\n        if (answer):\n            print(i)\n            flag += 1\n            break\n    if (flag == 0):\n        print(-1)\n",
        "test": "\nif __name__ == \"__main__\":\n    N = 4\n    solve(N)\n",
        "output": "2227\n",
        "fn_call": "solve"
    },
    {
        "text": "smallest missing non | function to prthe smallest missing non - negative integer up to every array indices ; stores the smallest missing non - negative integers between start index to current index ; store the boolean value to check smnonneg present between start index to each index of the array ; traverse the array ; since output always lies in the range [ 0 , n - 1 ] ; check if smnonneg is present between start index and current index or not ; print smallest missing non - negative integer ; ",
        "context": "",
        "code": "def smlstNonNeg(arr, N):\n    smNonNeg = 0\n    hash = [0] * (N + 1)\n    for i in range(N):\n        if (arr[i] >= 0 and arr[i] < N):\n            hash[arr[i]] = True\n        while (hash[smNonNeg]):\n            smNonNeg += 1\n        print(smNonNeg, end=\" \")\n",
        "test": "\nif __name__ == '__main__':\n    arr = [0, 1, 2, 3, 5]\n    N = len(arr)\n    smlstNonNeg(arr, N)\n",
        "output": "1 2 3 4 4 ",
        "fn_call": "smlstNonNeg"
    },
    {
        "text": "largest perfect square number in an array | python3 program to find the largest perfect square number among n numbers ; function to check if a number is perfect square number or not ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest perfect square number in the array ; stores the maximum of all perfect square numbers ; traverse all elements in the array ; store the maximum if current element is a perfect square ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def checkPerfectSquare(n):\n    d = sqrt(n)\n    if d * d == n:\n        return True\n    return False\n\n\ndef largestPerfectSquareNumber(a, n):\n    maxi = -1\n    for i in range(n):\n        if (checkPerfectSquare(a[i])):\n            maxi = max(a[i], maxi)\n    return maxi\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [16, 20, 25, 2, 3, 10]\n    n = len(a)\n    print(largestPerfectSquareNumber(a, n))\n",
        "output": "25\n",
        "fn_call": "largestPerfectSquareNumber"
    },
    {
        "text": "difference between maximum and minimum of a set of anagrams from an array | python3 program for the above approach ; utility function to find the hash value for each element of the given array ; initialize an array with first 10 prime numbers ; iterate over digits of n ; update hash value ; update n ; function to find the set of anagrams in the array and print the difference between the maximum and minimum of these numbers ; map to store the hash value and the array elements having that hash value ; find the hash value for each arr [ i ] by calling hash function ; iterate over the map ; if size of vector at m [ i ] greater than 1 then it must contain the anagrams ; find the minimum and maximum element of this anagrams vector ; display the difference ; if the end of map is reached , then no anagrams are present ; ",
        "context": "\nimport math\nfrom collections import defaultdict\n\n",
        "code": "def hashFunction(N):\n    prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    value = 1\n    while (N != 0):\n        r = N % 10\n        value = value * prime[r]\n        N = N // 10\n    return value\n\n\ndef findDiff(arr, n):\n    m = defaultdict(lambda: [])\n    for i in range(n):\n        h = hashFunction(arr[i])\n        m[h].append(arr[i])\n    i = 0\n    while (i != len(m)):\n        if (len(m[i]) > 1):\n            minn = min(m[i])\n            maxx = max(m[i])\n            print(maxx - minn)\n            break\n        elif (i == (len(m) - 1)):\n            print(-1)\n        i += 1\n",
        "test": "\narr = [121, 312, 234, 211, 112, 102]\nN = len(arr)\nfindDiff(arr, N)\n",
        "output": "99\n",
        "fn_call": "findDiff"
    },
    {
        "text": "minimize the number of replacements to get a string with same number of ' a ' , ' b ' and ' c ' in it | function to count numbers ; count the number of ' a ' , ' b ' and ' c ' in string ; if equal previously ; if not a multiple of 3 ; increase the number of a ' s \u2581 by \u2581 \u2581 removing \u2581 extra \u2581 ' b ' and c ; check if it is ' b ' and it more than n / 3 ; check if it is ' c ' and it more than n / 3 ; increase the number of b ' s \u2581 by \u2581 \u2581 removing \u2581 extra \u2581 ' c ; check if it is ' c ' and it more than n / 3 ; increase the number of c 's from back ; check if it is ' a ' and it more than n / 3 ; increase the number of b 's from back ; check if it is ' a ' and it more than n / 3 ; increase the number of c 's from back ; check if it is ' b ' and it more than n / 3 ; ",
        "context": "",
        "code": "def lexoSmallest(s, n):\n    ca = 0\n    cb = 0\n    cc = 0\n    for i in range(n):\n        if (s[i] == 'a'):\n            ca += 1\n        elif (s[i] == 'b'):\n            cb += 1\n        else:\n            cc += 1\n    if (ca == cb and cb == cc):\n        return s\n    cnt = n // 3\n    if (cnt * 3 != n):\n        return \"-1\"\n    i = 0\n    while (ca < cnt and i < n):\n        if (s[i] == 'b' and cb > cnt):\n            cb -= 1\n            s[i] = 'a'\n            ca += 1\n        elif (s[i] == 'c' and cc > cnt):\n            cc -= 1\n            s[i] = 'a'\n            ca += 1\n        i += 1\n    i = 0\n\n    while (cb < cnt and i < n):\n        if (s[i] == 'c' and cc > cnt):\n            cc -= 1\n            s[i] = '1'\n            cb += 1\n        i += 1\n    i = n - 1\n    while (cc = 0):\n        if (s[i] == 'a' and ca > cnt):\n            ca -= 1\n            s[i] = 'c'\n            cc += 1\n        i -= 1\n    i = n - 1\n    while (cb = 0):\n        if (s[i] == 'a' and ca > cnt):\n            ca -= 1\n            s[i] = 'b'\n            cb += 1\n        i -= 1\n    i = n - 1\n    while (cc = 0):\n        if (s[i] == 'b' and cb > cnt):\n            cb -= 1\n            s[i] = 'c'\n            cc += 1\n        i -= 1\n    return s\n",
        "test": "\ns = \"aaaaaa\"\nn = len(s)\nprint(*lexoSmallest(list(s), n), sep=\"\")\n",
        "output": "aabbcc\n",
        "fn_call": "lexoSmallest"
    },
    {
        "text": "highest and smallest power of k less than and greater than equal to n respectively | python3 implementation of the approach ; function to return the highest power of k less than or equal to n ; function to return the smallest power of k greater than or equal to n ; function to print the result ; ",
        "context": "\nimport math\n\n",
        "code": "def prevPowerofK(n, k):\n    p = int(math .log(n) / math .log(k))\n    return int(math .pow(k, p))\n\n\ndef nextPowerOfK(n, k):\n    return prevPowerofK(n, k) * k\n\n\ndef printResult(n, k):\n    print(prevPowerofK(n, k), nextPowerOfK(n, k))\n",
        "test": "\nn = 6\nk = 3\nprintResult(n, k)\n",
        "output": "3 9\n",
        "fn_call": "printResult"
    },
    {
        "text": "find if there exists multiple ways to draw line through ( x , y ) to cut rectangle in equal halfs | function that returns true if multiple lines are possible passing through ( x , y ) that divide the given rectangle into two equal parts ; if the point ( x , y ) is the centre of the rectangle ; ",
        "context": "",
        "code": "def isPossible(w, h, x, y):\n    if (x * 2 == w and y * 2 == h):\n        return True\n    return False\n",
        "test": "\nif __name__ == '__main__':\n    w = 1\n    h = 2\n    x = 1\n    y = 2\n    if (isPossible(w, h, x, y)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "No\n",
        "fn_call": "isPossible"
    },
    {
        "text": "number of irreflexive relations on a set | python3 program for the above approach ; function to calculate x ^ y modulo 1000000007 in o ( log y ) ; stores the result of x ^ y ; update x if it exceeds mod ; if x is divisible by mod ; if y is odd , then multiply x with result ; divide y by 2 ; update the value of x ; return the resultant value of x ^ y ; function to count the number of irreflixive relations in a set consisting of n elements ; return the resultant count ; ",
        "context": "\nmod = 1000000007\n\n",
        "code": "def power(x, y):\n    global mod\n    res = 1\n    x = x % mod\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return res\n\n\ndef irreflexiveRelation(N):\n    return power(2, N * N - N)\n",
        "test": "\nif __name__ == '__main__':\n    N = 2\n    print(irreflexiveRelation(N))\n",
        "output": "4\n",
        "fn_call": "irreflexiveRelation"
    },
    {
        "text": "minimum decrements on subarrays required to reduce all array elements to zero | function to count the minimum number of subarrays that are required to be decremented by 1 ; base case ; initializing ans to first element ; for a [ i ] > a [ i - 1 ] , operation ( a [ i ] - a [ i - 1 ] ) is required ; return the count ; ",
        "context": "",
        "code": "def min_operations(A):\n    if len(A) == 0:\n        return 0\n    ans = A[0]\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            ans += A[i] - A[i - 1]\n    return ans\n",
        "test": "\nA = [1, 2, 3, 2, 1]\nprint(min_operations(A))\n",
        "output": "3\n",
        "fn_call": "min_operations"
    },
    {
        "text": "section formula for 3 d | function to find the section of the line ; applying section formula ; printing result ; ",
        "context": "",
        "code": "def section(x1, x2, y1, y2, z1, z2, m, n):\n    x = ((m * x2) + (n * x1)) / (m + n)\n    y = ((m * y2) + (n * y1)) / (m + n)\n    z = ((m * z2) + (n * z1)) / (m + n)\n    print(\"(\", x, \",\", y, \",\", z, \")\")\n",
        "test": "\nif __name__ == '__main__':\n    x1 = 2\n    x2 = 4\n    y1 = -1\n    y2 = 3\n    z1 = 4\n    z2 = 2\n    m = 2\n    n = 3\n    section(x1, x2, y1, y2, z1, z2, m, n)\n",
        "output": "( 2.8 , 0.6 , 3.2 )\n",
        "fn_call": "section"
    },
    {
        "text": "minimum operations required to modify the array such that parity of adjacent elements is different | function to return the parity of a number ; function to return the minimum number of operations required ; operation needs to be performed ; parity of previous element ; parity of next element ; update parity of current element to be other than the parities of the previous and the next number ; ",
        "context": "",
        "code": "def parity(a):\n    return a % 3\n\n\ndef solve(array, size):\n    operations = 0\n    for i in range(0, size - 1):\n        if parity(array[i]) == parity(array[i + 1]):\n            operations += 1\n            if i + 2 < size:\n                pari1 = parity(array[i])\n                pari2 = parity(array[i + 2])\n                if pari1 == pari2:\n                    if pari1 == 0:\n                        array[i + 1] = 1\n                    elif pari1 == 1:\n                        array[i + 1] = 0\n                    else:\n                        array[i + 1] = 1\n                else:\n                    if ((pari1 == 0 and pari2 == 1) or (\n                            pari1 == 1 and pari2 == 0)):\n                        array[i + 1] = 2\n                    if ((pari1 == 1 and pari2 == 2) or (\n                            pari1 == 2 and pari2 == 1)):\n                        array[i + 1] = 0\n                    if ((pari1 == 2 and pari2 == 0) and (\n                            pari1 == 0 and pari2 == 2)):\n                        array[i + 1] = 1\n    return operations\n",
        "test": "\nif __name__ == \"__main__\":\n    array = [2, 1, 3, 0]\n    size = len(array)\n    print(solve(array, size))\n",
        "output": "1\n",
        "fn_call": "solve"
    },
    {
        "text": "fibonacci coding | to limit on the largest fibonacci number to be used ; array to store fibonacci numbers . fib [ i ] is going to store ( i + 2 ) 'th fibonacci number ; stores values in fib and returns index of the largest fibonacci number smaller than n . ; fib [ 0 ] stores 2 nd fibonacci no . ; fib [ 1 ] stores 3 rd fibonacci no . ; keep generating remaining numbers while previously generated number is smaller ; return index of the largest fibonacci number smaller than or equal to n . note that the above loop stopped when fib [ i - 1 ] became larger . ; returns pointer to the char string which corresponds to code for n ; allocate memory for codeword ; index of the largest fibonacci f  n as not used ( 0 bit ) , progress backwards ; additional '1' bit ; return pointer to codeword ; ",
        "context": "\nN = 30\nfib = [0 for i in range(N)]\n\n",
        "code": "def largestFiboLessOrEqual(n):\n    fib[0] = 1\n    fib[1] = 2\n    i = 2\n    while fib[i - 1] <= n:\n        fib[i] = fib[i - 1] + fib[i - 2]\n        i += 1\n    return (i - 2)\n\n\ndef fibonacciEncoding(n):\n    index = largestFiboLessOrEqual(n)\n    codeword = ['a'for i in range(index + 2)]\n    i = index\n    while (n):\n        codeword[i] = '1'\n        n = n - fib[i]\n        i = i - 1\n        while (i >= 0 and fib[i] > n):\n            codeword[i] = '0'\n            i = i - 1\n    codeword[index + 1] = '1'\n    return \"\".join(codeword)\n",
        "test": "\nn = 143\nprint(\"Fibonacci code word for\", n, \"is\", fibonacciEncoding(n))\n",
        "output": "Fibonacci code word for 143 is 01010101011\n",
        "fn_call": "fibonacciEncoding"
    },
    {
        "text": "s | to sort the array and return the answer ; sort the array ; fill all stated with - 1 when only one element ; as dp [ 0 ] = 0 ( base case ) so min no of elements to be removed are n - 1 elements ; iterate from 1 to n - 1 ; ",
        "context": "",
        "code": "def removals(arr, n, k):\n    arr .sort()\n    dp = [0 for i in range(n)]\n    for i in range(n):\n        dp[i] = -1\n    ans = n - 1\n    dp[0] = 0\n    for i in range(1, n):\n        dp[i] = i\n        j = dp[i - 1]\n        while (j != i and arr[i] - arr[j] > k):\n            j += 1\n            dp[i] = min(dp[i], j)\n            ans = min(ans, (n - (i - j + 1)))\n    return ans\n",
        "test": "\na = [1, 3, 4, 9, 10, 11, 12, 17, 20]\nn = len(a)\nk = 4\nprint(removals(a, n, k))\n",
        "output": "8\n",
        "fn_call": "removals"
    },
    {
        "text": "convert a into b by incrementing or decrementing 1 , 2 , or 5 any number of times | function to find minimum number of moves required to convert a into b ; stores the minimum number of moves required ; stores the absolute difference ; find the number of moves ; return cnt ; ",
        "context": "",
        "code": "def minimumSteps(a, b):\n    cnt = 0\n    a = abs(a - b)\n    cnt = (a // 5) + (a % 5) // 2 + (a % 5) % 2\n    return cnt\n",
        "test": "\nA = 3\nB = 9\nprint(minimumSteps(A, B))\n",
        "output": "2\n",
        "fn_call": "minimumSteps"
    },
    {
        "text": "count of numbers upto n digits formed using digits 0 to k | python3 implementation to count the numbers upto n digits such that no two zeros are adjacent ; function to count the numbers upto n digits such that no two zeros are adjacent ; condition to check if only one element remains ; if last element is non zero , return k - 1 ; if last element is 0 ; condition to check if value calculated already ; if last element is non zero , then two cases arise , current element can be either zero or non zero ; memoize this case ; if last is 0 , then current can only be non zero ; memoize and return ; ",
        "context": "\ndp = [[0] * 10 for j in range(15)]\n\n",
        "code": "def solve(n, last, k):\n    if (n == 1):\n        if (last == k):\n            return (k - 1)\n        else:\n            return 1\n    if (dp[n][last]):\n        return dp[n][last]\n    if (last == k):\n        dp[n][last] = ((k - 1) * solve(n - 1, k, k) +\n                       (k - 1) * solve(n - 1, 1, k))\n        return dp[n][last]\n    else:\n        dp[n][last] = solve(n - 1, k, k)\n        return dp[n][last]\n",
        "test": "\nn = 2\nk = 3\nx = solve(n, k, k) + solve(n, 1, k)\nprint(x)\n",
        "output": "8\n",
        "fn_call": "solve"
    },
    {
        "text": "print k different sorted permutations of a given array | utility function to print the original indices of the elements of the array ; function to print the required permutations ; to keep track of original indices ; sort the array ; count the number of swaps that can be made ; cannot generate 3 permutations ; print the first permutation ; find an index to swap and create second permutation ; print the last permutation ; ",
        "context": "",
        "code": "def printIndices(n, a):\n    for i in range(n):\n        print(a[i][1], end=\" \")\n    print(\"\",  end=\"\")\n\n\ndef printPermutations(n, a, k):\n    arr = [[0, 0]for i in range(n)]\n    for i in range(n):\n        arr[i][0] = a[i]\n        arr[i][1] = i\n    arr .sort(reverse=False)\n    count = 1\n    for i in range(1, n):\n        if (arr[i][0] == arr[i - 1][0]):\n            count += 1\n    if (count < k):\n        print(\"-1\", end=\"\")\n        return\n    next_pos = 1\n    for i in range(k - 1):\n        printIndices(n, arr)\n        for j in range(next_pos, n):\n            if (arr[j][0] == arr[j - 1][0]):\n                temp = arr[j]\n                arr[j] = arr[j - 1]\n                arr[j - 1] = temp\n                next_pos = j + 1\n                break\n    printIndices(n, arr)\n",
        "test": "\nif __name__ == '__main__':\n    a = [1, 3, 3, 1]\n    n = len(a)\n    k = 3\n    printPermutations(n, a, k)\n",
        "output": "0 3 1 2 3 0 1 2 3 0 2 1 ",
        "fn_call": "printPermutations"
    },
    {
        "text": "construct an array from xor of all elements of array except element at same index | function to construct new array ; calculate xor of array ; update array ; ",
        "context": "",
        "code": "def constructXOR(A, n):\n    XOR = 0\n    for i in range(0, n):\n        XOR ^= A[i]\n    for i in range(0, n):\n        A[i] = XOR ^ A[i]\n",
        "test": "\nA = [2, 4, 1, 3, 5]\nn = len(A)\nconstructXOR(A, n)\nfor i in range(0, n):\n    print(A[i], end=\" \")\n",
        "output": "3 5 0 2 4 ",
        "fn_call": "constructXOR"
    },
    {
        "text": "n queen problem | backtracking | python3 program to solve n queen problem using backtracking ; ld is an array where its indices indicate row - col + n - 1 ( n - 1 ) is for shifting the difference to store negative indices ; rd is an array where its indices indicate row + col and used to check whether a queen can be placed on right diagonal or not ; column array where its indices indicates column and used to check whether a queen can be placed in that row or not ; a utility function to print solution ; a recursive utility function to solve n queen problem ; base case : if all queens are placed then return true ; consider this column and try placing this queen in all rows one by one ; a check if a queen can be placed on board [ row ] [ col ] . we just need to check ld [ row - col + n - 1 ] and rd [ row + coln ] where ld and rd are for left and right diagonal respectively ; place this queen in board [ i ] [ col ] ; recur to place rest of the queens ; board [ i ] [ col ] = 0 backtrack ; if the queen cannot be placed in any row in this colum col then return false ; this function solves the n queen problem using backtracking . it mainly uses solvenqutil ( ) to solve the problem . it returns false if queens cannot be placed , otherwise , return true and prints placement of queens in the form of 1 s . please note that there may be more than one solutions , this function prints one of the feasible solutions . ; ",
        "context": "\nN = 4\nld = [0] * 30\nrd = [0] * 30\ncl = [0] * 30\n\n",
        "code": "def printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j], end=\" \")\n        print()\n\n\ndef solveNQUtil(board, col):\n    if (col >= N):\n        return True\n    for i in range(N):\n        if ((ld[i - col + N - 1] != 1 and rd[i + col] != 1) and cl[i] != 1):\n            board[i][col] = 1\n            ld[i - col + N - 1] = rd[i + col] = cl[i] = 1\n            if (solveNQUtil(board, col + 1)):\n                return True\n            ld[i - col + N - 1] = rd[i + col] = cl[i] = 0\n    return False\n\n\ndef solveNQ():\n    board = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    if (solveNQUtil(board, 0) == False):\n        printf(\"Solution does not exist\")\n        return False\n    printSolution(board)\n    return True\n",
        "test": "\nsolveNQ()\n",
        "output": "1 0 1 0 \n1 0 1 0 \n0 1 0 1 \n0 1 0 0 \n",
        "fn_call": "solveNQ"
    },
    {
        "text": "sort a string lexicographically by reversing a substring | function to find the substring in s required to be reversed ; stores the size of the string ; stores the starting point of the substring ; iterate over the string s while i = n ; if start >= 1 and i = 1 ; return the boolean value ; if i < n ; return true if s [ start ] is less than or equal to s [ i ] ; otherwise ; function to check if it is possible to sort the string or not ; global start , end , i stores the starting and the ending index of substring ; stores whether it is possible to sort the substring ; traverse the range [ 1 , n ] ; if s [ i ] is less than s [ i - 1 ] ; if flag stores true ; if adjust ( s , i , start , end ) return false ; pr - 1 ; unset the flag ; otherwise ; pr - 1 ; if start is equal to - 1 ; update start and end ; print the value of start and end ; ",
        "context": "",
        "code": "def adjust(S, i, start, end):\n    N = len(S)\n    start = i - 1\n    while (i < N and S[i] < S[i - 1]):\n        i += 1\n    end = i - 1\n    if (start = N):\n        return True, start, i, end\n    if (start >= 1 and i <= N):\n        return (S[end] >= S[start - 1] and S[start] <= S[i]), start, i, end\n    if (start >= 1):\n        return (S[end] >= S[start - 1]), start, i, end\n    if (i < N):\n        return (S[start] <= S[i]), start, i, end\n    return False, start, i, end\n\n\ndef isPossible(S, N):\n    start, end = -1, -1\n    flag = True\n    i = 1\n    while i < N:\n        if (S[i] < S[i - 1]):\n            if (flag):\n                f, start, i, end = adjust(S, i, start, end)\n                if (f == False):\n                    print(-1)\n                    return\n                flag = False\n            else:\n                print(-1)\n                return\n        i += 1\n    if (start == -1):\n        start, end = 1, 1\n    print(start, end)\n",
        "test": "\nif __name__ == '__main__':\n    S = \"abcyxuz\"\n    N = len(S)\n    isPossible(S, N)\n",
        "output": "3 5\n",
        "fn_call": "isPossible"
    },
    {
        "text": "number of subsequences with even and odd sum | set 2 | function to find number of subsequences with even and odd sum ; counting number of odds ; even count ; total subsequences is ( 2 ^ n - 1 ) for numberofevensubsequences subtract numberofoddsubsequences from total ; ",
        "context": "",
        "code": "def countSum(arr, n):\n    NumberOfOdds = 0\n    NumberOfEvens = 0\n    for i in range(n):\n        if (arr[i] & 1):\n            NumberOfOdds += 1\n    NumberOfEvens = n - NumberOfOdds\n    NumberOfOddSubsequences = (1 << NumberOfEvens) * (1 << (NumberOfOdds - 1))\n    NumberOfEvenSubsequences = (1 << n) - 1 - NumberOfOddSubsequences\n    return (NumberOfEvenSubsequences, NumberOfOddSubsequences)\n",
        "test": "\nif __name__ == \"__main__\":\n    arr = [1, 2, 2, 3]\n    n = len(arr)\n    ans = countSum(arr, n)\n    print(\"EvenSum =\", ans[0], end=\" \")\n    print(\"OddSum =\", ans[1])\n",
        "output": "EvenSum = 7 OddSum = 8\n",
        "fn_call": "countSum"
    },
    {
        "text": "find the closest pair from two sorted arrays | python3 program to find the pair from two sorted arays such that the sum of pair is closest to a given number x ; ar1 [ 0. . m - 1 ] and ar2 [ 0. . n - 1 ] are two given sorted arrays and x is given number . this function prints the pair from both arrays such that the sum of the pair is closest to x . ; initialize the diff between pair sum and x . ; start from left side of ar1 [ ] and right side of ar2 [ ] ; if this pair is closer to x than the previously found closest , then update res_l , res_r and diff ; if sum of this pair is more than x , move to smaller side ; move to the greater side ; print the result ; ",
        "context": "\nimport sys\n\n",
        "code": "def printClosest(ar1, ar2, m, n, x):\n    diff = sys .maxsize\n    l = 0\n    r = n - 1\n    while (l = 0):\n        if abs(ar1[l] + ar2[r] - x) < diff:\n            res_l = l\n            res_r = r\n            diff = abs(ar1[l] + ar2[r] - x)\n        if ar1[l] + ar2[r] > x:\n            r = r - 1\n        else:\n            l = l + 1\n    print(\"The closest pair is [\", ar1[res_l], \",\", ar2[res_r], \"]\")\n",
        "test": "\nar1 = [1, 4, 5, 7]\nar2 = [10, 20, 30, 40]\nm = len(ar1)\nn = len(ar2)\nx = 38\nprintClosest(ar1, ar2, m, n, x)\n",
        "output": "The closest pair is [ 7 , 30 ]\n",
        "fn_call": "printClosest"
    },
    {
        "text": "n | program to find n - th number which is both square and cube . ; ",
        "context": "",
        "code": "def nthSquareCube(n):\n    return n * n * n * n * n * n\n",
        "test": "\nn = 5\nprint(nthSquareCube(n))\n",
        "output": "15625\n",
        "fn_call": "nthSquareCube"
    },
    {
        "text": "sum of the first n terms of xor fibonacci series | function to calculate sum of the first n terms of xor fibonacci series ; store the sum of first n terms ; store xor of a and b ; case 1 : if n is divisible by 3 ; case 2 : if n % 3 leaves remainder 1 ; case 3 : if n % 3 leaves remainder 2 on division by 3 ; print the final sum ; ",
        "context": "",
        "code": "def findSum(a, b, N):\n    sum = 0\n    x = a ^ b\n    if N % 3 == 0:\n        sum = (N // 3) * (a + b + x)\n    elif N % 3 == 1:\n        sum = (N // 3) * (a + b + x) + a\n    else:\n        sum = (N // 3) * (a + b + x) + a + b\n    print(sum)\n    return\n",
        "test": "\nif __name__ == '__main__':\n    a = 2\n    b = 5\n    N = 8\n    findSum(a, b, N)\n",
        "output": "35\n",
        "fn_call": "findSum"
    },
    {
        "text": "minimum steps required to visit all corners of an n * m grid | python3 program to implement the above approach ; function to find the minimum count of steps required to visit all the corners of the grid ; stores corner of the grid ; stores minimum count of steps required to visit the first corner of the grid ; checking for leftmost upper corner ; checking for leftmost down corner ; checking for rightmost upper corner ; checking for rightmost down corner ; stores minimum count of steps required to visit remaining three corners of the grid ; ",
        "context": "\nimport sys\nINT_MAX = sys .maxsize\n\n",
        "code": "def min_steps_required(n, m, r, c):\n    i = 0\n    j = 0\n    corner_steps_req = INT_MAX\n    i = 1\n    j = 1\n    corner_steps_req = min(corner_steps_req, abs(r - i) + abs(j - c))\n    i = n\n    j = 1\n    corner_steps_req = min(corner_steps_req, abs(r - i) + abs(j - c))\n    i = 1\n    j = m\n    corner_steps_req = min(corner_steps_req, abs(r - i) + abs(j - c))\n    i = n\n    j = m\n    corner_steps_req = min(corner_steps_req, abs(r - i) + abs(j - c))\n    minimum_steps = min(2 * (n - 1) + m - 1, 2 * (m - 1) + n - 1)\n    return minimum_steps + corner_steps_req\n",
        "test": "\nif __name__ == \"__main__\":\n    n = 3\n    m = 2\n    r = 1\n    c = 1\n    print(min_steps_required(n, m, r, c))\n",
        "output": "4\n",
        "fn_call": "min_steps_required"
    },
    {
        "text": "remove minimum elements from either side such that 2 * min becomes more than max | a utility function to find minimum in arr [ l . . h ] ; a utility function to find maximum in arr [ l . . h ] ; returns the minimum number of removals from either end in arr [ l . . h ] so that 2 * min becomes greater than max . ; if there is 1 or less elements , return 0 for a single element , 2 * min > max ( assumption : all elements are positive in arr [ ] ) ; 1 ) find minimum and maximum in arr [ l . . h ] ; if the property is followed , no removals needed ; otherwise remove a character from left end and recur , then remove a character from right end and recur , take the minimum of two is returned ; ",
        "context": "",
        "code": "def mini(arr, l, h):\n    mn = arr[l]\n    for i in range(l + 1, h + 1):\n        if (mn > arr[i]):\n            mn = arr[i]\n    return mn\n\n\ndef max(arr, l, h):\n    mx = arr[l]\n    for i in range(l + 1, h + 1):\n        if (mx < arr[i]):\n            mx = arr[i]\n    return mx\n\n\ndef minRemovals(arr, l, h):\n    if (l >= h):\n        return 0\n    mn = mini(arr, l, h)\n    mx = max(arr, l, h)\n    if (2 * mn > mx):\n        return 0\n    return (min(minRemovals(arr, l + 1, h), minRemovals(arr, l, h - 1)) + 1)\n",
        "test": "\narr = [4, 5, 100, 9, 10, 11, 12, 15, 200]\nn = len(arr)\nprint(minRemovals(arr, 0, n - 1))\n",
        "output": "4\n",
        "fn_call": "minRemovals"
    },
    {
        "text": "count pairs from two sorted arrays whose sum is equal to a given value x | function to count all pairs from both the sorted arrays whose sum is equal to a given value ; insert all the elements of 1 st array in the hash table ( unordered_set ' us ' ) ; or each element of 'arr2[] ; find ( x - arr2 [ j ] ) in 'us   ; required count of pairs ; ",
        "context": "",
        "code": "def countPairs(arr1, arr2, m, n, x):\n    count = 0\n    us = set()\n    for i in range(m):\n        us .add(arr1[i])\n    for j in range(n):\n        if x - arr2[j] in us:\n            count += 1\n    return count\n",
        "test": "\narr1 = [1, 3, 5, 7]\narr2 = [2, 3, 5, 8]\nm = len(arr1)\nn = len(arr2)\nx = 10\nprint(\"Count =\", countPairs(arr1, arr2, m, n, x))\n",
        "output": "Count = 2\n",
        "fn_call": "countPairs"
    },
    {
        "text": "find unit digit of x raised to power y | python3 code to find the unit digit of x raised to power y . ; find unit digit ; get last digit of x ; last cyclic modular value ; here we simply return the unit digit or the power of a number ; ",
        "context": "\nimport math\n\n",
        "code": "def unitnumber(x, y):\n    x = x % 10\n    if y != 0:\n        y = y % 4 + 4\n    return (((int)(math .pow(x, y))) % 10)\n",
        "test": "\nx = 133\ny = 5\nprint(unitnumber(x, y))\n",
        "output": "3\n",
        "fn_call": "unitnumber"
    },
    {
        "text": "subtraction in the array | function to perform the given operation on arr [ ] ; skip elements which are 0 ; pick smallest non - zero element ; if all the elements of arr [ ] are 0 ; ",
        "context": "",
        "code": "def operations(arr, n, k):\n    arr .sort()\n    i = 0\n    sum = 0\n    while (k > 0):\n        while (i < n and arr[i] - sum == 0):\n            i += 1\n        if (i  0):\n            print(arr[i] - sum, end=\" \")\n            sum = arr[i]\n        else:\n            print(0)\n        k -= 1\n",
        "test": "\nk = 5\narr = [3, 6, 4, 2]\nn = len(arr)\noperations(arr, n, k)\n",
        "output": "2 1 1 2 0\n",
        "fn_call": "operations"
    },
    {
        "text": "check whether a number has exactly three distinct factors or not | python 3 program to check whether number has exactly three distinct factors or not ; utility function to check whether a number is prime or not ; corner cases ; this is checked so that we can skip middle five numbers in below loop ; function to check whether given number has three distinct factors or not ; find square root of number ; check whether number is perfect square or not ; if number is perfect square , check whether square root is prime or not ; ",
        "context": "\nfrom math import sqrt\n\n",
        "code": "def isPrime(n):\n    if (n <= 1):\n        return False\n    if (n <= 3):\n        return True\n    if (n % 2 == 0 or n % 3 == 0):\n        return False\n    k = int(sqrt(n)) + 1\n    for i in range(5, k, 6):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n    return True\n\n\ndef isThreeDisctFactors(n):\n    sq = int(sqrt(n))\n    if (1 * sq * sq != n):\n        return False\n    if (isPrime(sq)):\n        return True\n    else:\n        return False\n",
        "test": "\nif __name__ == '__main__':\n    num = 9\n    if (isThreeDisctFactors(num)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    num = 15\n    if (isThreeDisctFactors(num)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    num = 12397923568441\n    if (isThreeDisctFactors(num)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n",
        "output": "Yes\nNo\nNo\n",
        "fn_call": "isThreeDisctFactors"
    },
    {
        "text": "count the number of possible triangles | counttriangles function ; if it is possible with a [ l ] , a [ r ] and a [ i ] then it is also possible with a [ l + 1 ] . . a [ r - 1 ] , a [ r ] and a [ i ] ; checking for more possible solutions ; if not possible check for higher values of arr [ l ] ; ",
        "context": "",
        "code": "def CountTriangles(A):\n    n = len(A)\n    A .sort()\n    count = 0\n    for i in range(n - 1, 0, -1):\n        l = 0\n        r = i - 1\n        while (l < r):\n            if (A[l] + A[r] > A[i]):\n                count += r - l\n                r -= 1\n            else:\n                l += 1\n    print(\"No of possible solutions: \", count)\n",
        "test": "\nif __name__ == '__main__':\n    A = [4, 3, 5, 7, 6]\n    CountTriangles(A)\n",
        "output": "No of possible solutions:  9\n",
        "fn_call": "CountTriangles"
    },
    {
        "text": "optimal strategy for a game | special gold coin | function to return the winner of the game ; to store the count of silver coins ; update the position of the gold coin ; first player will win the game ; ",
        "context": "",
        "code": "def getWinner(string, length):\n    total = 0\n    for i in range(length):\n        if (string[i] == 'S'):\n            total += 1\n    if ((total % 2) == 1):\n        return \"First\"\n    return \"Second\"\n",
        "test": "\nif __name__ == \"__main__\":\n    string = \"GSSS\"\n    length = len(string)\n    print(getWinner(string, length))\n",
        "output": "First\n",
        "fn_call": "getWinner"
    },
    {
        "text": "shortest distance between a point and a circle | function to find the shortest distance ; ",
        "context": "",
        "code": "def dist(x1, y1, x2, y2, r):\n    print(\"The shortest distance between a point and a circle is \",\n          ((((x2 - x1)**2) + ((y2 - y1)**2))**(1 / 2)) - r)\n",
        "test": "\nx1 = 4\ny1 = 6\nx2 = 35\ny2 = 42\nr = 5\ndist(x1, y1, x2, y2, r)\n",
        "output": "The shortest distance between a point and a circle is  42.50789408087881\n",
        "fn_call": "dist"
    },
    {
        "text": "queries on array with disappearing and reappearing elements | function to perform the queries ; size of the array with 1 - based indexing ; number of queries ; iterating through the queries ; if m is more than the size of the array ; count of turns ; find the remainder ; if the remainder is 0 and turn is odd then the array is empty ; if the remainder is 0 and turn is even then array is full and is in its initial state ; if the remainder is not 0 and the turn is even ; current size of the array ; current size of the array ; print the result ; ",
        "context": "",
        "code": "def PerformQueries(a, vec):\n    ans = []\n    n = len(a) - 1\n    q = len(vec)\n    for i in range(q):\n        t = vec[i][0]\n        m = vec[i][1]\n        if (m > n):\n            ans .append(-1)\n            continue\n        turn = t // n\n        rem = t % n\n        if (rem == 0 and turn % 2 == 1):\n            ans .append(-1)\n            continue\n        if (rem == 0 and turn % 2 == 0):\n            ans .append(a[m])\n            continue\n        if (turn % 2 == 0):\n            cursize = n - rem\n            if (cursize < m):\n                ans .append(-1)\n                continue\n            ans .append(a[m + rem])\n        else:\n            cursize = rem\n            if (cursize < m):\n                ans .append(-1)\n                continue\n            ans .append(a[m])\n    for i in ans:\n        print(i)\n",
        "test": "\nif __name__ == \"__main__\":\n    a = [-1, 1, 2, 3, 4, 5]\n    vec = [[1, 4], [6, 1], [3, 5]]\n    PerformQueries(a, vec)\n",
        "output": "5\n1\n-1\n",
        "fn_call": "PerformQueries"
    },
    {
        "text": "split the given string into odds : digit dp | function to check whether a string is an odd number or not ; a function to find the minimum number of segments the given string can be divided such that every segment is a odd number ; declare a splitdp [ ] array and initialize to - 1 ; build the dp table in a bottom - up manner ; initially check if the entire prefix is odd ; if the given prefix can be split into odds then for the remaining string from i to j check if odd . if yes calculate the minimum split till j ; to check if the substring from i to j is a odd number or not ; if it is an odd number , then update the dp array ; return the minimum number of splits for the entire string ; ",
        "context": "",
        "code": "def checkOdd(number):\n    n = len(number)\n    num = ord(number[n - 1]) - 48\n    return (num & 1)\n\n\ndef splitIntoOdds(number):\n    numLen = len(number)\n    splitDP = [-1 for i in range(numLen + 1)]\n    for i in range(1, numLen + 1):\n        if (i  0):\n            splitDP[i] = 1\n        if (splitDP[i] != -1):\n            for j in range(1, 10):\n                if (i + j > numLen):\n                    break\n                if (checkOdd(number[i:i + j])):\n                    if (splitDP[i + j] == -1):\n                        splitDP[i + j] = 1 + splitDP[i]\n                    else:\n                        splitDP[i + j] = min(splitDP[i + j], 1 + splitDP[i])\n    return splitDP[numLen]\n",
        "test": "\nprint(splitIntoOdds(\"123456789123456789123\"))\n",
        "output": "3\n",
        "fn_call": "splitIntoOdds"
    }
]